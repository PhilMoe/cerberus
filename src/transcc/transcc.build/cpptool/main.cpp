
#include "main.h"

//${CONFIG_BEGIN}
#define CFG_BRL_DATABUFFER_IMPLEMENTED 1
#define CFG_BRL_FILESTREAM_IMPLEMENTED 1
#define CFG_BRL_OS_IMPLEMENTED 1
#define CFG_BRL_STREAM_IMPLEMENTED 1
#define CFG_BRL_THREAD_IMPLEMENTED 1
#define CFG_CD 
#define CFG_CONFIG release
#define CFG_CPP_DOUBLE_PRECISION_FLOATS 1
#define CFG_CPP_GC_MODE 0
#define CFG_HOST winnt
#define CFG_LANG cpp
#define CFG_MODPATH 
#define CFG_RELEASE 1
#define CFG_SAFEMODE 0
#define CFG_TARGET stdcpp
//${CONFIG_END}

//${TRANSCODE_BEGIN}

#include <wctype.h>
#include <locale.h>

// C++ Cerberus runtime.
//
// Placed into the public domain 24/02/2011.
// No warranty implied; use at your own risk.

//***** Cerberus Types *****

typedef wchar_t Char;
template<class T> class Array;
class String;
class Object;

#if CFG_CPP_DOUBLE_PRECISION_FLOATS
typedef double Float;
#define FLOAT(X) X
#else
typedef float Float;
#define FLOAT(X) X##f
#endif

void dbg_error( const char *p );

#if !_MSC_VER
#define sprintf_s sprintf
#define sscanf_s sscanf
#endif

//***** GC Config *****

#if CFG_CPP_GC_DEBUG
#define DEBUG_GC 1
#else
#define DEBUG_GC 0
#endif

// GC mode:
//
// 0 = disabled
// 1 = Incremental GC every OnWhatever
// 2 = Incremental GC every allocation
//
#ifndef CFG_CPP_GC_MODE
#define CFG_CPP_GC_MODE 1
#endif

//How many bytes alloced to trigger GC
//
#ifndef CFG_CPP_GC_TRIGGER
#define CFG_CPP_GC_TRIGGER 8*1024*1024
#endif

//GC_MODE 2 needs to track locals on a stack - this may need to be bumped if your app uses a LOT of locals, eg: is heavily recursive...
//
#ifndef CFG_CPP_GC_MAX_LOCALS
#define CFG_CPP_GC_MAX_LOCALS 8192
#endif

// ***** GC *****

#if _WIN32

int gc_micros(){
	static int f;
	static LARGE_INTEGER pcf;
	if( !f ){
		if( QueryPerformanceFrequency( &pcf ) && pcf.QuadPart>=1000000L ){
			pcf.QuadPart/=1000000L;
			f=1;
		}else{
			f=-1;
		}
	}
	if( f>0 ){
		LARGE_INTEGER pc;
		if( QueryPerformanceCounter( &pc ) ) return pc.QuadPart/pcf.QuadPart;
		f=-1;
	}
	return 0;// timeGetTime()*1000;
}

#elif __APPLE__

#include <mach/mach_time.h>

int gc_micros(){
	static int f;
	static mach_timebase_info_data_t timeInfo;
	if( !f ){
		mach_timebase_info( &timeInfo );
		timeInfo.denom*=1000L;
		f=1;
	}
	return mach_absolute_time()*timeInfo.numer/timeInfo.denom;
}

#else

int gc_micros(){
	return 0;
}

#endif

#define gc_mark_roots gc_mark

void gc_mark_roots();

struct gc_object;

gc_object *gc_object_alloc( int size );
void gc_object_free( gc_object *p );

struct gc_object{
	gc_object *succ;
	gc_object *pred;
	int flags;
	
	virtual ~gc_object(){
	}
	
	virtual void mark(){
	}
	
	void *operator new( size_t size ){
		return gc_object_alloc( size );
	}
	
	void operator delete( void *p ){
		gc_object_free( (gc_object*)p );
	}
};

gc_object gc_free_list;
gc_object gc_marked_list;
gc_object gc_unmarked_list;
gc_object gc_queued_list;	//doesn't really need to be doubly linked...

int gc_free_bytes;
int gc_marked_bytes;
int gc_alloced_bytes;
int gc_max_alloced_bytes;
int gc_new_bytes;
int gc_markbit=1;

gc_object *gc_cache[8];

void gc_collect_all();
void gc_mark_queued( int n );

#define GC_CLEAR_LIST( LIST ) ((LIST).succ=(LIST).pred=&(LIST))

#define GC_LIST_IS_EMPTY( LIST ) ((LIST).succ==&(LIST))

#define GC_REMOVE_NODE( NODE ){\
(NODE)->pred->succ=(NODE)->succ;\
(NODE)->succ->pred=(NODE)->pred;}

#define GC_INSERT_NODE( NODE,SUCC ){\
(NODE)->pred=(SUCC)->pred;\
(NODE)->succ=(SUCC);\
(SUCC)->pred->succ=(NODE);\
(SUCC)->pred=(NODE);}

void gc_init1(){
	GC_CLEAR_LIST( gc_free_list );
	GC_CLEAR_LIST( gc_marked_list );
	GC_CLEAR_LIST( gc_unmarked_list);
	GC_CLEAR_LIST( gc_queued_list );
}

void gc_init2(){
	gc_mark_roots();
}

#if CFG_CPP_GC_MODE==2

int gc_ctor_nest;
gc_object *gc_locals[CFG_CPP_GC_MAX_LOCALS],**gc_locals_sp=gc_locals;

struct gc_ctor{
	gc_ctor(){ ++gc_ctor_nest; }
	~gc_ctor(){ --gc_ctor_nest; }
};

struct gc_enter{
	gc_object **sp;
	gc_enter():sp(gc_locals_sp){
	}
	~gc_enter(){
#if DEBUG_GC
		static int max_locals;
		int n=gc_locals_sp-gc_locals;
		if( n>max_locals ){
			max_locals=n;
			printf( "max_locals=%i\n",n );
		}
#endif		
		gc_locals_sp=sp;
	}
};

#define GC_CTOR gc_ctor _c;
#define GC_ENTER gc_enter _e;

#else

struct gc_ctor{
};
struct gc_enter{
};

#define GC_CTOR
#define GC_ENTER

#endif

//Can be modified off thread!
static volatile int gc_ext_new_bytes;

#if _MSC_VER
#define atomic_add(P,V) InterlockedExchangeAdd((volatile unsigned int*)P,V)			//(*(P)+=(V))
#define atomic_sub(P,V) InterlockedExchangeSubtract((volatile unsigned int*)P,V)	//(*(P)-=(V))
#else
#define atomic_add(P,V) __sync_fetch_and_add(P,V)
#define atomic_sub(P,V) __sync_fetch_and_sub(P,V)
#endif

//Careful! May be called off thread!
//
void gc_ext_malloced( int size ){
	atomic_add( &gc_ext_new_bytes,size );
}

void gc_object_free( gc_object *p ){

	int size=p->flags & ~7;
	gc_free_bytes-=size;
	
	if( size<64 ){
		p->succ=gc_cache[size>>3];
		gc_cache[size>>3]=p;
	}else{
		free( p );
	}
}

void gc_flush_free( int size ){

	int t=gc_free_bytes-size;
	if( t<0 ) t=0;
	
	//ignore bytes freed by released strings
	int new_bytes=gc_new_bytes;
	
	while( gc_free_bytes>t ){
	
		gc_object *p=gc_free_list.succ;

		GC_REMOVE_NODE( p );

#if DEBUG_GC
//		printf( "deleting @%p\n",p );fflush( stdout );
//		p->flags|=4;
//		continue;
#endif
		delete p;
	}
	
	gc_new_bytes=new_bytes;
}

gc_object *gc_object_alloc( int size ){

	size=(size+7)&~7;
	
	gc_new_bytes+=size;
	
#if CFG_CPP_GC_MODE==2

	if( !gc_ctor_nest ){

#if DEBUG_GC
		int ms=gc_micros();
#endif
		if( gc_new_bytes+gc_ext_new_bytes>(CFG_CPP_GC_TRIGGER) ){
			atomic_sub( &gc_ext_new_bytes,gc_ext_new_bytes );
			gc_collect_all();
			gc_new_bytes=0;
		}else{
			gc_mark_queued( (long long)(gc_new_bytes)*(gc_alloced_bytes-gc_new_bytes)/(CFG_CPP_GC_TRIGGER)+gc_new_bytes );
		}

#if DEBUG_GC
		ms=gc_micros()-ms;
		if( ms>=100 ) {printf( "gc time:%i\n",ms );fflush( stdout );}
#endif
	}
	
#endif

	gc_flush_free( size );

	gc_object *p;
	if( size<64 && (p=gc_cache[size>>3]) ){
		gc_cache[size>>3]=p->succ;
	}else{
		p=(gc_object*)malloc( size );
	}
	
	p->flags=size|gc_markbit;
	GC_INSERT_NODE( p,&gc_unmarked_list );

	gc_alloced_bytes+=size;
	if( gc_alloced_bytes>gc_max_alloced_bytes ) gc_max_alloced_bytes=gc_alloced_bytes;
	
#if CFG_CPP_GC_MODE==2
	*gc_locals_sp++=p;
#endif

	return p;
}

#if DEBUG_GC

template<class T> gc_object *to_gc_object( T *t ){
	gc_object *p=dynamic_cast<gc_object*>(t);
	if( p && (p->flags & 4) ){
		printf( "gc error : object already deleted @%p\n",p );fflush( stdout );
		exit(-1);
	}
	return p;
}

#else

#define to_gc_object(t) dynamic_cast<gc_object*>(t)

#endif

template<class T> T *gc_retain( T *t ){
#if CFG_CPP_GC_MODE==2
	*gc_locals_sp++=to_gc_object( t );
#endif
	return t;
}

template<class T> void gc_mark( T *t ){

	gc_object *p=to_gc_object( t );
	
	if( p && (p->flags & 3)==gc_markbit ){
		p->flags^=1;
		GC_REMOVE_NODE( p );
		GC_INSERT_NODE( p,&gc_marked_list );
		gc_marked_bytes+=(p->flags & ~7);
		p->mark();
	}
}

template<class T> void gc_mark_q( T *t ){

	gc_object *p=to_gc_object( t );
	
	if( p && (p->flags & 3)==gc_markbit ){
		p->flags^=1;
		GC_REMOVE_NODE( p );
		GC_INSERT_NODE( p,&gc_queued_list );
	}
}

template<class T,class V> void gc_assign( T *&lhs,V *rhs ){

	gc_object *p=to_gc_object( rhs );
	
	if( p && (p->flags & 3)==gc_markbit ){
		p->flags^=1;
		GC_REMOVE_NODE( p );
		GC_INSERT_NODE( p,&gc_queued_list );
	}
	lhs=rhs;
}

void gc_mark_locals(){

#if CFG_CPP_GC_MODE==2
	for( gc_object **pp=gc_locals;pp!=gc_locals_sp;++pp ){
		gc_object *p=*pp;
		if( p && (p->flags & 3)==gc_markbit ){
			p->flags^=1;
			GC_REMOVE_NODE( p );
			GC_INSERT_NODE( p,&gc_marked_list );
			gc_marked_bytes+=(p->flags & ~7);
			p->mark();
		}
	}
#endif	
}

void gc_mark_queued( int n ){
	while( gc_marked_bytes<n && !GC_LIST_IS_EMPTY( gc_queued_list ) ){
		gc_object *p=gc_queued_list.succ;
		GC_REMOVE_NODE( p );
		GC_INSERT_NODE( p,&gc_marked_list );
		gc_marked_bytes+=(p->flags & ~7);
		p->mark();
	}
}

void gc_validate_list( gc_object &list,const char *msg ){
	gc_object *node=list.succ;
	while( node ){
		if( node==&list ) return;
		if( !node->pred ) break;
		if( node->pred->succ!=node ) break;
		node=node->succ;
	}
	if( msg ){
		puts( msg );fflush( stdout );
	}
	puts( "LIST ERROR!" );
	exit(-1);
}

//returns reclaimed bytes
void gc_sweep(){

	int reclaimed_bytes=gc_alloced_bytes-gc_marked_bytes;
	
	if( reclaimed_bytes ){
	
		//append unmarked list to end of free list
		gc_object *head=gc_unmarked_list.succ;
		gc_object *tail=gc_unmarked_list.pred;
		gc_object *succ=&gc_free_list;
		gc_object *pred=succ->pred;
		
		head->pred=pred;
		tail->succ=succ;
		pred->succ=head;
		succ->pred=tail;
		
		gc_free_bytes+=reclaimed_bytes;
	}

	//move marked to unmarked.
	if( GC_LIST_IS_EMPTY( gc_marked_list ) ){
		GC_CLEAR_LIST( gc_unmarked_list );
	}else{
		gc_unmarked_list.succ=gc_marked_list.succ;
		gc_unmarked_list.pred=gc_marked_list.pred;
		gc_unmarked_list.succ->pred=gc_unmarked_list.pred->succ=&gc_unmarked_list;
		GC_CLEAR_LIST( gc_marked_list );
	}
	
	//adjust sizes
	gc_alloced_bytes=gc_marked_bytes;
	gc_marked_bytes=0;
	gc_markbit^=1;
}

void gc_collect_all(){

//	puts( "Mark locals" );
	gc_mark_locals();

//	puts( "Marked queued" );
	gc_mark_queued( 0x7fffffff );

//	puts( "Sweep" );
	gc_sweep();

//	puts( "Mark roots" );
	gc_mark_roots();

#if DEBUG_GC
	gc_validate_list( gc_marked_list,"Validating gc_marked_list"  );
	gc_validate_list( gc_unmarked_list,"Validating gc_unmarked_list"  );
	gc_validate_list( gc_free_list,"Validating gc_free_list" );
#endif

}

void gc_collect(){
	
#if CFG_CPP_GC_MODE==1

#if DEBUG_GC
	int ms=gc_micros();
#endif

	if( gc_new_bytes+gc_ext_new_bytes>(CFG_CPP_GC_TRIGGER) ){
		atomic_sub( &gc_ext_new_bytes,gc_ext_new_bytes );
		gc_collect_all();
		gc_new_bytes=0;
	}else{
		gc_mark_queued( (long long)(gc_new_bytes)*(gc_alloced_bytes-gc_new_bytes)/(CFG_CPP_GC_TRIGGER)+gc_new_bytes );
	}

#if DEBUG_GC
	ms=gc_micros()-ms;
//	if( ms>=100 ) {printf( "gc time:%i\n",ms );fflush( stdout );}
	if( ms>10 ) {printf( "gc time:%i\n",ms );fflush( stdout );}
#endif

#endif
}

// ***** Array *****

template<class T> T *t_memcpy( T *dst,const T *src,int n ){
	memcpy( dst,src,n*sizeof(T) );
	return dst+n;
}

template<class T> T *t_memset( T *dst,int val,int n ){
	memset( dst,val,n*sizeof(T) );
	return dst+n;
}

template<class T> int t_memcmp( const T *x,const T *y,int n ){
	return memcmp( x,y,n*sizeof(T) );
}

template<class T> int t_strlen( const T *p ){
	const T *q=p++;
	while( *q++ ){}
	return q-p;
}

template<class T> T *t_create( int n,T *p ){
	t_memset( p,0,n );
	return p+n;
}

template<class T> T *t_create( int n,T *p,const T *q ){
	t_memcpy( p,q,n );
	return p+n;
}

template<class T> void t_destroy( int n,T *p ){
}

template<class T> void gc_mark_elements( int n,T *p ){
}

template<class T> void gc_mark_elements( int n,T **p ){
	for( int i=0;i<n;++i ) gc_mark( p[i] );
}

template<class T> class Array{
public:
	Array():rep( &nullRep ){
	}

	//Uses default...
//	Array( const Array<T> &t )...
	
	Array( int length ):rep( Rep::alloc( length ) ){
		t_create( rep->length,rep->data );
	}
	
	Array( const T *p,int length ):rep( Rep::alloc(length) ){
		t_create( rep->length,rep->data,p );
	}
	
	~Array(){
	}

	//Uses default...
//	Array &operator=( const Array &t )...
	
	int Length()const{ 
		return rep->length; 
	}
	
	T &At( int index ){
		if( index<0 || index>=rep->length ) dbg_error( "Array index out of range" );
		return rep->data[index]; 
	}
	
	const T &At( int index )const{
		if( index<0 || index>=rep->length ) dbg_error( "Array index out of range" );
		return rep->data[index]; 
	}
	
	T &operator[]( int index ){
		return rep->data[index]; 
	}

	const T &operator[]( int index )const{
		return rep->data[index]; 
	}
	
	Array Slice( int from,int term )const{
		int len=rep->length;
		if( from<0 ){ 
			from+=len;
			if( from<0 ) from=0;
		}else if( from>len ){
			from=len;
		}
		if( term<0 ){
			term+=len;
		}else if( term>len ){
			term=len;
		}
		if( term<=from ) return Array();
		return Array( rep->data+from,term-from );
	}

	Array Slice( int from )const{
		return Slice( from,rep->length );
	}
	
	Array Resize( int newlen )const{
		if( newlen<=0 ) return Array();
		int n=rep->length;
		if( newlen<n ) n=newlen;
		Rep *p=Rep::alloc( newlen );
		T *q=p->data;
		q=t_create( n,q,rep->data );
		q=t_create( (newlen-n),q );
		return Array( p );
	}
	
private:
	struct Rep : public gc_object{
		int length;
		T data[0];
		
		Rep():length(0){
			flags=3;
		}
		
		Rep( int length ):length(length){
		}
		
		~Rep(){
			t_destroy( length,data );
		}
		
		void mark(){
			gc_mark_elements( length,data );
		}
		
		static Rep *alloc( int length ){
			if( !length ) return &nullRep;
			void *p=gc_object_alloc( sizeof(Rep)+length*sizeof(T) );
			return ::new(p) Rep( length );
		}
		
	};
	Rep *rep;
	
	static Rep nullRep;
	
	template<class C> friend void gc_mark( Array<C> t );
	template<class C> friend void gc_mark_q( Array<C> t );
	template<class C> friend Array<C> gc_retain( Array<C> t );
	template<class C> friend void gc_assign( Array<C> &lhs,Array<C> rhs );
	template<class C> friend void gc_mark_elements( int n,Array<C> *p );
	
	Array( Rep *rep ):rep(rep){
	}
};

template<class T> typename Array<T>::Rep Array<T>::nullRep;

template<class T> Array<T> *t_create( int n,Array<T> *p ){
	for( int i=0;i<n;++i ) *p++=Array<T>();
	return p;
}

template<class T> Array<T> *t_create( int n,Array<T> *p,const Array<T> *q ){
	for( int i=0;i<n;++i ) *p++=*q++;
	return p;
}

template<class T> void gc_mark( Array<T> t ){
	gc_mark( t.rep );
}

template<class T> void gc_mark_q( Array<T> t ){
	gc_mark_q( t.rep );
}

template<class T> Array<T> gc_retain( Array<T> t ){
#if CFG_CPP_GC_MODE==2
	gc_retain( t.rep );
#endif
	return t;
}

template<class T> void gc_assign( Array<T> &lhs,Array<T> rhs ){
	gc_mark( rhs.rep );
	lhs=rhs;
}

template<class T> void gc_mark_elements( int n,Array<T> *p ){
	for( int i=0;i<n;++i ) gc_mark( p[i].rep );
}
		
// ***** String *****

static const char *_str_load_err;

class String{
public:
	String():rep( &nullRep ){
	}
	
	String( const String &t ):rep( t.rep ){
		rep->retain();
	}

	String( int n ){
		char buf[256];
		sprintf_s( buf,"%i",n );
		rep=Rep::alloc( t_strlen(buf) );
		for( int i=0;i<rep->length;++i ) rep->data[i]=buf[i];
	}
	
	String( Float n ){
		char buf[256];
		
		//would rather use snprintf, but it's doing weird things in MingW.
		//
		sprintf_s( buf,"%.17lg",n );
		//
		char *p;
		for( p=buf;*p;++p ){
			if( *p=='.' || *p=='e' ) break;
		}
		if( !*p ){
			*p++='.';
			*p++='0';
			*p=0;
		}

		rep=Rep::alloc( t_strlen(buf) );
		for( int i=0;i<rep->length;++i ) rep->data[i]=buf[i];
	}

	String( Char ch,int length ):rep( Rep::alloc(length) ){
		for( int i=0;i<length;++i ) rep->data[i]=ch;
	}

	String( const Char *p ):rep( Rep::alloc(t_strlen(p)) ){
		t_memcpy( rep->data,p,rep->length );
	}

	String( const Char *p,int length ):rep( Rep::alloc(length) ){
		t_memcpy( rep->data,p,rep->length );
	}
	
#if __OBJC__	
	String( NSString *nsstr ):rep( Rep::alloc([nsstr length]) ){
		unichar *buf=(unichar*)malloc( rep->length * sizeof(unichar) );
		[nsstr getCharacters:buf range:NSMakeRange(0,rep->length)];
		for( int i=0;i<rep->length;++i ) rep->data[i]=buf[i];
		free( buf );
	}
#endif

#if __cplusplus_winrt
	String( Platform::String ^str ):rep( Rep::alloc(str->Length()) ){
		for( int i=0;i<rep->length;++i ) rep->data[i]=str->Data()[i];
	}
#endif

	~String(){
		rep->release();
	}
	
	template<class C> String( const C *p ):rep( Rep::alloc(t_strlen(p)) ){
		for( int i=0;i<rep->length;++i ) rep->data[i]=p[i];
	}
	
	template<class C> String( const C *p,int length ):rep( Rep::alloc(length) ){
		for( int i=0;i<rep->length;++i ) rep->data[i]=p[i];
	}
	
	String Copy()const{
		Rep *crep=Rep::alloc( rep->length );
		t_memcpy( crep->data,rep->data,rep->length );
		return String( crep );
	}
	
	int Length()const{
		return rep->length;
	}
	
	const Char *Data()const{
		return rep->data;
	}
	
	Char At( int index )const{
		if( index<0 || index>=rep->length ) dbg_error( "Character index out of range" );
		return rep->data[index]; 
	}
	
	Char operator[]( int index )const{
		return rep->data[index];
	}
	
	String &operator=( const String &t ){
		t.rep->retain();
		rep->release();
		rep=t.rep;
		return *this;
	}
	
	String &operator+=( const String &t ){
		return operator=( *this+t );
	}
	
	int Compare( const String &t )const{
		int n=rep->length<t.rep->length ? rep->length : t.rep->length;
		for( int i=0;i<n;++i ){
			if( int q=(int)(rep->data[i])-(int)(t.rep->data[i]) ) return q;
		}
		return rep->length-t.rep->length;
	}
	
	bool operator==( const String &t )const{
		return rep->length==t.rep->length && t_memcmp( rep->data,t.rep->data,rep->length )==0;
	}
	
	bool operator!=( const String &t )const{
		return rep->length!=t.rep->length || t_memcmp( rep->data,t.rep->data,rep->length )!=0;
	}
	
	bool operator<( const String &t )const{
		return Compare( t )<0;
	}
	
	bool operator<=( const String &t )const{
		return Compare( t )<=0;
	}
	
	bool operator>( const String &t )const{
		return Compare( t )>0;
	}
	
	bool operator>=( const String &t )const{
		return Compare( t )>=0;
	}
	
	String operator+( const String &t )const{
		if( !rep->length ) return t;
		if( !t.rep->length ) return *this;
		Rep *p=Rep::alloc( rep->length+t.rep->length );
		Char *q=p->data;
		q=t_memcpy( q,rep->data,rep->length );
		q=t_memcpy( q,t.rep->data,t.rep->length );
		return String( p );
	}
	
	int Find( String find,int start=0 )const{
		if( start<0 ) start=0;
		while( start+find.rep->length<=rep->length ){
			if( !t_memcmp( rep->data+start,find.rep->data,find.rep->length ) ) return start;
			++start;
		}
		return -1;
	}
	
	int FindLast( String find )const{
		int start=rep->length-find.rep->length;
		while( start>=0 ){
			if( !t_memcmp( rep->data+start,find.rep->data,find.rep->length ) ) return start;
			--start;
		}
		return -1;
	}
	
	int FindLast( String find,int start )const{
		if( start>rep->length-find.rep->length ) start=rep->length-find.rep->length;
		while( start>=0 ){
			if( !t_memcmp( rep->data+start,find.rep->data,find.rep->length ) ) return start;
			--start;
		}
		return -1;
	}
	
	String Trim()const{
		int i=0,i2=rep->length;
		while( i<i2 && rep->data[i]<=32 ) ++i;
		while( i2>i && rep->data[i2-1]<=32 ) --i2;
		if( i==0 && i2==rep->length ) return *this;
		return String( rep->data+i,i2-i );
	}

	Array<String> Split( String sep )const{
	
		if( !sep.rep->length ){
			Array<String> bits( rep->length );
			for( int i=0;i<rep->length;++i ){
				bits[i]=String( (Char)(*this)[i],1 );
			}
			return bits;
		}
		
		int i=0,i2,n=1;
		while( (i2=Find( sep,i ))!=-1 ){
			++n;
			i=i2+sep.rep->length;
		}
		Array<String> bits( n );
		if( n==1 ){
			bits[0]=*this;
			return bits;
		}
		i=0;n=0;
		while( (i2=Find( sep,i ))!=-1 ){
			bits[n++]=Slice( i,i2 );
			i=i2+sep.rep->length;
		}
		bits[n]=Slice( i );
		return bits;
	}

	String Join( Array<String> bits )const{
		if( bits.Length()==0 ) return String();
		if( bits.Length()==1 ) return bits[0];
		int newlen=rep->length * (bits.Length()-1);
		for( int i=0;i<bits.Length();++i ){
			newlen+=bits[i].rep->length;
		}
		Rep *p=Rep::alloc( newlen );
		Char *q=p->data;
		q=t_memcpy( q,bits[0].rep->data,bits[0].rep->length );
		for( int i=1;i<bits.Length();++i ){
			q=t_memcpy( q,rep->data,rep->length );
			q=t_memcpy( q,bits[i].rep->data,bits[i].rep->length );
		}
		return String( p );
	}

	String Replace( String find,String repl )const{
		int i=0,i2,newlen=0;
		while( (i2=Find( find,i ))!=-1 ){
			newlen+=(i2-i)+repl.rep->length;
			i=i2+find.rep->length;
		}
		if( !i ) return *this;
		newlen+=rep->length-i;
		Rep *p=Rep::alloc( newlen );
		Char *q=p->data;
		i=0;
		while( (i2=Find( find,i ))!=-1 ){
			q=t_memcpy( q,rep->data+i,i2-i );
			q=t_memcpy( q,repl.rep->data,repl.rep->length );
			i=i2+find.rep->length;
		}
		q=t_memcpy( q,rep->data+i,rep->length-i );
		return String( p );
	}

	String ToLower()const{
		for( int i=0;i<rep->length;++i ){
			Char t=towlower( rep->data[i] );
			if( t==rep->data[i] ) continue;
			Rep *p=Rep::alloc( rep->length );
			Char *q=p->data;
			t_memcpy( q,rep->data,i );
			for( q[i++]=t;i<rep->length;++i ){
				q[i]=towlower( rep->data[i] );
			}
			return String( p );
		}
		return *this;
	}

	String ToUpper()const{
		for( int i=0;i<rep->length;++i ){
			Char t=towupper( rep->data[i] );
			if( t==rep->data[i] ) continue;
			Rep *p=Rep::alloc( rep->length );
			Char *q=p->data;
			t_memcpy( q,rep->data,i );
			for( q[i++]=t;i<rep->length;++i ){
				q[i]=towupper( rep->data[i] );
			}
			return String( p );
		}
		return *this;
	}
	
	bool Contains( String sub )const{
		return Find( sub )!=-1;
	}

	bool StartsWith( String sub )const{
		return sub.rep->length<=rep->length && !t_memcmp( rep->data,sub.rep->data,sub.rep->length );
	}

	bool EndsWith( String sub )const{
		return sub.rep->length<=rep->length && !t_memcmp( rep->data+rep->length-sub.rep->length,sub.rep->data,sub.rep->length );
	}
	
	String Slice( int from,int term )const{
		int len=rep->length;
		if( from<0 ){
			from+=len;
			if( from<0 ) from=0;
		}else if( from>len ){
			from=len;
		}
		if( term<0 ){
			term+=len;
		}else if( term>len ){
			term=len;
		}
		if( term<from ) return String();
		if( from==0 && term==len ) return *this;
		return String( rep->data+from,term-from );
	}

	String Slice( int from )const{
		return Slice( from,rep->length );
	}
	
	Array<int> ToChars()const{
		Array<int> chars( rep->length );
		for( int i=0;i<rep->length;++i ) chars[i]=rep->data[i];
		return chars;
	}
	
	int ToInt()const{
		char buf[64];
		return atoi( ToCString<char>( buf,sizeof(buf) ) );
	}
	
	Float ToFloat()const{
		char buf[256];
		return atof( ToCString<char>( buf,sizeof(buf) ) );
	}

	template<class C> class CString{
		struct Rep{
			int refs;
			C data[1];
		};
		Rep *_rep;
		static Rep _nul;
	public:
		template<class T> CString( const T *data,int length ){
			_rep=(Rep*)malloc( length*sizeof(C)+sizeof(Rep) );
			_rep->refs=1;
			_rep->data[length]=0;
			for( int i=0;i<length;++i ){
				_rep->data[i]=(C)data[i];
			}
		}
		CString():_rep( new Rep ){
			_rep->refs=1;
		}
		CString( const CString &c ):_rep(c._rep){
			++_rep->refs;
		}
		~CString(){
			if( !--_rep->refs ) free( _rep );
		}
		CString &operator=( const CString &c ){
			++c._rep->refs;
			if( !--_rep->refs ) free( _rep );
			_rep=c._rep;
			return *this;
		}
		operator const C*()const{ 
			return _rep->data;
		}
	};
	
	template<class C> CString<C> ToCString()const{
		return CString<C>( rep->data,rep->length );
	}

	template<class C> C *ToCString( C *p,int length )const{
		if( --length>rep->length ) length=rep->length;
		for( int i=0;i<length;++i ) p[i]=rep->data[i];
		p[length]=0;
		return p;
	}
	
#if __OBJC__	
	NSString *ToNSString()const{
		return [NSString stringWithCharacters:ToCString<unichar>() length:rep->length];
	}
#endif

#if __cplusplus_winrt
	Platform::String ^ToWinRTString()const{
		return ref new Platform::String( rep->data,rep->length );
	}
#endif
	CString<char> ToUtf8()const{
		std::vector<unsigned char> buf;
		Save( buf );
		return CString<char>( &buf[0],buf.size() );
	}

	bool Save( FILE *fp )const{
		std::vector<unsigned char> buf;
		Save( buf );
		return buf.size() ? fwrite( &buf[0],1,buf.size(),fp )==buf.size() : true;
	}
	
	void Save( std::vector<unsigned char> &buf )const{
	
		Char *p=rep->data;
		Char *e=p+rep->length;
		
		while( p<e ){
			Char c=*p++;
			if( c<0x80 ){
				buf.push_back( c );
			}else if( c<0x800 ){
				buf.push_back( 0xc0 | (c>>6) );
				buf.push_back( 0x80 | (c & 0x3f) );
			}else{
				buf.push_back( 0xe0 | (c>>12) );
				buf.push_back( 0x80 | ((c>>6) & 0x3f) );
				buf.push_back( 0x80 | (c & 0x3f) );
			}
		}
	}
	
	static String FromChars( Array<int> chars ){
		int n=chars.Length();
		Rep *p=Rep::alloc( n );
		for( int i=0;i<n;++i ){
			p->data[i]=chars[i];
		}
		return String( p );
	}

	static String Load( FILE *fp ){
		unsigned char tmp[4096];
		std::vector<unsigned char> buf;
		for(;;){
			int n=fread( tmp,1,4096,fp );
			if( n>0 ) buf.insert( buf.end(),tmp,tmp+n );
			if( n!=4096 ) break;
		}
		return buf.size() ? String::Load( &buf[0],buf.size() ) : String();
	}
	
	static String Load( unsigned char *p,int n ){
	
		_str_load_err=0;
		
		unsigned char *e=p+n;
		std::vector<Char> chars;
		
		int t0=n>0 ? p[0] : -1;
		int t1=n>1 ? p[1] : -1;

		if( t0==0xfe && t1==0xff ){
			p+=2;
			while( p<e-1 ){
				int c=*p++;
				chars.push_back( (c<<8)|*p++ );
			}
		}else if( t0==0xff && t1==0xfe ){
			p+=2;
			while( p<e-1 ){
				int c=*p++;
				chars.push_back( (*p++<<8)|c );
			}
		}else{
			int t2=n>2 ? p[2] : -1;
			if( t0==0xef && t1==0xbb && t2==0xbf ) p+=3;
			unsigned char *q=p;
			bool fail=false;
			while( p<e ){
				unsigned int c=*p++;
				if( c & 0x80 ){
					if( (c & 0xe0)==0xc0 ){
						if( p>=e || (p[0] & 0xc0)!=0x80 ){
							fail=true;
							break;
						}
						c=((c & 0x1f)<<6) | (p[0] & 0x3f);
						p+=1;
					}else if( (c & 0xf0)==0xe0 ){
						if( p+1>=e || (p[0] & 0xc0)!=0x80 || (p[1] & 0xc0)!=0x80 ){
							fail=true;
							break;
						}
						c=((c & 0x0f)<<12) | ((p[0] & 0x3f)<<6) | (p[1] & 0x3f);
						p+=2;
					}else{
						fail=true;
						break;
					}
				}
				chars.push_back( c );
			}
			if( fail ){
				_str_load_err="Invalid UTF-8";
				return String( q,n );
			}
		}
		return chars.size() ? String( &chars[0],chars.size() ) : String();
	}

private:
	
	struct Rep{
		int refs;
		int length;
		Char data[0];
		
		Rep():refs(1),length(0){
		}
		
		Rep( int length ):refs(1),length(length){
		}
		
		void retain(){
			++refs;
		}
		
		void release(){
			if( --refs || this==&nullRep ) return;
			gc_new_bytes-=sizeof(Rep)+length*sizeof(Char);
			free( this );
		}

		static Rep *alloc( int length ){
			if( !length ) return &nullRep;
			void *p=malloc( sizeof(Rep)+length*sizeof(Char) );
			gc_new_bytes+=sizeof(Rep)+length*sizeof(Char);
			return new(p) Rep( length );
		}
	};
	Rep *rep;
	
	static Rep nullRep;
	
	String( Rep *rep ):rep(rep){
	}
};

String::Rep String::nullRep;

String *t_create( int n,String *p ){
	for( int i=0;i<n;++i ) new( &p[i] ) String();
	return p+n;
}

String *t_create( int n,String *p,const String *q ){
	for( int i=0;i<n;++i ) new( &p[i] ) String( q[i] );
	return p+n;
}

void t_destroy( int n,String *p ){
	for( int i=0;i<n;++i ) p[i].~String();
}

// ***** Object *****

String dbg_stacktrace();

class Object : public gc_object{
public:
	virtual bool Equals( Object *obj ){
		return this==obj;
	}
	
	virtual int Compare( Object *obj ){
		return (char*)this-(char*)obj;
	}
	
	virtual String debug(){
		return "+Object\n";
	}
};

class ThrowableObject : public Object{
#ifndef NDEBUG
public:
	String stackTrace;
	ThrowableObject():stackTrace( dbg_stacktrace() ){}
#endif
};

struct gc_interface{
	virtual ~gc_interface(){}
};

//***** Debugger *****

//#define Error bbError
//#define Print bbPrint

int bbPrint( String t );

#define dbg_stream stderr

#if _MSC_VER
#define dbg_typeof decltype
#else
#define dbg_typeof __typeof__
#endif 

struct dbg_func;
struct dbg_var_type;

static int dbg_suspend;
static int dbg_stepmode;

const char *dbg_info;
String dbg_exstack;

static void *dbg_var_buf[65536*3];
static void **dbg_var_ptr=dbg_var_buf;

static dbg_func *dbg_func_buf[1024];
static dbg_func **dbg_func_ptr=dbg_func_buf;

String dbg_type( bool *p ){
	return "Bool";
}

String dbg_type( int *p ){
	return "Int";
}

String dbg_type( Float *p ){
	return "Float";
}

String dbg_type( String *p ){
	return "String";
}

template<class T> String dbg_type( T **p ){
	return "Object";
}

template<class T> String dbg_type( Array<T> *p ){
	return dbg_type( &(*p)[0] )+"[]";
}

String dbg_value( bool *p ){
	return *p ? "True" : "False";
}

String dbg_value( int *p ){
	return String( *p );
}

String dbg_value( Float *p ){
	return String( *p );
}

String dbg_value( String *p ){
	String t=*p;
	if( t.Length()>100 ) t=t.Slice( 0,100 )+"...";
	t=t.Replace( "\"","~q" );
	t=t.Replace( "\t","~t" );
	t=t.Replace( "\n","~n" );
	t=t.Replace( "\r","~r" );
	return String("\"")+t+"\"";
}

template<class T> String dbg_value( T **t ){
	Object *p=dynamic_cast<Object*>( *t );
	char buf[64];
	sprintf_s( buf,"%p",p );
	return String("@") + (buf[0]=='0' && buf[1]=='x' ? buf+2 : buf );
}

template<class T> String dbg_value( Array<T> *p ){
	String t="[";
	int n=(*p).Length();
	if( n>100 ) n=100;
	for( int i=0;i<n;++i ){
		if( i ) t+=",";
		t+=dbg_value( &(*p)[i] );
	}
	return t+"]";
}

String dbg_ptr_value( void *p ){
	char buf[64];
	sprintf_s( buf,"%p",p );
	return (buf[0]=='0' && buf[1]=='x' ? buf+2 : buf );
}

template<class T> String dbg_decl( const char *id,T *ptr ){
	return String( id )+":"+dbg_type(ptr)+"="+dbg_value(ptr)+"\n";
}

struct dbg_var_type{
	virtual String type( void *p )=0;
	virtual String value( void *p )=0;
};

template<class T> struct dbg_var_type_t : public dbg_var_type{

	String type( void *p ){
		return dbg_type( (T*)p );
	}
	
	String value( void *p ){
		return dbg_value( (T*)p );
	}
	
	static dbg_var_type_t<T> info;
};
template<class T> dbg_var_type_t<T> dbg_var_type_t<T>::info;

struct dbg_blk{
	void **var_ptr;
	
	dbg_blk():var_ptr(dbg_var_ptr){
		if( dbg_stepmode=='l' ) --dbg_suspend;
	}
	
	~dbg_blk(){
		if( dbg_stepmode=='l' ) ++dbg_suspend;
		dbg_var_ptr=var_ptr;
	}
};

struct dbg_func : public dbg_blk{
	const char *id;
	const char *info;

	dbg_func( const char *p ):id(p),info(dbg_info){
		*dbg_func_ptr++=this;
		if( dbg_stepmode=='s' ) --dbg_suspend;
	}
	
	~dbg_func(){
		if( dbg_stepmode=='s' ) ++dbg_suspend;
		--dbg_func_ptr;
		dbg_info=info;
	}
};

int dbg_print( String t ){
	static char *buf;
	static int len;
	int n=t.Length();
	if( n+100>len ){
		len=n+100;
		free( buf );
		buf=(char*)malloc( len );
	}
	buf[n]='\n';
	for( int i=0;i<n;++i ) buf[i]=t[i];
	fwrite( buf,n+1,1,dbg_stream );
	fflush( dbg_stream );
	return 0;
}

void dbg_callstack(){

	void **var_ptr=dbg_var_buf;
	dbg_func **func_ptr=dbg_func_buf;
	
	while( var_ptr!=dbg_var_ptr ){
		while( func_ptr!=dbg_func_ptr && var_ptr==(*func_ptr)->var_ptr ){
			const char *id=(*func_ptr++)->id;
			const char *info=func_ptr!=dbg_func_ptr ? (*func_ptr)->info : dbg_info;
			fprintf( dbg_stream,"+%s;%s\n",id,info );
		}
		void *vp=*var_ptr++;
		const char *nm=(const char*)*var_ptr++;
		dbg_var_type *ty=(dbg_var_type*)*var_ptr++;
		dbg_print( String(nm)+":"+ty->type(vp)+"="+ty->value(vp) );
	}
	while( func_ptr!=dbg_func_ptr ){
		const char *id=(*func_ptr++)->id;
		const char *info=func_ptr!=dbg_func_ptr ? (*func_ptr)->info : dbg_info;
		fprintf( dbg_stream,"+%s;%s\n",id,info );
	}
}

String dbg_stacktrace(){
	if( !dbg_info || !dbg_info[0] ) return "";
	String str=String( dbg_info )+"\n";
	dbg_func **func_ptr=dbg_func_ptr;
	if( func_ptr==dbg_func_buf ) return str;
	while( --func_ptr!=dbg_func_buf ){
		str+=String( (*func_ptr)->info )+"\n";
	}
	return str;
}

void dbg_throw( const char *err ){
	dbg_exstack=dbg_stacktrace();
	throw err;
}

void dbg_stop(){

#if TARGET_OS_IPHONE
	dbg_throw( "STOP" );
#endif

	fprintf( dbg_stream,"{{~~%s~~}}\n",dbg_info );
	dbg_callstack();
	dbg_print( "" );
	
	for(;;){

		char buf[256];
		char *e=fgets( buf,256,stdin );
		if( !e ) exit( -1 );
		
		e=strchr( buf,'\n' );
		if( !e ) exit( -1 );
		
		*e=0;
		
		Object *p;
		
		switch( buf[0] ){
		case '?':
			break;
		case 'r':	//run
			dbg_suspend=0;		
			dbg_stepmode=0;
			return;
		case 's':	//step
			dbg_suspend=1;
			dbg_stepmode='s';
			return;
		case 'e':	//enter func
			dbg_suspend=1;
			dbg_stepmode='e';
			return;
		case 'l':	//leave block
			dbg_suspend=0;
			dbg_stepmode='l';
			return;
		case '@':	//dump object
			p=0;
			sscanf_s( buf+1,"%p",&p );
			if( p ){
				dbg_print( p->debug() );
			}else{
				dbg_print( "" );
			}
			break;
		case 'q':	//quit!
			exit( 0 );
			break;			
		default:
			printf( "????? %s ?????",buf );fflush( stdout );
			exit( -1 );
		}
	}
}

void dbg_error( const char *err ){

#if TARGET_OS_IPHONE
	dbg_throw( err );
#endif

	for(;;){
		bbPrint( String("Cerberus Runtime Error : ")+err );
		bbPrint( dbg_stacktrace() );
		dbg_stop();
	}
}

#define DBG_INFO(X) dbg_info=(X);if( dbg_suspend>0 ) dbg_stop();

#define DBG_ENTER(P) dbg_func _dbg_func(P);

#define DBG_BLOCK() dbg_blk _dbg_blk;

#define DBG_GLOBAL( ID,NAME )	//TODO!

#define DBG_LOCAL( ID,NAME )\
*dbg_var_ptr++=&ID;\
*dbg_var_ptr++=(void*)NAME;\
*dbg_var_ptr++=&dbg_var_type_t<dbg_typeof(ID)>::info;

//**** main ****

int argc;
const char **argv;

Float D2R=0.017453292519943295f;
Float R2D=57.29577951308232f;

int bbPrint( String t ){

	static std::vector<unsigned char> buf;
	buf.clear();
	t.Save( buf );
	buf.push_back( '\n' );
	buf.push_back( 0 );
	
#if __cplusplus_winrt	//winrt?

#if CFG_WINRT_PRINT_ENABLED
	OutputDebugStringA( (const char*)&buf[0] );
#endif

#elif _WIN32			//windows?

	fputs( (const char*)&buf[0],stdout );
	fflush( stdout );

#elif __APPLE__			//macos/ios?

	fputs( (const char*)&buf[0],stdout );
	fflush( stdout );
	
#elif __linux			//linux?

#if CFG_ANDROID_NDK_PRINT_ENABLED
	LOGI( (const char*)&buf[0] );
#else
	fputs( (const char*)&buf[0],stdout );
	fflush( stdout );
#endif

#endif

	return 0;
}

class BBExitApp{
};

int bbError( String err ){
	if( !err.Length() ){
#if __cplusplus_winrt
		throw BBExitApp();
#else
		exit( 0 );
#endif
	}
	dbg_error( err.ToCString<char>() );
	return 0;
}

int bbDebugLog( String t ){
	bbPrint( t );
	return 0;
}

int bbDebugStop(){
	dbg_stop();
	return 0;
}

int bbInit();
int bbMain();

#if _MSC_VER

static void _cdecl seTranslator( unsigned int ex,EXCEPTION_POINTERS *p ){

	switch( ex ){
	case EXCEPTION_ACCESS_VIOLATION:dbg_error( "Memory access violation" );
	case EXCEPTION_ILLEGAL_INSTRUCTION:dbg_error( "Illegal instruction" );
	case EXCEPTION_INT_DIVIDE_BY_ZERO:dbg_error( "Integer divide by zero" );
	case EXCEPTION_STACK_OVERFLOW:dbg_error( "Stack overflow" );
	}
	dbg_error( "Unknown exception" );
}

#else

void sighandler( int sig  ){
	switch( sig ){
	case SIGSEGV:dbg_error( "Memory access violation" );
	case SIGILL:dbg_error( "Illegal instruction" );
	case SIGFPE:dbg_error( "Floating point exception" );
#if !_WIN32
	case SIGBUS:dbg_error( "Bus error" );
#endif	
	}
	dbg_error( "Unknown signal" );
}

#endif

//entry point call by target main()...
//
int bb_std_main( int argc,const char **argv ){

	::argc=argc;
	::argv=argv;
	
#if _MSC_VER

	_set_se_translator( seTranslator );

#else
	
	signal( SIGSEGV,sighandler );
	signal( SIGILL,sighandler );
	signal( SIGFPE,sighandler );
#if !_WIN32
	signal( SIGBUS,sighandler );
#endif

#endif

	if( !setlocale( LC_CTYPE,"en_US.UTF-8" ) ){
		setlocale( LC_CTYPE,"" );
	}

	gc_init1();

	bbInit();
	
	gc_init2();

	bbMain();

	return 0;
}


//***** game.h *****

struct BBGameEvent{
	enum{
		None=0,
		KeyDown=1,KeyUp=2,KeyChar=3,
		MouseDown=4,MouseUp=5,MouseMove=6,
		TouchDown=7,TouchUp=8,TouchMove=9,
		MotionAccel=10
	};
};

class BBGameDelegate : public Object{
public:
	virtual void StartGame(){}
	virtual void SuspendGame(){}
	virtual void ResumeGame(){}
	virtual void UpdateGame(){}
	virtual void RenderGame(){}
	virtual void KeyEvent( int event,int data ){}
	virtual void MouseEvent( int event,int data,Float x,Float y, Float z ){}
	virtual void TouchEvent( int event,int data,Float x,Float y ){}
	virtual void MotionEvent( int event,int data,Float x,Float y,Float z ){}
	virtual void DiscardGraphics(){}
};

struct BBDisplayMode : public Object{
	int width;
	int height;
	int depth;
	int hertz;
	int flags;
	BBDisplayMode( int width=0,int height=0,int depth=0,int hertz=0,int flags=0 ):width(width),height(height),depth(depth),hertz(hertz),flags(flags){}
};

class BBGame{
public:
	BBGame();
	virtual ~BBGame(){}
	
	// ***** Extern *****
	static BBGame *Game(){ return _game; }
	
	virtual void SetDelegate( BBGameDelegate *delegate );
	virtual BBGameDelegate *Delegate(){ return _delegate; }
	
	virtual void SetKeyboardEnabled( bool enabled );
	virtual bool KeyboardEnabled();
	
	virtual void SetUpdateRate( int updateRate );
	virtual int UpdateRate();
	
	virtual bool Started(){ return _started; }
	virtual bool Suspended(){ return _suspended; }
	
	virtual int Millisecs();
	virtual void GetDate( Array<int> date );
	virtual int SaveState( String state );
	virtual String LoadState();
	virtual String LoadString( String path );
	virtual int CountJoysticks( bool update );
	virtual bool PollJoystick( int port,Array<Float> joyx,Array<Float> joyy,Array<Float> joyz,Array<bool> buttons );
	virtual void OpenUrl( String url );
	virtual void SetMouseVisible( bool visible );
	virtual void SetMousePos( double xpos, double ypos );
	virtual void SetClipboard( String _text );
	virtual String GetClipboard();
	
	virtual int GetDeviceWidth(){ return 0; }
	virtual int GetDeviceHeight(){ return 0; }
	virtual void SetDeviceWindow( int width,int height,int flags ){}
	virtual void SetDeviceWindowIcon( String _path ){}
	virtual void SetDeviceWindowPosition( int _x, int _y ){}
	virtual void SetDeviceWindowSize( int _width, int _height ){}
	virtual void SetDeviceWindowSizeLimits( int _minWidth, int _minHeight, int _maxWidth, int _maxHeight ){}
	virtual void SetDeviceWindowTitle( String _title ){}
	virtual Array<BBDisplayMode*> GetDisplayModes(){ return Array<BBDisplayMode*>(); }
	virtual BBDisplayMode *GetDesktopMode(){ return 0; }
	virtual void SetSwapInterval( int interval ){}

	// ***** Native *****
	virtual String PathToFilePath( String path );
	virtual FILE *OpenFile( String path,String mode );
	virtual unsigned char *LoadData( String path,int *plength );
	virtual unsigned char *LoadImageData( String path,int *width,int *height,int *depth ){ return 0; }
	virtual unsigned char *LoadAudioData( String path,int *length,int *channels,int *format,int *hertz ){ return 0; }
	
	//***** Internal *****
	virtual void Die( ThrowableObject *ex );
	virtual void gc_collect();
	virtual void StartGame();
	virtual void SuspendGame();
	virtual void ResumeGame();
	virtual void UpdateGame();
	virtual void RenderGame();
	virtual void KeyEvent( int ev,int data );
	virtual void MouseEvent( int ev,int data,float x,float y, float z );
	virtual void TouchEvent( int ev,int data,float x,float y );
	virtual void MotionEvent( int ev,int data,float x,float y,float z );
	virtual void DiscardGraphics();
	
protected:

	static BBGame *_game;

	BBGameDelegate *_delegate;
	bool _keyboardEnabled;
	int _updateRate;
	bool _started;
	bool _suspended;
};

//***** game.cpp *****

BBGame *BBGame::_game;

BBGame::BBGame():
_delegate( 0 ),
_keyboardEnabled( false ),
_updateRate( 0 ),
_started( false ),
_suspended( false ){
	_game=this;
}

void BBGame::SetDelegate( BBGameDelegate *delegate ){
	_delegate=delegate;
}

void BBGame::SetKeyboardEnabled( bool enabled ){
	_keyboardEnabled=enabled;
}

bool BBGame::KeyboardEnabled(){
	return _keyboardEnabled;
}

void BBGame::SetUpdateRate( int updateRate ){
	_updateRate=updateRate;
}

int BBGame::UpdateRate(){
	return _updateRate;
}

int BBGame::Millisecs(){
	return 0;
}

void BBGame::GetDate( Array<int> date ){
	int n=date.Length();
	if( n>0 ){
		time_t t=time( 0 );
		
#if _MSC_VER
		struct tm tii;
		struct tm *ti=&tii;
		localtime_s( ti,&t );
#else
		struct tm *ti=localtime( &t );
#endif

		date[0]=ti->tm_year+1900;
		if( n>1 ){ 
			date[1]=ti->tm_mon+1;
			if( n>2 ){
				date[2]=ti->tm_mday;
				if( n>3 ){
					date[3]=ti->tm_hour;
					if( n>4 ){
						date[4]=ti->tm_min;
						if( n>5 ){
							date[5]=ti->tm_sec;
							if( n>6 ){
								date[6]=0;
							}
						}
					}
				}
			}
		}
	}
}

int BBGame::SaveState( String state ){
	if( FILE *f=OpenFile( "./.cerberusstate","wb" ) ){
		bool ok=state.Save( f );
		fclose( f );
		return ok ? 0 : -2;
	}
	return -1;
}

String BBGame::LoadState(){
	if( FILE *f=OpenFile( "./.cerberusstate","rb" ) ){
		String str=String::Load( f );
		fclose( f );
		return str;
	}
	return "";
}

String BBGame::LoadString( String path ){
	if( FILE *fp=OpenFile( path,"rb" ) ){
		String str=String::Load( fp );
		fclose( fp );
		return str;
	}
	return "";
}

int BBGame::CountJoysticks( bool update ){
	return 0;
}

bool BBGame::PollJoystick( int port,Array<Float> joyx,Array<Float> joyy,Array<Float> joyz,Array<bool> buttons ){
	return false;
}

void BBGame::OpenUrl( String url ){
}

void BBGame::SetMouseVisible( bool visible ){
}

void BBGame::SetMousePos( double xpos, double ypos ){
}

void BBGame::SetClipboard( String _text ){
}

String BBGame::GetClipboard(){
	return "";
}

//***** C++ Game *****

String BBGame::PathToFilePath( String path ){
	return path;
}

FILE *BBGame::OpenFile( String path,String mode ){
	path=PathToFilePath( path );
	if( path=="" ) return 0;
	
#if __cplusplus_winrt
	path=path.Replace( "/","\\" );
	FILE *f;
	if( _wfopen_s( &f,path.ToCString<wchar_t>(),mode.ToCString<wchar_t>() ) ) return 0;
	return f;
#elif _WIN32
	return _wfopen( path.ToCString<wchar_t>(),mode.ToCString<wchar_t>() );
#else
	return fopen( path.ToCString<char>(),mode.ToCString<char>() );
#endif
}

unsigned char *BBGame::LoadData( String path,int *plength ){

	FILE *f=OpenFile( path,"rb" );
	if( !f ) return 0;

	const int BUF_SZ=4096;
	std::vector<void*> tmps;
	int length=0;
	
	for(;;){
		void *p=malloc( BUF_SZ );
		int n=fread( p,1,BUF_SZ,f );
		tmps.push_back( p );
		length+=n;
		if( n!=BUF_SZ ) break;
	}
	fclose( f );
	
	unsigned char *data=(unsigned char*)malloc( length );
	unsigned char *p=data;
	
	int sz=length;
	for( int i=0;i<tmps.size();++i ){
		int n=sz>BUF_SZ ? BUF_SZ : sz;
		memcpy( p,tmps[i],n );
		free( tmps[i] );
		sz-=n;
		p+=n;
	}
	
	*plength=length;
	
	gc_ext_malloced( length );
	
	return data;
}

//***** INTERNAL *****

void BBGame::Die( ThrowableObject *ex ){
	bbPrint( "Cerberus Runtime Error : Uncaught Cerberus Exception" );
#ifndef NDEBUG
	bbPrint( ex->stackTrace );
#endif
	exit( -1 );
}

void BBGame::gc_collect(){
	gc_mark( _delegate );
	::gc_collect();
}

void BBGame::StartGame(){

	if( _started ) return;
	_started=true;
	
	try{
		_delegate->StartGame();
	}catch( ThrowableObject *ex ){
		Die( ex );
	}
	gc_collect();
}

void BBGame::SuspendGame(){

	if( !_started || _suspended ) return;
	_suspended=true;
	
	try{
		_delegate->SuspendGame();
	}catch( ThrowableObject *ex ){
		Die( ex );
	}
	gc_collect();
}

void BBGame::ResumeGame(){

	if( !_started || !_suspended ) return;
	_suspended=false;
	
	try{
		_delegate->ResumeGame();
	}catch( ThrowableObject *ex ){
		Die( ex );
	}
	gc_collect();
}

void BBGame::UpdateGame(){

	if( !_started || _suspended ) return;
	
	try{
		_delegate->UpdateGame();
	}catch( ThrowableObject *ex ){
		Die( ex );
	}
	gc_collect();
}

void BBGame::RenderGame(){

	if( !_started ) return;
	
	try{
		_delegate->RenderGame();
	}catch( ThrowableObject *ex ){
		Die( ex );
	}
	gc_collect();
}

void BBGame::KeyEvent( int ev,int data ){

	if( !_started ) return;
	
	try{
		_delegate->KeyEvent( ev,data );
	}catch( ThrowableObject *ex ){
		Die( ex );
	}
	gc_collect();
}

void BBGame::MouseEvent( int ev,int data,float x,float y, float z ){

	if( !_started ) return;
	
	try{
		_delegate->MouseEvent( ev,data,x,y,z );
	}catch( ThrowableObject *ex ){
		Die( ex );
	}
	gc_collect();
}

void BBGame::TouchEvent( int ev,int data,float x,float y ){

	if( !_started ) return;
	
	try{
		_delegate->TouchEvent( ev,data,x,y );
	}catch( ThrowableObject *ex ){
		Die( ex );
	}
	gc_collect();
}

void BBGame::MotionEvent( int ev,int data,float x,float y,float z ){

	if( !_started ) return;
	
	try{
		_delegate->MotionEvent( ev,data,x,y,z );
	}catch( ThrowableObject *ex ){
		Die( ex );
	}
	gc_collect();
}

void BBGame::DiscardGraphics(){

	if( !_started ) return;
	
	try{
		_delegate->DiscardGraphics();
	}catch( ThrowableObject *ex ){
		Die( ex );
	}
	gc_collect();
}

// Stdcpp trans.system runtime.
//
// Placed into the public domain 24/02/2011.
// No warranty implied; use as your own risk.

#if _WIN32

#ifndef PATH_MAX
#define PATH_MAX MAX_PATH
#endif

typedef WCHAR OS_CHAR;
typedef struct _stat stat_t;

#define mkdir( X,Y ) _wmkdir( X )
#define rmdir _wrmdir
#define remove _wremove
#define rename _wrename
#define stat _wstat
#define _fopen _wfopen
#define putenv _wputenv
#define getenv _wgetenv
#define system _wsystem
#define chdir _wchdir
#define getcwd _wgetcwd
#define realpath(X,Y) _wfullpath( Y,X,PATH_MAX )	//Note: first args SWAPPED to be posix-like!
#define opendir _wopendir
#define readdir _wreaddir
#define closedir _wclosedir
#define DIR _WDIR
#define dirent _wdirent

#elif __APPLE__

typedef char OS_CHAR;
typedef struct stat stat_t;

#define _fopen fopen

#elif __linux

/*
#include <unistd.h>
#include <sys/stat.h>
#include <dirent.h>
*/

typedef char OS_CHAR;
typedef struct stat stat_t;

#define _fopen fopen

#endif

static String _appPath;
static Array<String> _appArgs;

static String::CString<char> C_STR( const String &t ){
	return t.ToCString<char>();
}

static String::CString<OS_CHAR> OS_STR( const String &t ){
	return t.ToCString<OS_CHAR>();
}

String HostOS(){
#if _WIN32
	return "winnt";
#elif __APPLE__
	return "macos";
#elif __linux
	return "linux";
#else
	return "";
#endif
}

String RealPath( String path ){
	std::vector<OS_CHAR> buf( PATH_MAX+1 );
	if( realpath( OS_STR( path ),&buf[0] ) ){}
	buf[buf.size()-1]=0;
	for( int i=0;i<PATH_MAX && buf[i];++i ){
		if( buf[i]=='\\' ) buf[i]='/';
		
	}
	return String( &buf[0] );
}

String AppPath(){

	if( _appPath.Length() ) return _appPath;
	
#if _WIN32

	OS_CHAR buf[PATH_MAX+1];
	GetModuleFileNameW( GetModuleHandleW(0),buf,PATH_MAX );
	buf[PATH_MAX]=0;
	_appPath=String( buf );
	
#elif __APPLE__

	char buf[PATH_MAX];
	uint32_t size=sizeof( buf );
	_NSGetExecutablePath( buf,&size );
	buf[PATH_MAX-1]=0;
	_appPath=String( buf );
	
#elif __linux

	char lnk[PATH_MAX],buf[PATH_MAX];
	pid_t pid=getpid();
	sprintf( lnk,"/proc/%i/exe",pid );
	int i=readlink( lnk,buf,PATH_MAX );
	if( i>0 && i<PATH_MAX ){
		buf[i]=0;
		_appPath=String( buf );
	}

#endif

	_appPath=RealPath( _appPath );
	return _appPath;
}

Array<String> AppArgs(){
	if( _appArgs.Length() ) return _appArgs;
	_appArgs=Array<String>( argc );
	for( int i=0;i<argc;++i ){
		_appArgs[i]=String( argv[i] );
	}
	return _appArgs;
}
	
int FileType( String path ){
	stat_t st;
	if( stat( OS_STR(path),&st ) ) return 0;
	switch( st.st_mode & S_IFMT ){
	case S_IFREG : return 1;
	case S_IFDIR : return 2;
	}
	return 0;
}

int FileSize( String path ){
	stat_t st;
	if( stat( OS_STR(path),&st ) ) return -1;
	return st.st_size;
}

int FileTime( String path ){
	stat_t st;
	if( stat( OS_STR(path),&st ) ) return -1;
	return st.st_mtime;
}

String LoadString( String path ){
	if( FILE *fp=_fopen( OS_STR(path),OS_STR("rb") ) ){
		String str=String::Load( fp );
		if( _str_load_err ){
			bbPrint( String( _str_load_err )+" in file: "+path );
		}
		fclose( fp );
		return str;
	}
	return "";
}
	
int SaveString( String str,String path ){
	if( FILE *fp=_fopen( OS_STR(path),OS_STR("wb") ) ){
		bool ok=str.Save( fp );
		fclose( fp );
		return ok ? 0 : -2;
	}else{
//		printf( "FOPEN 'wb' for SaveString '%s' failed\n",C_STR( path ) );
		fflush( stdout );
	}
	return -1;
}

Array<String> LoadDir( String path ){
	std::vector<String> files;
	
#if _WIN32

	WIN32_FIND_DATAW filedata;
	HANDLE handle=FindFirstFileW( OS_STR(path+"/*"),&filedata );
	if( handle!=INVALID_HANDLE_VALUE ){
		do{
			String f=filedata.cFileName;
			if( f=="." || f==".." ) continue;
			files.push_back( f );
		}while( FindNextFileW( handle,&filedata ) );
		FindClose( handle );
	}else{
//		printf( "FindFirstFileW for LoadDir(%s) failed\n",C_STR(path) );
		fflush( stdout );
	}
	
#else

	if( DIR *dir=opendir( OS_STR(path) ) ){
		while( dirent *ent=readdir( dir ) ){
			String f=ent->d_name;
			if( f=="." || f==".." ) continue;
			files.push_back( f );
		}
		closedir( dir );
	}else{
//		printf( "opendir for LoadDir(%s) failed\n",C_STR(path) );
		fflush( stdout );
	}

#endif

	return files.size() ? Array<String>( &files[0],files.size() ) : Array<String>();
}
	
int CopyFile( String srcpath,String dstpath ){

#if _WIN32

    if( CopyFileW( OS_STR(srcpath),OS_STR(dstpath),FALSE ) ) return 1;
    return 0;

#elif __APPLE__

    // Would like to use COPY_ALL here, but it breaks trans on MacOS - produces weird 'pch out of date' error with copied projects.
    //
    // Ranlib strikes back!
    //
    // DAWLANE - Added file attributes COPYFILE_XATTR | COPYFILE_STAT (NEEDS CONFIRMING)
    if( copyfile( OS_STR(srcpath),OS_STR(dstpath),0,COPYFILE_XATTR | COPYFILE_STAT | COPYFILE_DATA )>=0 ) return 1;
    return 0;

#else

    int err=-1;
    if( FILE *srcp=_fopen( OS_STR( srcpath ),OS_STR( "rb" ) ) ){
        err=-2;
        if( FILE *dstp=_fopen( OS_STR( dstpath ),OS_STR( "wb" ) ) ){
            err=0;
            char buf[1024];
            while( int n=fread( buf,1,1024,srcp ) ){
                if( fwrite( buf,1,n,dstp )!=n ){
                    err=-3;
                    break;
                }
            }
            fclose( dstp );
     
            // DAWLANE - Copy over the file attributes.
            struct stat st;
            stat( OS_STR( srcpath ), &st );
            chmod( OS_STR( dstpath ), st.st_mode );
        }else{
//            printf( "FOPEN 'wb' for CopyFile(%s,%s) failed\n",C_STR(srcpath),C_STR(dstpath) );
            fflush( stdout );
        }
        fclose( srcp );
    }else{
//        printf( "FOPEN 'rb' for CopyFile(%s,%s) failed\n",C_STR(srcpath),C_STR(dstpath) );
        fflush( stdout );
    }
    return err==0;

#endif
}

int ChangeDir( String path ){
	return chdir( OS_STR(path) );
}

String CurrentDir(){
	std::vector<OS_CHAR> buf( PATH_MAX+1 );
	if( getcwd( &buf[0],buf.size() ) ){}
	buf[buf.size()-1]=0;
	return String( &buf[0] );
}

int CreateDir( String path ){
	mkdir( OS_STR( path ),0777 );
	return FileType(path)==2;
}

int DeleteDir( String path ){
	rmdir( OS_STR(path) );
	return FileType(path)==0;
}

int DeleteFile( String path ){
	remove( OS_STR(path) );
	return FileType(path)==0;
}

int SetEnv( String name,String value ){
#if _WIN32
	return putenv( OS_STR( name+"="+value ) );
#else
	if( value.Length() ) return setenv( OS_STR( name ),OS_STR( value ),1 );
	unsetenv( OS_STR( name ) );
	return 0;
#endif
}

String GetEnv( String name ){
	if( OS_CHAR *p=getenv( OS_STR(name) ) ) return String( p );
	return "";
}

int Execute( String cmd ){

#if _WIN32

	cmd=String("cmd /S /C \"")+cmd+"\"";

	PROCESS_INFORMATION pi={0};
	STARTUPINFOW si={sizeof(si)};

	if( !CreateProcessW( 0,(WCHAR*)(const OS_CHAR*)OS_STR(cmd),0,0,1,CREATE_DEFAULT_ERROR_MODE,0,0,&si,&pi ) ) return -1;

	WaitForSingleObject( pi.hProcess,INFINITE );

	int res=GetExitCodeProcess( pi.hProcess,(DWORD*)&res ) ? res : -1;

	CloseHandle( pi.hProcess );
	CloseHandle( pi.hThread );

	return res;

#else

	return system( OS_STR(cmd) );

#endif
}

int ExitApp( int retcode ){
	exit( retcode );
	return 0;
}

#define STB_IMAGE_IMPLEMENTATION
#define STB_IMAGE_WRITE_IMPLEMENTATION
#define STB_IMAGE_RESIZE_IMPLEMENTATION
// undefining __STDC_WANT_SECURE_LIB__ makes an error disappear
#undef __STDC_WANT_SECURE_LIB__
/* stb_image - v2.25 - public domain image loader - http://nothings.org/stb
                                  no warranty implied; use at your own risk

   Do this:
      #define STB_IMAGE_IMPLEMENTATION
   before you include this file in *one* C or C++ file to create the implementation.

   // i.e. it should look like this:
   #include ...
   #include ...
   #include ...
   #define STB_IMAGE_IMPLEMENTATION
   #include "stb_image.h"

   You can #define STBI_ASSERT(x) before the #include to avoid using assert.h.
   And #define STBI_MALLOC, STBI_REALLOC, and STBI_FREE to avoid using malloc,realloc,free


   QUICK NOTES:
      Primarily of interest to game developers and other people who can
          avoid problematic images and only need the trivial interface

      JPEG baseline & progressive (12 bpc/arithmetic not supported, same as stock IJG lib)
      PNG 1/2/4/8/16-bit-per-channel

      TGA (not sure what subset, if a subset)
      BMP non-1bpp, non-RLE
      PSD (composited view only, no extra channels, 8/16 bit-per-channel)

      GIF (*comp always reports as 4-channel)
      HDR (radiance rgbE format)
      PIC (Softimage PIC)
      PNM (PPM and PGM binary only)

      Animated GIF still needs a proper API, but here's one way to do it:
          http://gist.github.com/urraka/685d9a6340b26b830d49

      - decode from memory or through FILE (define STBI_NO_STDIO to remove code)
      - decode from arbitrary I/O callbacks
      - SIMD acceleration on x86/x64 (SSE2) and ARM (NEON)

   Full documentation under "DOCUMENTATION" below.


LICENSE

  See end of file for license information.

RECENT REVISION HISTORY:

      2.25  (2020-02-02) fix warnings
      2.24  (2020-02-02) fix warnings; thread-local failure_reason and flip_vertically
      2.23  (2019-08-11) fix clang static analysis warning
      2.22  (2019-03-04) gif fixes, fix warnings
      2.21  (2019-02-25) fix typo in comment
      2.20  (2019-02-07) support utf8 filenames in Windows; fix warnings and platform ifdefs
      2.19  (2018-02-11) fix warning
      2.18  (2018-01-30) fix warnings
      2.17  (2018-01-29) bugfix, 1-bit BMP, 16-bitness query, fix warnings
      2.16  (2017-07-23) all functions have 16-bit variants; optimizations; bugfixes
      2.15  (2017-03-18) fix png-1,2,4; all Imagenet JPGs; no runtime SSE detection on GCC
      2.14  (2017-03-03) remove deprecated STBI_JPEG_OLD; fixes for Imagenet JPGs
      2.13  (2016-12-04) experimental 16-bit API, only for PNG so far; fixes
      2.12  (2016-04-02) fix typo in 2.11 PSD fix that caused crashes
      2.11  (2016-04-02) 16-bit PNGS; enable SSE2 in non-gcc x64
                         RGB-format JPEG; remove white matting in PSD;
                         allocate large structures on the stack;
                         correct channel count for PNG & BMP
      2.10  (2016-01-22) avoid warning introduced in 2.09
      2.09  (2016-01-16) 16-bit TGA; comments in PNM files; STBI_REALLOC_SIZED

   See end of file for full revision history.


 ============================    Contributors    =========================

 Image formats                          Extensions, features
    Sean Barrett (jpeg, png, bmp)          Jetro Lauha (stbi_info)
    Nicolas Schulz (hdr, psd)              Martin "SpartanJ" Golini (stbi_info)
    Jonathan Dummer (tga)                  James "moose2000" Brown (iPhone PNG)
    Jean-Marc Lienher (gif)                Ben "Disch" Wenger (io callbacks)
    Tom Seddon (pic)                       Omar Cornut (1/2/4-bit PNG)
    Thatcher Ulrich (psd)                  Nicolas Guillemot (vertical flip)
    Ken Miller (pgm, ppm)                  Richard Mitton (16-bit PSD)
    github:urraka (animated gif)           Junggon Kim (PNM comments)
    Christopher Forseth (animated gif)     Daniel Gibson (16-bit TGA)
                                           socks-the-fox (16-bit PNG)
                                           Jeremy Sawicki (handle all ImageNet JPGs)
 Optimizations & bugfixes                  Mikhail Morozov (1-bit BMP)
    Fabian "ryg" Giesen                    Anael Seghezzi (is-16-bit query)
    Arseny Kapoulkine
    John-Mark Allen
    Carmelo J Fdez-Aguera

 Bug & warning fixes
    Marc LeBlanc            David Woo          Guillaume George   Martins Mozeiko
    Christpher Lloyd        Jerry Jansson      Joseph Thomson     Phil Jordan
    Dave Moore              Roy Eltham         Hayaki Saito       Nathan Reed
    Won Chun                Luke Graham        Johan Duparc       Nick Verigakis
    the Horde3D community   Thomas Ruf         Ronny Chevalier    github:rlyeh
    Janez Zemva             John Bartholomew   Michal Cichon      github:romigrou
    Jonathan Blow           Ken Hamada         Tero Hanninen      github:svdijk
    Laurent Gomila          Cort Stratton      Sergio Gonzalez    github:snagar
    Aruelien Pocheville     Thibault Reuille   Cass Everitt       github:Zelex
    Ryamond Barbiero        Paul Du Bois       Engin Manap        github:grim210
    Aldo Culquicondor       Philipp Wiesemann  Dale Weiler        github:sammyhw
    Oriol Ferrer Mesia      Josh Tobin         Matthew Gregan     github:phprus
    Julian Raschke          Gregory Mullen     Baldur Karlsson    github:poppolopoppo
    Christian Floisand      Kevin Schmidt      JR Smith           github:darealshinji
    Brad Weinberger         Matvey Cherevko                       github:Michaelangel007
    Blazej Dariusz Roszkowski                  Alexander Veselov
*/

#ifndef STBI_INCLUDE_STB_IMAGE_H
#define STBI_INCLUDE_STB_IMAGE_H

// DOCUMENTATION
//
// Limitations:
//    - no 12-bit-per-channel JPEG
//    - no JPEGs with arithmetic coding
//    - GIF always returns *comp=4
//
// Basic usage (see HDR discussion below for HDR usage):
//    int x,y,n;
//    unsigned char *data = stbi_load(filename, &x, &y, &n, 0);
//    // ... process data if not NULL ...
//    // ... x = width, y = height, n = # 8-bit components per pixel ...
//    // ... replace '0' with '1'..'4' to force that many components per pixel
//    // ... but 'n' will always be the number that it would have been if you said 0
//    stbi_image_free(data)
//
// Standard parameters:
//    int *x                 -- outputs image width in pixels
//    int *y                 -- outputs image height in pixels
//    int *channels_in_file  -- outputs # of image components in image file
//    int desired_channels   -- if non-zero, # of image components requested in result
//
// The return value from an image loader is an 'unsigned char *' which points
// to the pixel data, or NULL on an allocation failure or if the image is
// corrupt or invalid. The pixel data consists of *y scanlines of *x pixels,
// with each pixel consisting of N interleaved 8-bit components; the first
// pixel pointed to is top-left-most in the image. There is no padding between
// image scanlines or between pixels, regardless of format. The number of
// components N is 'desired_channels' if desired_channels is non-zero, or
// *channels_in_file otherwise. If desired_channels is non-zero,
// *channels_in_file has the number of components that _would_ have been
// output otherwise. E.g. if you set desired_channels to 4, you will always
// get RGBA output, but you can check *channels_in_file to see if it's trivially
// opaque because e.g. there were only 3 channels in the source image.
//
// An output image with N components has the following components interleaved
// in this order in each pixel:
//
//     N=#comp     components
//       1           grey
//       2           grey, alpha
//       3           red, green, blue
//       4           red, green, blue, alpha
//
// If image loading fails for any reason, the return value will be NULL,
// and *x, *y, *channels_in_file will be unchanged. The function
// stbi_failure_reason() can be queried for an extremely brief, end-user
// unfriendly explanation of why the load failed. Define STBI_NO_FAILURE_STRINGS
// to avoid compiling these strings at all, and STBI_FAILURE_USERMSG to get slightly
// more user-friendly ones.
//
// Paletted PNG, BMP, GIF, and PIC images are automatically depalettized.
//
// ===========================================================================
//
// UNICODE:
//
//   If compiling for Windows and you wish to use Unicode filenames, compile
//   with
//       #define STBI_WINDOWS_UTF8
//   and pass utf8-encoded filenames. Call stbi_convert_wchar_to_utf8 to convert
//   Windows wchar_t filenames to utf8.
//
// ===========================================================================
//
// Philosophy
//
// stb libraries are designed with the following priorities:
//
//    1. easy to use
//    2. easy to maintain
//    3. good performance
//
// Sometimes I let "good performance" creep up in priority over "easy to maintain",
// and for best performance I may provide less-easy-to-use APIs that give higher
// performance, in addition to the easy-to-use ones. Nevertheless, it's important
// to keep in mind that from the standpoint of you, a client of this library,
// all you care about is #1 and #3, and stb libraries DO NOT emphasize #3 above all.
//
// Some secondary priorities arise directly from the first two, some of which
// provide more explicit reasons why performance can't be emphasized.
//
//    - Portable ("ease of use")
//    - Small source code footprint ("easy to maintain")
//    - No dependencies ("ease of use")
//
// ===========================================================================
//
// I/O callbacks
//
// I/O callbacks allow you to read from arbitrary sources, like packaged
// files or some other source. Data read from callbacks are processed
// through a small internal buffer (currently 128 bytes) to try to reduce
// overhead.
//
// The three functions you must define are "read" (reads some bytes of data),
// "skip" (skips some bytes of data), "eof" (reports if the stream is at the end).
//
// ===========================================================================
//
// SIMD support
//
// The JPEG decoder will try to automatically use SIMD kernels on x86 when
// supported by the compiler. For ARM Neon support, you must explicitly
// request it.
//
// (The old do-it-yourself SIMD API is no longer supported in the current
// code.)
//
// On x86, SSE2 will automatically be used when available based on a run-time
// test; if not, the generic C versions are used as a fall-back. On ARM targets,
// the typical path is to have separate builds for NEON and non-NEON devices
// (at least this is true for iOS and Android). Therefore, the NEON support is
// toggled by a build flag: define STBI_NEON to get NEON loops.
//
// If for some reason you do not want to use any of SIMD code, or if
// you have issues compiling it, you can disable it entirely by
// defining STBI_NO_SIMD.
//
// ===========================================================================
//
// HDR image support   (disable by defining STBI_NO_HDR)
//
// stb_image supports loading HDR images in general, and currently the Radiance
// .HDR file format specifically. You can still load any file through the existing
// interface; if you attempt to load an HDR file, it will be automatically remapped
// to LDR, assuming gamma 2.2 and an arbitrary scale factor defaulting to 1;
// both of these constants can be reconfigured through this interface:
//
//     stbi_hdr_to_ldr_gamma(2.2f);
//     stbi_hdr_to_ldr_scale(1.0f);
//
// (note, do not use _inverse_ constants; stbi_image will invert them
// appropriately).
//
// Additionally, there is a new, parallel interface for loading files as
// (linear) floats to preserve the full dynamic range:
//
//    float *data = stbi_loadf(filename, &x, &y, &n, 0);
//
// If you load LDR images through this interface, those images will
// be promoted to floating point values, run through the inverse of
// constants corresponding to the above:
//
//     stbi_ldr_to_hdr_scale(1.0f);
//     stbi_ldr_to_hdr_gamma(2.2f);
//
// Finally, given a filename (or an open file or memory block--see header
// file for details) containing image data, you can query for the "most
// appropriate" interface to use (that is, whether the image is HDR or
// not), using:
//
//     stbi_is_hdr(char *filename);
//
// ===========================================================================
//
// iPhone PNG support:
//
// By default we convert iphone-formatted PNGs back to RGB, even though
// they are internally encoded differently. You can disable this conversion
// by calling stbi_convert_iphone_png_to_rgb(0), in which case
// you will always just get the native iphone "format" through (which
// is BGR stored in RGB).
//
// Call stbi_set_unpremultiply_on_load(1) as well to force a divide per
// pixel to remove any premultiplied alpha *only* if the image file explicitly
// says there's premultiplied data (currently only happens in iPhone images,
// and only if iPhone convert-to-rgb processing is on).
//
// ===========================================================================
//
// ADDITIONAL CONFIGURATION
//
//  - You can suppress implementation of any of the decoders to reduce
//    your code footprint by #defining one or more of the following
//    symbols before creating the implementation.
//
//        STBI_NO_JPEG
//        STBI_NO_PNG
//        STBI_NO_BMP
//        STBI_NO_PSD
//        STBI_NO_TGA
//        STBI_NO_GIF
//        STBI_NO_HDR
//        STBI_NO_PIC
//        STBI_NO_PNM   (.ppm and .pgm)
//
//  - You can request *only* certain decoders and suppress all other ones
//    (this will be more forward-compatible, as addition of new decoders
//    doesn't require you to disable them explicitly):
//
//        STBI_ONLY_JPEG
//        STBI_ONLY_PNG
//        STBI_ONLY_BMP
//        STBI_ONLY_PSD
//        STBI_ONLY_TGA
//        STBI_ONLY_GIF
//        STBI_ONLY_HDR
//        STBI_ONLY_PIC
//        STBI_ONLY_PNM   (.ppm and .pgm)
//
//   - If you use STBI_NO_PNG (or _ONLY_ without PNG), and you still
//     want the zlib decoder to be available, #define STBI_SUPPORT_ZLIB
//


#ifndef STBI_NO_STDIO
#include <stdio.h>
#endif // STBI_NO_STDIO

#define STBI_VERSION 1

enum
{
   STBI_default = 0, // only used for desired_channels

   STBI_grey       = 1,
   STBI_grey_alpha = 2,
   STBI_rgb        = 3,
   STBI_rgb_alpha  = 4
};

#include <stdlib.h>
typedef unsigned char stbi_uc;
typedef unsigned short stbi_us;

#ifdef __cplusplus
extern "C" {
#endif

#ifndef STBIDEF
#ifdef STB_IMAGE_STATIC
#define STBIDEF static
#else
#define STBIDEF extern
#endif
#endif

//////////////////////////////////////////////////////////////////////////////
//
// PRIMARY API - works on images of any type
//

//
// load image by filename, open file, or memory buffer
//

typedef struct
{
   int      (*read)  (void *user,char *data,int size);   // fill 'data' with 'size' bytes.  return number of bytes actually read
   void     (*skip)  (void *user,int n);                 // skip the next 'n' bytes, or 'unget' the last -n bytes if negative
   int      (*eof)   (void *user);                       // returns nonzero if we are at end of file/data
} stbi_io_callbacks;

////////////////////////////////////
//
// 8-bits-per-channel interface
//

STBIDEF stbi_uc *stbi_load_from_memory   (stbi_uc           const *buffer, int len   , int *x, int *y, int *channels_in_file, int desired_channels);
STBIDEF stbi_uc *stbi_load_from_callbacks(stbi_io_callbacks const *clbk  , void *user, int *x, int *y, int *channels_in_file, int desired_channels);

#ifndef STBI_NO_STDIO
STBIDEF stbi_uc *stbi_load            (char const *filename, int *x, int *y, int *channels_in_file, int desired_channels);
STBIDEF stbi_uc *stbi_load_from_file  (FILE *f, int *x, int *y, int *channels_in_file, int desired_channels);
// for stbi_load_from_file, file pointer is left pointing immediately after image
#endif

#ifndef STBI_NO_GIF
STBIDEF stbi_uc *stbi_load_gif_from_memory(stbi_uc const *buffer, int len, int **delays, int *x, int *y, int *z, int *comp, int req_comp);
#endif

#ifdef STBI_WINDOWS_UTF8
STBIDEF int stbi_convert_wchar_to_utf8(char *buffer, size_t bufferlen, const wchar_t* input);
#endif

////////////////////////////////////
//
// 16-bits-per-channel interface
//

STBIDEF stbi_us *stbi_load_16_from_memory   (stbi_uc const *buffer, int len, int *x, int *y, int *channels_in_file, int desired_channels);
STBIDEF stbi_us *stbi_load_16_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *channels_in_file, int desired_channels);

#ifndef STBI_NO_STDIO
STBIDEF stbi_us *stbi_load_16          (char const *filename, int *x, int *y, int *channels_in_file, int desired_channels);
STBIDEF stbi_us *stbi_load_from_file_16(FILE *f, int *x, int *y, int *channels_in_file, int desired_channels);
#endif

////////////////////////////////////
//
// float-per-channel interface
//
#ifndef STBI_NO_LINEAR
   STBIDEF float *stbi_loadf_from_memory     (stbi_uc const *buffer, int len, int *x, int *y, int *channels_in_file, int desired_channels);
   STBIDEF float *stbi_loadf_from_callbacks  (stbi_io_callbacks const *clbk, void *user, int *x, int *y,  int *channels_in_file, int desired_channels);

   #ifndef STBI_NO_STDIO
   STBIDEF float *stbi_loadf            (char const *filename, int *x, int *y, int *channels_in_file, int desired_channels);
   STBIDEF float *stbi_loadf_from_file  (FILE *f, int *x, int *y, int *channels_in_file, int desired_channels);
   #endif
#endif

#ifndef STBI_NO_HDR
   STBIDEF void   stbi_hdr_to_ldr_gamma(float gamma);
   STBIDEF void   stbi_hdr_to_ldr_scale(float scale);
#endif // STBI_NO_HDR

#ifndef STBI_NO_LINEAR
   STBIDEF void   stbi_ldr_to_hdr_gamma(float gamma);
   STBIDEF void   stbi_ldr_to_hdr_scale(float scale);
#endif // STBI_NO_LINEAR

// stbi_is_hdr is always defined, but always returns false if STBI_NO_HDR
STBIDEF int    stbi_is_hdr_from_callbacks(stbi_io_callbacks const *clbk, void *user);
STBIDEF int    stbi_is_hdr_from_memory(stbi_uc const *buffer, int len);
#ifndef STBI_NO_STDIO
STBIDEF int      stbi_is_hdr          (char const *filename);
STBIDEF int      stbi_is_hdr_from_file(FILE *f);
#endif // STBI_NO_STDIO


// get a VERY brief reason for failure
// on most compilers (and ALL modern mainstream compilers) this is threadsafe
STBIDEF const char *stbi_failure_reason  (void);

// free the loaded image -- this is just free()
STBIDEF void     stbi_image_free      (void *retval_from_stbi_load);

// get image dimensions & components without fully decoding
STBIDEF int      stbi_info_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp);
STBIDEF int      stbi_info_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp);
STBIDEF int      stbi_is_16_bit_from_memory(stbi_uc const *buffer, int len);
STBIDEF int      stbi_is_16_bit_from_callbacks(stbi_io_callbacks const *clbk, void *user);

#ifndef STBI_NO_STDIO
STBIDEF int      stbi_info               (char const *filename,     int *x, int *y, int *comp);
STBIDEF int      stbi_info_from_file     (FILE *f,                  int *x, int *y, int *comp);
STBIDEF int      stbi_is_16_bit          (char const *filename);
STBIDEF int      stbi_is_16_bit_from_file(FILE *f);
#endif



// for image formats that explicitly notate that they have premultiplied alpha,
// we just return the colors as stored in the file. set this flag to force
// unpremultiplication. results are undefined if the unpremultiply overflow.
STBIDEF void stbi_set_unpremultiply_on_load(int flag_true_if_should_unpremultiply);

// indicate whether we should process iphone images back to canonical format,
// or just pass them through "as-is"
STBIDEF void stbi_convert_iphone_png_to_rgb(int flag_true_if_should_convert);

// flip the image vertically, so the first pixel in the output array is the bottom left
STBIDEF void stbi_set_flip_vertically_on_load(int flag_true_if_should_flip);

// as above, but only applies to images loaded on the thread that calls the function
// this function is only available if your compiler supports thread-local variables;
// calling it will fail to link if your compiler doesn't
STBIDEF void stbi_set_flip_vertically_on_load_thread(int flag_true_if_should_flip);

// ZLIB client - used by PNG, available for other purposes

STBIDEF char *stbi_zlib_decode_malloc_guesssize(const char *buffer, int len, int initial_size, int *outlen);
STBIDEF char *stbi_zlib_decode_malloc_guesssize_headerflag(const char *buffer, int len, int initial_size, int *outlen, int parse_header);
STBIDEF char *stbi_zlib_decode_malloc(const char *buffer, int len, int *outlen);
STBIDEF int   stbi_zlib_decode_buffer(char *obuffer, int olen, const char *ibuffer, int ilen);

STBIDEF char *stbi_zlib_decode_noheader_malloc(const char *buffer, int len, int *outlen);
STBIDEF int   stbi_zlib_decode_noheader_buffer(char *obuffer, int olen, const char *ibuffer, int ilen);


#ifdef __cplusplus
}
#endif

//
//
////   end header file   /////////////////////////////////////////////////////
#endif // STBI_INCLUDE_STB_IMAGE_H

#ifdef STB_IMAGE_IMPLEMENTATION

#if defined(STBI_ONLY_JPEG) || defined(STBI_ONLY_PNG) || defined(STBI_ONLY_BMP) \
  || defined(STBI_ONLY_TGA) || defined(STBI_ONLY_GIF) || defined(STBI_ONLY_PSD) \
  || defined(STBI_ONLY_HDR) || defined(STBI_ONLY_PIC) || defined(STBI_ONLY_PNM) \
  || defined(STBI_ONLY_ZLIB)
   #ifndef STBI_ONLY_JPEG
   #define STBI_NO_JPEG
   #endif
   #ifndef STBI_ONLY_PNG
   #define STBI_NO_PNG
   #endif
   #ifndef STBI_ONLY_BMP
   #define STBI_NO_BMP
   #endif
   #ifndef STBI_ONLY_PSD
   #define STBI_NO_PSD
   #endif
   #ifndef STBI_ONLY_TGA
   #define STBI_NO_TGA
   #endif
   #ifndef STBI_ONLY_GIF
   #define STBI_NO_GIF
   #endif
   #ifndef STBI_ONLY_HDR
   #define STBI_NO_HDR
   #endif
   #ifndef STBI_ONLY_PIC
   #define STBI_NO_PIC
   #endif
   #ifndef STBI_ONLY_PNM
   #define STBI_NO_PNM
   #endif
#endif

#if defined(STBI_NO_PNG) && !defined(STBI_SUPPORT_ZLIB) && !defined(STBI_NO_ZLIB)
#define STBI_NO_ZLIB
#endif


#include <stdarg.h>
#include <stddef.h> // ptrdiff_t on osx
#include <stdlib.h>
#include <string.h>
#include <limits.h>

#if !defined(STBI_NO_LINEAR) || !defined(STBI_NO_HDR)
#include <math.h>  // ldexp, pow
#endif

#ifndef STBI_NO_STDIO
#include <stdio.h>
#endif

#ifndef STBI_ASSERT
#include <assert.h>
#define STBI_ASSERT(x) assert(x)
#endif

#ifdef __cplusplus
#define STBI_EXTERN extern "C"
#else
#define STBI_EXTERN extern
#endif


#ifndef _MSC_VER
   #ifdef __cplusplus
   #define stbi_inline inline
   #else
   #define stbi_inline
   #endif
#else
   #define stbi_inline __forceinline
#endif

#ifndef STBI_NO_THREAD_LOCALS
   #if defined(__cplusplus) &&  __cplusplus >= 201103L
      #define STBI_THREAD_LOCAL       thread_local
   #elif defined (__STDC_VERSION__) && __STDC_VERSION__ >= 201112L
      #define STBI_THREAD_LOCAL       _Thread_local
   #elif defined(__GNUC__)
      #define STBI_THREAD_LOCAL       __thread
   #elif defined(_MSC_VER)
      #define STBI_THREAD_LOCAL       __declspec(thread)
#endif
#endif

#ifdef _MSC_VER
typedef unsigned short stbi__uint16;
typedef   signed short stbi__int16;
typedef unsigned int   stbi__uint32;
typedef   signed int   stbi__int32;
#else
#include <stdint.h>
typedef uint16_t stbi__uint16;
typedef int16_t  stbi__int16;
typedef uint32_t stbi__uint32;
typedef int32_t  stbi__int32;
#endif

// should produce compiler error if size is wrong
typedef unsigned char validate_uint32[sizeof(stbi__uint32)==4 ? 1 : -1];

#ifdef _MSC_VER
#define STBI_NOTUSED(v)  (void)(v)
#else
#define STBI_NOTUSED(v)  (void)sizeof(v)
#endif

#ifdef _MSC_VER
#define STBI_HAS_LROTL
#endif

#ifdef STBI_HAS_LROTL
   #define stbi_lrot(x,y)  _lrotl(x,y)
#else
   #define stbi_lrot(x,y)  (((x) << (y)) | ((x) >> (32 - (y))))
#endif

#if defined(STBI_MALLOC) && defined(STBI_FREE) && (defined(STBI_REALLOC) || defined(STBI_REALLOC_SIZED))
// ok
#elif !defined(STBI_MALLOC) && !defined(STBI_FREE) && !defined(STBI_REALLOC) && !defined(STBI_REALLOC_SIZED)
// ok
#else
#error "Must define all or none of STBI_MALLOC, STBI_FREE, and STBI_REALLOC (or STBI_REALLOC_SIZED)."
#endif

#ifndef STBI_MALLOC
#define STBI_MALLOC(sz)           malloc(sz)
#define STBI_REALLOC(p,newsz)     realloc(p,newsz)
#define STBI_FREE(p)              free(p)
#endif

#ifndef STBI_REALLOC_SIZED
#define STBI_REALLOC_SIZED(p,oldsz,newsz) STBI_REALLOC(p,newsz)
#endif

// x86/x64 detection
#if defined(__x86_64__) || defined(_M_X64)
#define STBI__X64_TARGET
#elif defined(__i386) || defined(_M_IX86)
#define STBI__X86_TARGET
#endif

#if defined(__GNUC__) && defined(STBI__X86_TARGET) && !defined(__SSE2__) && !defined(STBI_NO_SIMD)
// gcc doesn't support sse2 intrinsics unless you compile with -msse2,
// which in turn means it gets to use SSE2 everywhere. This is unfortunate,
// but previous attempts to provide the SSE2 functions with runtime
// detection caused numerous issues. The way architecture extensions are
// exposed in GCC/Clang is, sadly, not really suited for one-file libs.
// New behavior: if compiled with -msse2, we use SSE2 without any
// detection; if not, we don't use it at all.
#define STBI_NO_SIMD
#endif

#if defined(__MINGW32__) && defined(STBI__X86_TARGET) && !defined(STBI_MINGW_ENABLE_SSE2) && !defined(STBI_NO_SIMD)
// Note that __MINGW32__ doesn't actually mean 32-bit, so we have to avoid STBI__X64_TARGET
//
// 32-bit MinGW wants ESP to be 16-byte aligned, but this is not in the
// Windows ABI and VC++ as well as Windows DLLs don't maintain that invariant.
// As a result, enabling SSE2 on 32-bit MinGW is dangerous when not
// simultaneously enabling "-mstackrealign".
//
// See https://github.com/nothings/stb/issues/81 for more information.
//
// So default to no SSE2 on 32-bit MinGW. If you've read this far and added
// -mstackrealign to your build settings, feel free to #define STBI_MINGW_ENABLE_SSE2.
#define STBI_NO_SIMD
#endif

#if !defined(STBI_NO_SIMD) && (defined(STBI__X86_TARGET) || defined(STBI__X64_TARGET))
#define STBI_SSE2
#include <emmintrin.h>

#ifdef _MSC_VER

#if _MSC_VER >= 1400  // not VC6
#include <intrin.h> // __cpuid
static int stbi__cpuid3(void)
{
   int info[4];
   __cpuid(info,1);
   return info[3];
}
#else
static int stbi__cpuid3(void)
{
   int res;
   __asm {
      mov  eax,1
      cpuid
      mov  res,edx
   }
   return res;
}
#endif

#define STBI_SIMD_ALIGN(type, name) __declspec(align(16)) type name

#if !defined(STBI_NO_JPEG) && defined(STBI_SSE2)
static int stbi__sse2_available(void)
{
   int info3 = stbi__cpuid3();
   return ((info3 >> 26) & 1) != 0;
}
#endif

#else // assume GCC-style if not VC++
#define STBI_SIMD_ALIGN(type, name) type name __attribute__((aligned(16)))

#if !defined(STBI_NO_JPEG) && defined(STBI_SSE2)
static int stbi__sse2_available(void)
{
   // If we're even attempting to compile this on GCC/Clang, that means
   // -msse2 is on, which means the compiler is allowed to use SSE2
   // instructions at will, and so are we.
   return 1;
}
#endif

#endif
#endif

// ARM NEON
#if defined(STBI_NO_SIMD) && defined(STBI_NEON)
#undef STBI_NEON
#endif

#ifdef STBI_NEON
#include <arm_neon.h>
// assume GCC or Clang on ARM targets
#define STBI_SIMD_ALIGN(type, name) type name __attribute__((aligned(16)))
#endif

#ifndef STBI_SIMD_ALIGN
#define STBI_SIMD_ALIGN(type, name) type name
#endif

///////////////////////////////////////////////
//
//  stbi__context struct and start_xxx functions

// stbi__context structure is our basic context used by all images, so it
// contains all the IO context, plus some basic image information
typedef struct
{
   stbi__uint32 img_x, img_y;
   int img_n, img_out_n;

   stbi_io_callbacks io;
   void *io_user_data;

   int read_from_callbacks;
   int buflen;
   stbi_uc buffer_start[128];

   stbi_uc *img_buffer, *img_buffer_end;
   stbi_uc *img_buffer_original, *img_buffer_original_end;
} stbi__context;


static void stbi__refill_buffer(stbi__context *s);

// initialize a memory-decode context
static void stbi__start_mem(stbi__context *s, stbi_uc const *buffer, int len)
{
   s->io.read = NULL;
   s->read_from_callbacks = 0;
   s->img_buffer = s->img_buffer_original = (stbi_uc *) buffer;
   s->img_buffer_end = s->img_buffer_original_end = (stbi_uc *) buffer+len;
}

// initialize a callback-based context
static void stbi__start_callbacks(stbi__context *s, stbi_io_callbacks *c, void *user)
{
   s->io = *c;
   s->io_user_data = user;
   s->buflen = sizeof(s->buffer_start);
   s->read_from_callbacks = 1;
   s->img_buffer_original = s->buffer_start;
   stbi__refill_buffer(s);
   s->img_buffer_original_end = s->img_buffer_end;
}

#ifndef STBI_NO_STDIO

static int stbi__stdio_read(void *user, char *data, int size)
{
   return (int) fread(data,1,size,(FILE*) user);
}

static void stbi__stdio_skip(void *user, int n)
{
   fseek((FILE*) user, n, SEEK_CUR);
}

static int stbi__stdio_eof(void *user)
{
   return feof((FILE*) user);
}

static stbi_io_callbacks stbi__stdio_callbacks =
{
   stbi__stdio_read,
   stbi__stdio_skip,
   stbi__stdio_eof,
};

static void stbi__start_file(stbi__context *s, FILE *f)
{
   stbi__start_callbacks(s, &stbi__stdio_callbacks, (void *) f);
}

//static void stop_file(stbi__context *s) { }

#endif // !STBI_NO_STDIO

static void stbi__rewind(stbi__context *s)
{
   // conceptually rewind SHOULD rewind to the beginning of the stream,
   // but we just rewind to the beginning of the initial buffer, because
   // we only use it after doing 'test', which only ever looks at at most 92 bytes
   s->img_buffer = s->img_buffer_original;
   s->img_buffer_end = s->img_buffer_original_end;
}

enum
{
   STBI_ORDER_RGB,
   STBI_ORDER_BGR
};

typedef struct
{
   int bits_per_channel;
   int num_channels;
   int channel_order;
} stbi__result_info;

#ifndef STBI_NO_JPEG
static int      stbi__jpeg_test(stbi__context *s);
static void    *stbi__jpeg_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);
static int      stbi__jpeg_info(stbi__context *s, int *x, int *y, int *comp);
#endif

#ifndef STBI_NO_PNG
static int      stbi__png_test(stbi__context *s);
static void    *stbi__png_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);
static int      stbi__png_info(stbi__context *s, int *x, int *y, int *comp);
static int      stbi__png_is16(stbi__context *s);
#endif

#ifndef STBI_NO_BMP
static int      stbi__bmp_test(stbi__context *s);
static void    *stbi__bmp_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);
static int      stbi__bmp_info(stbi__context *s, int *x, int *y, int *comp);
#endif

#ifndef STBI_NO_TGA
static int      stbi__tga_test(stbi__context *s);
static void    *stbi__tga_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);
static int      stbi__tga_info(stbi__context *s, int *x, int *y, int *comp);
#endif

#ifndef STBI_NO_PSD
static int      stbi__psd_test(stbi__context *s);
static void    *stbi__psd_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri, int bpc);
static int      stbi__psd_info(stbi__context *s, int *x, int *y, int *comp);
static int      stbi__psd_is16(stbi__context *s);
#endif

#ifndef STBI_NO_HDR
static int      stbi__hdr_test(stbi__context *s);
static float   *stbi__hdr_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);
static int      stbi__hdr_info(stbi__context *s, int *x, int *y, int *comp);
#endif

#ifndef STBI_NO_PIC
static int      stbi__pic_test(stbi__context *s);
static void    *stbi__pic_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);
static int      stbi__pic_info(stbi__context *s, int *x, int *y, int *comp);
#endif

#ifndef STBI_NO_GIF
static int      stbi__gif_test(stbi__context *s);
static void    *stbi__gif_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);
static void    *stbi__load_gif_main(stbi__context *s, int **delays, int *x, int *y, int *z, int *comp, int req_comp);
static int      stbi__gif_info(stbi__context *s, int *x, int *y, int *comp);
#endif

#ifndef STBI_NO_PNM
static int      stbi__pnm_test(stbi__context *s);
static void    *stbi__pnm_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);
static int      stbi__pnm_info(stbi__context *s, int *x, int *y, int *comp);
#endif

static
#ifdef STBI_THREAD_LOCAL
STBI_THREAD_LOCAL
#endif
const char *stbi__g_failure_reason;

STBIDEF const char *stbi_failure_reason(void)
{
   return stbi__g_failure_reason;
}

#ifndef STBI_NO_FAILURE_STRINGS
static int stbi__err(const char *str)
{
   stbi__g_failure_reason = str;
   return 0;
}
#endif

static void *stbi__malloc(size_t size)
{
    return STBI_MALLOC(size);
}

// stb_image uses ints pervasively, including for offset calculations.
// therefore the largest decoded image size we can support with the
// current code, even on 64-bit targets, is INT_MAX. this is not a
// significant limitation for the intended use case.
//
// we do, however, need to make sure our size calculations don't
// overflow. hence a few helper functions for size calculations that
// multiply integers together, making sure that they're non-negative
// and no overflow occurs.

// return 1 if the sum is valid, 0 on overflow.
// negative terms are considered invalid.
static int stbi__addsizes_valid(int a, int b)
{
   if (b < 0) return 0;
   // now 0 <= b <= INT_MAX, hence also
   // 0 <= INT_MAX - b <= INTMAX.
   // And "a + b <= INT_MAX" (which might overflow) is the
   // same as a <= INT_MAX - b (no overflow)
   return a <= INT_MAX - b;
}

// returns 1 if the product is valid, 0 on overflow.
// negative factors are considered invalid.
static int stbi__mul2sizes_valid(int a, int b)
{
   if (a < 0 || b < 0) return 0;
   if (b == 0) return 1; // mul-by-0 is always safe
   // portable way to check for no overflows in a*b
   return a <= INT_MAX/b;
}

#if !defined(STBI_NO_JPEG) || !defined(STBI_NO_PNG) || !defined(STBI_NO_TGA) || !defined(STBI_NO_HDR)
// returns 1 if "a*b + add" has no negative terms/factors and doesn't overflow
static int stbi__mad2sizes_valid(int a, int b, int add)
{
   return stbi__mul2sizes_valid(a, b) && stbi__addsizes_valid(a*b, add);
}
#endif

// returns 1 if "a*b*c + add" has no negative terms/factors and doesn't overflow
static int stbi__mad3sizes_valid(int a, int b, int c, int add)
{
   return stbi__mul2sizes_valid(a, b) && stbi__mul2sizes_valid(a*b, c) &&
      stbi__addsizes_valid(a*b*c, add);
}

// returns 1 if "a*b*c*d + add" has no negative terms/factors and doesn't overflow
#if !defined(STBI_NO_LINEAR) || !defined(STBI_NO_HDR)
static int stbi__mad4sizes_valid(int a, int b, int c, int d, int add)
{
   return stbi__mul2sizes_valid(a, b) && stbi__mul2sizes_valid(a*b, c) &&
      stbi__mul2sizes_valid(a*b*c, d) && stbi__addsizes_valid(a*b*c*d, add);
}
#endif

#if !defined(STBI_NO_JPEG) || !defined(STBI_NO_PNG) || !defined(STBI_NO_TGA) || !defined(STBI_NO_HDR)
// mallocs with size overflow checking
static void *stbi__malloc_mad2(int a, int b, int add)
{
   if (!stbi__mad2sizes_valid(a, b, add)) return NULL;
   return stbi__malloc(a*b + add);
}
#endif

static void *stbi__malloc_mad3(int a, int b, int c, int add)
{
   if (!stbi__mad3sizes_valid(a, b, c, add)) return NULL;
   return stbi__malloc(a*b*c + add);
}

#if !defined(STBI_NO_LINEAR) || !defined(STBI_NO_HDR)
static void *stbi__malloc_mad4(int a, int b, int c, int d, int add)
{
   if (!stbi__mad4sizes_valid(a, b, c, d, add)) return NULL;
   return stbi__malloc(a*b*c*d + add);
}
#endif

// stbi__err - error
// stbi__errpf - error returning pointer to float
// stbi__errpuc - error returning pointer to unsigned char

#ifdef STBI_NO_FAILURE_STRINGS
   #define stbi__err(x,y)  0
#elif defined(STBI_FAILURE_USERMSG)
   #define stbi__err(x,y)  stbi__err(y)
#else
   #define stbi__err(x,y)  stbi__err(x)
#endif

#define stbi__errpf(x,y)   ((float *)(size_t) (stbi__err(x,y)?NULL:NULL))
#define stbi__errpuc(x,y)  ((unsigned char *)(size_t) (stbi__err(x,y)?NULL:NULL))

STBIDEF void stbi_image_free(void *retval_from_stbi_load)
{
   STBI_FREE(retval_from_stbi_load);
}

#ifndef STBI_NO_LINEAR
static float   *stbi__ldr_to_hdr(stbi_uc *data, int x, int y, int comp);
#endif

#ifndef STBI_NO_HDR
static stbi_uc *stbi__hdr_to_ldr(float   *data, int x, int y, int comp);
#endif

static int stbi__vertically_flip_on_load_global = 0;

STBIDEF void stbi_set_flip_vertically_on_load(int flag_true_if_should_flip)
{
   stbi__vertically_flip_on_load_global = flag_true_if_should_flip;
}

#ifndef STBI_THREAD_LOCAL
#define stbi__vertically_flip_on_load  stbi__vertically_flip_on_load_global
#else
static STBI_THREAD_LOCAL int stbi__vertically_flip_on_load_local, stbi__vertically_flip_on_load_set;

STBIDEF void stbi_set_flip_vertically_on_load_thread(int flag_true_if_should_flip)
{
   stbi__vertically_flip_on_load_local = flag_true_if_should_flip;
   stbi__vertically_flip_on_load_set = 1;
}

#define stbi__vertically_flip_on_load  (stbi__vertically_flip_on_load_set       \
                                         ? stbi__vertically_flip_on_load_local  \
                                         : stbi__vertically_flip_on_load_global)
#endif // STBI_THREAD_LOCAL

static void *stbi__load_main(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri, int bpc)
{
   memset(ri, 0, sizeof(*ri)); // make sure it's initialized if we add new fields
   ri->bits_per_channel = 8; // default is 8 so most paths don't have to be changed
   ri->channel_order = STBI_ORDER_RGB; // all current input & output are this, but this is here so we can add BGR order
   ri->num_channels = 0;

   #ifndef STBI_NO_JPEG
   if (stbi__jpeg_test(s)) return stbi__jpeg_load(s,x,y,comp,req_comp, ri);
   #endif
   #ifndef STBI_NO_PNG
   if (stbi__png_test(s))  return stbi__png_load(s,x,y,comp,req_comp, ri);
   #endif
   #ifndef STBI_NO_BMP
   if (stbi__bmp_test(s))  return stbi__bmp_load(s,x,y,comp,req_comp, ri);
   #endif
   #ifndef STBI_NO_GIF
   if (stbi__gif_test(s))  return stbi__gif_load(s,x,y,comp,req_comp, ri);
   #endif
   #ifndef STBI_NO_PSD
   if (stbi__psd_test(s))  return stbi__psd_load(s,x,y,comp,req_comp, ri, bpc);
   #else
   STBI_NOTUSED(bpc);
   #endif
   #ifndef STBI_NO_PIC
   if (stbi__pic_test(s))  return stbi__pic_load(s,x,y,comp,req_comp, ri);
   #endif
   #ifndef STBI_NO_PNM
   if (stbi__pnm_test(s))  return stbi__pnm_load(s,x,y,comp,req_comp, ri);
   #endif

   #ifndef STBI_NO_HDR
   if (stbi__hdr_test(s)) {
      float *hdr = stbi__hdr_load(s, x,y,comp,req_comp, ri);
      return stbi__hdr_to_ldr(hdr, *x, *y, req_comp ? req_comp : *comp);
   }
   #endif

   #ifndef STBI_NO_TGA
   // test tga last because it's a crappy test!
   if (stbi__tga_test(s))
      return stbi__tga_load(s,x,y,comp,req_comp, ri);
   #endif

   return stbi__errpuc("unknown image type", "Image not of any known type, or corrupt");
}

static stbi_uc *stbi__convert_16_to_8(stbi__uint16 *orig, int w, int h, int channels)
{
   int i;
   int img_len = w * h * channels;
   stbi_uc *reduced;

   reduced = (stbi_uc *) stbi__malloc(img_len);
   if (reduced == NULL) return stbi__errpuc("outofmem", "Out of memory");

   for (i = 0; i < img_len; ++i)
      reduced[i] = (stbi_uc)((orig[i] >> 8) & 0xFF); // top half of each byte is sufficient approx of 16->8 bit scaling

   STBI_FREE(orig);
   return reduced;
}

static stbi__uint16 *stbi__convert_8_to_16(stbi_uc *orig, int w, int h, int channels)
{
   int i;
   int img_len = w * h * channels;
   stbi__uint16 *enlarged;

   enlarged = (stbi__uint16 *) stbi__malloc(img_len*2);
   if (enlarged == NULL) return (stbi__uint16 *) stbi__errpuc("outofmem", "Out of memory");

   for (i = 0; i < img_len; ++i)
      enlarged[i] = (stbi__uint16)((orig[i] << 8) + orig[i]); // replicate to high and low byte, maps 0->0, 255->0xffff

   STBI_FREE(orig);
   return enlarged;
}

static void stbi__vertical_flip(void *image, int w, int h, int bytes_per_pixel)
{
   int row;
   size_t bytes_per_row = (size_t)w * bytes_per_pixel;
   stbi_uc temp[2048];
   stbi_uc *bytes = (stbi_uc *)image;

   for (row = 0; row < (h>>1); row++) {
      stbi_uc *row0 = bytes + row*bytes_per_row;
      stbi_uc *row1 = bytes + (h - row - 1)*bytes_per_row;
      // swap row0 with row1
      size_t bytes_left = bytes_per_row;
      while (bytes_left) {
         size_t bytes_copy = (bytes_left < sizeof(temp)) ? bytes_left : sizeof(temp);
         memcpy(temp, row0, bytes_copy);
         memcpy(row0, row1, bytes_copy);
         memcpy(row1, temp, bytes_copy);
         row0 += bytes_copy;
         row1 += bytes_copy;
         bytes_left -= bytes_copy;
      }
   }
}

#ifndef STBI_NO_GIF
static void stbi__vertical_flip_slices(void *image, int w, int h, int z, int bytes_per_pixel)
{
   int slice;
   int slice_size = w * h * bytes_per_pixel;

   stbi_uc *bytes = (stbi_uc *)image;
   for (slice = 0; slice < z; ++slice) {
      stbi__vertical_flip(bytes, w, h, bytes_per_pixel);
      bytes += slice_size;
   }
}
#endif

static unsigned char *stbi__load_and_postprocess_8bit(stbi__context *s, int *x, int *y, int *comp, int req_comp)
{
   stbi__result_info ri;
   void *result = stbi__load_main(s, x, y, comp, req_comp, &ri, 8);

   if (result == NULL)
      return NULL;

   if (ri.bits_per_channel != 8) {
      STBI_ASSERT(ri.bits_per_channel == 16);
      result = stbi__convert_16_to_8((stbi__uint16 *) result, *x, *y, req_comp == 0 ? *comp : req_comp);
      ri.bits_per_channel = 8;
   }

   // @TODO: move stbi__convert_format to here

   if (stbi__vertically_flip_on_load) {
      int channels = req_comp ? req_comp : *comp;
      stbi__vertical_flip(result, *x, *y, channels * sizeof(stbi_uc));
   }

   return (unsigned char *) result;
}

static stbi__uint16 *stbi__load_and_postprocess_16bit(stbi__context *s, int *x, int *y, int *comp, int req_comp)
{
   stbi__result_info ri;
   void *result = stbi__load_main(s, x, y, comp, req_comp, &ri, 16);

   if (result == NULL)
      return NULL;

   if (ri.bits_per_channel != 16) {
      STBI_ASSERT(ri.bits_per_channel == 8);
      result = stbi__convert_8_to_16((stbi_uc *) result, *x, *y, req_comp == 0 ? *comp : req_comp);
      ri.bits_per_channel = 16;
   }

   // @TODO: move stbi__convert_format16 to here
   // @TODO: special case RGB-to-Y (and RGBA-to-YA) for 8-bit-to-16-bit case to keep more precision

   if (stbi__vertically_flip_on_load) {
      int channels = req_comp ? req_comp : *comp;
      stbi__vertical_flip(result, *x, *y, channels * sizeof(stbi__uint16));
   }

   return (stbi__uint16 *) result;
}

#if !defined(STBI_NO_HDR) && !defined(STBI_NO_LINEAR)
static void stbi__float_postprocess(float *result, int *x, int *y, int *comp, int req_comp)
{
   if (stbi__vertically_flip_on_load && result != NULL) {
      int channels = req_comp ? req_comp : *comp;
      stbi__vertical_flip(result, *x, *y, channels * sizeof(float));
   }
}
#endif

#ifndef STBI_NO_STDIO

#if defined(_MSC_VER) && defined(STBI_WINDOWS_UTF8)
STBI_EXTERN __declspec(dllimport) int __stdcall MultiByteToWideChar(unsigned int cp, unsigned long flags, const char *str, int cbmb, wchar_t *widestr, int cchwide);
STBI_EXTERN __declspec(dllimport) int __stdcall WideCharToMultiByte(unsigned int cp, unsigned long flags, const wchar_t *widestr, int cchwide, char *str, int cbmb, const char *defchar, int *used_default);
#endif

#if defined(_MSC_VER) && defined(STBI_WINDOWS_UTF8)
STBIDEF int stbi_convert_wchar_to_utf8(char *buffer, size_t bufferlen, const wchar_t* input)
{
	return WideCharToMultiByte(65001 /* UTF8 */, 0, input, -1, buffer, (int) bufferlen, NULL, NULL);
}
#endif

static FILE *stbi__fopen(char const *filename, char const *mode)
{
   FILE *f;
#if defined(_MSC_VER) && defined(STBI_WINDOWS_UTF8)
   wchar_t wMode[64];
   wchar_t wFilename[1024];
	if (0 == MultiByteToWideChar(65001 /* UTF8 */, 0, filename, -1, wFilename, sizeof(wFilename)))
      return 0;

	if (0 == MultiByteToWideChar(65001 /* UTF8 */, 0, mode, -1, wMode, sizeof(wMode)))
      return 0;

#if _MSC_VER >= 1400
	if (0 != _wfopen_s(&f, wFilename, wMode))
		f = 0;
#else
   f = _wfopen(wFilename, wMode);
#endif

#elif defined(_MSC_VER) && _MSC_VER >= 1400
   if (0 != fopen_s(&f, filename, mode))
      f=0;
#else
   f = fopen(filename, mode);
#endif
   return f;
}


STBIDEF stbi_uc *stbi_load(char const *filename, int *x, int *y, int *comp, int req_comp)
{
   FILE *f = stbi__fopen(filename, "rb");
   unsigned char *result;
   if (!f) return stbi__errpuc("can't fopen", "Unable to open file");
   result = stbi_load_from_file(f,x,y,comp,req_comp);
   fclose(f);
   return result;
}

STBIDEF stbi_uc *stbi_load_from_file(FILE *f, int *x, int *y, int *comp, int req_comp)
{
   unsigned char *result;
   stbi__context s;
   stbi__start_file(&s,f);
   result = stbi__load_and_postprocess_8bit(&s,x,y,comp,req_comp);
   if (result) {
      // need to 'unget' all the characters in the IO buffer
      fseek(f, - (int) (s.img_buffer_end - s.img_buffer), SEEK_CUR);
   }
   return result;
}

STBIDEF stbi__uint16 *stbi_load_from_file_16(FILE *f, int *x, int *y, int *comp, int req_comp)
{
   stbi__uint16 *result;
   stbi__context s;
   stbi__start_file(&s,f);
   result = stbi__load_and_postprocess_16bit(&s,x,y,comp,req_comp);
   if (result) {
      // need to 'unget' all the characters in the IO buffer
      fseek(f, - (int) (s.img_buffer_end - s.img_buffer), SEEK_CUR);
   }
   return result;
}

STBIDEF stbi_us *stbi_load_16(char const *filename, int *x, int *y, int *comp, int req_comp)
{
   FILE *f = stbi__fopen(filename, "rb");
   stbi__uint16 *result;
   if (!f) return (stbi_us *) stbi__errpuc("can't fopen", "Unable to open file");
   result = stbi_load_from_file_16(f,x,y,comp,req_comp);
   fclose(f);
   return result;
}


#endif //!STBI_NO_STDIO

STBIDEF stbi_us *stbi_load_16_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *channels_in_file, int desired_channels)
{
   stbi__context s;
   stbi__start_mem(&s,buffer,len);
   return stbi__load_and_postprocess_16bit(&s,x,y,channels_in_file,desired_channels);
}

STBIDEF stbi_us *stbi_load_16_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *channels_in_file, int desired_channels)
{
   stbi__context s;
   stbi__start_callbacks(&s, (stbi_io_callbacks *)clbk, user);
   return stbi__load_and_postprocess_16bit(&s,x,y,channels_in_file,desired_channels);
}

STBIDEF stbi_uc *stbi_load_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp, int req_comp)
{
   stbi__context s;
   stbi__start_mem(&s,buffer,len);
   return stbi__load_and_postprocess_8bit(&s,x,y,comp,req_comp);
}

STBIDEF stbi_uc *stbi_load_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp, int req_comp)
{
   stbi__context s;
   stbi__start_callbacks(&s, (stbi_io_callbacks *) clbk, user);
   return stbi__load_and_postprocess_8bit(&s,x,y,comp,req_comp);
}

#ifndef STBI_NO_GIF
STBIDEF stbi_uc *stbi_load_gif_from_memory(stbi_uc const *buffer, int len, int **delays, int *x, int *y, int *z, int *comp, int req_comp)
{
   unsigned char *result;
   stbi__context s;
   stbi__start_mem(&s,buffer,len);

   result = (unsigned char*) stbi__load_gif_main(&s, delays, x, y, z, comp, req_comp);
   if (stbi__vertically_flip_on_load) {
      stbi__vertical_flip_slices( result, *x, *y, *z, *comp );
   }

   return result;
}
#endif

#ifndef STBI_NO_LINEAR
static float *stbi__loadf_main(stbi__context *s, int *x, int *y, int *comp, int req_comp)
{
   unsigned char *data;
   #ifndef STBI_NO_HDR
   if (stbi__hdr_test(s)) {
      stbi__result_info ri;
      float *hdr_data = stbi__hdr_load(s,x,y,comp,req_comp, &ri);
      if (hdr_data)
         stbi__float_postprocess(hdr_data,x,y,comp,req_comp);
      return hdr_data;
   }
   #endif
   data = stbi__load_and_postprocess_8bit(s, x, y, comp, req_comp);
   if (data)
      return stbi__ldr_to_hdr(data, *x, *y, req_comp ? req_comp : *comp);
   return stbi__errpf("unknown image type", "Image not of any known type, or corrupt");
}

STBIDEF float *stbi_loadf_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp, int req_comp)
{
   stbi__context s;
   stbi__start_mem(&s,buffer,len);
   return stbi__loadf_main(&s,x,y,comp,req_comp);
}

STBIDEF float *stbi_loadf_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp, int req_comp)
{
   stbi__context s;
   stbi__start_callbacks(&s, (stbi_io_callbacks *) clbk, user);
   return stbi__loadf_main(&s,x,y,comp,req_comp);
}

#ifndef STBI_NO_STDIO
STBIDEF float *stbi_loadf(char const *filename, int *x, int *y, int *comp, int req_comp)
{
   float *result;
   FILE *f = stbi__fopen(filename, "rb");
   if (!f) return stbi__errpf("can't fopen", "Unable to open file");
   result = stbi_loadf_from_file(f,x,y,comp,req_comp);
   fclose(f);
   return result;
}

STBIDEF float *stbi_loadf_from_file(FILE *f, int *x, int *y, int *comp, int req_comp)
{
   stbi__context s;
   stbi__start_file(&s,f);
   return stbi__loadf_main(&s,x,y,comp,req_comp);
}
#endif // !STBI_NO_STDIO

#endif // !STBI_NO_LINEAR

// these is-hdr-or-not is defined independent of whether STBI_NO_LINEAR is
// defined, for API simplicity; if STBI_NO_LINEAR is defined, it always
// reports false!

STBIDEF int stbi_is_hdr_from_memory(stbi_uc const *buffer, int len)
{
   #ifndef STBI_NO_HDR
   stbi__context s;
   stbi__start_mem(&s,buffer,len);
   return stbi__hdr_test(&s);
   #else
   STBI_NOTUSED(buffer);
   STBI_NOTUSED(len);
   return 0;
   #endif
}

#ifndef STBI_NO_STDIO
STBIDEF int      stbi_is_hdr          (char const *filename)
{
   FILE *f = stbi__fopen(filename, "rb");
   int result=0;
   if (f) {
      result = stbi_is_hdr_from_file(f);
      fclose(f);
   }
   return result;
}

STBIDEF int stbi_is_hdr_from_file(FILE *f)
{
   #ifndef STBI_NO_HDR
   long pos = ftell(f);
   int res;
   stbi__context s;
   stbi__start_file(&s,f);
   res = stbi__hdr_test(&s);
   fseek(f, pos, SEEK_SET);
   return res;
   #else
   STBI_NOTUSED(f);
   return 0;
   #endif
}
#endif // !STBI_NO_STDIO

STBIDEF int      stbi_is_hdr_from_callbacks(stbi_io_callbacks const *clbk, void *user)
{
   #ifndef STBI_NO_HDR
   stbi__context s;
   stbi__start_callbacks(&s, (stbi_io_callbacks *) clbk, user);
   return stbi__hdr_test(&s);
   #else
   STBI_NOTUSED(clbk);
   STBI_NOTUSED(user);
   return 0;
   #endif
}

#ifndef STBI_NO_LINEAR
static float stbi__l2h_gamma=2.2f, stbi__l2h_scale=1.0f;

STBIDEF void   stbi_ldr_to_hdr_gamma(float gamma) { stbi__l2h_gamma = gamma; }
STBIDEF void   stbi_ldr_to_hdr_scale(float scale) { stbi__l2h_scale = scale; }
#endif

static float stbi__h2l_gamma_i=1.0f/2.2f, stbi__h2l_scale_i=1.0f;

STBIDEF void   stbi_hdr_to_ldr_gamma(float gamma) { stbi__h2l_gamma_i = 1/gamma; }
STBIDEF void   stbi_hdr_to_ldr_scale(float scale) { stbi__h2l_scale_i = 1/scale; }


//////////////////////////////////////////////////////////////////////////////
//
// Common code used by all image loaders
//

enum
{
   STBI__SCAN_load=0,
   STBI__SCAN_type,
   STBI__SCAN_header
};

static void stbi__refill_buffer(stbi__context *s)
{
   int n = (s->io.read)(s->io_user_data,(char*)s->buffer_start,s->buflen);
   if (n == 0) {
      // at end of file, treat same as if from memory, but need to handle case
      // where s->img_buffer isn't pointing to safe memory, e.g. 0-byte file
      s->read_from_callbacks = 0;
      s->img_buffer = s->buffer_start;
      s->img_buffer_end = s->buffer_start+1;
      *s->img_buffer = 0;
   } else {
      s->img_buffer = s->buffer_start;
      s->img_buffer_end = s->buffer_start + n;
   }
}

stbi_inline static stbi_uc stbi__get8(stbi__context *s)
{
   if (s->img_buffer < s->img_buffer_end)
      return *s->img_buffer++;
   if (s->read_from_callbacks) {
      stbi__refill_buffer(s);
      return *s->img_buffer++;
   }
   return 0;
}

#if defined(STBI_NO_JPEG) && defined(STBI_NO_HDR) && defined(STBI_NO_PIC) && defined(STBI_NO_PNM)
// nothing
#else
stbi_inline static int stbi__at_eof(stbi__context *s)
{
   if (s->io.read) {
      if (!(s->io.eof)(s->io_user_data)) return 0;
      // if feof() is true, check if buffer = end
      // special case: we've only got the special 0 character at the end
      if (s->read_from_callbacks == 0) return 1;
   }

   return s->img_buffer >= s->img_buffer_end;
}
#endif

#if defined(STBI_NO_JPEG) && defined(STBI_NO_PNG) && defined(STBI_NO_BMP) && defined(STBI_NO_PSD) && defined(STBI_NO_TGA) && defined(STBI_NO_GIF) && defined(STBI_NO_PIC)
// nothing
#else
static void stbi__skip(stbi__context *s, int n)
{
   if (n < 0) {
      s->img_buffer = s->img_buffer_end;
      return;
   }
   if (s->io.read) {
      int blen = (int) (s->img_buffer_end - s->img_buffer);
      if (blen < n) {
         s->img_buffer = s->img_buffer_end;
         (s->io.skip)(s->io_user_data, n - blen);
         return;
      }
   }
   s->img_buffer += n;
}
#endif

#if defined(STBI_NO_PNG) && defined(STBI_NO_TGA) && defined(STBI_NO_HDR) && defined(STBI_NO_PNM)
// nothing
#else
static int stbi__getn(stbi__context *s, stbi_uc *buffer, int n)
{
   if (s->io.read) {
      int blen = (int) (s->img_buffer_end - s->img_buffer);
      if (blen < n) {
         int res, count;

         memcpy(buffer, s->img_buffer, blen);

         count = (s->io.read)(s->io_user_data, (char*) buffer + blen, n - blen);
         res = (count == (n-blen));
         s->img_buffer = s->img_buffer_end;
         return res;
      }
   }

   if (s->img_buffer+n <= s->img_buffer_end) {
      memcpy(buffer, s->img_buffer, n);
      s->img_buffer += n;
      return 1;
   } else
      return 0;
}
#endif

#if defined(STBI_NO_JPEG) && defined(STBI_NO_PNG) && defined(STBI_NO_PSD) && defined(STBI_NO_PIC)
// nothing
#else
static int stbi__get16be(stbi__context *s)
{
   int z = stbi__get8(s);
   return (z << 8) + stbi__get8(s);
}
#endif

#if defined(STBI_NO_PNG) && defined(STBI_NO_PSD) && defined(STBI_NO_PIC)
// nothing
#else
static stbi__uint32 stbi__get32be(stbi__context *s)
{
   stbi__uint32 z = stbi__get16be(s);
   return (z << 16) + stbi__get16be(s);
}
#endif

#if defined(STBI_NO_BMP) && defined(STBI_NO_TGA) && defined(STBI_NO_GIF)
// nothing
#else
static int stbi__get16le(stbi__context *s)
{
   int z = stbi__get8(s);
   return z + (stbi__get8(s) << 8);
}
#endif

#ifndef STBI_NO_BMP
static stbi__uint32 stbi__get32le(stbi__context *s)
{
   stbi__uint32 z = stbi__get16le(s);
   return z + (stbi__get16le(s) << 16);
}
#endif

#define STBI__BYTECAST(x)  ((stbi_uc) ((x) & 255))  // truncate int to byte without warnings

#if defined(STBI_NO_JPEG) && defined(STBI_NO_PNG) && defined(STBI_NO_BMP) && defined(STBI_NO_PSD) && defined(STBI_NO_TGA) && defined(STBI_NO_GIF) && defined(STBI_NO_PIC) && defined(STBI_NO_PNM)
// nothing
#else
//////////////////////////////////////////////////////////////////////////////
//
//  generic converter from built-in img_n to req_comp
//    individual types do this automatically as much as possible (e.g. jpeg
//    does all cases internally since it needs to colorspace convert anyway,
//    and it never has alpha, so very few cases ). png can automatically
//    interleave an alpha=255 channel, but falls back to this for other cases
//
//  assume data buffer is malloced, so malloc a new one and free that one
//  only failure mode is malloc failing

static stbi_uc stbi__compute_y(int r, int g, int b)
{
   return (stbi_uc) (((r*77) + (g*150) +  (29*b)) >> 8);
}
#endif

#if defined(STBI_NO_PNG) && defined(STBI_NO_BMP) && defined(STBI_NO_PSD) && defined(STBI_NO_TGA) && defined(STBI_NO_GIF) && defined(STBI_NO_PIC) && defined(STBI_NO_PNM)
// nothing
#else
static unsigned char *stbi__convert_format(unsigned char *data, int img_n, int req_comp, unsigned int x, unsigned int y)
{
   int i,j;
   unsigned char *good;

   if (req_comp == img_n) return data;
   STBI_ASSERT(req_comp >= 1 && req_comp <= 4);

   good = (unsigned char *) stbi__malloc_mad3(req_comp, x, y, 0);
   if (good == NULL) {
      STBI_FREE(data);
      return stbi__errpuc("outofmem", "Out of memory");
   }

   for (j=0; j < (int) y; ++j) {
      unsigned char *src  = data + j * x * img_n   ;
      unsigned char *dest = good + j * x * req_comp;

      #define STBI__COMBO(a,b)  ((a)*8+(b))
      #define STBI__CASE(a,b)   case STBI__COMBO(a,b): for(i=x-1; i >= 0; --i, src += a, dest += b)
      // convert source image with img_n components to one with req_comp components;
      // avoid switch per pixel, so use switch per scanline and massive macros
      switch (STBI__COMBO(img_n, req_comp)) {
         STBI__CASE(1,2) { dest[0]=src[0]; dest[1]=255;                                     } break;
         STBI__CASE(1,3) { dest[0]=dest[1]=dest[2]=src[0];                                  } break;
         STBI__CASE(1,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=255;                     } break;
         STBI__CASE(2,1) { dest[0]=src[0];                                                  } break;
         STBI__CASE(2,3) { dest[0]=dest[1]=dest[2]=src[0];                                  } break;
         STBI__CASE(2,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=src[1];                  } break;
         STBI__CASE(3,4) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];dest[3]=255;        } break;
         STBI__CASE(3,1) { dest[0]=stbi__compute_y(src[0],src[1],src[2]);                   } break;
         STBI__CASE(3,2) { dest[0]=stbi__compute_y(src[0],src[1],src[2]); dest[1] = 255;    } break;
         STBI__CASE(4,1) { dest[0]=stbi__compute_y(src[0],src[1],src[2]);                   } break;
         STBI__CASE(4,2) { dest[0]=stbi__compute_y(src[0],src[1],src[2]); dest[1] = src[3]; } break;
         STBI__CASE(4,3) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];                    } break;
         default: STBI_ASSERT(0);
      }
      #undef STBI__CASE
   }

   STBI_FREE(data);
   return good;
}
#endif

#if defined(STBI_NO_PNG) && defined(STBI_NO_PSD)
// nothing
#else
static stbi__uint16 stbi__compute_y_16(int r, int g, int b)
{
   return (stbi__uint16) (((r*77) + (g*150) +  (29*b)) >> 8);
}
#endif

#if defined(STBI_NO_PNG) && defined(STBI_NO_PSD)
// nothing
#else
static stbi__uint16 *stbi__convert_format16(stbi__uint16 *data, int img_n, int req_comp, unsigned int x, unsigned int y)
{
   int i,j;
   stbi__uint16 *good;

   if (req_comp == img_n) return data;
   STBI_ASSERT(req_comp >= 1 && req_comp <= 4);

   good = (stbi__uint16 *) stbi__malloc(req_comp * x * y * 2);
   if (good == NULL) {
      STBI_FREE(data);
      return (stbi__uint16 *) stbi__errpuc("outofmem", "Out of memory");
   }

   for (j=0; j < (int) y; ++j) {
      stbi__uint16 *src  = data + j * x * img_n   ;
      stbi__uint16 *dest = good + j * x * req_comp;

      #define STBI__COMBO(a,b)  ((a)*8+(b))
      #define STBI__CASE(a,b)   case STBI__COMBO(a,b): for(i=x-1; i >= 0; --i, src += a, dest += b)
      // convert source image with img_n components to one with req_comp components;
      // avoid switch per pixel, so use switch per scanline and massive macros
      switch (STBI__COMBO(img_n, req_comp)) {
         STBI__CASE(1,2) { dest[0]=src[0]; dest[1]=0xffff;                                     } break;
         STBI__CASE(1,3) { dest[0]=dest[1]=dest[2]=src[0];                                     } break;
         STBI__CASE(1,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=0xffff;                     } break;
         STBI__CASE(2,1) { dest[0]=src[0];                                                     } break;
         STBI__CASE(2,3) { dest[0]=dest[1]=dest[2]=src[0];                                     } break;
         STBI__CASE(2,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=src[1];                     } break;
         STBI__CASE(3,4) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];dest[3]=0xffff;        } break;
         STBI__CASE(3,1) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]);                   } break;
         STBI__CASE(3,2) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]); dest[1] = 0xffff; } break;
         STBI__CASE(4,1) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]);                   } break;
         STBI__CASE(4,2) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]); dest[1] = src[3]; } break;
         STBI__CASE(4,3) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];                       } break;
         default: STBI_ASSERT(0);
      }
      #undef STBI__CASE
   }

   STBI_FREE(data);
   return good;
}
#endif

#ifndef STBI_NO_LINEAR
static float   *stbi__ldr_to_hdr(stbi_uc *data, int x, int y, int comp)
{
   int i,k,n;
   float *output;
   if (!data) return NULL;
   output = (float *) stbi__malloc_mad4(x, y, comp, sizeof(float), 0);
   if (output == NULL) { STBI_FREE(data); return stbi__errpf("outofmem", "Out of memory"); }
   // compute number of non-alpha components
   if (comp & 1) n = comp; else n = comp-1;
   for (i=0; i < x*y; ++i) {
      for (k=0; k < n; ++k) {
         output[i*comp + k] = (float) (pow(data[i*comp+k]/255.0f, stbi__l2h_gamma) * stbi__l2h_scale);
      }
   }
   if (n < comp) {
      for (i=0; i < x*y; ++i) {
         output[i*comp + n] = data[i*comp + n]/255.0f;
      }
   }
   STBI_FREE(data);
   return output;
}
#endif

#ifndef STBI_NO_HDR
#define stbi__float2int(x)   ((int) (x))
static stbi_uc *stbi__hdr_to_ldr(float   *data, int x, int y, int comp)
{
   int i,k,n;
   stbi_uc *output;
   if (!data) return NULL;
   output = (stbi_uc *) stbi__malloc_mad3(x, y, comp, 0);
   if (output == NULL) { STBI_FREE(data); return stbi__errpuc("outofmem", "Out of memory"); }
   // compute number of non-alpha components
   if (comp & 1) n = comp; else n = comp-1;
   for (i=0; i < x*y; ++i) {
      for (k=0; k < n; ++k) {
         float z = (float) pow(data[i*comp+k]*stbi__h2l_scale_i, stbi__h2l_gamma_i) * 255 + 0.5f;
         if (z < 0) z = 0;
         if (z > 255) z = 255;
         output[i*comp + k] = (stbi_uc) stbi__float2int(z);
      }
      if (k < comp) {
         float z = data[i*comp+k] * 255 + 0.5f;
         if (z < 0) z = 0;
         if (z > 255) z = 255;
         output[i*comp + k] = (stbi_uc) stbi__float2int(z);
      }
   }
   STBI_FREE(data);
   return output;
}
#endif

//////////////////////////////////////////////////////////////////////////////
//
//  "baseline" JPEG/JFIF decoder
//
//    simple implementation
//      - doesn't support delayed output of y-dimension
//      - simple interface (only one output format: 8-bit interleaved RGB)
//      - doesn't try to recover corrupt jpegs
//      - doesn't allow partial loading, loading multiple at once
//      - still fast on x86 (copying globals into locals doesn't help x86)
//      - allocates lots of intermediate memory (full size of all components)
//        - non-interleaved case requires this anyway
//        - allows good upsampling (see next)
//    high-quality
//      - upsampled channels are bilinearly interpolated, even across blocks
//      - quality integer IDCT derived from IJG's 'slow'
//    performance
//      - fast huffman; reasonable integer IDCT
//      - some SIMD kernels for common paths on targets with SSE2/NEON
//      - uses a lot of intermediate memory, could cache poorly

#ifndef STBI_NO_JPEG

// huffman decoding acceleration
#define FAST_BITS   9  // larger handles more cases; smaller stomps less cache

typedef struct
{
   stbi_uc  fast[1 << FAST_BITS];
   // weirdly, repacking this into AoS is a 10% speed loss, instead of a win
   stbi__uint16 code[256];
   stbi_uc  values[256];
   stbi_uc  size[257];
   unsigned int maxcode[18];
   int    delta[17];   // old 'firstsymbol' - old 'firstcode'
} stbi__huffman;

typedef struct
{
   stbi__context *s;
   stbi__huffman huff_dc[4];
   stbi__huffman huff_ac[4];
   stbi__uint16 dequant[4][64];
   stbi__int16 fast_ac[4][1 << FAST_BITS];

// sizes for components, interleaved MCUs
   int img_h_max, img_v_max;
   int img_mcu_x, img_mcu_y;
   int img_mcu_w, img_mcu_h;

// definition of jpeg image component
   struct
   {
      int id;
      int h,v;
      int tq;
      int hd,ha;
      int dc_pred;

      int x,y,w2,h2;
      stbi_uc *data;
      void *raw_data, *raw_coeff;
      stbi_uc *linebuf;
      short   *coeff;   // progressive only
      int      coeff_w, coeff_h; // number of 8x8 coefficient blocks
   } img_comp[4];

   stbi__uint32   code_buffer; // jpeg entropy-coded buffer
   int            code_bits;   // number of valid bits
   unsigned char  marker;      // marker seen while filling entropy buffer
   int            nomore;      // flag if we saw a marker so must stop

   int            progressive;
   int            spec_start;
   int            spec_end;
   int            succ_high;
   int            succ_low;
   int            eob_run;
   int            jfif;
   int            app14_color_transform; // Adobe APP14 tag
   int            rgb;

   int scan_n, order[4];
   int restart_interval, todo;

// kernels
   void (*idct_block_kernel)(stbi_uc *out, int out_stride, short data[64]);
   void (*YCbCr_to_RGB_kernel)(stbi_uc *out, const stbi_uc *y, const stbi_uc *pcb, const stbi_uc *pcr, int count, int step);
   stbi_uc *(*resample_row_hv_2_kernel)(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs);
} stbi__jpeg;

static int stbi__build_huffman(stbi__huffman *h, int *count)
{
   int i,j,k=0;
   unsigned int code;
   // build size list for each symbol (from JPEG spec)
   for (i=0; i < 16; ++i)
      for (j=0; j < count[i]; ++j)
         h->size[k++] = (stbi_uc) (i+1);
   h->size[k] = 0;

   // compute actual symbols (from jpeg spec)
   code = 0;
   k = 0;
   for(j=1; j <= 16; ++j) {
      // compute delta to add to code to compute symbol id
      h->delta[j] = k - code;
      if (h->size[k] == j) {
         while (h->size[k] == j)
            h->code[k++] = (stbi__uint16) (code++);
         if (code-1 >= (1u << j)) return stbi__err("bad code lengths","Corrupt JPEG");
      }
      // compute largest code + 1 for this size, preshifted as needed later
      h->maxcode[j] = code << (16-j);
      code <<= 1;
   }
   h->maxcode[j] = 0xffffffff;

   // build non-spec acceleration table; 255 is flag for not-accelerated
   memset(h->fast, 255, 1 << FAST_BITS);
   for (i=0; i < k; ++i) {
      int s = h->size[i];
      if (s <= FAST_BITS) {
         int c = h->code[i] << (FAST_BITS-s);
         int m = 1 << (FAST_BITS-s);
         for (j=0; j < m; ++j) {
            h->fast[c+j] = (stbi_uc) i;
         }
      }
   }
   return 1;
}

// build a table that decodes both magnitude and value of small ACs in
// one go.
static void stbi__build_fast_ac(stbi__int16 *fast_ac, stbi__huffman *h)
{
   int i;
   for (i=0; i < (1 << FAST_BITS); ++i) {
      stbi_uc fast = h->fast[i];
      fast_ac[i] = 0;
      if (fast < 255) {
         int rs = h->values[fast];
         int run = (rs >> 4) & 15;
         int magbits = rs & 15;
         int len = h->size[fast];

         if (magbits && len + magbits <= FAST_BITS) {
            // magnitude code followed by receive_extend code
            int k = ((i << len) & ((1 << FAST_BITS) - 1)) >> (FAST_BITS - magbits);
            int m = 1 << (magbits - 1);
            if (k < m) k += (~0U << magbits) + 1;
            // if the result is small enough, we can fit it in fast_ac table
            if (k >= -128 && k <= 127)
               fast_ac[i] = (stbi__int16) ((k * 256) + (run * 16) + (len + magbits));
         }
      }
   }
}

static void stbi__grow_buffer_unsafe(stbi__jpeg *j)
{
   do {
      unsigned int b = j->nomore ? 0 : stbi__get8(j->s);
      if (b == 0xff) {
         int c = stbi__get8(j->s);
         while (c == 0xff) c = stbi__get8(j->s); // consume fill bytes
         if (c != 0) {
            j->marker = (unsigned char) c;
            j->nomore = 1;
            return;
         }
      }
      j->code_buffer |= b << (24 - j->code_bits);
      j->code_bits += 8;
   } while (j->code_bits <= 24);
}

// (1 << n) - 1
static const stbi__uint32 stbi__bmask[17]={0,1,3,7,15,31,63,127,255,511,1023,2047,4095,8191,16383,32767,65535};

// decode a jpeg huffman value from the bitstream
stbi_inline static int stbi__jpeg_huff_decode(stbi__jpeg *j, stbi__huffman *h)
{
   unsigned int temp;
   int c,k;

   if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);

   // look at the top FAST_BITS and determine what symbol ID it is,
   // if the code is <= FAST_BITS
   c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);
   k = h->fast[c];
   if (k < 255) {
      int s = h->size[k];
      if (s > j->code_bits)
         return -1;
      j->code_buffer <<= s;
      j->code_bits -= s;
      return h->values[k];
   }

   // naive test is to shift the code_buffer down so k bits are
   // valid, then test against maxcode. To speed this up, we've
   // preshifted maxcode left so that it has (16-k) 0s at the
   // end; in other words, regardless of the number of bits, it
   // wants to be compared against something shifted to have 16;
   // that way we don't need to shift inside the loop.
   temp = j->code_buffer >> 16;
   for (k=FAST_BITS+1 ; ; ++k)
      if (temp < h->maxcode[k])
         break;
   if (k == 17) {
      // error! code not found
      j->code_bits -= 16;
      return -1;
   }

   if (k > j->code_bits)
      return -1;

   // convert the huffman code to the symbol id
   c = ((j->code_buffer >> (32 - k)) & stbi__bmask[k]) + h->delta[k];
   STBI_ASSERT((((j->code_buffer) >> (32 - h->size[c])) & stbi__bmask[h->size[c]]) == h->code[c]);

   // convert the id to a symbol
   j->code_bits -= k;
   j->code_buffer <<= k;
   return h->values[c];
}

// bias[n] = (-1<<n) + 1
static const int stbi__jbias[16] = {0,-1,-3,-7,-15,-31,-63,-127,-255,-511,-1023,-2047,-4095,-8191,-16383,-32767};

// combined JPEG 'receive' and JPEG 'extend', since baseline
// always extends everything it receives.
stbi_inline static int stbi__extend_receive(stbi__jpeg *j, int n)
{
   unsigned int k;
   int sgn;
   if (j->code_bits < n) stbi__grow_buffer_unsafe(j);

   sgn = (stbi__int32)j->code_buffer >> 31; // sign bit is always in MSB
   k = stbi_lrot(j->code_buffer, n);
   STBI_ASSERT(n >= 0 && n < (int) (sizeof(stbi__bmask)/sizeof(*stbi__bmask)));
   j->code_buffer = k & ~stbi__bmask[n];
   k &= stbi__bmask[n];
   j->code_bits -= n;
   return k + (stbi__jbias[n] & ~sgn);
}

// get some unsigned bits
stbi_inline static int stbi__jpeg_get_bits(stbi__jpeg *j, int n)
{
   unsigned int k;
   if (j->code_bits < n) stbi__grow_buffer_unsafe(j);
   k = stbi_lrot(j->code_buffer, n);
   j->code_buffer = k & ~stbi__bmask[n];
   k &= stbi__bmask[n];
   j->code_bits -= n;
   return k;
}

stbi_inline static int stbi__jpeg_get_bit(stbi__jpeg *j)
{
   unsigned int k;
   if (j->code_bits < 1) stbi__grow_buffer_unsafe(j);
   k = j->code_buffer;
   j->code_buffer <<= 1;
   --j->code_bits;
   return k & 0x80000000;
}

// given a value that's at position X in the zigzag stream,
// where does it appear in the 8x8 matrix coded as row-major?
static const stbi_uc stbi__jpeg_dezigzag[64+15] =
{
    0,  1,  8, 16,  9,  2,  3, 10,
   17, 24, 32, 25, 18, 11,  4,  5,
   12, 19, 26, 33, 40, 48, 41, 34,
   27, 20, 13,  6,  7, 14, 21, 28,
   35, 42, 49, 56, 57, 50, 43, 36,
   29, 22, 15, 23, 30, 37, 44, 51,
   58, 59, 52, 45, 38, 31, 39, 46,
   53, 60, 61, 54, 47, 55, 62, 63,
   // let corrupt input sample past end
   63, 63, 63, 63, 63, 63, 63, 63,
   63, 63, 63, 63, 63, 63, 63
};

// decode one 64-entry block--
static int stbi__jpeg_decode_block(stbi__jpeg *j, short data[64], stbi__huffman *hdc, stbi__huffman *hac, stbi__int16 *fac, int b, stbi__uint16 *dequant)
{
   int diff,dc,k;
   int t;

   if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
   t = stbi__jpeg_huff_decode(j, hdc);
   if (t < 0) return stbi__err("bad huffman code","Corrupt JPEG");

   // 0 all the ac values now so we can do it 32-bits at a time
   memset(data,0,64*sizeof(data[0]));

   diff = t ? stbi__extend_receive(j, t) : 0;
   dc = j->img_comp[b].dc_pred + diff;
   j->img_comp[b].dc_pred = dc;
   data[0] = (short) (dc * dequant[0]);

   // decode AC components, see JPEG spec
   k = 1;
   do {
      unsigned int zig;
      int c,r,s;
      if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
      c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);
      r = fac[c];
      if (r) { // fast-AC path
         k += (r >> 4) & 15; // run
         s = r & 15; // combined length
         j->code_buffer <<= s;
         j->code_bits -= s;
         // decode into unzigzag'd location
         zig = stbi__jpeg_dezigzag[k++];
         data[zig] = (short) ((r >> 8) * dequant[zig]);
      } else {
         int rs = stbi__jpeg_huff_decode(j, hac);
         if (rs < 0) return stbi__err("bad huffman code","Corrupt JPEG");
         s = rs & 15;
         r = rs >> 4;
         if (s == 0) {
            if (rs != 0xf0) break; // end block
            k += 16;
         } else {
            k += r;
            // decode into unzigzag'd location
            zig = stbi__jpeg_dezigzag[k++];
            data[zig] = (short) (stbi__extend_receive(j,s) * dequant[zig]);
         }
      }
   } while (k < 64);
   return 1;
}

static int stbi__jpeg_decode_block_prog_dc(stbi__jpeg *j, short data[64], stbi__huffman *hdc, int b)
{
   int diff,dc;
   int t;
   if (j->spec_end != 0) return stbi__err("can't merge dc and ac", "Corrupt JPEG");

   if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);

   if (j->succ_high == 0) {
      // first scan for DC coefficient, must be first
      memset(data,0,64*sizeof(data[0])); // 0 all the ac values now
      t = stbi__jpeg_huff_decode(j, hdc);
      diff = t ? stbi__extend_receive(j, t) : 0;

      dc = j->img_comp[b].dc_pred + diff;
      j->img_comp[b].dc_pred = dc;
      data[0] = (short) (dc << j->succ_low);
   } else {
      // refinement scan for DC coefficient
      if (stbi__jpeg_get_bit(j))
         data[0] += (short) (1 << j->succ_low);
   }
   return 1;
}

// @OPTIMIZE: store non-zigzagged during the decode passes,
// and only de-zigzag when dequantizing
static int stbi__jpeg_decode_block_prog_ac(stbi__jpeg *j, short data[64], stbi__huffman *hac, stbi__int16 *fac)
{
   int k;
   if (j->spec_start == 0) return stbi__err("can't merge dc and ac", "Corrupt JPEG");

   if (j->succ_high == 0) {
      int shift = j->succ_low;

      if (j->eob_run) {
         --j->eob_run;
         return 1;
      }

      k = j->spec_start;
      do {
         unsigned int zig;
         int c,r,s;
         if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
         c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);
         r = fac[c];
         if (r) { // fast-AC path
            k += (r >> 4) & 15; // run
            s = r & 15; // combined length
            j->code_buffer <<= s;
            j->code_bits -= s;
            zig = stbi__jpeg_dezigzag[k++];
            data[zig] = (short) ((r >> 8) << shift);
         } else {
            int rs = stbi__jpeg_huff_decode(j, hac);
            if (rs < 0) return stbi__err("bad huffman code","Corrupt JPEG");
            s = rs & 15;
            r = rs >> 4;
            if (s == 0) {
               if (r < 15) {
                  j->eob_run = (1 << r);
                  if (r)
                     j->eob_run += stbi__jpeg_get_bits(j, r);
                  --j->eob_run;
                  break;
               }
               k += 16;
            } else {
               k += r;
               zig = stbi__jpeg_dezigzag[k++];
               data[zig] = (short) (stbi__extend_receive(j,s) << shift);
            }
         }
      } while (k <= j->spec_end);
   } else {
      // refinement scan for these AC coefficients

      short bit = (short) (1 << j->succ_low);

      if (j->eob_run) {
         --j->eob_run;
         for (k = j->spec_start; k <= j->spec_end; ++k) {
            short *p = &data[stbi__jpeg_dezigzag[k]];
            if (*p != 0)
               if (stbi__jpeg_get_bit(j))
                  if ((*p & bit)==0) {
                     if (*p > 0)
                        *p += bit;
                     else
                        *p -= bit;
                  }
         }
      } else {
         k = j->spec_start;
         do {
            int r,s;
            int rs = stbi__jpeg_huff_decode(j, hac); // @OPTIMIZE see if we can use the fast path here, advance-by-r is so slow, eh
            if (rs < 0) return stbi__err("bad huffman code","Corrupt JPEG");
            s = rs & 15;
            r = rs >> 4;
            if (s == 0) {
               if (r < 15) {
                  j->eob_run = (1 << r) - 1;
                  if (r)
                     j->eob_run += stbi__jpeg_get_bits(j, r);
                  r = 64; // force end of block
               } else {
                  // r=15 s=0 should write 16 0s, so we just do
                  // a run of 15 0s and then write s (which is 0),
                  // so we don't have to do anything special here
               }
            } else {
               if (s != 1) return stbi__err("bad huffman code", "Corrupt JPEG");
               // sign bit
               if (stbi__jpeg_get_bit(j))
                  s = bit;
               else
                  s = -bit;
            }

            // advance by r
            while (k <= j->spec_end) {
               short *p = &data[stbi__jpeg_dezigzag[k++]];
               if (*p != 0) {
                  if (stbi__jpeg_get_bit(j))
                     if ((*p & bit)==0) {
                        if (*p > 0)
                           *p += bit;
                        else
                           *p -= bit;
                     }
               } else {
                  if (r == 0) {
                     *p = (short) s;
                     break;
                  }
                  --r;
               }
            }
         } while (k <= j->spec_end);
      }
   }
   return 1;
}

// take a -128..127 value and stbi__clamp it and convert to 0..255
stbi_inline static stbi_uc stbi__clamp(int x)
{
   // trick to use a single test to catch both cases
   if ((unsigned int) x > 255) {
      if (x < 0) return 0;
      if (x > 255) return 255;
   }
   return (stbi_uc) x;
}

#define stbi__f2f(x)  ((int) (((x) * 4096 + 0.5)))
#define stbi__fsh(x)  ((x) * 4096)

// derived from jidctint -- DCT_ISLOW
#define STBI__IDCT_1D(s0,s1,s2,s3,s4,s5,s6,s7) \
   int t0,t1,t2,t3,p1,p2,p3,p4,p5,x0,x1,x2,x3; \
   p2 = s2;                                    \
   p3 = s6;                                    \
   p1 = (p2+p3) * stbi__f2f(0.5411961f);       \
   t2 = p1 + p3*stbi__f2f(-1.847759065f);      \
   t3 = p1 + p2*stbi__f2f( 0.765366865f);      \
   p2 = s0;                                    \
   p3 = s4;                                    \
   t0 = stbi__fsh(p2+p3);                      \
   t1 = stbi__fsh(p2-p3);                      \
   x0 = t0+t3;                                 \
   x3 = t0-t3;                                 \
   x1 = t1+t2;                                 \
   x2 = t1-t2;                                 \
   t0 = s7;                                    \
   t1 = s5;                                    \
   t2 = s3;                                    \
   t3 = s1;                                    \
   p3 = t0+t2;                                 \
   p4 = t1+t3;                                 \
   p1 = t0+t3;                                 \
   p2 = t1+t2;                                 \
   p5 = (p3+p4)*stbi__f2f( 1.175875602f);      \
   t0 = t0*stbi__f2f( 0.298631336f);           \
   t1 = t1*stbi__f2f( 2.053119869f);           \
   t2 = t2*stbi__f2f( 3.072711026f);           \
   t3 = t3*stbi__f2f( 1.501321110f);           \
   p1 = p5 + p1*stbi__f2f(-0.899976223f);      \
   p2 = p5 + p2*stbi__f2f(-2.562915447f);      \
   p3 = p3*stbi__f2f(-1.961570560f);           \
   p4 = p4*stbi__f2f(-0.390180644f);           \
   t3 += p1+p4;                                \
   t2 += p2+p3;                                \
   t1 += p2+p4;                                \
   t0 += p1+p3;

static void stbi__idct_block(stbi_uc *out, int out_stride, short data[64])
{
   int i,val[64],*v=val;
   stbi_uc *o;
   short *d = data;

   // columns
   for (i=0; i < 8; ++i,++d, ++v) {
      // if all zeroes, shortcut -- this avoids dequantizing 0s and IDCTing
      if (d[ 8]==0 && d[16]==0 && d[24]==0 && d[32]==0
           && d[40]==0 && d[48]==0 && d[56]==0) {
         //    no shortcut                 0     seconds
         //    (1|2|3|4|5|6|7)==0          0     seconds
         //    all separate               -0.047 seconds
         //    1 && 2|3 && 4|5 && 6|7:    -0.047 seconds
         int dcterm = d[0]*4;
         v[0] = v[8] = v[16] = v[24] = v[32] = v[40] = v[48] = v[56] = dcterm;
      } else {
         STBI__IDCT_1D(d[ 0],d[ 8],d[16],d[24],d[32],d[40],d[48],d[56])
         // constants scaled things up by 1<<12; let's bring them back
         // down, but keep 2 extra bits of precision
         x0 += 512; x1 += 512; x2 += 512; x3 += 512;
         v[ 0] = (x0+t3) >> 10;
         v[56] = (x0-t3) >> 10;
         v[ 8] = (x1+t2) >> 10;
         v[48] = (x1-t2) >> 10;
         v[16] = (x2+t1) >> 10;
         v[40] = (x2-t1) >> 10;
         v[24] = (x3+t0) >> 10;
         v[32] = (x3-t0) >> 10;
      }
   }

   for (i=0, v=val, o=out; i < 8; ++i,v+=8,o+=out_stride) {
      // no fast case since the first 1D IDCT spread components out
      STBI__IDCT_1D(v[0],v[1],v[2],v[3],v[4],v[5],v[6],v[7])
      // constants scaled things up by 1<<12, plus we had 1<<2 from first
      // loop, plus horizontal and vertical each scale by sqrt(8) so together
      // we've got an extra 1<<3, so 1<<17 total we need to remove.
      // so we want to round that, which means adding 0.5 * 1<<17,
      // aka 65536. Also, we'll end up with -128 to 127 that we want
      // to encode as 0..255 by adding 128, so we'll add that before the shift
      x0 += 65536 + (128<<17);
      x1 += 65536 + (128<<17);
      x2 += 65536 + (128<<17);
      x3 += 65536 + (128<<17);
      // tried computing the shifts into temps, or'ing the temps to see
      // if any were out of range, but that was slower
      o[0] = stbi__clamp((x0+t3) >> 17);
      o[7] = stbi__clamp((x0-t3) >> 17);
      o[1] = stbi__clamp((x1+t2) >> 17);
      o[6] = stbi__clamp((x1-t2) >> 17);
      o[2] = stbi__clamp((x2+t1) >> 17);
      o[5] = stbi__clamp((x2-t1) >> 17);
      o[3] = stbi__clamp((x3+t0) >> 17);
      o[4] = stbi__clamp((x3-t0) >> 17);
   }
}

#ifdef STBI_SSE2
// sse2 integer IDCT. not the fastest possible implementation but it
// produces bit-identical results to the generic C version so it's
// fully "transparent".
static void stbi__idct_simd(stbi_uc *out, int out_stride, short data[64])
{
   // This is constructed to match our regular (generic) integer IDCT exactly.
   __m128i row0, row1, row2, row3, row4, row5, row6, row7;
   __m128i tmp;

   // dot product constant: even elems=x, odd elems=y
   #define dct_const(x,y)  _mm_setr_epi16((x),(y),(x),(y),(x),(y),(x),(y))

   // out(0) = c0[even]*x + c0[odd]*y   (c0, x, y 16-bit, out 32-bit)
   // out(1) = c1[even]*x + c1[odd]*y
   #define dct_rot(out0,out1, x,y,c0,c1) \
      __m128i c0##lo = _mm_unpacklo_epi16((x),(y)); \
      __m128i c0##hi = _mm_unpackhi_epi16((x),(y)); \
      __m128i out0##_l = _mm_madd_epi16(c0##lo, c0); \
      __m128i out0##_h = _mm_madd_epi16(c0##hi, c0); \
      __m128i out1##_l = _mm_madd_epi16(c0##lo, c1); \
      __m128i out1##_h = _mm_madd_epi16(c0##hi, c1)

   // out = in << 12  (in 16-bit, out 32-bit)
   #define dct_widen(out, in) \
      __m128i out##_l = _mm_srai_epi32(_mm_unpacklo_epi16(_mm_setzero_si128(), (in)), 4); \
      __m128i out##_h = _mm_srai_epi32(_mm_unpackhi_epi16(_mm_setzero_si128(), (in)), 4)

   // wide add
   #define dct_wadd(out, a, b) \
      __m128i out##_l = _mm_add_epi32(a##_l, b##_l); \
      __m128i out##_h = _mm_add_epi32(a##_h, b##_h)

   // wide sub
   #define dct_wsub(out, a, b) \
      __m128i out##_l = _mm_sub_epi32(a##_l, b##_l); \
      __m128i out##_h = _mm_sub_epi32(a##_h, b##_h)

   // butterfly a/b, add bias, then shift by "s" and pack
   #define dct_bfly32o(out0, out1, a,b,bias,s) \
      { \
         __m128i abiased_l = _mm_add_epi32(a##_l, bias); \
         __m128i abiased_h = _mm_add_epi32(a##_h, bias); \
         dct_wadd(sum, abiased, b); \
         dct_wsub(dif, abiased, b); \
         out0 = _mm_packs_epi32(_mm_srai_epi32(sum_l, s), _mm_srai_epi32(sum_h, s)); \
         out1 = _mm_packs_epi32(_mm_srai_epi32(dif_l, s), _mm_srai_epi32(dif_h, s)); \
      }

   // 8-bit interleave step (for transposes)
   #define dct_interleave8(a, b) \
      tmp = a; \
      a = _mm_unpacklo_epi8(a, b); \
      b = _mm_unpackhi_epi8(tmp, b)

   // 16-bit interleave step (for transposes)
   #define dct_interleave16(a, b) \
      tmp = a; \
      a = _mm_unpacklo_epi16(a, b); \
      b = _mm_unpackhi_epi16(tmp, b)

   #define dct_pass(bias,shift) \
      { \
         /* even part */ \
         dct_rot(t2e,t3e, row2,row6, rot0_0,rot0_1); \
         __m128i sum04 = _mm_add_epi16(row0, row4); \
         __m128i dif04 = _mm_sub_epi16(row0, row4); \
         dct_widen(t0e, sum04); \
         dct_widen(t1e, dif04); \
         dct_wadd(x0, t0e, t3e); \
         dct_wsub(x3, t0e, t3e); \
         dct_wadd(x1, t1e, t2e); \
         dct_wsub(x2, t1e, t2e); \
         /* odd part */ \
         dct_rot(y0o,y2o, row7,row3, rot2_0,rot2_1); \
         dct_rot(y1o,y3o, row5,row1, rot3_0,rot3_1); \
         __m128i sum17 = _mm_add_epi16(row1, row7); \
         __m128i sum35 = _mm_add_epi16(row3, row5); \
         dct_rot(y4o,y5o, sum17,sum35, rot1_0,rot1_1); \
         dct_wadd(x4, y0o, y4o); \
         dct_wadd(x5, y1o, y5o); \
         dct_wadd(x6, y2o, y5o); \
         dct_wadd(x7, y3o, y4o); \
         dct_bfly32o(row0,row7, x0,x7,bias,shift); \
         dct_bfly32o(row1,row6, x1,x6,bias,shift); \
         dct_bfly32o(row2,row5, x2,x5,bias,shift); \
         dct_bfly32o(row3,row4, x3,x4,bias,shift); \
      }

   __m128i rot0_0 = dct_const(stbi__f2f(0.5411961f), stbi__f2f(0.5411961f) + stbi__f2f(-1.847759065f));
   __m128i rot0_1 = dct_const(stbi__f2f(0.5411961f) + stbi__f2f( 0.765366865f), stbi__f2f(0.5411961f));
   __m128i rot1_0 = dct_const(stbi__f2f(1.175875602f) + stbi__f2f(-0.899976223f), stbi__f2f(1.175875602f));
   __m128i rot1_1 = dct_const(stbi__f2f(1.175875602f), stbi__f2f(1.175875602f) + stbi__f2f(-2.562915447f));
   __m128i rot2_0 = dct_const(stbi__f2f(-1.961570560f) + stbi__f2f( 0.298631336f), stbi__f2f(-1.961570560f));
   __m128i rot2_1 = dct_const(stbi__f2f(-1.961570560f), stbi__f2f(-1.961570560f) + stbi__f2f( 3.072711026f));
   __m128i rot3_0 = dct_const(stbi__f2f(-0.390180644f) + stbi__f2f( 2.053119869f), stbi__f2f(-0.390180644f));
   __m128i rot3_1 = dct_const(stbi__f2f(-0.390180644f), stbi__f2f(-0.390180644f) + stbi__f2f( 1.501321110f));

   // rounding biases in column/row passes, see stbi__idct_block for explanation.
   __m128i bias_0 = _mm_set1_epi32(512);
   __m128i bias_1 = _mm_set1_epi32(65536 + (128<<17));

   // load
   row0 = _mm_load_si128((const __m128i *) (data + 0*8));
   row1 = _mm_load_si128((const __m128i *) (data + 1*8));
   row2 = _mm_load_si128((const __m128i *) (data + 2*8));
   row3 = _mm_load_si128((const __m128i *) (data + 3*8));
   row4 = _mm_load_si128((const __m128i *) (data + 4*8));
   row5 = _mm_load_si128((const __m128i *) (data + 5*8));
   row6 = _mm_load_si128((const __m128i *) (data + 6*8));
   row7 = _mm_load_si128((const __m128i *) (data + 7*8));

   // column pass
   dct_pass(bias_0, 10);

   {
      // 16bit 8x8 transpose pass 1
      dct_interleave16(row0, row4);
      dct_interleave16(row1, row5);
      dct_interleave16(row2, row6);
      dct_interleave16(row3, row7);

      // transpose pass 2
      dct_interleave16(row0, row2);
      dct_interleave16(row1, row3);
      dct_interleave16(row4, row6);
      dct_interleave16(row5, row7);

      // transpose pass 3
      dct_interleave16(row0, row1);
      dct_interleave16(row2, row3);
      dct_interleave16(row4, row5);
      dct_interleave16(row6, row7);
   }

   // row pass
   dct_pass(bias_1, 17);

   {
      // pack
      __m128i p0 = _mm_packus_epi16(row0, row1); // a0a1a2a3...a7b0b1b2b3...b7
      __m128i p1 = _mm_packus_epi16(row2, row3);
      __m128i p2 = _mm_packus_epi16(row4, row5);
      __m128i p3 = _mm_packus_epi16(row6, row7);

      // 8bit 8x8 transpose pass 1
      dct_interleave8(p0, p2); // a0e0a1e1...
      dct_interleave8(p1, p3); // c0g0c1g1...

      // transpose pass 2
      dct_interleave8(p0, p1); // a0c0e0g0...
      dct_interleave8(p2, p3); // b0d0f0h0...

      // transpose pass 3
      dct_interleave8(p0, p2); // a0b0c0d0...
      dct_interleave8(p1, p3); // a4b4c4d4...

      // store
      _mm_storel_epi64((__m128i *) out, p0); out += out_stride;
      _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p0, 0x4e)); out += out_stride;
      _mm_storel_epi64((__m128i *) out, p2); out += out_stride;
      _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p2, 0x4e)); out += out_stride;
      _mm_storel_epi64((__m128i *) out, p1); out += out_stride;
      _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p1, 0x4e)); out += out_stride;
      _mm_storel_epi64((__m128i *) out, p3); out += out_stride;
      _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p3, 0x4e));
   }

#undef dct_const
#undef dct_rot
#undef dct_widen
#undef dct_wadd
#undef dct_wsub
#undef dct_bfly32o
#undef dct_interleave8
#undef dct_interleave16
#undef dct_pass
}

#endif // STBI_SSE2

#ifdef STBI_NEON

// NEON integer IDCT. should produce bit-identical
// results to the generic C version.
static void stbi__idct_simd(stbi_uc *out, int out_stride, short data[64])
{
   int16x8_t row0, row1, row2, row3, row4, row5, row6, row7;

   int16x4_t rot0_0 = vdup_n_s16(stbi__f2f(0.5411961f));
   int16x4_t rot0_1 = vdup_n_s16(stbi__f2f(-1.847759065f));
   int16x4_t rot0_2 = vdup_n_s16(stbi__f2f( 0.765366865f));
   int16x4_t rot1_0 = vdup_n_s16(stbi__f2f( 1.175875602f));
   int16x4_t rot1_1 = vdup_n_s16(stbi__f2f(-0.899976223f));
   int16x4_t rot1_2 = vdup_n_s16(stbi__f2f(-2.562915447f));
   int16x4_t rot2_0 = vdup_n_s16(stbi__f2f(-1.961570560f));
   int16x4_t rot2_1 = vdup_n_s16(stbi__f2f(-0.390180644f));
   int16x4_t rot3_0 = vdup_n_s16(stbi__f2f( 0.298631336f));
   int16x4_t rot3_1 = vdup_n_s16(stbi__f2f( 2.053119869f));
   int16x4_t rot3_2 = vdup_n_s16(stbi__f2f( 3.072711026f));
   int16x4_t rot3_3 = vdup_n_s16(stbi__f2f( 1.501321110f));

#define dct_long_mul(out, inq, coeff) \
   int32x4_t out##_l = vmull_s16(vget_low_s16(inq), coeff); \
   int32x4_t out##_h = vmull_s16(vget_high_s16(inq), coeff)

#define dct_long_mac(out, acc, inq, coeff) \
   int32x4_t out##_l = vmlal_s16(acc##_l, vget_low_s16(inq), coeff); \
   int32x4_t out##_h = vmlal_s16(acc##_h, vget_high_s16(inq), coeff)

#define dct_widen(out, inq) \
   int32x4_t out##_l = vshll_n_s16(vget_low_s16(inq), 12); \
   int32x4_t out##_h = vshll_n_s16(vget_high_s16(inq), 12)

// wide add
#define dct_wadd(out, a, b) \
   int32x4_t out##_l = vaddq_s32(a##_l, b##_l); \
   int32x4_t out##_h = vaddq_s32(a##_h, b##_h)

// wide sub
#define dct_wsub(out, a, b) \
   int32x4_t out##_l = vsubq_s32(a##_l, b##_l); \
   int32x4_t out##_h = vsubq_s32(a##_h, b##_h)

// butterfly a/b, then shift using "shiftop" by "s" and pack
#define dct_bfly32o(out0,out1, a,b,shiftop,s) \
   { \
      dct_wadd(sum, a, b); \
      dct_wsub(dif, a, b); \
      out0 = vcombine_s16(shiftop(sum_l, s), shiftop(sum_h, s)); \
      out1 = vcombine_s16(shiftop(dif_l, s), shiftop(dif_h, s)); \
   }

#define dct_pass(shiftop, shift) \
   { \
      /* even part */ \
      int16x8_t sum26 = vaddq_s16(row2, row6); \
      dct_long_mul(p1e, sum26, rot0_0); \
      dct_long_mac(t2e, p1e, row6, rot0_1); \
      dct_long_mac(t3e, p1e, row2, rot0_2); \
      int16x8_t sum04 = vaddq_s16(row0, row4); \
      int16x8_t dif04 = vsubq_s16(row0, row4); \
      dct_widen(t0e, sum04); \
      dct_widen(t1e, dif04); \
      dct_wadd(x0, t0e, t3e); \
      dct_wsub(x3, t0e, t3e); \
      dct_wadd(x1, t1e, t2e); \
      dct_wsub(x2, t1e, t2e); \
      /* odd part */ \
      int16x8_t sum15 = vaddq_s16(row1, row5); \
      int16x8_t sum17 = vaddq_s16(row1, row7); \
      int16x8_t sum35 = vaddq_s16(row3, row5); \
      int16x8_t sum37 = vaddq_s16(row3, row7); \
      int16x8_t sumodd = vaddq_s16(sum17, sum35); \
      dct_long_mul(p5o, sumodd, rot1_0); \
      dct_long_mac(p1o, p5o, sum17, rot1_1); \
      dct_long_mac(p2o, p5o, sum35, rot1_2); \
      dct_long_mul(p3o, sum37, rot2_0); \
      dct_long_mul(p4o, sum15, rot2_1); \
      dct_wadd(sump13o, p1o, p3o); \
      dct_wadd(sump24o, p2o, p4o); \
      dct_wadd(sump23o, p2o, p3o); \
      dct_wadd(sump14o, p1o, p4o); \
      dct_long_mac(x4, sump13o, row7, rot3_0); \
      dct_long_mac(x5, sump24o, row5, rot3_1); \
      dct_long_mac(x6, sump23o, row3, rot3_2); \
      dct_long_mac(x7, sump14o, row1, rot3_3); \
      dct_bfly32o(row0,row7, x0,x7,shiftop,shift); \
      dct_bfly32o(row1,row6, x1,x6,shiftop,shift); \
      dct_bfly32o(row2,row5, x2,x5,shiftop,shift); \
      dct_bfly32o(row3,row4, x3,x4,shiftop,shift); \
   }

   // load
   row0 = vld1q_s16(data + 0*8);
   row1 = vld1q_s16(data + 1*8);
   row2 = vld1q_s16(data + 2*8);
   row3 = vld1q_s16(data + 3*8);
   row4 = vld1q_s16(data + 4*8);
   row5 = vld1q_s16(data + 5*8);
   row6 = vld1q_s16(data + 6*8);
   row7 = vld1q_s16(data + 7*8);

   // add DC bias
   row0 = vaddq_s16(row0, vsetq_lane_s16(1024, vdupq_n_s16(0), 0));

   // column pass
   dct_pass(vrshrn_n_s32, 10);

   // 16bit 8x8 transpose
   {
// these three map to a single VTRN.16, VTRN.32, and VSWP, respectively.
// whether compilers actually get this is another story, sadly.
#define dct_trn16(x, y) { int16x8x2_t t = vtrnq_s16(x, y); x = t.val[0]; y = t.val[1]; }
#define dct_trn32(x, y) { int32x4x2_t t = vtrnq_s32(vreinterpretq_s32_s16(x), vreinterpretq_s32_s16(y)); x = vreinterpretq_s16_s32(t.val[0]); y = vreinterpretq_s16_s32(t.val[1]); }
#define dct_trn64(x, y) { int16x8_t x0 = x; int16x8_t y0 = y; x = vcombine_s16(vget_low_s16(x0), vget_low_s16(y0)); y = vcombine_s16(vget_high_s16(x0), vget_high_s16(y0)); }

      // pass 1
      dct_trn16(row0, row1); // a0b0a2b2a4b4a6b6
      dct_trn16(row2, row3);
      dct_trn16(row4, row5);
      dct_trn16(row6, row7);

      // pass 2
      dct_trn32(row0, row2); // a0b0c0d0a4b4c4d4
      dct_trn32(row1, row3);
      dct_trn32(row4, row6);
      dct_trn32(row5, row7);

      // pass 3
      dct_trn64(row0, row4); // a0b0c0d0e0f0g0h0
      dct_trn64(row1, row5);
      dct_trn64(row2, row6);
      dct_trn64(row3, row7);

#undef dct_trn16
#undef dct_trn32
#undef dct_trn64
   }

   // row pass
   // vrshrn_n_s32 only supports shifts up to 16, we need
   // 17. so do a non-rounding shift of 16 first then follow
   // up with a rounding shift by 1.
   dct_pass(vshrn_n_s32, 16);

   {
      // pack and round
      uint8x8_t p0 = vqrshrun_n_s16(row0, 1);
      uint8x8_t p1 = vqrshrun_n_s16(row1, 1);
      uint8x8_t p2 = vqrshrun_n_s16(row2, 1);
      uint8x8_t p3 = vqrshrun_n_s16(row3, 1);
      uint8x8_t p4 = vqrshrun_n_s16(row4, 1);
      uint8x8_t p5 = vqrshrun_n_s16(row5, 1);
      uint8x8_t p6 = vqrshrun_n_s16(row6, 1);
      uint8x8_t p7 = vqrshrun_n_s16(row7, 1);

      // again, these can translate into one instruction, but often don't.
#define dct_trn8_8(x, y) { uint8x8x2_t t = vtrn_u8(x, y); x = t.val[0]; y = t.val[1]; }
#define dct_trn8_16(x, y) { uint16x4x2_t t = vtrn_u16(vreinterpret_u16_u8(x), vreinterpret_u16_u8(y)); x = vreinterpret_u8_u16(t.val[0]); y = vreinterpret_u8_u16(t.val[1]); }
#define dct_trn8_32(x, y) { uint32x2x2_t t = vtrn_u32(vreinterpret_u32_u8(x), vreinterpret_u32_u8(y)); x = vreinterpret_u8_u32(t.val[0]); y = vreinterpret_u8_u32(t.val[1]); }

      // sadly can't use interleaved stores here since we only write
      // 8 bytes to each scan line!

      // 8x8 8-bit transpose pass 1
      dct_trn8_8(p0, p1);
      dct_trn8_8(p2, p3);
      dct_trn8_8(p4, p5);
      dct_trn8_8(p6, p7);

      // pass 2
      dct_trn8_16(p0, p2);
      dct_trn8_16(p1, p3);
      dct_trn8_16(p4, p6);
      dct_trn8_16(p5, p7);

      // pass 3
      dct_trn8_32(p0, p4);
      dct_trn8_32(p1, p5);
      dct_trn8_32(p2, p6);
      dct_trn8_32(p3, p7);

      // store
      vst1_u8(out, p0); out += out_stride;
      vst1_u8(out, p1); out += out_stride;
      vst1_u8(out, p2); out += out_stride;
      vst1_u8(out, p3); out += out_stride;
      vst1_u8(out, p4); out += out_stride;
      vst1_u8(out, p5); out += out_stride;
      vst1_u8(out, p6); out += out_stride;
      vst1_u8(out, p7);

#undef dct_trn8_8
#undef dct_trn8_16
#undef dct_trn8_32
   }

#undef dct_long_mul
#undef dct_long_mac
#undef dct_widen
#undef dct_wadd
#undef dct_wsub
#undef dct_bfly32o
#undef dct_pass
}

#endif // STBI_NEON

#define STBI__MARKER_none  0xff
// if there's a pending marker from the entropy stream, return that
// otherwise, fetch from the stream and get a marker. if there's no
// marker, return 0xff, which is never a valid marker value
static stbi_uc stbi__get_marker(stbi__jpeg *j)
{
   stbi_uc x;
   if (j->marker != STBI__MARKER_none) { x = j->marker; j->marker = STBI__MARKER_none; return x; }
   x = stbi__get8(j->s);
   if (x != 0xff) return STBI__MARKER_none;
   while (x == 0xff)
      x = stbi__get8(j->s); // consume repeated 0xff fill bytes
   return x;
}

// in each scan, we'll have scan_n components, and the order
// of the components is specified by order[]
#define STBI__RESTART(x)     ((x) >= 0xd0 && (x) <= 0xd7)

// after a restart interval, stbi__jpeg_reset the entropy decoder and
// the dc prediction
static void stbi__jpeg_reset(stbi__jpeg *j)
{
   j->code_bits = 0;
   j->code_buffer = 0;
   j->nomore = 0;
   j->img_comp[0].dc_pred = j->img_comp[1].dc_pred = j->img_comp[2].dc_pred = j->img_comp[3].dc_pred = 0;
   j->marker = STBI__MARKER_none;
   j->todo = j->restart_interval ? j->restart_interval : 0x7fffffff;
   j->eob_run = 0;
   // no more than 1<<31 MCUs if no restart_interal? that's plenty safe,
   // since we don't even allow 1<<30 pixels
}

static int stbi__parse_entropy_coded_data(stbi__jpeg *z)
{
   stbi__jpeg_reset(z);
   if (!z->progressive) {
      if (z->scan_n == 1) {
         int i,j;
         STBI_SIMD_ALIGN(short, data[64]);
         int n = z->order[0];
         // non-interleaved data, we just need to process one block at a time,
         // in trivial scanline order
         // number of blocks to do just depends on how many actual "pixels" this
         // component has, independent of interleaved MCU blocking and such
         int w = (z->img_comp[n].x+7) >> 3;
         int h = (z->img_comp[n].y+7) >> 3;
         for (j=0; j < h; ++j) {
            for (i=0; i < w; ++i) {
               int ha = z->img_comp[n].ha;
               if (!stbi__jpeg_decode_block(z, data, z->huff_dc+z->img_comp[n].hd, z->huff_ac+ha, z->fast_ac[ha], n, z->dequant[z->img_comp[n].tq])) return 0;
               z->idct_block_kernel(z->img_comp[n].data+z->img_comp[n].w2*j*8+i*8, z->img_comp[n].w2, data);
               // every data block is an MCU, so countdown the restart interval
               if (--z->todo <= 0) {
                  if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
                  // if it's NOT a restart, then just bail, so we get corrupt data
                  // rather than no data
                  if (!STBI__RESTART(z->marker)) return 1;
                  stbi__jpeg_reset(z);
               }
            }
         }
         return 1;
      } else { // interleaved
         int i,j,k,x,y;
         STBI_SIMD_ALIGN(short, data[64]);
         for (j=0; j < z->img_mcu_y; ++j) {
            for (i=0; i < z->img_mcu_x; ++i) {
               // scan an interleaved mcu... process scan_n components in order
               for (k=0; k < z->scan_n; ++k) {
                  int n = z->order[k];
                  // scan out an mcu's worth of this component; that's just determined
                  // by the basic H and V specified for the component
                  for (y=0; y < z->img_comp[n].v; ++y) {
                     for (x=0; x < z->img_comp[n].h; ++x) {
                        int x2 = (i*z->img_comp[n].h + x)*8;
                        int y2 = (j*z->img_comp[n].v + y)*8;
                        int ha = z->img_comp[n].ha;
                        if (!stbi__jpeg_decode_block(z, data, z->huff_dc+z->img_comp[n].hd, z->huff_ac+ha, z->fast_ac[ha], n, z->dequant[z->img_comp[n].tq])) return 0;
                        z->idct_block_kernel(z->img_comp[n].data+z->img_comp[n].w2*y2+x2, z->img_comp[n].w2, data);
                     }
                  }
               }
               // after all interleaved components, that's an interleaved MCU,
               // so now count down the restart interval
               if (--z->todo <= 0) {
                  if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
                  if (!STBI__RESTART(z->marker)) return 1;
                  stbi__jpeg_reset(z);
               }
            }
         }
         return 1;
      }
   } else {
      if (z->scan_n == 1) {
         int i,j;
         int n = z->order[0];
         // non-interleaved data, we just need to process one block at a time,
         // in trivial scanline order
         // number of blocks to do just depends on how many actual "pixels" this
         // component has, independent of interleaved MCU blocking and such
         int w = (z->img_comp[n].x+7) >> 3;
         int h = (z->img_comp[n].y+7) >> 3;
         for (j=0; j < h; ++j) {
            for (i=0; i < w; ++i) {
               short *data = z->img_comp[n].coeff + 64 * (i + j * z->img_comp[n].coeff_w);
               if (z->spec_start == 0) {
                  if (!stbi__jpeg_decode_block_prog_dc(z, data, &z->huff_dc[z->img_comp[n].hd], n))
                     return 0;
               } else {
                  int ha = z->img_comp[n].ha;
                  if (!stbi__jpeg_decode_block_prog_ac(z, data, &z->huff_ac[ha], z->fast_ac[ha]))
                     return 0;
               }
               // every data block is an MCU, so countdown the restart interval
               if (--z->todo <= 0) {
                  if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
                  if (!STBI__RESTART(z->marker)) return 1;
                  stbi__jpeg_reset(z);
               }
            }
         }
         return 1;
      } else { // interleaved
         int i,j,k,x,y;
         for (j=0; j < z->img_mcu_y; ++j) {
            for (i=0; i < z->img_mcu_x; ++i) {
               // scan an interleaved mcu... process scan_n components in order
               for (k=0; k < z->scan_n; ++k) {
                  int n = z->order[k];
                  // scan out an mcu's worth of this component; that's just determined
                  // by the basic H and V specified for the component
                  for (y=0; y < z->img_comp[n].v; ++y) {
                     for (x=0; x < z->img_comp[n].h; ++x) {
                        int x2 = (i*z->img_comp[n].h + x);
                        int y2 = (j*z->img_comp[n].v + y);
                        short *data = z->img_comp[n].coeff + 64 * (x2 + y2 * z->img_comp[n].coeff_w);
                        if (!stbi__jpeg_decode_block_prog_dc(z, data, &z->huff_dc[z->img_comp[n].hd], n))
                           return 0;
                     }
                  }
               }
               // after all interleaved components, that's an interleaved MCU,
               // so now count down the restart interval
               if (--z->todo <= 0) {
                  if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
                  if (!STBI__RESTART(z->marker)) return 1;
                  stbi__jpeg_reset(z);
               }
            }
         }
         return 1;
      }
   }
}

static void stbi__jpeg_dequantize(short *data, stbi__uint16 *dequant)
{
   int i;
   for (i=0; i < 64; ++i)
      data[i] *= dequant[i];
}

static void stbi__jpeg_finish(stbi__jpeg *z)
{
   if (z->progressive) {
      // dequantize and idct the data
      int i,j,n;
      for (n=0; n < z->s->img_n; ++n) {
         int w = (z->img_comp[n].x+7) >> 3;
         int h = (z->img_comp[n].y+7) >> 3;
         for (j=0; j < h; ++j) {
            for (i=0; i < w; ++i) {
               short *data = z->img_comp[n].coeff + 64 * (i + j * z->img_comp[n].coeff_w);
               stbi__jpeg_dequantize(data, z->dequant[z->img_comp[n].tq]);
               z->idct_block_kernel(z->img_comp[n].data+z->img_comp[n].w2*j*8+i*8, z->img_comp[n].w2, data);
            }
         }
      }
   }
}

static int stbi__process_marker(stbi__jpeg *z, int m)
{
   int L;
   switch (m) {
      case STBI__MARKER_none: // no marker found
         return stbi__err("expected marker","Corrupt JPEG");

      case 0xDD: // DRI - specify restart interval
         if (stbi__get16be(z->s) != 4) return stbi__err("bad DRI len","Corrupt JPEG");
         z->restart_interval = stbi__get16be(z->s);
         return 1;

      case 0xDB: // DQT - define quantization table
         L = stbi__get16be(z->s)-2;
         while (L > 0) {
            int q = stbi__get8(z->s);
            int p = q >> 4, sixteen = (p != 0);
            int t = q & 15,i;
            if (p != 0 && p != 1) return stbi__err("bad DQT type","Corrupt JPEG");
            if (t > 3) return stbi__err("bad DQT table","Corrupt JPEG");

            for (i=0; i < 64; ++i)
               z->dequant[t][stbi__jpeg_dezigzag[i]] = (stbi__uint16)(sixteen ? stbi__get16be(z->s) : stbi__get8(z->s));
            L -= (sixteen ? 129 : 65);
         }
         return L==0;

      case 0xC4: // DHT - define huffman table
         L = stbi__get16be(z->s)-2;
         while (L > 0) {
            stbi_uc *v;
            int sizes[16],i,n=0;
            int q = stbi__get8(z->s);
            int tc = q >> 4;
            int th = q & 15;
            if (tc > 1 || th > 3) return stbi__err("bad DHT header","Corrupt JPEG");
            for (i=0; i < 16; ++i) {
               sizes[i] = stbi__get8(z->s);
               n += sizes[i];
            }
            L -= 17;
            if (tc == 0) {
               if (!stbi__build_huffman(z->huff_dc+th, sizes)) return 0;
               v = z->huff_dc[th].values;
            } else {
               if (!stbi__build_huffman(z->huff_ac+th, sizes)) return 0;
               v = z->huff_ac[th].values;
            }
            for (i=0; i < n; ++i)
               v[i] = stbi__get8(z->s);
            if (tc != 0)
               stbi__build_fast_ac(z->fast_ac[th], z->huff_ac + th);
            L -= n;
         }
         return L==0;
   }

   // check for comment block or APP blocks
   if ((m >= 0xE0 && m <= 0xEF) || m == 0xFE) {
      L = stbi__get16be(z->s);
      if (L < 2) {
         if (m == 0xFE)
            return stbi__err("bad COM len","Corrupt JPEG");
         else
            return stbi__err("bad APP len","Corrupt JPEG");
      }
      L -= 2;

      if (m == 0xE0 && L >= 5) { // JFIF APP0 segment
         static const unsigned char tag[5] = {'J','F','I','F','\0'};
         int ok = 1;
         int i;
         for (i=0; i < 5; ++i)
            if (stbi__get8(z->s) != tag[i])
               ok = 0;
         L -= 5;
         if (ok)
            z->jfif = 1;
      } else if (m == 0xEE && L >= 12) { // Adobe APP14 segment
         static const unsigned char tag[6] = {'A','d','o','b','e','\0'};
         int ok = 1;
         int i;
         for (i=0; i < 6; ++i)
            if (stbi__get8(z->s) != tag[i])
               ok = 0;
         L -= 6;
         if (ok) {
            stbi__get8(z->s); // version
            stbi__get16be(z->s); // flags0
            stbi__get16be(z->s); // flags1
            z->app14_color_transform = stbi__get8(z->s); // color transform
            L -= 6;
         }
      }

      stbi__skip(z->s, L);
      return 1;
   }

   return stbi__err("unknown marker","Corrupt JPEG");
}

// after we see SOS
static int stbi__process_scan_header(stbi__jpeg *z)
{
   int i;
   int Ls = stbi__get16be(z->s);
   z->scan_n = stbi__get8(z->s);
   if (z->scan_n < 1 || z->scan_n > 4 || z->scan_n > (int) z->s->img_n) return stbi__err("bad SOS component count","Corrupt JPEG");
   if (Ls != 6+2*z->scan_n) return stbi__err("bad SOS len","Corrupt JPEG");
   for (i=0; i < z->scan_n; ++i) {
      int id = stbi__get8(z->s), which;
      int q = stbi__get8(z->s);
      for (which = 0; which < z->s->img_n; ++which)
         if (z->img_comp[which].id == id)
            break;
      if (which == z->s->img_n) return 0; // no match
      z->img_comp[which].hd = q >> 4;   if (z->img_comp[which].hd > 3) return stbi__err("bad DC huff","Corrupt JPEG");
      z->img_comp[which].ha = q & 15;   if (z->img_comp[which].ha > 3) return stbi__err("bad AC huff","Corrupt JPEG");
      z->order[i] = which;
   }

   {
      int aa;
      z->spec_start = stbi__get8(z->s);
      z->spec_end   = stbi__get8(z->s); // should be 63, but might be 0
      aa = stbi__get8(z->s);
      z->succ_high = (aa >> 4);
      z->succ_low  = (aa & 15);
      if (z->progressive) {
         if (z->spec_start > 63 || z->spec_end > 63  || z->spec_start > z->spec_end || z->succ_high > 13 || z->succ_low > 13)
            return stbi__err("bad SOS", "Corrupt JPEG");
      } else {
         if (z->spec_start != 0) return stbi__err("bad SOS","Corrupt JPEG");
         if (z->succ_high != 0 || z->succ_low != 0) return stbi__err("bad SOS","Corrupt JPEG");
         z->spec_end = 63;
      }
   }

   return 1;
}

static int stbi__free_jpeg_components(stbi__jpeg *z, int ncomp, int why)
{
   int i;
   for (i=0; i < ncomp; ++i) {
      if (z->img_comp[i].raw_data) {
         STBI_FREE(z->img_comp[i].raw_data);
         z->img_comp[i].raw_data = NULL;
         z->img_comp[i].data = NULL;
      }
      if (z->img_comp[i].raw_coeff) {
         STBI_FREE(z->img_comp[i].raw_coeff);
         z->img_comp[i].raw_coeff = 0;
         z->img_comp[i].coeff = 0;
      }
      if (z->img_comp[i].linebuf) {
         STBI_FREE(z->img_comp[i].linebuf);
         z->img_comp[i].linebuf = NULL;
      }
   }
   return why;
}

static int stbi__process_frame_header(stbi__jpeg *z, int scan)
{
   stbi__context *s = z->s;
   int Lf,p,i,q, h_max=1,v_max=1,c;
   Lf = stbi__get16be(s);         if (Lf < 11) return stbi__err("bad SOF len","Corrupt JPEG"); // JPEG
   p  = stbi__get8(s);            if (p != 8) return stbi__err("only 8-bit","JPEG format not supported: 8-bit only"); // JPEG baseline
   s->img_y = stbi__get16be(s);   if (s->img_y == 0) return stbi__err("no header height", "JPEG format not supported: delayed height"); // Legal, but we don't handle it--but neither does IJG
   s->img_x = stbi__get16be(s);   if (s->img_x == 0) return stbi__err("0 width","Corrupt JPEG"); // JPEG requires
   c = stbi__get8(s);
   if (c != 3 && c != 1 && c != 4) return stbi__err("bad component count","Corrupt JPEG");
   s->img_n = c;
   for (i=0; i < c; ++i) {
      z->img_comp[i].data = NULL;
      z->img_comp[i].linebuf = NULL;
   }

   if (Lf != 8+3*s->img_n) return stbi__err("bad SOF len","Corrupt JPEG");

   z->rgb = 0;
   for (i=0; i < s->img_n; ++i) {
      static const unsigned char rgb[3] = { 'R', 'G', 'B' };
      z->img_comp[i].id = stbi__get8(s);
      if (s->img_n == 3 && z->img_comp[i].id == rgb[i])
         ++z->rgb;
      q = stbi__get8(s);
      z->img_comp[i].h = (q >> 4);  if (!z->img_comp[i].h || z->img_comp[i].h > 4) return stbi__err("bad H","Corrupt JPEG");
      z->img_comp[i].v = q & 15;    if (!z->img_comp[i].v || z->img_comp[i].v > 4) return stbi__err("bad V","Corrupt JPEG");
      z->img_comp[i].tq = stbi__get8(s);  if (z->img_comp[i].tq > 3) return stbi__err("bad TQ","Corrupt JPEG");
   }

   if (scan != STBI__SCAN_load) return 1;

   if (!stbi__mad3sizes_valid(s->img_x, s->img_y, s->img_n, 0)) return stbi__err("too large", "Image too large to decode");

   for (i=0; i < s->img_n; ++i) {
      if (z->img_comp[i].h > h_max) h_max = z->img_comp[i].h;
      if (z->img_comp[i].v > v_max) v_max = z->img_comp[i].v;
   }

   // compute interleaved mcu info
   z->img_h_max = h_max;
   z->img_v_max = v_max;
   z->img_mcu_w = h_max * 8;
   z->img_mcu_h = v_max * 8;
   // these sizes can't be more than 17 bits
   z->img_mcu_x = (s->img_x + z->img_mcu_w-1) / z->img_mcu_w;
   z->img_mcu_y = (s->img_y + z->img_mcu_h-1) / z->img_mcu_h;

   for (i=0; i < s->img_n; ++i) {
      // number of effective pixels (e.g. for non-interleaved MCU)
      z->img_comp[i].x = (s->img_x * z->img_comp[i].h + h_max-1) / h_max;
      z->img_comp[i].y = (s->img_y * z->img_comp[i].v + v_max-1) / v_max;
      // to simplify generation, we'll allocate enough memory to decode
      // the bogus oversized data from using interleaved MCUs and their
      // big blocks (e.g. a 16x16 iMCU on an image of width 33); we won't
      // discard the extra data until colorspace conversion
      //
      // img_mcu_x, img_mcu_y: <=17 bits; comp[i].h and .v are <=4 (checked earlier)
      // so these muls can't overflow with 32-bit ints (which we require)
      z->img_comp[i].w2 = z->img_mcu_x * z->img_comp[i].h * 8;
      z->img_comp[i].h2 = z->img_mcu_y * z->img_comp[i].v * 8;
      z->img_comp[i].coeff = 0;
      z->img_comp[i].raw_coeff = 0;
      z->img_comp[i].linebuf = NULL;
      z->img_comp[i].raw_data = stbi__malloc_mad2(z->img_comp[i].w2, z->img_comp[i].h2, 15);
      if (z->img_comp[i].raw_data == NULL)
         return stbi__free_jpeg_components(z, i+1, stbi__err("outofmem", "Out of memory"));
      // align blocks for idct using mmx/sse
      z->img_comp[i].data = (stbi_uc*) (((size_t) z->img_comp[i].raw_data + 15) & ~15);
      if (z->progressive) {
         // w2, h2 are multiples of 8 (see above)
         z->img_comp[i].coeff_w = z->img_comp[i].w2 / 8;
         z->img_comp[i].coeff_h = z->img_comp[i].h2 / 8;
         z->img_comp[i].raw_coeff = stbi__malloc_mad3(z->img_comp[i].w2, z->img_comp[i].h2, sizeof(short), 15);
         if (z->img_comp[i].raw_coeff == NULL)
            return stbi__free_jpeg_components(z, i+1, stbi__err("outofmem", "Out of memory"));
         z->img_comp[i].coeff = (short*) (((size_t) z->img_comp[i].raw_coeff + 15) & ~15);
      }
   }

   return 1;
}

// use comparisons since in some cases we handle more than one case (e.g. SOF)
#define stbi__DNL(x)         ((x) == 0xdc)
#define stbi__SOI(x)         ((x) == 0xd8)
#define stbi__EOI(x)         ((x) == 0xd9)
#define stbi__SOF(x)         ((x) == 0xc0 || (x) == 0xc1 || (x) == 0xc2)
#define stbi__SOS(x)         ((x) == 0xda)

#define stbi__SOF_progressive(x)   ((x) == 0xc2)

static int stbi__decode_jpeg_header(stbi__jpeg *z, int scan)
{
   int m;
   z->jfif = 0;
   z->app14_color_transform = -1; // valid values are 0,1,2
   z->marker = STBI__MARKER_none; // initialize cached marker to empty
   m = stbi__get_marker(z);
   if (!stbi__SOI(m)) return stbi__err("no SOI","Corrupt JPEG");
   if (scan == STBI__SCAN_type) return 1;
   m = stbi__get_marker(z);
   while (!stbi__SOF(m)) {
      if (!stbi__process_marker(z,m)) return 0;
      m = stbi__get_marker(z);
      while (m == STBI__MARKER_none) {
         // some files have extra padding after their blocks, so ok, we'll scan
         if (stbi__at_eof(z->s)) return stbi__err("no SOF", "Corrupt JPEG");
         m = stbi__get_marker(z);
      }
   }
   z->progressive = stbi__SOF_progressive(m);
   if (!stbi__process_frame_header(z, scan)) return 0;
   return 1;
}

// decode image to YCbCr format
static int stbi__decode_jpeg_image(stbi__jpeg *j)
{
   int m;
   for (m = 0; m < 4; m++) {
      j->img_comp[m].raw_data = NULL;
      j->img_comp[m].raw_coeff = NULL;
   }
   j->restart_interval = 0;
   if (!stbi__decode_jpeg_header(j, STBI__SCAN_load)) return 0;
   m = stbi__get_marker(j);
   while (!stbi__EOI(m)) {
      if (stbi__SOS(m)) {
         if (!stbi__process_scan_header(j)) return 0;
         if (!stbi__parse_entropy_coded_data(j)) return 0;
         if (j->marker == STBI__MARKER_none ) {
            // handle 0s at the end of image data from IP Kamera 9060
            while (!stbi__at_eof(j->s)) {
               int x = stbi__get8(j->s);
               if (x == 255) {
                  j->marker = stbi__get8(j->s);
                  break;
               }
            }
            // if we reach eof without hitting a marker, stbi__get_marker() below will fail and we'll eventually return 0
         }
      } else if (stbi__DNL(m)) {
         int Ld = stbi__get16be(j->s);
         stbi__uint32 NL = stbi__get16be(j->s);
         if (Ld != 4) return stbi__err("bad DNL len", "Corrupt JPEG");
         if (NL != j->s->img_y) return stbi__err("bad DNL height", "Corrupt JPEG");
      } else {
         if (!stbi__process_marker(j, m)) return 0;
      }
      m = stbi__get_marker(j);
   }
   if (j->progressive)
      stbi__jpeg_finish(j);
   return 1;
}

// static jfif-centered resampling (across block boundaries)

typedef stbi_uc *(*resample_row_func)(stbi_uc *out, stbi_uc *in0, stbi_uc *in1,
                                    int w, int hs);

#define stbi__div4(x) ((stbi_uc) ((x) >> 2))

static stbi_uc *resample_row_1(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
{
   STBI_NOTUSED(out);
   STBI_NOTUSED(in_far);
   STBI_NOTUSED(w);
   STBI_NOTUSED(hs);
   return in_near;
}

static stbi_uc* stbi__resample_row_v_2(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
{
   // need to generate two samples vertically for every one in input
   int i;
   STBI_NOTUSED(hs);
   for (i=0; i < w; ++i)
      out[i] = stbi__div4(3*in_near[i] + in_far[i] + 2);
   return out;
}

static stbi_uc*  stbi__resample_row_h_2(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
{
   // need to generate two samples horizontally for every one in input
   int i;
   stbi_uc *input = in_near;

   if (w == 1) {
      // if only one sample, can't do any interpolation
      out[0] = out[1] = input[0];
      return out;
   }

   out[0] = input[0];
   out[1] = stbi__div4(input[0]*3 + input[1] + 2);
   for (i=1; i < w-1; ++i) {
      int n = 3*input[i]+2;
      out[i*2+0] = stbi__div4(n+input[i-1]);
      out[i*2+1] = stbi__div4(n+input[i+1]);
   }
   out[i*2+0] = stbi__div4(input[w-2]*3 + input[w-1] + 2);
   out[i*2+1] = input[w-1];

   STBI_NOTUSED(in_far);
   STBI_NOTUSED(hs);

   return out;
}

#define stbi__div16(x) ((stbi_uc) ((x) >> 4))

static stbi_uc *stbi__resample_row_hv_2(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
{
   // need to generate 2x2 samples for every one in input
   int i,t0,t1;
   if (w == 1) {
      out[0] = out[1] = stbi__div4(3*in_near[0] + in_far[0] + 2);
      return out;
   }

   t1 = 3*in_near[0] + in_far[0];
   out[0] = stbi__div4(t1+2);
   for (i=1; i < w; ++i) {
      t0 = t1;
      t1 = 3*in_near[i]+in_far[i];
      out[i*2-1] = stbi__div16(3*t0 + t1 + 8);
      out[i*2  ] = stbi__div16(3*t1 + t0 + 8);
   }
   out[w*2-1] = stbi__div4(t1+2);

   STBI_NOTUSED(hs);

   return out;
}

#if defined(STBI_SSE2) || defined(STBI_NEON)
static stbi_uc *stbi__resample_row_hv_2_simd(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
{
   // need to generate 2x2 samples for every one in input
   int i=0,t0,t1;

   if (w == 1) {
      out[0] = out[1] = stbi__div4(3*in_near[0] + in_far[0] + 2);
      return out;
   }

   t1 = 3*in_near[0] + in_far[0];
   // process groups of 8 pixels for as long as we can.
   // note we can't handle the last pixel in a row in this loop
   // because we need to handle the filter boundary conditions.
   for (; i < ((w-1) & ~7); i += 8) {
#if defined(STBI_SSE2)
      // load and perform the vertical filtering pass
      // this uses 3*x + y = 4*x + (y - x)
      __m128i zero  = _mm_setzero_si128();
      __m128i farb  = _mm_loadl_epi64((__m128i *) (in_far + i));
      __m128i nearb = _mm_loadl_epi64((__m128i *) (in_near + i));
      __m128i farw  = _mm_unpacklo_epi8(farb, zero);
      __m128i nearw = _mm_unpacklo_epi8(nearb, zero);
      __m128i diff  = _mm_sub_epi16(farw, nearw);
      __m128i nears = _mm_slli_epi16(nearw, 2);
      __m128i curr  = _mm_add_epi16(nears, diff); // current row

      // horizontal filter works the same based on shifted vers of current
      // row. "prev" is current row shifted right by 1 pixel; we need to
      // insert the previous pixel value (from t1).
      // "next" is current row shifted left by 1 pixel, with first pixel
      // of next block of 8 pixels added in.
      __m128i prv0 = _mm_slli_si128(curr, 2);
      __m128i nxt0 = _mm_srli_si128(curr, 2);
      __m128i prev = _mm_insert_epi16(prv0, t1, 0);
      __m128i next = _mm_insert_epi16(nxt0, 3*in_near[i+8] + in_far[i+8], 7);

      // horizontal filter, polyphase implementation since it's convenient:
      // even pixels = 3*cur + prev = cur*4 + (prev - cur)
      // odd  pixels = 3*cur + next = cur*4 + (next - cur)
      // note the shared term.
      __m128i bias  = _mm_set1_epi16(8);
      __m128i curs = _mm_slli_epi16(curr, 2);
      __m128i prvd = _mm_sub_epi16(prev, curr);
      __m128i nxtd = _mm_sub_epi16(next, curr);
      __m128i curb = _mm_add_epi16(curs, bias);
      __m128i even = _mm_add_epi16(prvd, curb);
      __m128i odd  = _mm_add_epi16(nxtd, curb);

      // interleave even and odd pixels, then undo scaling.
      __m128i int0 = _mm_unpacklo_epi16(even, odd);
      __m128i int1 = _mm_unpackhi_epi16(even, odd);
      __m128i de0  = _mm_srli_epi16(int0, 4);
      __m128i de1  = _mm_srli_epi16(int1, 4);

      // pack and write output
      __m128i outv = _mm_packus_epi16(de0, de1);
      _mm_storeu_si128((__m128i *) (out + i*2), outv);
#elif defined(STBI_NEON)
      // load and perform the vertical filtering pass
      // this uses 3*x + y = 4*x + (y - x)
      uint8x8_t farb  = vld1_u8(in_far + i);
      uint8x8_t nearb = vld1_u8(in_near + i);
      int16x8_t diff  = vreinterpretq_s16_u16(vsubl_u8(farb, nearb));
      int16x8_t nears = vreinterpretq_s16_u16(vshll_n_u8(nearb, 2));
      int16x8_t curr  = vaddq_s16(nears, diff); // current row

      // horizontal filter works the same based on shifted vers of current
      // row. "prev" is current row shifted right by 1 pixel; we need to
      // insert the previous pixel value (from t1).
      // "next" is current row shifted left by 1 pixel, with first pixel
      // of next block of 8 pixels added in.
      int16x8_t prv0 = vextq_s16(curr, curr, 7);
      int16x8_t nxt0 = vextq_s16(curr, curr, 1);
      int16x8_t prev = vsetq_lane_s16(t1, prv0, 0);
      int16x8_t next = vsetq_lane_s16(3*in_near[i+8] + in_far[i+8], nxt0, 7);

      // horizontal filter, polyphase implementation since it's convenient:
      // even pixels = 3*cur + prev = cur*4 + (prev - cur)
      // odd  pixels = 3*cur + next = cur*4 + (next - cur)
      // note the shared term.
      int16x8_t curs = vshlq_n_s16(curr, 2);
      int16x8_t prvd = vsubq_s16(prev, curr);
      int16x8_t nxtd = vsubq_s16(next, curr);
      int16x8_t even = vaddq_s16(curs, prvd);
      int16x8_t odd  = vaddq_s16(curs, nxtd);

      // undo scaling and round, then store with even/odd phases interleaved
      uint8x8x2_t o;
      o.val[0] = vqrshrun_n_s16(even, 4);
      o.val[1] = vqrshrun_n_s16(odd,  4);
      vst2_u8(out + i*2, o);
#endif

      // "previous" value for next iter
      t1 = 3*in_near[i+7] + in_far[i+7];
   }

   t0 = t1;
   t1 = 3*in_near[i] + in_far[i];
   out[i*2] = stbi__div16(3*t1 + t0 + 8);

   for (++i; i < w; ++i) {
      t0 = t1;
      t1 = 3*in_near[i]+in_far[i];
      out[i*2-1] = stbi__div16(3*t0 + t1 + 8);
      out[i*2  ] = stbi__div16(3*t1 + t0 + 8);
   }
   out[w*2-1] = stbi__div4(t1+2);

   STBI_NOTUSED(hs);

   return out;
}
#endif

static stbi_uc *stbi__resample_row_generic(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
{
   // resample with nearest-neighbor
   int i,j;
   STBI_NOTUSED(in_far);
   for (i=0; i < w; ++i)
      for (j=0; j < hs; ++j)
         out[i*hs+j] = in_near[i];
   return out;
}

// this is a reduced-precision calculation of YCbCr-to-RGB introduced
// to make sure the code produces the same results in both SIMD and scalar
#define stbi__float2fixed(x)  (((int) ((x) * 4096.0f + 0.5f)) << 8)
static void stbi__YCbCr_to_RGB_row(stbi_uc *out, const stbi_uc *y, const stbi_uc *pcb, const stbi_uc *pcr, int count, int step)
{
   int i;
   for (i=0; i < count; ++i) {
      int y_fixed = (y[i] << 20) + (1<<19); // rounding
      int r,g,b;
      int cr = pcr[i] - 128;
      int cb = pcb[i] - 128;
      r = y_fixed +  cr* stbi__float2fixed(1.40200f);
      g = y_fixed + (cr*-stbi__float2fixed(0.71414f)) + ((cb*-stbi__float2fixed(0.34414f)) & 0xffff0000);
      b = y_fixed                                     +   cb* stbi__float2fixed(1.77200f);
      r >>= 20;
      g >>= 20;
      b >>= 20;
      if ((unsigned) r > 255) { if (r < 0) r = 0; else r = 255; }
      if ((unsigned) g > 255) { if (g < 0) g = 0; else g = 255; }
      if ((unsigned) b > 255) { if (b < 0) b = 0; else b = 255; }
      out[0] = (stbi_uc)r;
      out[1] = (stbi_uc)g;
      out[2] = (stbi_uc)b;
      out[3] = 255;
      out += step;
   }
}

#if defined(STBI_SSE2) || defined(STBI_NEON)
static void stbi__YCbCr_to_RGB_simd(stbi_uc *out, stbi_uc const *y, stbi_uc const *pcb, stbi_uc const *pcr, int count, int step)
{
   int i = 0;

#ifdef STBI_SSE2
   // step == 3 is pretty ugly on the final interleave, and i'm not convinced
   // it's useful in practice (you wouldn't use it for textures, for example).
   // so just accelerate step == 4 case.
   if (step == 4) {
      // this is a fairly straightforward implementation and not super-optimized.
      __m128i signflip  = _mm_set1_epi8(-0x80);
      __m128i cr_const0 = _mm_set1_epi16(   (short) ( 1.40200f*4096.0f+0.5f));
      __m128i cr_const1 = _mm_set1_epi16( - (short) ( 0.71414f*4096.0f+0.5f));
      __m128i cb_const0 = _mm_set1_epi16( - (short) ( 0.34414f*4096.0f+0.5f));
      __m128i cb_const1 = _mm_set1_epi16(   (short) ( 1.77200f*4096.0f+0.5f));
      __m128i y_bias = _mm_set1_epi8((char) (unsigned char) 128);
      __m128i xw = _mm_set1_epi16(255); // alpha channel

      for (; i+7 < count; i += 8) {
         // load
         __m128i y_bytes = _mm_loadl_epi64((__m128i *) (y+i));
         __m128i cr_bytes = _mm_loadl_epi64((__m128i *) (pcr+i));
         __m128i cb_bytes = _mm_loadl_epi64((__m128i *) (pcb+i));
         __m128i cr_biased = _mm_xor_si128(cr_bytes, signflip); // -128
         __m128i cb_biased = _mm_xor_si128(cb_bytes, signflip); // -128

         // unpack to short (and left-shift cr, cb by 8)
         __m128i yw  = _mm_unpacklo_epi8(y_bias, y_bytes);
         __m128i crw = _mm_unpacklo_epi8(_mm_setzero_si128(), cr_biased);
         __m128i cbw = _mm_unpacklo_epi8(_mm_setzero_si128(), cb_biased);

         // color transform
         __m128i yws = _mm_srli_epi16(yw, 4);
         __m128i cr0 = _mm_mulhi_epi16(cr_const0, crw);
         __m128i cb0 = _mm_mulhi_epi16(cb_const0, cbw);
         __m128i cb1 = _mm_mulhi_epi16(cbw, cb_const1);
         __m128i cr1 = _mm_mulhi_epi16(crw, cr_const1);
         __m128i rws = _mm_add_epi16(cr0, yws);
         __m128i gwt = _mm_add_epi16(cb0, yws);
         __m128i bws = _mm_add_epi16(yws, cb1);
         __m128i gws = _mm_add_epi16(gwt, cr1);

         // descale
         __m128i rw = _mm_srai_epi16(rws, 4);
         __m128i bw = _mm_srai_epi16(bws, 4);
         __m128i gw = _mm_srai_epi16(gws, 4);

         // back to byte, set up for transpose
         __m128i brb = _mm_packus_epi16(rw, bw);
         __m128i gxb = _mm_packus_epi16(gw, xw);

         // transpose to interleave channels
         __m128i t0 = _mm_unpacklo_epi8(brb, gxb);
         __m128i t1 = _mm_unpackhi_epi8(brb, gxb);
         __m128i o0 = _mm_unpacklo_epi16(t0, t1);
         __m128i o1 = _mm_unpackhi_epi16(t0, t1);

         // store
         _mm_storeu_si128((__m128i *) (out + 0), o0);
         _mm_storeu_si128((__m128i *) (out + 16), o1);
         out += 32;
      }
   }
#endif

#ifdef STBI_NEON
   // in this version, step=3 support would be easy to add. but is there demand?
   if (step == 4) {
      // this is a fairly straightforward implementation and not super-optimized.
      uint8x8_t signflip = vdup_n_u8(0x80);
      int16x8_t cr_const0 = vdupq_n_s16(   (short) ( 1.40200f*4096.0f+0.5f));
      int16x8_t cr_const1 = vdupq_n_s16( - (short) ( 0.71414f*4096.0f+0.5f));
      int16x8_t cb_const0 = vdupq_n_s16( - (short) ( 0.34414f*4096.0f+0.5f));
      int16x8_t cb_const1 = vdupq_n_s16(   (short) ( 1.77200f*4096.0f+0.5f));

      for (; i+7 < count; i += 8) {
         // load
         uint8x8_t y_bytes  = vld1_u8(y + i);
         uint8x8_t cr_bytes = vld1_u8(pcr + i);
         uint8x8_t cb_bytes = vld1_u8(pcb + i);
         int8x8_t cr_biased = vreinterpret_s8_u8(vsub_u8(cr_bytes, signflip));
         int8x8_t cb_biased = vreinterpret_s8_u8(vsub_u8(cb_bytes, signflip));

         // expand to s16
         int16x8_t yws = vreinterpretq_s16_u16(vshll_n_u8(y_bytes, 4));
         int16x8_t crw = vshll_n_s8(cr_biased, 7);
         int16x8_t cbw = vshll_n_s8(cb_biased, 7);

         // color transform
         int16x8_t cr0 = vqdmulhq_s16(crw, cr_const0);
         int16x8_t cb0 = vqdmulhq_s16(cbw, cb_const0);
         int16x8_t cr1 = vqdmulhq_s16(crw, cr_const1);
         int16x8_t cb1 = vqdmulhq_s16(cbw, cb_const1);
         int16x8_t rws = vaddq_s16(yws, cr0);
         int16x8_t gws = vaddq_s16(vaddq_s16(yws, cb0), cr1);
         int16x8_t bws = vaddq_s16(yws, cb1);

         // undo scaling, round, convert to byte
         uint8x8x4_t o;
         o.val[0] = vqrshrun_n_s16(rws, 4);
         o.val[1] = vqrshrun_n_s16(gws, 4);
         o.val[2] = vqrshrun_n_s16(bws, 4);
         o.val[3] = vdup_n_u8(255);

         // store, interleaving r/g/b/a
         vst4_u8(out, o);
         out += 8*4;
      }
   }
#endif

   for (; i < count; ++i) {
      int y_fixed = (y[i] << 20) + (1<<19); // rounding
      int r,g,b;
      int cr = pcr[i] - 128;
      int cb = pcb[i] - 128;
      r = y_fixed + cr* stbi__float2fixed(1.40200f);
      g = y_fixed + cr*-stbi__float2fixed(0.71414f) + ((cb*-stbi__float2fixed(0.34414f)) & 0xffff0000);
      b = y_fixed                                   +   cb* stbi__float2fixed(1.77200f);
      r >>= 20;
      g >>= 20;
      b >>= 20;
      if ((unsigned) r > 255) { if (r < 0) r = 0; else r = 255; }
      if ((unsigned) g > 255) { if (g < 0) g = 0; else g = 255; }
      if ((unsigned) b > 255) { if (b < 0) b = 0; else b = 255; }
      out[0] = (stbi_uc)r;
      out[1] = (stbi_uc)g;
      out[2] = (stbi_uc)b;
      out[3] = 255;
      out += step;
   }
}
#endif

// set up the kernels
static void stbi__setup_jpeg(stbi__jpeg *j)
{
   j->idct_block_kernel = stbi__idct_block;
   j->YCbCr_to_RGB_kernel = stbi__YCbCr_to_RGB_row;
   j->resample_row_hv_2_kernel = stbi__resample_row_hv_2;

#ifdef STBI_SSE2
   if (stbi__sse2_available()) {
      j->idct_block_kernel = stbi__idct_simd;
      j->YCbCr_to_RGB_kernel = stbi__YCbCr_to_RGB_simd;
      j->resample_row_hv_2_kernel = stbi__resample_row_hv_2_simd;
   }
#endif

#ifdef STBI_NEON
   j->idct_block_kernel = stbi__idct_simd;
   j->YCbCr_to_RGB_kernel = stbi__YCbCr_to_RGB_simd;
   j->resample_row_hv_2_kernel = stbi__resample_row_hv_2_simd;
#endif
}

// clean up the temporary component buffers
static void stbi__cleanup_jpeg(stbi__jpeg *j)
{
   stbi__free_jpeg_components(j, j->s->img_n, 0);
}

typedef struct
{
   resample_row_func resample;
   stbi_uc *line0,*line1;
   int hs,vs;   // expansion factor in each axis
   int w_lores; // horizontal pixels pre-expansion
   int ystep;   // how far through vertical expansion we are
   int ypos;    // which pre-expansion row we're on
} stbi__resample;

// fast 0..255 * 0..255 => 0..255 rounded multiplication
static stbi_uc stbi__blinn_8x8(stbi_uc x, stbi_uc y)
{
   unsigned int t = x*y + 128;
   return (stbi_uc) ((t + (t >>8)) >> 8);
}

static stbi_uc *load_jpeg_image(stbi__jpeg *z, int *out_x, int *out_y, int *comp, int req_comp)
{
   int n, decode_n, is_rgb;
   z->s->img_n = 0; // make stbi__cleanup_jpeg safe

   // validate req_comp
   if (req_comp < 0 || req_comp > 4) return stbi__errpuc("bad req_comp", "Internal error");

   // load a jpeg image from whichever source, but leave in YCbCr format
   if (!stbi__decode_jpeg_image(z)) { stbi__cleanup_jpeg(z); return NULL; }

   // determine actual number of components to generate
   n = req_comp ? req_comp : z->s->img_n >= 3 ? 3 : 1;

   is_rgb = z->s->img_n == 3 && (z->rgb == 3 || (z->app14_color_transform == 0 && !z->jfif));

   if (z->s->img_n == 3 && n < 3 && !is_rgb)
      decode_n = 1;
   else
      decode_n = z->s->img_n;

   // resample and color-convert
   {
      int k;
      unsigned int i,j;
      stbi_uc *output;
      stbi_uc *coutput[4] = { NULL, NULL, NULL, NULL };

      stbi__resample res_comp[4];

      for (k=0; k < decode_n; ++k) {
         stbi__resample *r = &res_comp[k];

         // allocate line buffer big enough for upsampling off the edges
         // with upsample factor of 4
         z->img_comp[k].linebuf = (stbi_uc *) stbi__malloc(z->s->img_x + 3);
         if (!z->img_comp[k].linebuf) { stbi__cleanup_jpeg(z); return stbi__errpuc("outofmem", "Out of memory"); }

         r->hs      = z->img_h_max / z->img_comp[k].h;
         r->vs      = z->img_v_max / z->img_comp[k].v;
         r->ystep   = r->vs >> 1;
         r->w_lores = (z->s->img_x + r->hs-1) / r->hs;
         r->ypos    = 0;
         r->line0   = r->line1 = z->img_comp[k].data;

         if      (r->hs == 1 && r->vs == 1) r->resample = resample_row_1;
         else if (r->hs == 1 && r->vs == 2) r->resample = stbi__resample_row_v_2;
         else if (r->hs == 2 && r->vs == 1) r->resample = stbi__resample_row_h_2;
         else if (r->hs == 2 && r->vs == 2) r->resample = z->resample_row_hv_2_kernel;
         else                               r->resample = stbi__resample_row_generic;
      }

      // can't error after this so, this is safe
      output = (stbi_uc *) stbi__malloc_mad3(n, z->s->img_x, z->s->img_y, 1);
      if (!output) { stbi__cleanup_jpeg(z); return stbi__errpuc("outofmem", "Out of memory"); }

      // now go ahead and resample
      for (j=0; j < z->s->img_y; ++j) {
         stbi_uc *out = output + n * z->s->img_x * j;
         for (k=0; k < decode_n; ++k) {
            stbi__resample *r = &res_comp[k];
            int y_bot = r->ystep >= (r->vs >> 1);
            coutput[k] = r->resample(z->img_comp[k].linebuf,
                                     y_bot ? r->line1 : r->line0,
                                     y_bot ? r->line0 : r->line1,
                                     r->w_lores, r->hs);
            if (++r->ystep >= r->vs) {
               r->ystep = 0;
               r->line0 = r->line1;
               if (++r->ypos < z->img_comp[k].y)
                  r->line1 += z->img_comp[k].w2;
            }
         }
         if (n >= 3) {
            stbi_uc *y = coutput[0];
            if (z->s->img_n == 3) {
               if (is_rgb) {
                  for (i=0; i < z->s->img_x; ++i) {
                     out[0] = y[i];
                     out[1] = coutput[1][i];
                     out[2] = coutput[2][i];
                     out[3] = 255;
                     out += n;
                  }
               } else {
                  z->YCbCr_to_RGB_kernel(out, y, coutput[1], coutput[2], z->s->img_x, n);
               }
            } else if (z->s->img_n == 4) {
               if (z->app14_color_transform == 0) { // CMYK
                  for (i=0; i < z->s->img_x; ++i) {
                     stbi_uc m = coutput[3][i];
                     out[0] = stbi__blinn_8x8(coutput[0][i], m);
                     out[1] = stbi__blinn_8x8(coutput[1][i], m);
                     out[2] = stbi__blinn_8x8(coutput[2][i], m);
                     out[3] = 255;
                     out += n;
                  }
               } else if (z->app14_color_transform == 2) { // YCCK
                  z->YCbCr_to_RGB_kernel(out, y, coutput[1], coutput[2], z->s->img_x, n);
                  for (i=0; i < z->s->img_x; ++i) {
                     stbi_uc m = coutput[3][i];
                     out[0] = stbi__blinn_8x8(255 - out[0], m);
                     out[1] = stbi__blinn_8x8(255 - out[1], m);
                     out[2] = stbi__blinn_8x8(255 - out[2], m);
                     out += n;
                  }
               } else { // YCbCr + alpha?  Ignore the fourth channel for now
                  z->YCbCr_to_RGB_kernel(out, y, coutput[1], coutput[2], z->s->img_x, n);
               }
            } else
               for (i=0; i < z->s->img_x; ++i) {
                  out[0] = out[1] = out[2] = y[i];
                  out[3] = 255; // not used if n==3
                  out += n;
               }
         } else {
            if (is_rgb) {
               if (n == 1)
                  for (i=0; i < z->s->img_x; ++i)
                     *out++ = stbi__compute_y(coutput[0][i], coutput[1][i], coutput[2][i]);
               else {
                  for (i=0; i < z->s->img_x; ++i, out += 2) {
                     out[0] = stbi__compute_y(coutput[0][i], coutput[1][i], coutput[2][i]);
                     out[1] = 255;
                  }
               }
            } else if (z->s->img_n == 4 && z->app14_color_transform == 0) {
               for (i=0; i < z->s->img_x; ++i) {
                  stbi_uc m = coutput[3][i];
                  stbi_uc r = stbi__blinn_8x8(coutput[0][i], m);
                  stbi_uc g = stbi__blinn_8x8(coutput[1][i], m);
                  stbi_uc b = stbi__blinn_8x8(coutput[2][i], m);
                  out[0] = stbi__compute_y(r, g, b);
                  out[1] = 255;
                  out += n;
               }
            } else if (z->s->img_n == 4 && z->app14_color_transform == 2) {
               for (i=0; i < z->s->img_x; ++i) {
                  out[0] = stbi__blinn_8x8(255 - coutput[0][i], coutput[3][i]);
                  out[1] = 255;
                  out += n;
               }
            } else {
               stbi_uc *y = coutput[0];
               if (n == 1)
                  for (i=0; i < z->s->img_x; ++i) out[i] = y[i];
               else
                  for (i=0; i < z->s->img_x; ++i) { *out++ = y[i]; *out++ = 255; }
            }
         }
      }
      stbi__cleanup_jpeg(z);
      *out_x = z->s->img_x;
      *out_y = z->s->img_y;
      if (comp) *comp = z->s->img_n >= 3 ? 3 : 1; // report original components, not output
      return output;
   }
}

static void *stbi__jpeg_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
{
   unsigned char* result;
   stbi__jpeg* j = (stbi__jpeg*) stbi__malloc(sizeof(stbi__jpeg));
   STBI_NOTUSED(ri);
   j->s = s;
   stbi__setup_jpeg(j);
   result = load_jpeg_image(j, x,y,comp,req_comp);
   STBI_FREE(j);
   return result;
}

static int stbi__jpeg_test(stbi__context *s)
{
   int r;
   stbi__jpeg* j = (stbi__jpeg*)stbi__malloc(sizeof(stbi__jpeg));
   j->s = s;
   stbi__setup_jpeg(j);
   r = stbi__decode_jpeg_header(j, STBI__SCAN_type);
   stbi__rewind(s);
   STBI_FREE(j);
   return r;
}

static int stbi__jpeg_info_raw(stbi__jpeg *j, int *x, int *y, int *comp)
{
   if (!stbi__decode_jpeg_header(j, STBI__SCAN_header)) {
      stbi__rewind( j->s );
      return 0;
   }
   if (x) *x = j->s->img_x;
   if (y) *y = j->s->img_y;
   if (comp) *comp = j->s->img_n >= 3 ? 3 : 1;
   return 1;
}

static int stbi__jpeg_info(stbi__context *s, int *x, int *y, int *comp)
{
   int result;
   stbi__jpeg* j = (stbi__jpeg*) (stbi__malloc(sizeof(stbi__jpeg)));
   j->s = s;
   result = stbi__jpeg_info_raw(j, x, y, comp);
   STBI_FREE(j);
   return result;
}
#endif

// public domain zlib decode    v0.2  Sean Barrett 2006-11-18
//    simple implementation
//      - all input must be provided in an upfront buffer
//      - all output is written to a single output buffer (can malloc/realloc)
//    performance
//      - fast huffman

#ifndef STBI_NO_ZLIB

// fast-way is faster to check than jpeg huffman, but slow way is slower
#define STBI__ZFAST_BITS  9 // accelerate all cases in default tables
#define STBI__ZFAST_MASK  ((1 << STBI__ZFAST_BITS) - 1)

// zlib-style huffman encoding
// (jpegs packs from left, zlib from right, so can't share code)
typedef struct
{
   stbi__uint16 fast[1 << STBI__ZFAST_BITS];
   stbi__uint16 firstcode[16];
   int maxcode[17];
   stbi__uint16 firstsymbol[16];
   stbi_uc  size[288];
   stbi__uint16 value[288];
} stbi__zhuffman;

stbi_inline static int stbi__bitreverse16(int n)
{
  n = ((n & 0xAAAA) >>  1) | ((n & 0x5555) << 1);
  n = ((n & 0xCCCC) >>  2) | ((n & 0x3333) << 2);
  n = ((n & 0xF0F0) >>  4) | ((n & 0x0F0F) << 4);
  n = ((n & 0xFF00) >>  8) | ((n & 0x00FF) << 8);
  return n;
}

stbi_inline static int stbi__bit_reverse(int v, int bits)
{
   STBI_ASSERT(bits <= 16);
   // to bit reverse n bits, reverse 16 and shift
   // e.g. 11 bits, bit reverse and shift away 5
   return stbi__bitreverse16(v) >> (16-bits);
}

static int stbi__zbuild_huffman(stbi__zhuffman *z, const stbi_uc *sizelist, int num)
{
   int i,k=0;
   int code, next_code[16], sizes[17];

   // DEFLATE spec for generating codes
   memset(sizes, 0, sizeof(sizes));
   memset(z->fast, 0, sizeof(z->fast));
   for (i=0; i < num; ++i)
      ++sizes[sizelist[i]];
   sizes[0] = 0;
   for (i=1; i < 16; ++i)
      if (sizes[i] > (1 << i))
         return stbi__err("bad sizes", "Corrupt PNG");
   code = 0;
   for (i=1; i < 16; ++i) {
      next_code[i] = code;
      z->firstcode[i] = (stbi__uint16) code;
      z->firstsymbol[i] = (stbi__uint16) k;
      code = (code + sizes[i]);
      if (sizes[i])
         if (code-1 >= (1 << i)) return stbi__err("bad codelengths","Corrupt PNG");
      z->maxcode[i] = code << (16-i); // preshift for inner loop
      code <<= 1;
      k += sizes[i];
   }
   z->maxcode[16] = 0x10000; // sentinel
   for (i=0; i < num; ++i) {
      int s = sizelist[i];
      if (s) {
         int c = next_code[s] - z->firstcode[s] + z->firstsymbol[s];
         stbi__uint16 fastv = (stbi__uint16) ((s << 9) | i);
         z->size [c] = (stbi_uc     ) s;
         z->value[c] = (stbi__uint16) i;
         if (s <= STBI__ZFAST_BITS) {
            int j = stbi__bit_reverse(next_code[s],s);
            while (j < (1 << STBI__ZFAST_BITS)) {
               z->fast[j] = fastv;
               j += (1 << s);
            }
         }
         ++next_code[s];
      }
   }
   return 1;
}

// zlib-from-memory implementation for PNG reading
//    because PNG allows splitting the zlib stream arbitrarily,
//    and it's annoying structurally to have PNG call ZLIB call PNG,
//    we require PNG read all the IDATs and combine them into a single
//    memory buffer

typedef struct
{
   stbi_uc *zbuffer, *zbuffer_end;
   int num_bits;
   stbi__uint32 code_buffer;

   char *zout;
   char *zout_start;
   char *zout_end;
   int   z_expandable;

   stbi__zhuffman z_length, z_distance;
} stbi__zbuf;

stbi_inline static stbi_uc stbi__zget8(stbi__zbuf *z)
{
   if (z->zbuffer >= z->zbuffer_end) return 0;
   return *z->zbuffer++;
}

static void stbi__fill_bits(stbi__zbuf *z)
{
   do {
      STBI_ASSERT(z->code_buffer < (1U << z->num_bits));
      z->code_buffer |= (unsigned int) stbi__zget8(z) << z->num_bits;
      z->num_bits += 8;
   } while (z->num_bits <= 24);
}

stbi_inline static unsigned int stbi__zreceive(stbi__zbuf *z, int n)
{
   unsigned int k;
   if (z->num_bits < n) stbi__fill_bits(z);
   k = z->code_buffer & ((1 << n) - 1);
   z->code_buffer >>= n;
   z->num_bits -= n;
   return k;
}

static int stbi__zhuffman_decode_slowpath(stbi__zbuf *a, stbi__zhuffman *z)
{
   int b,s,k;
   // not resolved by fast table, so compute it the slow way
   // use jpeg approach, which requires MSbits at top
   k = stbi__bit_reverse(a->code_buffer, 16);
   for (s=STBI__ZFAST_BITS+1; ; ++s)
      if (k < z->maxcode[s])
         break;
   if (s == 16) return -1; // invalid code!
   // code size is s, so:
   b = (k >> (16-s)) - z->firstcode[s] + z->firstsymbol[s];
   STBI_ASSERT(z->size[b] == s);
   a->code_buffer >>= s;
   a->num_bits -= s;
   return z->value[b];
}

stbi_inline static int stbi__zhuffman_decode(stbi__zbuf *a, stbi__zhuffman *z)
{
   int b,s;
   if (a->num_bits < 16) stbi__fill_bits(a);
   b = z->fast[a->code_buffer & STBI__ZFAST_MASK];
   if (b) {
      s = b >> 9;
      a->code_buffer >>= s;
      a->num_bits -= s;
      return b & 511;
   }
   return stbi__zhuffman_decode_slowpath(a, z);
}

static int stbi__zexpand(stbi__zbuf *z, char *zout, int n)  // need to make room for n bytes
{
   char *q;
   int cur, limit, old_limit;
   z->zout = zout;
   if (!z->z_expandable) return stbi__err("output buffer limit","Corrupt PNG");
   cur   = (int) (z->zout     - z->zout_start);
   limit = old_limit = (int) (z->zout_end - z->zout_start);
   while (cur + n > limit)
      limit *= 2;
   q = (char *) STBI_REALLOC_SIZED(z->zout_start, old_limit, limit);
   STBI_NOTUSED(old_limit);
   if (q == NULL) return stbi__err("outofmem", "Out of memory");
   z->zout_start = q;
   z->zout       = q + cur;
   z->zout_end   = q + limit;
   return 1;
}

static const int stbi__zlength_base[31] = {
   3,4,5,6,7,8,9,10,11,13,
   15,17,19,23,27,31,35,43,51,59,
   67,83,99,115,131,163,195,227,258,0,0 };

static const int stbi__zlength_extra[31]=
{ 0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0 };

static const int stbi__zdist_base[32] = { 1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,
257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0};

static const int stbi__zdist_extra[32] =
{ 0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13};

static int stbi__parse_huffman_block(stbi__zbuf *a)
{
   char *zout = a->zout;
   for(;;) {
      int z = stbi__zhuffman_decode(a, &a->z_length);
      if (z < 256) {
         if (z < 0) return stbi__err("bad huffman code","Corrupt PNG"); // error in huffman codes
         if (zout >= a->zout_end) {
            if (!stbi__zexpand(a, zout, 1)) return 0;
            zout = a->zout;
         }
         *zout++ = (char) z;
      } else {
         stbi_uc *p;
         int len,dist;
         if (z == 256) {
            a->zout = zout;
            return 1;
         }
         z -= 257;
         len = stbi__zlength_base[z];
         if (stbi__zlength_extra[z]) len += stbi__zreceive(a, stbi__zlength_extra[z]);
         z = stbi__zhuffman_decode(a, &a->z_distance);
         if (z < 0) return stbi__err("bad huffman code","Corrupt PNG");
         dist = stbi__zdist_base[z];
         if (stbi__zdist_extra[z]) dist += stbi__zreceive(a, stbi__zdist_extra[z]);
         if (zout - a->zout_start < dist) return stbi__err("bad dist","Corrupt PNG");
         if (zout + len > a->zout_end) {
            if (!stbi__zexpand(a, zout, len)) return 0;
            zout = a->zout;
         }
         p = (stbi_uc *) (zout - dist);
         if (dist == 1) { // run of one byte; common in images.
            stbi_uc v = *p;
            if (len) { do *zout++ = v; while (--len); }
         } else {
            if (len) { do *zout++ = *p++; while (--len); }
         }
      }
   }
}

static int stbi__compute_huffman_codes(stbi__zbuf *a)
{
   static const stbi_uc length_dezigzag[19] = { 16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15 };
   stbi__zhuffman z_codelength;
   stbi_uc lencodes[286+32+137];//padding for maximum single op
   stbi_uc codelength_sizes[19];
   int i,n;

   int hlit  = stbi__zreceive(a,5) + 257;
   int hdist = stbi__zreceive(a,5) + 1;
   int hclen = stbi__zreceive(a,4) + 4;
   int ntot  = hlit + hdist;

   memset(codelength_sizes, 0, sizeof(codelength_sizes));
   for (i=0; i < hclen; ++i) {
      int s = stbi__zreceive(a,3);
      codelength_sizes[length_dezigzag[i]] = (stbi_uc) s;
   }
   if (!stbi__zbuild_huffman(&z_codelength, codelength_sizes, 19)) return 0;

   n = 0;
   while (n < ntot) {
      int c = stbi__zhuffman_decode(a, &z_codelength);
      if (c < 0 || c >= 19) return stbi__err("bad codelengths", "Corrupt PNG");
      if (c < 16)
         lencodes[n++] = (stbi_uc) c;
      else {
         stbi_uc fill = 0;
         if (c == 16) {
            c = stbi__zreceive(a,2)+3;
            if (n == 0) return stbi__err("bad codelengths", "Corrupt PNG");
            fill = lencodes[n-1];
         } else if (c == 17)
            c = stbi__zreceive(a,3)+3;
         else {
            STBI_ASSERT(c == 18);
            c = stbi__zreceive(a,7)+11;
         }
         if (ntot - n < c) return stbi__err("bad codelengths", "Corrupt PNG");
         memset(lencodes+n, fill, c);
         n += c;
      }
   }
   if (n != ntot) return stbi__err("bad codelengths","Corrupt PNG");
   if (!stbi__zbuild_huffman(&a->z_length, lencodes, hlit)) return 0;
   if (!stbi__zbuild_huffman(&a->z_distance, lencodes+hlit, hdist)) return 0;
   return 1;
}

static int stbi__parse_uncompressed_block(stbi__zbuf *a)
{
   stbi_uc header[4];
   int len,nlen,k;
   if (a->num_bits & 7)
      stbi__zreceive(a, a->num_bits & 7); // discard
   // drain the bit-packed data into header
   k = 0;
   while (a->num_bits > 0) {
      header[k++] = (stbi_uc) (a->code_buffer & 255); // suppress MSVC run-time check
      a->code_buffer >>= 8;
      a->num_bits -= 8;
   }
   STBI_ASSERT(a->num_bits == 0);
   // now fill header the normal way
   while (k < 4)
      header[k++] = stbi__zget8(a);
   len  = header[1] * 256 + header[0];
   nlen = header[3] * 256 + header[2];
   if (nlen != (len ^ 0xffff)) return stbi__err("zlib corrupt","Corrupt PNG");
   if (a->zbuffer + len > a->zbuffer_end) return stbi__err("read past buffer","Corrupt PNG");
   if (a->zout + len > a->zout_end)
      if (!stbi__zexpand(a, a->zout, len)) return 0;
   memcpy(a->zout, a->zbuffer, len);
   a->zbuffer += len;
   a->zout += len;
   return 1;
}

static int stbi__parse_zlib_header(stbi__zbuf *a)
{
   int cmf   = stbi__zget8(a);
   int cm    = cmf & 15;
   /* int cinfo = cmf >> 4; */
   int flg   = stbi__zget8(a);
   if ((cmf*256+flg) % 31 != 0) return stbi__err("bad zlib header","Corrupt PNG"); // zlib spec
   if (flg & 32) return stbi__err("no preset dict","Corrupt PNG"); // preset dictionary not allowed in png
   if (cm != 8) return stbi__err("bad compression","Corrupt PNG"); // DEFLATE required for png
   // window = 1 << (8 + cinfo)... but who cares, we fully buffer output
   return 1;
}

static const stbi_uc stbi__zdefault_length[288] =
{
   8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
   8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
   8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
   8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
   8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
   9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9, 9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
   9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9, 9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
   9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9, 9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
   7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7, 7,7,7,7,7,7,7,7,8,8,8,8,8,8,8,8
};
static const stbi_uc stbi__zdefault_distance[32] =
{
   5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5
};
/*
Init algorithm:
{
   int i;   // use <= to match clearly with spec
   for (i=0; i <= 143; ++i)     stbi__zdefault_length[i]   = 8;
   for (   ; i <= 255; ++i)     stbi__zdefault_length[i]   = 9;
   for (   ; i <= 279; ++i)     stbi__zdefault_length[i]   = 7;
   for (   ; i <= 287; ++i)     stbi__zdefault_length[i]   = 8;

   for (i=0; i <=  31; ++i)     stbi__zdefault_distance[i] = 5;
}
*/

static int stbi__parse_zlib(stbi__zbuf *a, int parse_header)
{
   int final, type;
   if (parse_header)
      if (!stbi__parse_zlib_header(a)) return 0;
   a->num_bits = 0;
   a->code_buffer = 0;
   do {
      final = stbi__zreceive(a,1);
      type = stbi__zreceive(a,2);
      if (type == 0) {
         if (!stbi__parse_uncompressed_block(a)) return 0;
      } else if (type == 3) {
         return 0;
      } else {
         if (type == 1) {
            // use fixed code lengths
            if (!stbi__zbuild_huffman(&a->z_length  , stbi__zdefault_length  , 288)) return 0;
            if (!stbi__zbuild_huffman(&a->z_distance, stbi__zdefault_distance,  32)) return 0;
         } else {
            if (!stbi__compute_huffman_codes(a)) return 0;
         }
         if (!stbi__parse_huffman_block(a)) return 0;
      }
   } while (!final);
   return 1;
}

static int stbi__do_zlib(stbi__zbuf *a, char *obuf, int olen, int exp, int parse_header)
{
   a->zout_start = obuf;
   a->zout       = obuf;
   a->zout_end   = obuf + olen;
   a->z_expandable = exp;

   return stbi__parse_zlib(a, parse_header);
}

STBIDEF char *stbi_zlib_decode_malloc_guesssize(const char *buffer, int len, int initial_size, int *outlen)
{
   stbi__zbuf a;
   char *p = (char *) stbi__malloc(initial_size);
   if (p == NULL) return NULL;
   a.zbuffer = (stbi_uc *) buffer;
   a.zbuffer_end = (stbi_uc *) buffer + len;
   if (stbi__do_zlib(&a, p, initial_size, 1, 1)) {
      if (outlen) *outlen = (int) (a.zout - a.zout_start);
      return a.zout_start;
   } else {
      STBI_FREE(a.zout_start);
      return NULL;
   }
}

STBIDEF char *stbi_zlib_decode_malloc(char const *buffer, int len, int *outlen)
{
   return stbi_zlib_decode_malloc_guesssize(buffer, len, 16384, outlen);
}

STBIDEF char *stbi_zlib_decode_malloc_guesssize_headerflag(const char *buffer, int len, int initial_size, int *outlen, int parse_header)
{
   stbi__zbuf a;
   char *p = (char *) stbi__malloc(initial_size);
   if (p == NULL) return NULL;
   a.zbuffer = (stbi_uc *) buffer;
   a.zbuffer_end = (stbi_uc *) buffer + len;
   if (stbi__do_zlib(&a, p, initial_size, 1, parse_header)) {
      if (outlen) *outlen = (int) (a.zout - a.zout_start);
      return a.zout_start;
   } else {
      STBI_FREE(a.zout_start);
      return NULL;
   }
}

STBIDEF int stbi_zlib_decode_buffer(char *obuffer, int olen, char const *ibuffer, int ilen)
{
   stbi__zbuf a;
   a.zbuffer = (stbi_uc *) ibuffer;
   a.zbuffer_end = (stbi_uc *) ibuffer + ilen;
   if (stbi__do_zlib(&a, obuffer, olen, 0, 1))
      return (int) (a.zout - a.zout_start);
   else
      return -1;
}

STBIDEF char *stbi_zlib_decode_noheader_malloc(char const *buffer, int len, int *outlen)
{
   stbi__zbuf a;
   char *p = (char *) stbi__malloc(16384);
   if (p == NULL) return NULL;
   a.zbuffer = (stbi_uc *) buffer;
   a.zbuffer_end = (stbi_uc *) buffer+len;
   if (stbi__do_zlib(&a, p, 16384, 1, 0)) {
      if (outlen) *outlen = (int) (a.zout - a.zout_start);
      return a.zout_start;
   } else {
      STBI_FREE(a.zout_start);
      return NULL;
   }
}

STBIDEF int stbi_zlib_decode_noheader_buffer(char *obuffer, int olen, const char *ibuffer, int ilen)
{
   stbi__zbuf a;
   a.zbuffer = (stbi_uc *) ibuffer;
   a.zbuffer_end = (stbi_uc *) ibuffer + ilen;
   if (stbi__do_zlib(&a, obuffer, olen, 0, 0))
      return (int) (a.zout - a.zout_start);
   else
      return -1;
}
#endif

// public domain "baseline" PNG decoder   v0.10  Sean Barrett 2006-11-18
//    simple implementation
//      - only 8-bit samples
//      - no CRC checking
//      - allocates lots of intermediate memory
//        - avoids problem of streaming data between subsystems
//        - avoids explicit window management
//    performance
//      - uses stb_zlib, a PD zlib implementation with fast huffman decoding

#ifndef STBI_NO_PNG
typedef struct
{
   stbi__uint32 length;
   stbi__uint32 type;
} stbi__pngchunk;

static stbi__pngchunk stbi__get_chunk_header(stbi__context *s)
{
   stbi__pngchunk c;
   c.length = stbi__get32be(s);
   c.type   = stbi__get32be(s);
   return c;
}

static int stbi__check_png_header(stbi__context *s)
{
   static const stbi_uc png_sig[8] = { 137,80,78,71,13,10,26,10 };
   int i;
   for (i=0; i < 8; ++i)
      if (stbi__get8(s) != png_sig[i]) return stbi__err("bad png sig","Not a PNG");
   return 1;
}

typedef struct
{
   stbi__context *s;
   stbi_uc *idata, *expanded, *out;
   int depth;
} stbi__png;


enum {
   STBI__F_none=0,
   STBI__F_sub=1,
   STBI__F_up=2,
   STBI__F_avg=3,
   STBI__F_paeth=4,
   // synthetic filters used for first scanline to avoid needing a dummy row of 0s
   STBI__F_avg_first,
   STBI__F_paeth_first
};

static stbi_uc first_row_filter[5] =
{
   STBI__F_none,
   STBI__F_sub,
   STBI__F_none,
   STBI__F_avg_first,
   STBI__F_paeth_first
};

static int stbi__paeth(int a, int b, int c)
{
   int p = a + b - c;
   int pa = abs(p-a);
   int pb = abs(p-b);
   int pc = abs(p-c);
   if (pa <= pb && pa <= pc) return a;
   if (pb <= pc) return b;
   return c;
}

static const stbi_uc stbi__depth_scale_table[9] = { 0, 0xff, 0x55, 0, 0x11, 0,0,0, 0x01 };

// create the png data from post-deflated data
static int stbi__create_png_image_raw(stbi__png *a, stbi_uc *raw, stbi__uint32 raw_len, int out_n, stbi__uint32 x, stbi__uint32 y, int depth, int color)
{
   int bytes = (depth == 16? 2 : 1);
   stbi__context *s = a->s;
   stbi__uint32 i,j,stride = x*out_n*bytes;
   stbi__uint32 img_len, img_width_bytes;
   int k;
   int img_n = s->img_n; // copy it into a local for later

   int output_bytes = out_n*bytes;
   int filter_bytes = img_n*bytes;
   int width = x;

   STBI_ASSERT(out_n == s->img_n || out_n == s->img_n+1);
   a->out = (stbi_uc *) stbi__malloc_mad3(x, y, output_bytes, 0); // extra bytes to write off the end into
   if (!a->out) return stbi__err("outofmem", "Out of memory");

   if (!stbi__mad3sizes_valid(img_n, x, depth, 7)) return stbi__err("too large", "Corrupt PNG");
   img_width_bytes = (((img_n * x * depth) + 7) >> 3);
   img_len = (img_width_bytes + 1) * y;

   // we used to check for exact match between raw_len and img_len on non-interlaced PNGs,
   // but issue #276 reported a PNG in the wild that had extra data at the end (all zeros),
   // so just check for raw_len < img_len always.
   if (raw_len < img_len) return stbi__err("not enough pixels","Corrupt PNG");

   for (j=0; j < y; ++j) {
      stbi_uc *cur = a->out + stride*j;
      stbi_uc *prior;
      int filter = *raw++;

      if (filter > 4)
         return stbi__err("invalid filter","Corrupt PNG");

      if (depth < 8) {
         STBI_ASSERT(img_width_bytes <= x);
         cur += x*out_n - img_width_bytes; // store output to the rightmost img_len bytes, so we can decode in place
         filter_bytes = 1;
         width = img_width_bytes;
      }
      prior = cur - stride; // bugfix: need to compute this after 'cur +=' computation above

      // if first row, use special filter that doesn't sample previous row
      if (j == 0) filter = first_row_filter[filter];

      // handle first byte explicitly
      for (k=0; k < filter_bytes; ++k) {
         switch (filter) {
            case STBI__F_none       : cur[k] = raw[k]; break;
            case STBI__F_sub        : cur[k] = raw[k]; break;
            case STBI__F_up         : cur[k] = STBI__BYTECAST(raw[k] + prior[k]); break;
            case STBI__F_avg        : cur[k] = STBI__BYTECAST(raw[k] + (prior[k]>>1)); break;
            case STBI__F_paeth      : cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(0,prior[k],0)); break;
            case STBI__F_avg_first  : cur[k] = raw[k]; break;
            case STBI__F_paeth_first: cur[k] = raw[k]; break;
         }
      }

      if (depth == 8) {
         if (img_n != out_n)
            cur[img_n] = 255; // first pixel
         raw += img_n;
         cur += out_n;
         prior += out_n;
      } else if (depth == 16) {
         if (img_n != out_n) {
            cur[filter_bytes]   = 255; // first pixel top byte
            cur[filter_bytes+1] = 255; // first pixel bottom byte
         }
         raw += filter_bytes;
         cur += output_bytes;
         prior += output_bytes;
      } else {
         raw += 1;
         cur += 1;
         prior += 1;
      }

      // this is a little gross, so that we don't switch per-pixel or per-component
      if (depth < 8 || img_n == out_n) {
         int nk = (width - 1)*filter_bytes;
         #define STBI__CASE(f) \
             case f:     \
                for (k=0; k < nk; ++k)
         switch (filter) {
            // "none" filter turns into a memcpy here; make that explicit.
            case STBI__F_none:         memcpy(cur, raw, nk); break;
            STBI__CASE(STBI__F_sub)          { cur[k] = STBI__BYTECAST(raw[k] + cur[k-filter_bytes]); } break;
            STBI__CASE(STBI__F_up)           { cur[k] = STBI__BYTECAST(raw[k] + prior[k]); } break;
            STBI__CASE(STBI__F_avg)          { cur[k] = STBI__BYTECAST(raw[k] + ((prior[k] + cur[k-filter_bytes])>>1)); } break;
            STBI__CASE(STBI__F_paeth)        { cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k-filter_bytes],prior[k],prior[k-filter_bytes])); } break;
            STBI__CASE(STBI__F_avg_first)    { cur[k] = STBI__BYTECAST(raw[k] + (cur[k-filter_bytes] >> 1)); } break;
            STBI__CASE(STBI__F_paeth_first)  { cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k-filter_bytes],0,0)); } break;
         }
         #undef STBI__CASE
         raw += nk;
      } else {
         STBI_ASSERT(img_n+1 == out_n);
         #define STBI__CASE(f) \
             case f:     \
                for (i=x-1; i >= 1; --i, cur[filter_bytes]=255,raw+=filter_bytes,cur+=output_bytes,prior+=output_bytes) \
                   for (k=0; k < filter_bytes; ++k)
         switch (filter) {
            STBI__CASE(STBI__F_none)         { cur[k] = raw[k]; } break;
            STBI__CASE(STBI__F_sub)          { cur[k] = STBI__BYTECAST(raw[k] + cur[k- output_bytes]); } break;
            STBI__CASE(STBI__F_up)           { cur[k] = STBI__BYTECAST(raw[k] + prior[k]); } break;
            STBI__CASE(STBI__F_avg)          { cur[k] = STBI__BYTECAST(raw[k] + ((prior[k] + cur[k- output_bytes])>>1)); } break;
            STBI__CASE(STBI__F_paeth)        { cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k- output_bytes],prior[k],prior[k- output_bytes])); } break;
            STBI__CASE(STBI__F_avg_first)    { cur[k] = STBI__BYTECAST(raw[k] + (cur[k- output_bytes] >> 1)); } break;
            STBI__CASE(STBI__F_paeth_first)  { cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k- output_bytes],0,0)); } break;
         }
         #undef STBI__CASE

         // the loop above sets the high byte of the pixels' alpha, but for
         // 16 bit png files we also need the low byte set. we'll do that here.
         if (depth == 16) {
            cur = a->out + stride*j; // start at the beginning of the row again
            for (i=0; i < x; ++i,cur+=output_bytes) {
               cur[filter_bytes+1] = 255;
            }
         }
      }
   }

   // we make a separate pass to expand bits to pixels; for performance,
   // this could run two scanlines behind the above code, so it won't
   // intefere with filtering but will still be in the cache.
   if (depth < 8) {
      for (j=0; j < y; ++j) {
         stbi_uc *cur = a->out + stride*j;
         stbi_uc *in  = a->out + stride*j + x*out_n - img_width_bytes;
         // unpack 1/2/4-bit into a 8-bit buffer. allows us to keep the common 8-bit path optimal at minimal cost for 1/2/4-bit
         // png guarante byte alignment, if width is not multiple of 8/4/2 we'll decode dummy trailing data that will be skipped in the later loop
         stbi_uc scale = (color == 0) ? stbi__depth_scale_table[depth] : 1; // scale grayscale values to 0..255 range

         // note that the final byte might overshoot and write more data than desired.
         // we can allocate enough data that this never writes out of memory, but it
         // could also overwrite the next scanline. can it overwrite non-empty data
         // on the next scanline? yes, consider 1-pixel-wide scanlines with 1-bit-per-pixel.
         // so we need to explicitly clamp the final ones

         if (depth == 4) {
            for (k=x*img_n; k >= 2; k-=2, ++in) {
               *cur++ = scale * ((*in >> 4)       );
               *cur++ = scale * ((*in     ) & 0x0f);
            }
            if (k > 0) *cur++ = scale * ((*in >> 4)       );
         } else if (depth == 2) {
            for (k=x*img_n; k >= 4; k-=4, ++in) {
               *cur++ = scale * ((*in >> 6)       );
               *cur++ = scale * ((*in >> 4) & 0x03);
               *cur++ = scale * ((*in >> 2) & 0x03);
               *cur++ = scale * ((*in     ) & 0x03);
            }
            if (k > 0) *cur++ = scale * ((*in >> 6)       );
            if (k > 1) *cur++ = scale * ((*in >> 4) & 0x03);
            if (k > 2) *cur++ = scale * ((*in >> 2) & 0x03);
         } else if (depth == 1) {
            for (k=x*img_n; k >= 8; k-=8, ++in) {
               *cur++ = scale * ((*in >> 7)       );
               *cur++ = scale * ((*in >> 6) & 0x01);
               *cur++ = scale * ((*in >> 5) & 0x01);
               *cur++ = scale * ((*in >> 4) & 0x01);
               *cur++ = scale * ((*in >> 3) & 0x01);
               *cur++ = scale * ((*in >> 2) & 0x01);
               *cur++ = scale * ((*in >> 1) & 0x01);
               *cur++ = scale * ((*in     ) & 0x01);
            }
            if (k > 0) *cur++ = scale * ((*in >> 7)       );
            if (k > 1) *cur++ = scale * ((*in >> 6) & 0x01);
            if (k > 2) *cur++ = scale * ((*in >> 5) & 0x01);
            if (k > 3) *cur++ = scale * ((*in >> 4) & 0x01);
            if (k > 4) *cur++ = scale * ((*in >> 3) & 0x01);
            if (k > 5) *cur++ = scale * ((*in >> 2) & 0x01);
            if (k > 6) *cur++ = scale * ((*in >> 1) & 0x01);
         }
         if (img_n != out_n) {
            int q;
            // insert alpha = 255
            cur = a->out + stride*j;
            if (img_n == 1) {
               for (q=x-1; q >= 0; --q) {
                  cur[q*2+1] = 255;
                  cur[q*2+0] = cur[q];
               }
            } else {
               STBI_ASSERT(img_n == 3);
               for (q=x-1; q >= 0; --q) {
                  cur[q*4+3] = 255;
                  cur[q*4+2] = cur[q*3+2];
                  cur[q*4+1] = cur[q*3+1];
                  cur[q*4+0] = cur[q*3+0];
               }
            }
         }
      }
   } else if (depth == 16) {
      // force the image data from big-endian to platform-native.
      // this is done in a separate pass due to the decoding relying
      // on the data being untouched, but could probably be done
      // per-line during decode if care is taken.
      stbi_uc *cur = a->out;
      stbi__uint16 *cur16 = (stbi__uint16*)cur;

      for(i=0; i < x*y*out_n; ++i,cur16++,cur+=2) {
         *cur16 = (cur[0] << 8) | cur[1];
      }
   }

   return 1;
}

static int stbi__create_png_image(stbi__png *a, stbi_uc *image_data, stbi__uint32 image_data_len, int out_n, int depth, int color, int interlaced)
{
   int bytes = (depth == 16 ? 2 : 1);
   int out_bytes = out_n * bytes;
   stbi_uc *final;
   int p;
   if (!interlaced)
      return stbi__create_png_image_raw(a, image_data, image_data_len, out_n, a->s->img_x, a->s->img_y, depth, color);

   // de-interlacing
   final = (stbi_uc *) stbi__malloc_mad3(a->s->img_x, a->s->img_y, out_bytes, 0);
   for (p=0; p < 7; ++p) {
      int xorig[] = { 0,4,0,2,0,1,0 };
      int yorig[] = { 0,0,4,0,2,0,1 };
      int xspc[]  = { 8,8,4,4,2,2,1 };
      int yspc[]  = { 8,8,8,4,4,2,2 };
      int i,j,x,y;
      // pass1_x[4] = 0, pass1_x[5] = 1, pass1_x[12] = 1
      x = (a->s->img_x - xorig[p] + xspc[p]-1) / xspc[p];
      y = (a->s->img_y - yorig[p] + yspc[p]-1) / yspc[p];
      if (x && y) {
         stbi__uint32 img_len = ((((a->s->img_n * x * depth) + 7) >> 3) + 1) * y;
         if (!stbi__create_png_image_raw(a, image_data, image_data_len, out_n, x, y, depth, color)) {
            STBI_FREE(final);
            return 0;
         }
         for (j=0; j < y; ++j) {
            for (i=0; i < x; ++i) {
               int out_y = j*yspc[p]+yorig[p];
               int out_x = i*xspc[p]+xorig[p];
               memcpy(final + out_y*a->s->img_x*out_bytes + out_x*out_bytes,
                      a->out + (j*x+i)*out_bytes, out_bytes);
            }
         }
         STBI_FREE(a->out);
         image_data += img_len;
         image_data_len -= img_len;
      }
   }
   a->out = final;

   return 1;
}

static int stbi__compute_transparency(stbi__png *z, stbi_uc tc[3], int out_n)
{
   stbi__context *s = z->s;
   stbi__uint32 i, pixel_count = s->img_x * s->img_y;
   stbi_uc *p = z->out;

   // compute color-based transparency, assuming we've
   // already got 255 as the alpha value in the output
   STBI_ASSERT(out_n == 2 || out_n == 4);

   if (out_n == 2) {
      for (i=0; i < pixel_count; ++i) {
         p[1] = (p[0] == tc[0] ? 0 : 255);
         p += 2;
      }
   } else {
      for (i=0; i < pixel_count; ++i) {
         if (p[0] == tc[0] && p[1] == tc[1] && p[2] == tc[2])
            p[3] = 0;
         p += 4;
      }
   }
   return 1;
}

static int stbi__compute_transparency16(stbi__png *z, stbi__uint16 tc[3], int out_n)
{
   stbi__context *s = z->s;
   stbi__uint32 i, pixel_count = s->img_x * s->img_y;
   stbi__uint16 *p = (stbi__uint16*) z->out;

   // compute color-based transparency, assuming we've
   // already got 65535 as the alpha value in the output
   STBI_ASSERT(out_n == 2 || out_n == 4);

   if (out_n == 2) {
      for (i = 0; i < pixel_count; ++i) {
         p[1] = (p[0] == tc[0] ? 0 : 65535);
         p += 2;
      }
   } else {
      for (i = 0; i < pixel_count; ++i) {
         if (p[0] == tc[0] && p[1] == tc[1] && p[2] == tc[2])
            p[3] = 0;
         p += 4;
      }
   }
   return 1;
}

static int stbi__expand_png_palette(stbi__png *a, stbi_uc *palette, int len, int pal_img_n)
{
   stbi__uint32 i, pixel_count = a->s->img_x * a->s->img_y;
   stbi_uc *p, *temp_out, *orig = a->out;

   p = (stbi_uc *) stbi__malloc_mad2(pixel_count, pal_img_n, 0);
   if (p == NULL) return stbi__err("outofmem", "Out of memory");

   // between here and free(out) below, exitting would leak
   temp_out = p;

   if (pal_img_n == 3) {
      for (i=0; i < pixel_count; ++i) {
         int n = orig[i]*4;
         p[0] = palette[n  ];
         p[1] = palette[n+1];
         p[2] = palette[n+2];
         p += 3;
      }
   } else {
      for (i=0; i < pixel_count; ++i) {
         int n = orig[i]*4;
         p[0] = palette[n  ];
         p[1] = palette[n+1];
         p[2] = palette[n+2];
         p[3] = palette[n+3];
         p += 4;
      }
   }
   STBI_FREE(a->out);
   a->out = temp_out;

   STBI_NOTUSED(len);

   return 1;
}

static int stbi__unpremultiply_on_load = 0;
static int stbi__de_iphone_flag = 0;

STBIDEF void stbi_set_unpremultiply_on_load(int flag_true_if_should_unpremultiply)
{
   stbi__unpremultiply_on_load = flag_true_if_should_unpremultiply;
}

STBIDEF void stbi_convert_iphone_png_to_rgb(int flag_true_if_should_convert)
{
   stbi__de_iphone_flag = flag_true_if_should_convert;
}

static void stbi__de_iphone(stbi__png *z)
{
   stbi__context *s = z->s;
   stbi__uint32 i, pixel_count = s->img_x * s->img_y;
   stbi_uc *p = z->out;

   if (s->img_out_n == 3) {  // convert bgr to rgb
      for (i=0; i < pixel_count; ++i) {
         stbi_uc t = p[0];
         p[0] = p[2];
         p[2] = t;
         p += 3;
      }
   } else {
      STBI_ASSERT(s->img_out_n == 4);
      if (stbi__unpremultiply_on_load) {
         // convert bgr to rgb and unpremultiply
         for (i=0; i < pixel_count; ++i) {
            stbi_uc a = p[3];
            stbi_uc t = p[0];
            if (a) {
               stbi_uc half = a / 2;
               p[0] = (p[2] * 255 + half) / a;
               p[1] = (p[1] * 255 + half) / a;
               p[2] = ( t   * 255 + half) / a;
            } else {
               p[0] = p[2];
               p[2] = t;
            }
            p += 4;
         }
      } else {
         // convert bgr to rgb
         for (i=0; i < pixel_count; ++i) {
            stbi_uc t = p[0];
            p[0] = p[2];
            p[2] = t;
            p += 4;
         }
      }
   }
}

#define STBI__PNG_TYPE(a,b,c,d)  (((unsigned) (a) << 24) + ((unsigned) (b) << 16) + ((unsigned) (c) << 8) + (unsigned) (d))

static int stbi__parse_png_file(stbi__png *z, int scan, int req_comp)
{
   stbi_uc palette[1024], pal_img_n=0;
   stbi_uc has_trans=0, tc[3]={0};
   stbi__uint16 tc16[3];
   stbi__uint32 ioff=0, idata_limit=0, i, pal_len=0;
   int first=1,k,interlace=0, color=0, is_iphone=0;
   stbi__context *s = z->s;

   z->expanded = NULL;
   z->idata = NULL;
   z->out = NULL;

   if (!stbi__check_png_header(s)) return 0;

   if (scan == STBI__SCAN_type) return 1;

   for (;;) {
      stbi__pngchunk c = stbi__get_chunk_header(s);
      switch (c.type) {
         case STBI__PNG_TYPE('C','g','B','I'):
            is_iphone = 1;
            stbi__skip(s, c.length);
            break;
         case STBI__PNG_TYPE('I','H','D','R'): {
            int comp,filter;
            if (!first) return stbi__err("multiple IHDR","Corrupt PNG");
            first = 0;
            if (c.length != 13) return stbi__err("bad IHDR len","Corrupt PNG");
            s->img_x = stbi__get32be(s); if (s->img_x > (1 << 24)) return stbi__err("too large","Very large image (corrupt?)");
            s->img_y = stbi__get32be(s); if (s->img_y > (1 << 24)) return stbi__err("too large","Very large image (corrupt?)");
            z->depth = stbi__get8(s);  if (z->depth != 1 && z->depth != 2 && z->depth != 4 && z->depth != 8 && z->depth != 16)  return stbi__err("1/2/4/8/16-bit only","PNG not supported: 1/2/4/8/16-bit only");
            color = stbi__get8(s);  if (color > 6)         return stbi__err("bad ctype","Corrupt PNG");
            if (color == 3 && z->depth == 16)                  return stbi__err("bad ctype","Corrupt PNG");
            if (color == 3) pal_img_n = 3; else if (color & 1) return stbi__err("bad ctype","Corrupt PNG");
            comp  = stbi__get8(s);  if (comp) return stbi__err("bad comp method","Corrupt PNG");
            filter= stbi__get8(s);  if (filter) return stbi__err("bad filter method","Corrupt PNG");
            interlace = stbi__get8(s); if (interlace>1) return stbi__err("bad interlace method","Corrupt PNG");
            if (!s->img_x || !s->img_y) return stbi__err("0-pixel image","Corrupt PNG");
            if (!pal_img_n) {
               s->img_n = (color & 2 ? 3 : 1) + (color & 4 ? 1 : 0);
               if ((1 << 30) / s->img_x / s->img_n < s->img_y) return stbi__err("too large", "Image too large to decode");
               if (scan == STBI__SCAN_header) return 1;
            } else {
               // if paletted, then pal_n is our final components, and
               // img_n is # components to decompress/filter.
               s->img_n = 1;
               if ((1 << 30) / s->img_x / 4 < s->img_y) return stbi__err("too large","Corrupt PNG");
               // if SCAN_header, have to scan to see if we have a tRNS
            }
            break;
         }

         case STBI__PNG_TYPE('P','L','T','E'):  {
            if (first) return stbi__err("first not IHDR", "Corrupt PNG");
            if (c.length > 256*3) return stbi__err("invalid PLTE","Corrupt PNG");
            pal_len = c.length / 3;
            if (pal_len * 3 != c.length) return stbi__err("invalid PLTE","Corrupt PNG");
            for (i=0; i < pal_len; ++i) {
               palette[i*4+0] = stbi__get8(s);
               palette[i*4+1] = stbi__get8(s);
               palette[i*4+2] = stbi__get8(s);
               palette[i*4+3] = 255;
            }
            break;
         }

         case STBI__PNG_TYPE('t','R','N','S'): {
            if (first) return stbi__err("first not IHDR", "Corrupt PNG");
            if (z->idata) return stbi__err("tRNS after IDAT","Corrupt PNG");
            if (pal_img_n) {
               if (scan == STBI__SCAN_header) { s->img_n = 4; return 1; }
               if (pal_len == 0) return stbi__err("tRNS before PLTE","Corrupt PNG");
               if (c.length > pal_len) return stbi__err("bad tRNS len","Corrupt PNG");
               pal_img_n = 4;
               for (i=0; i < c.length; ++i)
                  palette[i*4+3] = stbi__get8(s);
            } else {
               if (!(s->img_n & 1)) return stbi__err("tRNS with alpha","Corrupt PNG");
               if (c.length != (stbi__uint32) s->img_n*2) return stbi__err("bad tRNS len","Corrupt PNG");
               has_trans = 1;
               if (z->depth == 16) {
                  for (k = 0; k < s->img_n; ++k) tc16[k] = (stbi__uint16)stbi__get16be(s); // copy the values as-is
               } else {
                  for (k = 0; k < s->img_n; ++k) tc[k] = (stbi_uc)(stbi__get16be(s) & 255) * stbi__depth_scale_table[z->depth]; // non 8-bit images will be larger
               }
            }
            break;
         }

         case STBI__PNG_TYPE('I','D','A','T'): {
            if (first) return stbi__err("first not IHDR", "Corrupt PNG");
            if (pal_img_n && !pal_len) return stbi__err("no PLTE","Corrupt PNG");
            if (scan == STBI__SCAN_header) { s->img_n = pal_img_n; return 1; }
            if ((int)(ioff + c.length) < (int)ioff) return 0;
            if (ioff + c.length > idata_limit) {
               stbi__uint32 idata_limit_old = idata_limit;
               stbi_uc *p;
               if (idata_limit == 0) idata_limit = c.length > 4096 ? c.length : 4096;
               while (ioff + c.length > idata_limit)
                  idata_limit *= 2;
               STBI_NOTUSED(idata_limit_old);
               p = (stbi_uc *) STBI_REALLOC_SIZED(z->idata, idata_limit_old, idata_limit); if (p == NULL) return stbi__err("outofmem", "Out of memory");
               z->idata = p;
            }
            if (!stbi__getn(s, z->idata+ioff,c.length)) return stbi__err("outofdata","Corrupt PNG");
            ioff += c.length;
            break;
         }

         case STBI__PNG_TYPE('I','E','N','D'): {
            stbi__uint32 raw_len, bpl;
            if (first) return stbi__err("first not IHDR", "Corrupt PNG");
            if (scan != STBI__SCAN_load) return 1;
            if (z->idata == NULL) return stbi__err("no IDAT","Corrupt PNG");
            // initial guess for decoded data size to avoid unnecessary reallocs
            bpl = (s->img_x * z->depth + 7) / 8; // bytes per line, per component
            raw_len = bpl * s->img_y * s->img_n /* pixels */ + s->img_y /* filter mode per row */;
            z->expanded = (stbi_uc *) stbi_zlib_decode_malloc_guesssize_headerflag((char *) z->idata, ioff, raw_len, (int *) &raw_len, !is_iphone);
            if (z->expanded == NULL) return 0; // zlib should set error
            STBI_FREE(z->idata); z->idata = NULL;
            if ((req_comp == s->img_n+1 && req_comp != 3 && !pal_img_n) || has_trans)
               s->img_out_n = s->img_n+1;
            else
               s->img_out_n = s->img_n;
            if (!stbi__create_png_image(z, z->expanded, raw_len, s->img_out_n, z->depth, color, interlace)) return 0;
            if (has_trans) {
               if (z->depth == 16) {
                  if (!stbi__compute_transparency16(z, tc16, s->img_out_n)) return 0;
               } else {
                  if (!stbi__compute_transparency(z, tc, s->img_out_n)) return 0;
               }
            }
            if (is_iphone && stbi__de_iphone_flag && s->img_out_n > 2)
               stbi__de_iphone(z);
            if (pal_img_n) {
               // pal_img_n == 3 or 4
               s->img_n = pal_img_n; // record the actual colors we had
               s->img_out_n = pal_img_n;
               if (req_comp >= 3) s->img_out_n = req_comp;
               if (!stbi__expand_png_palette(z, palette, pal_len, s->img_out_n))
                  return 0;
            } else if (has_trans) {
               // non-paletted image with tRNS -> source image has (constant) alpha
               ++s->img_n;
            }
            STBI_FREE(z->expanded); z->expanded = NULL;
            // end of PNG chunk, read and skip CRC
            stbi__get32be(s);
            return 1;
         }

         default:
            // if critical, fail
            if (first) return stbi__err("first not IHDR", "Corrupt PNG");
            if ((c.type & (1 << 29)) == 0) {
               #ifndef STBI_NO_FAILURE_STRINGS
               // not threadsafe
               static char invalid_chunk[] = "XXXX PNG chunk not known";
               invalid_chunk[0] = STBI__BYTECAST(c.type >> 24);
               invalid_chunk[1] = STBI__BYTECAST(c.type >> 16);
               invalid_chunk[2] = STBI__BYTECAST(c.type >>  8);
               invalid_chunk[3] = STBI__BYTECAST(c.type >>  0);
               #endif
               return stbi__err(invalid_chunk, "PNG not supported: unknown PNG chunk type");
            }
            stbi__skip(s, c.length);
            break;
      }
      // end of PNG chunk, read and skip CRC
      stbi__get32be(s);
   }
}

static void *stbi__do_png(stbi__png *p, int *x, int *y, int *n, int req_comp, stbi__result_info *ri)
{
   void *result=NULL;
   if (req_comp < 0 || req_comp > 4) return stbi__errpuc("bad req_comp", "Internal error");
   if (stbi__parse_png_file(p, STBI__SCAN_load, req_comp)) {
      if (p->depth < 8)
         ri->bits_per_channel = 8;
      else
         ri->bits_per_channel = p->depth;
      result = p->out;
      p->out = NULL;
      if (req_comp && req_comp != p->s->img_out_n) {
         if (ri->bits_per_channel == 8)
            result = stbi__convert_format((unsigned char *) result, p->s->img_out_n, req_comp, p->s->img_x, p->s->img_y);
         else
            result = stbi__convert_format16((stbi__uint16 *) result, p->s->img_out_n, req_comp, p->s->img_x, p->s->img_y);
         p->s->img_out_n = req_comp;
         if (result == NULL) return result;
      }
      *x = p->s->img_x;
      *y = p->s->img_y;
      if (n) *n = p->s->img_n;
   }
   STBI_FREE(p->out);      p->out      = NULL;
   STBI_FREE(p->expanded); p->expanded = NULL;
   STBI_FREE(p->idata);    p->idata    = NULL;

   return result;
}

static void *stbi__png_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
{
   stbi__png p;
   p.s = s;
   return stbi__do_png(&p, x,y,comp,req_comp, ri);
}

static int stbi__png_test(stbi__context *s)
{
   int r;
   r = stbi__check_png_header(s);
   stbi__rewind(s);
   return r;
}

static int stbi__png_info_raw(stbi__png *p, int *x, int *y, int *comp)
{
   if (!stbi__parse_png_file(p, STBI__SCAN_header, 0)) {
      stbi__rewind( p->s );
      return 0;
   }
   if (x) *x = p->s->img_x;
   if (y) *y = p->s->img_y;
   if (comp) *comp = p->s->img_n;
   return 1;
}

static int stbi__png_info(stbi__context *s, int *x, int *y, int *comp)
{
   stbi__png p;
   p.s = s;
   return stbi__png_info_raw(&p, x, y, comp);
}

static int stbi__png_is16(stbi__context *s)
{
   stbi__png p;
   p.s = s;
   if (!stbi__png_info_raw(&p, NULL, NULL, NULL))
	   return 0;
   if (p.depth != 16) {
      stbi__rewind(p.s);
      return 0;
   }
   return 1;
}
#endif

// Microsoft/Windows BMP image

#ifndef STBI_NO_BMP
static int stbi__bmp_test_raw(stbi__context *s)
{
   int r;
   int sz;
   if (stbi__get8(s) != 'B') return 0;
   if (stbi__get8(s) != 'M') return 0;
   stbi__get32le(s); // discard filesize
   stbi__get16le(s); // discard reserved
   stbi__get16le(s); // discard reserved
   stbi__get32le(s); // discard data offset
   sz = stbi__get32le(s);
   r = (sz == 12 || sz == 40 || sz == 56 || sz == 108 || sz == 124);
   return r;
}

static int stbi__bmp_test(stbi__context *s)
{
   int r = stbi__bmp_test_raw(s);
   stbi__rewind(s);
   return r;
}


// returns 0..31 for the highest set bit
static int stbi__high_bit(unsigned int z)
{
   int n=0;
   if (z == 0) return -1;
   if (z >= 0x10000) { n += 16; z >>= 16; }
   if (z >= 0x00100) { n +=  8; z >>=  8; }
   if (z >= 0x00010) { n +=  4; z >>=  4; }
   if (z >= 0x00004) { n +=  2; z >>=  2; }
   if (z >= 0x00002) { n +=  1;/* >>=  1;*/ }
   return n;
}

static int stbi__bitcount(unsigned int a)
{
   a = (a & 0x55555555) + ((a >>  1) & 0x55555555); // max 2
   a = (a & 0x33333333) + ((a >>  2) & 0x33333333); // max 4
   a = (a + (a >> 4)) & 0x0f0f0f0f; // max 8 per 4, now 8 bits
   a = (a + (a >> 8)); // max 16 per 8 bits
   a = (a + (a >> 16)); // max 32 per 8 bits
   return a & 0xff;
}

// extract an arbitrarily-aligned N-bit value (N=bits)
// from v, and then make it 8-bits long and fractionally
// extend it to full full range.
static int stbi__shiftsigned(unsigned int v, int shift, int bits)
{
   static unsigned int mul_table[9] = {
      0,
      0xff/*0b11111111*/, 0x55/*0b01010101*/, 0x49/*0b01001001*/, 0x11/*0b00010001*/,
      0x21/*0b00100001*/, 0x41/*0b01000001*/, 0x81/*0b10000001*/, 0x01/*0b00000001*/,
   };
   static unsigned int shift_table[9] = {
      0, 0,0,1,0,2,4,6,0,
   };
   if (shift < 0)
      v <<= -shift;
   else
      v >>= shift;
   STBI_ASSERT(v < 256);
   v >>= (8-bits);
   STBI_ASSERT(bits >= 0 && bits <= 8);
   return (int) ((unsigned) v * mul_table[bits]) >> shift_table[bits];
}

typedef struct
{
   int bpp, offset, hsz;
   unsigned int mr,mg,mb,ma, all_a;
   int extra_read;
} stbi__bmp_data;

static void *stbi__bmp_parse_header(stbi__context *s, stbi__bmp_data *info)
{
   int hsz;
   if (stbi__get8(s) != 'B' || stbi__get8(s) != 'M') return stbi__errpuc("not BMP", "Corrupt BMP");
   stbi__get32le(s); // discard filesize
   stbi__get16le(s); // discard reserved
   stbi__get16le(s); // discard reserved
   info->offset = stbi__get32le(s);
   info->hsz = hsz = stbi__get32le(s);
   info->mr = info->mg = info->mb = info->ma = 0;
   info->extra_read = 14;

   if (hsz != 12 && hsz != 40 && hsz != 56 && hsz != 108 && hsz != 124) return stbi__errpuc("unknown BMP", "BMP type not supported: unknown");
   if (hsz == 12) {
      s->img_x = stbi__get16le(s);
      s->img_y = stbi__get16le(s);
   } else {
      s->img_x = stbi__get32le(s);
      s->img_y = stbi__get32le(s);
   }
   if (stbi__get16le(s) != 1) return stbi__errpuc("bad BMP", "bad BMP");
   info->bpp = stbi__get16le(s);
   if (hsz != 12) {
      int compress = stbi__get32le(s);
      if (compress == 1 || compress == 2) return stbi__errpuc("BMP RLE", "BMP type not supported: RLE");
      stbi__get32le(s); // discard sizeof
      stbi__get32le(s); // discard hres
      stbi__get32le(s); // discard vres
      stbi__get32le(s); // discard colorsused
      stbi__get32le(s); // discard max important
      if (hsz == 40 || hsz == 56) {
         if (hsz == 56) {
            stbi__get32le(s);
            stbi__get32le(s);
            stbi__get32le(s);
            stbi__get32le(s);
         }
         if (info->bpp == 16 || info->bpp == 32) {
            if (compress == 0) {
               if (info->bpp == 32) {
                  info->mr = 0xffu << 16;
                  info->mg = 0xffu <<  8;
                  info->mb = 0xffu <<  0;
                  info->ma = 0xffu << 24;
                  info->all_a = 0; // if all_a is 0 at end, then we loaded alpha channel but it was all 0
               } else {
                  info->mr = 31u << 10;
                  info->mg = 31u <<  5;
                  info->mb = 31u <<  0;
               }
            } else if (compress == 3) {
               info->mr = stbi__get32le(s);
               info->mg = stbi__get32le(s);
               info->mb = stbi__get32le(s);
               info->extra_read += 12;
               // not documented, but generated by photoshop and handled by mspaint
               if (info->mr == info->mg && info->mg == info->mb) {
                  // ?!?!?
                  return stbi__errpuc("bad BMP", "bad BMP");
               }
            } else
               return stbi__errpuc("bad BMP", "bad BMP");
         }
      } else {
         int i;
         if (hsz != 108 && hsz != 124)
            return stbi__errpuc("bad BMP", "bad BMP");
         info->mr = stbi__get32le(s);
         info->mg = stbi__get32le(s);
         info->mb = stbi__get32le(s);
         info->ma = stbi__get32le(s);
         stbi__get32le(s); // discard color space
         for (i=0; i < 12; ++i)
            stbi__get32le(s); // discard color space parameters
         if (hsz == 124) {
            stbi__get32le(s); // discard rendering intent
            stbi__get32le(s); // discard offset of profile data
            stbi__get32le(s); // discard size of profile data
            stbi__get32le(s); // discard reserved
         }
      }
   }
   return (void *) 1;
}


static void *stbi__bmp_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
{
   stbi_uc *out;
   unsigned int mr=0,mg=0,mb=0,ma=0, all_a;
   stbi_uc pal[256][4];
   int psize=0,i,j,width;
   int flip_vertically, pad, target;
   stbi__bmp_data info;
   STBI_NOTUSED(ri);

   info.all_a = 255;
   if (stbi__bmp_parse_header(s, &info) == NULL)
      return NULL; // error code already set

   flip_vertically = ((int) s->img_y) > 0;
   s->img_y = abs((int) s->img_y);

   mr = info.mr;
   mg = info.mg;
   mb = info.mb;
   ma = info.ma;
   all_a = info.all_a;

   if (info.hsz == 12) {
      if (info.bpp < 24)
         psize = (info.offset - info.extra_read - 24) / 3;
   } else {
      if (info.bpp < 16)
         psize = (info.offset - info.extra_read - info.hsz) >> 2;
   }
   if (psize == 0) {
      STBI_ASSERT(info.offset == (s->img_buffer - s->buffer_start));
   }

   if (info.bpp == 24 && ma == 0xff000000)
      s->img_n = 3;
   else
      s->img_n = ma ? 4 : 3;
   if (req_comp && req_comp >= 3) // we can directly decode 3 or 4
      target = req_comp;
   else
      target = s->img_n; // if they want monochrome, we'll post-convert

   // sanity-check size
   if (!stbi__mad3sizes_valid(target, s->img_x, s->img_y, 0))
      return stbi__errpuc("too large", "Corrupt BMP");

   out = (stbi_uc *) stbi__malloc_mad3(target, s->img_x, s->img_y, 0);
   if (!out) return stbi__errpuc("outofmem", "Out of memory");
   if (info.bpp < 16) {
      int z=0;
      if (psize == 0 || psize > 256) { STBI_FREE(out); return stbi__errpuc("invalid", "Corrupt BMP"); }
      for (i=0; i < psize; ++i) {
         pal[i][2] = stbi__get8(s);
         pal[i][1] = stbi__get8(s);
         pal[i][0] = stbi__get8(s);
         if (info.hsz != 12) stbi__get8(s);
         pal[i][3] = 255;
      }
      stbi__skip(s, info.offset - info.extra_read - info.hsz - psize * (info.hsz == 12 ? 3 : 4));
      if (info.bpp == 1) width = (s->img_x + 7) >> 3;
      else if (info.bpp == 4) width = (s->img_x + 1) >> 1;
      else if (info.bpp == 8) width = s->img_x;
      else { STBI_FREE(out); return stbi__errpuc("bad bpp", "Corrupt BMP"); }
      pad = (-width)&3;
      if (info.bpp == 1) {
         for (j=0; j < (int) s->img_y; ++j) {
            int bit_offset = 7, v = stbi__get8(s);
            for (i=0; i < (int) s->img_x; ++i) {
               int color = (v>>bit_offset)&0x1;
               out[z++] = pal[color][0];
               out[z++] = pal[color][1];
               out[z++] = pal[color][2];
               if (target == 4) out[z++] = 255;
               if (i+1 == (int) s->img_x) break;
               if((--bit_offset) < 0) {
                  bit_offset = 7;
                  v = stbi__get8(s);
               }
            }
            stbi__skip(s, pad);
         }
      } else {
         for (j=0; j < (int) s->img_y; ++j) {
            for (i=0; i < (int) s->img_x; i += 2) {
               int v=stbi__get8(s),v2=0;
               if (info.bpp == 4) {
                  v2 = v & 15;
                  v >>= 4;
               }
               out[z++] = pal[v][0];
               out[z++] = pal[v][1];
               out[z++] = pal[v][2];
               if (target == 4) out[z++] = 255;
               if (i+1 == (int) s->img_x) break;
               v = (info.bpp == 8) ? stbi__get8(s) : v2;
               out[z++] = pal[v][0];
               out[z++] = pal[v][1];
               out[z++] = pal[v][2];
               if (target == 4) out[z++] = 255;
            }
            stbi__skip(s, pad);
         }
      }
   } else {
      int rshift=0,gshift=0,bshift=0,ashift=0,rcount=0,gcount=0,bcount=0,acount=0;
      int z = 0;
      int easy=0;
      stbi__skip(s, info.offset - info.extra_read - info.hsz);
      if (info.bpp == 24) width = 3 * s->img_x;
      else if (info.bpp == 16) width = 2*s->img_x;
      else /* bpp = 32 and pad = 0 */ width=0;
      pad = (-width) & 3;
      if (info.bpp == 24) {
         easy = 1;
      } else if (info.bpp == 32) {
         if (mb == 0xff && mg == 0xff00 && mr == 0x00ff0000 && ma == 0xff000000)
            easy = 2;
      }
      if (!easy) {
         if (!mr || !mg || !mb) { STBI_FREE(out); return stbi__errpuc("bad masks", "Corrupt BMP"); }
         // right shift amt to put high bit in position #7
         rshift = stbi__high_bit(mr)-7; rcount = stbi__bitcount(mr);
         gshift = stbi__high_bit(mg)-7; gcount = stbi__bitcount(mg);
         bshift = stbi__high_bit(mb)-7; bcount = stbi__bitcount(mb);
         ashift = stbi__high_bit(ma)-7; acount = stbi__bitcount(ma);
      }
      for (j=0; j < (int) s->img_y; ++j) {
         if (easy) {
            for (i=0; i < (int) s->img_x; ++i) {
               unsigned char a;
               out[z+2] = stbi__get8(s);
               out[z+1] = stbi__get8(s);
               out[z+0] = stbi__get8(s);
               z += 3;
               a = (easy == 2 ? stbi__get8(s) : 255);
               all_a |= a;
               if (target == 4) out[z++] = a;
            }
         } else {
            int bpp = info.bpp;
            for (i=0; i < (int) s->img_x; ++i) {
               stbi__uint32 v = (bpp == 16 ? (stbi__uint32) stbi__get16le(s) : stbi__get32le(s));
               unsigned int a;
               out[z++] = STBI__BYTECAST(stbi__shiftsigned(v & mr, rshift, rcount));
               out[z++] = STBI__BYTECAST(stbi__shiftsigned(v & mg, gshift, gcount));
               out[z++] = STBI__BYTECAST(stbi__shiftsigned(v & mb, bshift, bcount));
               a = (ma ? stbi__shiftsigned(v & ma, ashift, acount) : 255);
               all_a |= a;
               if (target == 4) out[z++] = STBI__BYTECAST(a);
            }
         }
         stbi__skip(s, pad);
      }
   }

   // if alpha channel is all 0s, replace with all 255s
   if (target == 4 && all_a == 0)
      for (i=4*s->img_x*s->img_y-1; i >= 0; i -= 4)
         out[i] = 255;

   if (flip_vertically) {
      stbi_uc t;
      for (j=0; j < (int) s->img_y>>1; ++j) {
         stbi_uc *p1 = out +      j     *s->img_x*target;
         stbi_uc *p2 = out + (s->img_y-1-j)*s->img_x*target;
         for (i=0; i < (int) s->img_x*target; ++i) {
            t = p1[i]; p1[i] = p2[i]; p2[i] = t;
         }
      }
   }

   if (req_comp && req_comp != target) {
      out = stbi__convert_format(out, target, req_comp, s->img_x, s->img_y);
      if (out == NULL) return out; // stbi__convert_format frees input on failure
   }

   *x = s->img_x;
   *y = s->img_y;
   if (comp) *comp = s->img_n;
   return out;
}
#endif

// Targa Truevision - TGA
// by Jonathan Dummer
#ifndef STBI_NO_TGA
// returns STBI_rgb or whatever, 0 on error
static int stbi__tga_get_comp(int bits_per_pixel, int is_grey, int* is_rgb16)
{
   // only RGB or RGBA (incl. 16bit) or grey allowed
   if (is_rgb16) *is_rgb16 = 0;
   switch(bits_per_pixel) {
      case 8:  return STBI_grey;
      case 16: if(is_grey) return STBI_grey_alpha;
               // fallthrough
      case 15: if(is_rgb16) *is_rgb16 = 1;
               return STBI_rgb;
      case 24: // fallthrough
      case 32: return bits_per_pixel/8;
      default: return 0;
   }
}

static int stbi__tga_info(stbi__context *s, int *x, int *y, int *comp)
{
    int tga_w, tga_h, tga_comp, tga_image_type, tga_bits_per_pixel, tga_colormap_bpp;
    int sz, tga_colormap_type;
    stbi__get8(s);                   // discard Offset
    tga_colormap_type = stbi__get8(s); // colormap type
    if( tga_colormap_type > 1 ) {
        stbi__rewind(s);
        return 0;      // only RGB or indexed allowed
    }
    tga_image_type = stbi__get8(s); // image type
    if ( tga_colormap_type == 1 ) { // colormapped (paletted) image
        if (tga_image_type != 1 && tga_image_type != 9) {
            stbi__rewind(s);
            return 0;
        }
        stbi__skip(s,4);       // skip index of first colormap entry and number of entries
        sz = stbi__get8(s);    //   check bits per palette color entry
        if ( (sz != 8) && (sz != 15) && (sz != 16) && (sz != 24) && (sz != 32) ) {
            stbi__rewind(s);
            return 0;
        }
        stbi__skip(s,4);       // skip image x and y origin
        tga_colormap_bpp = sz;
    } else { // "normal" image w/o colormap - only RGB or grey allowed, +/- RLE
        if ( (tga_image_type != 2) && (tga_image_type != 3) && (tga_image_type != 10) && (tga_image_type != 11) ) {
            stbi__rewind(s);
            return 0; // only RGB or grey allowed, +/- RLE
        }
        stbi__skip(s,9); // skip colormap specification and image x/y origin
        tga_colormap_bpp = 0;
    }
    tga_w = stbi__get16le(s);
    if( tga_w < 1 ) {
        stbi__rewind(s);
        return 0;   // test width
    }
    tga_h = stbi__get16le(s);
    if( tga_h < 1 ) {
        stbi__rewind(s);
        return 0;   // test height
    }
    tga_bits_per_pixel = stbi__get8(s); // bits per pixel
    stbi__get8(s); // ignore alpha bits
    if (tga_colormap_bpp != 0) {
        if((tga_bits_per_pixel != 8) && (tga_bits_per_pixel != 16)) {
            // when using a colormap, tga_bits_per_pixel is the size of the indexes
            // I don't think anything but 8 or 16bit indexes makes sense
            stbi__rewind(s);
            return 0;
        }
        tga_comp = stbi__tga_get_comp(tga_colormap_bpp, 0, NULL);
    } else {
        tga_comp = stbi__tga_get_comp(tga_bits_per_pixel, (tga_image_type == 3) || (tga_image_type == 11), NULL);
    }
    if(!tga_comp) {
      stbi__rewind(s);
      return 0;
    }
    if (x) *x = tga_w;
    if (y) *y = tga_h;
    if (comp) *comp = tga_comp;
    return 1;                   // seems to have passed everything
}

static int stbi__tga_test(stbi__context *s)
{
   int res = 0;
   int sz, tga_color_type;
   stbi__get8(s);      //   discard Offset
   tga_color_type = stbi__get8(s);   //   color type
   if ( tga_color_type > 1 ) goto errorEnd;   //   only RGB or indexed allowed
   sz = stbi__get8(s);   //   image type
   if ( tga_color_type == 1 ) { // colormapped (paletted) image
      if (sz != 1 && sz != 9) goto errorEnd; // colortype 1 demands image type 1 or 9
      stbi__skip(s,4);       // skip index of first colormap entry and number of entries
      sz = stbi__get8(s);    //   check bits per palette color entry
      if ( (sz != 8) && (sz != 15) && (sz != 16) && (sz != 24) && (sz != 32) ) goto errorEnd;
      stbi__skip(s,4);       // skip image x and y origin
   } else { // "normal" image w/o colormap
      if ( (sz != 2) && (sz != 3) && (sz != 10) && (sz != 11) ) goto errorEnd; // only RGB or grey allowed, +/- RLE
      stbi__skip(s,9); // skip colormap specification and image x/y origin
   }
   if ( stbi__get16le(s) < 1 ) goto errorEnd;      //   test width
   if ( stbi__get16le(s) < 1 ) goto errorEnd;      //   test height
   sz = stbi__get8(s);   //   bits per pixel
   if ( (tga_color_type == 1) && (sz != 8) && (sz != 16) ) goto errorEnd; // for colormapped images, bpp is size of an index
   if ( (sz != 8) && (sz != 15) && (sz != 16) && (sz != 24) && (sz != 32) ) goto errorEnd;

   res = 1; // if we got this far, everything's good and we can return 1 instead of 0

errorEnd:
   stbi__rewind(s);
   return res;
}

// read 16bit value and convert to 24bit RGB
static void stbi__tga_read_rgb16(stbi__context *s, stbi_uc* out)
{
   stbi__uint16 px = (stbi__uint16)stbi__get16le(s);
   stbi__uint16 fiveBitMask = 31;
   // we have 3 channels with 5bits each
   int r = (px >> 10) & fiveBitMask;
   int g = (px >> 5) & fiveBitMask;
   int b = px & fiveBitMask;
   // Note that this saves the data in RGB(A) order, so it doesn't need to be swapped later
   out[0] = (stbi_uc)((r * 255)/31);
   out[1] = (stbi_uc)((g * 255)/31);
   out[2] = (stbi_uc)((b * 255)/31);

   // some people claim that the most significant bit might be used for alpha
   // (possibly if an alpha-bit is set in the "image descriptor byte")
   // but that only made 16bit test images completely translucent..
   // so let's treat all 15 and 16bit TGAs as RGB with no alpha.
}

static void *stbi__tga_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
{
   //   read in the TGA header stuff
   int tga_offset = stbi__get8(s);
   int tga_indexed = stbi__get8(s);
   int tga_image_type = stbi__get8(s);
   int tga_is_RLE = 0;
   int tga_palette_start = stbi__get16le(s);
   int tga_palette_len = stbi__get16le(s);
   int tga_palette_bits = stbi__get8(s);
   int tga_x_origin = stbi__get16le(s);
   int tga_y_origin = stbi__get16le(s);
   int tga_width = stbi__get16le(s);
   int tga_height = stbi__get16le(s);
   int tga_bits_per_pixel = stbi__get8(s);
   int tga_comp, tga_rgb16=0;
   int tga_inverted = stbi__get8(s);
   // int tga_alpha_bits = tga_inverted & 15; // the 4 lowest bits - unused (useless?)
   //   image data
   unsigned char *tga_data;
   unsigned char *tga_palette = NULL;
   int i, j;
   unsigned char raw_data[4] = {0};
   int RLE_count = 0;
   int RLE_repeating = 0;
   int read_next_pixel = 1;
   STBI_NOTUSED(ri);
   STBI_NOTUSED(tga_x_origin); // @TODO
   STBI_NOTUSED(tga_y_origin); // @TODO

   //   do a tiny bit of precessing
   if ( tga_image_type >= 8 )
   {
      tga_image_type -= 8;
      tga_is_RLE = 1;
   }
   tga_inverted = 1 - ((tga_inverted >> 5) & 1);

   //   If I'm paletted, then I'll use the number of bits from the palette
   if ( tga_indexed ) tga_comp = stbi__tga_get_comp(tga_palette_bits, 0, &tga_rgb16);
   else tga_comp = stbi__tga_get_comp(tga_bits_per_pixel, (tga_image_type == 3), &tga_rgb16);

   if(!tga_comp) // shouldn't really happen, stbi__tga_test() should have ensured basic consistency
      return stbi__errpuc("bad format", "Can't find out TGA pixelformat");

   //   tga info
   *x = tga_width;
   *y = tga_height;
   if (comp) *comp = tga_comp;

   if (!stbi__mad3sizes_valid(tga_width, tga_height, tga_comp, 0))
      return stbi__errpuc("too large", "Corrupt TGA");

   tga_data = (unsigned char*)stbi__malloc_mad3(tga_width, tga_height, tga_comp, 0);
   if (!tga_data) return stbi__errpuc("outofmem", "Out of memory");

   // skip to the data's starting position (offset usually = 0)
   stbi__skip(s, tga_offset );

   if ( !tga_indexed && !tga_is_RLE && !tga_rgb16 ) {
      for (i=0; i < tga_height; ++i) {
         int row = tga_inverted ? tga_height -i - 1 : i;
         stbi_uc *tga_row = tga_data + row*tga_width*tga_comp;
         stbi__getn(s, tga_row, tga_width * tga_comp);
      }
   } else  {
      //   do I need to load a palette?
      if ( tga_indexed)
      {
         //   any data to skip? (offset usually = 0)
         stbi__skip(s, tga_palette_start );
         //   load the palette
         tga_palette = (unsigned char*)stbi__malloc_mad2(tga_palette_len, tga_comp, 0);
         if (!tga_palette) {
            STBI_FREE(tga_data);
            return stbi__errpuc("outofmem", "Out of memory");
         }
         if (tga_rgb16) {
            stbi_uc *pal_entry = tga_palette;
            STBI_ASSERT(tga_comp == STBI_rgb);
            for (i=0; i < tga_palette_len; ++i) {
               stbi__tga_read_rgb16(s, pal_entry);
               pal_entry += tga_comp;
            }
         } else if (!stbi__getn(s, tga_palette, tga_palette_len * tga_comp)) {
               STBI_FREE(tga_data);
               STBI_FREE(tga_palette);
               return stbi__errpuc("bad palette", "Corrupt TGA");
         }
      }
      //   load the data
      for (i=0; i < tga_width * tga_height; ++i)
      {
         //   if I'm in RLE mode, do I need to get a RLE stbi__pngchunk?
         if ( tga_is_RLE )
         {
            if ( RLE_count == 0 )
            {
               //   yep, get the next byte as a RLE command
               int RLE_cmd = stbi__get8(s);
               RLE_count = 1 + (RLE_cmd & 127);
               RLE_repeating = RLE_cmd >> 7;
               read_next_pixel = 1;
            } else if ( !RLE_repeating )
            {
               read_next_pixel = 1;
            }
         } else
         {
            read_next_pixel = 1;
         }
         //   OK, if I need to read a pixel, do it now
         if ( read_next_pixel )
         {
            //   load however much data we did have
            if ( tga_indexed )
            {
               // read in index, then perform the lookup
               int pal_idx = (tga_bits_per_pixel == 8) ? stbi__get8(s) : stbi__get16le(s);
               if ( pal_idx >= tga_palette_len ) {
                  // invalid index
                  pal_idx = 0;
               }
               pal_idx *= tga_comp;
               for (j = 0; j < tga_comp; ++j) {
                  raw_data[j] = tga_palette[pal_idx+j];
               }
            } else if(tga_rgb16) {
               STBI_ASSERT(tga_comp == STBI_rgb);
               stbi__tga_read_rgb16(s, raw_data);
            } else {
               //   read in the data raw
               for (j = 0; j < tga_comp; ++j) {
                  raw_data[j] = stbi__get8(s);
               }
            }
            //   clear the reading flag for the next pixel
            read_next_pixel = 0;
         } // end of reading a pixel

         // copy data
         for (j = 0; j < tga_comp; ++j)
           tga_data[i*tga_comp+j] = raw_data[j];

         //   in case we're in RLE mode, keep counting down
         --RLE_count;
      }
      //   do I need to invert the image?
      if ( tga_inverted )
      {
         for (j = 0; j*2 < tga_height; ++j)
         {
            int index1 = j * tga_width * tga_comp;
            int index2 = (tga_height - 1 - j) * tga_width * tga_comp;
            for (i = tga_width * tga_comp; i > 0; --i)
            {
               unsigned char temp = tga_data[index1];
               tga_data[index1] = tga_data[index2];
               tga_data[index2] = temp;
               ++index1;
               ++index2;
            }
         }
      }
      //   clear my palette, if I had one
      if ( tga_palette != NULL )
      {
         STBI_FREE( tga_palette );
      }
   }

   // swap RGB - if the source data was RGB16, it already is in the right order
   if (tga_comp >= 3 && !tga_rgb16)
   {
      unsigned char* tga_pixel = tga_data;
      for (i=0; i < tga_width * tga_height; ++i)
      {
         unsigned char temp = tga_pixel[0];
         tga_pixel[0] = tga_pixel[2];
         tga_pixel[2] = temp;
         tga_pixel += tga_comp;
      }
   }

   // convert to target component count
   if (req_comp && req_comp != tga_comp)
      tga_data = stbi__convert_format(tga_data, tga_comp, req_comp, tga_width, tga_height);

   //   the things I do to get rid of an error message, and yet keep
   //   Microsoft's C compilers happy... [8^(
   tga_palette_start = tga_palette_len = tga_palette_bits =
         tga_x_origin = tga_y_origin = 0;
   STBI_NOTUSED(tga_palette_start);
   //   OK, done
   return tga_data;
}
#endif

// *************************************************************************************************
// Photoshop PSD loader -- PD by Thatcher Ulrich, integration by Nicolas Schulz, tweaked by STB

#ifndef STBI_NO_PSD
static int stbi__psd_test(stbi__context *s)
{
   int r = (stbi__get32be(s) == 0x38425053);
   stbi__rewind(s);
   return r;
}

static int stbi__psd_decode_rle(stbi__context *s, stbi_uc *p, int pixelCount)
{
   int count, nleft, len;

   count = 0;
   while ((nleft = pixelCount - count) > 0) {
      len = stbi__get8(s);
      if (len == 128) {
         // No-op.
      } else if (len < 128) {
         // Copy next len+1 bytes literally.
         len++;
         if (len > nleft) return 0; // corrupt data
         count += len;
         while (len) {
            *p = stbi__get8(s);
            p += 4;
            len--;
         }
      } else if (len > 128) {
         stbi_uc   val;
         // Next -len+1 bytes in the dest are replicated from next source byte.
         // (Interpret len as a negative 8-bit int.)
         len = 257 - len;
         if (len > nleft) return 0; // corrupt data
         val = stbi__get8(s);
         count += len;
         while (len) {
            *p = val;
            p += 4;
            len--;
         }
      }
   }

   return 1;
}

static void *stbi__psd_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri, int bpc)
{
   int pixelCount;
   int channelCount, compression;
   int channel, i;
   int bitdepth;
   int w,h;
   stbi_uc *out;
   STBI_NOTUSED(ri);

   // Check identifier
   if (stbi__get32be(s) != 0x38425053)   // "8BPS"
      return stbi__errpuc("not PSD", "Corrupt PSD image");

   // Check file type version.
   if (stbi__get16be(s) != 1)
      return stbi__errpuc("wrong version", "Unsupported version of PSD image");

   // Skip 6 reserved bytes.
   stbi__skip(s, 6 );

   // Read the number of channels (R, G, B, A, etc).
   channelCount = stbi__get16be(s);
   if (channelCount < 0 || channelCount > 16)
      return stbi__errpuc("wrong channel count", "Unsupported number of channels in PSD image");

   // Read the rows and columns of the image.
   h = stbi__get32be(s);
   w = stbi__get32be(s);

   // Make sure the depth is 8 bits.
   bitdepth = stbi__get16be(s);
   if (bitdepth != 8 && bitdepth != 16)
      return stbi__errpuc("unsupported bit depth", "PSD bit depth is not 8 or 16 bit");

   // Make sure the color mode is RGB.
   // Valid options are:
   //   0: Bitmap
   //   1: Grayscale
   //   2: Indexed color
   //   3: RGB color
   //   4: CMYK color
   //   7: Multichannel
   //   8: Duotone
   //   9: Lab color
   if (stbi__get16be(s) != 3)
      return stbi__errpuc("wrong color format", "PSD is not in RGB color format");

   // Skip the Mode Data.  (It's the palette for indexed color; other info for other modes.)
   stbi__skip(s,stbi__get32be(s) );

   // Skip the image resources.  (resolution, pen tool paths, etc)
   stbi__skip(s, stbi__get32be(s) );

   // Skip the reserved data.
   stbi__skip(s, stbi__get32be(s) );

   // Find out if the data is compressed.
   // Known values:
   //   0: no compression
   //   1: RLE compressed
   compression = stbi__get16be(s);
   if (compression > 1)
      return stbi__errpuc("bad compression", "PSD has an unknown compression format");

   // Check size
   if (!stbi__mad3sizes_valid(4, w, h, 0))
      return stbi__errpuc("too large", "Corrupt PSD");

   // Create the destination image.

   if (!compression && bitdepth == 16 && bpc == 16) {
      out = (stbi_uc *) stbi__malloc_mad3(8, w, h, 0);
      ri->bits_per_channel = 16;
   } else
      out = (stbi_uc *) stbi__malloc(4 * w*h);

   if (!out) return stbi__errpuc("outofmem", "Out of memory");
   pixelCount = w*h;

   // Initialize the data to zero.
   //memset( out, 0, pixelCount * 4 );

   // Finally, the image data.
   if (compression) {
      // RLE as used by .PSD and .TIFF
      // Loop until you get the number of unpacked bytes you are expecting:
      //     Read the next source byte into n.
      //     If n is between 0 and 127 inclusive, copy the next n+1 bytes literally.
      //     Else if n is between -127 and -1 inclusive, copy the next byte -n+1 times.
      //     Else if n is 128, noop.
      // Endloop

      // The RLE-compressed data is preceded by a 2-byte data count for each row in the data,
      // which we're going to just skip.
      stbi__skip(s, h * channelCount * 2 );

      // Read the RLE data by channel.
      for (channel = 0; channel < 4; channel++) {
         stbi_uc *p;

         p = out+channel;
         if (channel >= channelCount) {
            // Fill this channel with default data.
            for (i = 0; i < pixelCount; i++, p += 4)
               *p = (channel == 3 ? 255 : 0);
         } else {
            // Read the RLE data.
            if (!stbi__psd_decode_rle(s, p, pixelCount)) {
               STBI_FREE(out);
               return stbi__errpuc("corrupt", "bad RLE data");
            }
         }
      }

   } else {
      // We're at the raw image data.  It's each channel in order (Red, Green, Blue, Alpha, ...)
      // where each channel consists of an 8-bit (or 16-bit) value for each pixel in the image.

      // Read the data by channel.
      for (channel = 0; channel < 4; channel++) {
         if (channel >= channelCount) {
            // Fill this channel with default data.
            if (bitdepth == 16 && bpc == 16) {
               stbi__uint16 *q = ((stbi__uint16 *) out) + channel;
               stbi__uint16 val = channel == 3 ? 65535 : 0;
               for (i = 0; i < pixelCount; i++, q += 4)
                  *q = val;
            } else {
               stbi_uc *p = out+channel;
               stbi_uc val = channel == 3 ? 255 : 0;
               for (i = 0; i < pixelCount; i++, p += 4)
                  *p = val;
            }
         } else {
            if (ri->bits_per_channel == 16) {    // output bpc
               stbi__uint16 *q = ((stbi__uint16 *) out) + channel;
               for (i = 0; i < pixelCount; i++, q += 4)
                  *q = (stbi__uint16) stbi__get16be(s);
            } else {
               stbi_uc *p = out+channel;
               if (bitdepth == 16) {  // input bpc
                  for (i = 0; i < pixelCount; i++, p += 4)
                     *p = (stbi_uc) (stbi__get16be(s) >> 8);
               } else {
                  for (i = 0; i < pixelCount; i++, p += 4)
                     *p = stbi__get8(s);
               }
            }
         }
      }
   }

   // remove weird white matte from PSD
   if (channelCount >= 4) {
      if (ri->bits_per_channel == 16) {
         for (i=0; i < w*h; ++i) {
            stbi__uint16 *pixel = (stbi__uint16 *) out + 4*i;
            if (pixel[3] != 0 && pixel[3] != 65535) {
               float a = pixel[3] / 65535.0f;
               float ra = 1.0f / a;
               float inv_a = 65535.0f * (1 - ra);
               pixel[0] = (stbi__uint16) (pixel[0]*ra + inv_a);
               pixel[1] = (stbi__uint16) (pixel[1]*ra + inv_a);
               pixel[2] = (stbi__uint16) (pixel[2]*ra + inv_a);
            }
         }
      } else {
         for (i=0; i < w*h; ++i) {
            unsigned char *pixel = out + 4*i;
            if (pixel[3] != 0 && pixel[3] != 255) {
               float a = pixel[3] / 255.0f;
               float ra = 1.0f / a;
               float inv_a = 255.0f * (1 - ra);
               pixel[0] = (unsigned char) (pixel[0]*ra + inv_a);
               pixel[1] = (unsigned char) (pixel[1]*ra + inv_a);
               pixel[2] = (unsigned char) (pixel[2]*ra + inv_a);
            }
         }
      }
   }

   // convert to desired output format
   if (req_comp && req_comp != 4) {
      if (ri->bits_per_channel == 16)
         out = (stbi_uc *) stbi__convert_format16((stbi__uint16 *) out, 4, req_comp, w, h);
      else
         out = stbi__convert_format(out, 4, req_comp, w, h);
      if (out == NULL) return out; // stbi__convert_format frees input on failure
   }

   if (comp) *comp = 4;
   *y = h;
   *x = w;

   return out;
}
#endif

// *************************************************************************************************
// Softimage PIC loader
// by Tom Seddon
//
// See http://softimage.wiki.softimage.com/index.php/INFO:_PIC_file_format
// See http://ozviz.wasp.uwa.edu.au/~pbourke/dataformats/softimagepic/

#ifndef STBI_NO_PIC
static int stbi__pic_is4(stbi__context *s,const char *str)
{
   int i;
   for (i=0; i<4; ++i)
      if (stbi__get8(s) != (stbi_uc)str[i])
         return 0;

   return 1;
}

static int stbi__pic_test_core(stbi__context *s)
{
   int i;

   if (!stbi__pic_is4(s,"\x53\x80\xF6\x34"))
      return 0;

   for(i=0;i<84;++i)
      stbi__get8(s);

   if (!stbi__pic_is4(s,"PICT"))
      return 0;

   return 1;
}

typedef struct
{
   stbi_uc size,type,channel;
} stbi__pic_packet;

static stbi_uc *stbi__readval(stbi__context *s, int channel, stbi_uc *dest)
{
   int mask=0x80, i;

   for (i=0; i<4; ++i, mask>>=1) {
      if (channel & mask) {
         if (stbi__at_eof(s)) return stbi__errpuc("bad file","PIC file too short");
         dest[i]=stbi__get8(s);
      }
   }

   return dest;
}

static void stbi__copyval(int channel,stbi_uc *dest,const stbi_uc *src)
{
   int mask=0x80,i;

   for (i=0;i<4; ++i, mask>>=1)
      if (channel&mask)
         dest[i]=src[i];
}

static stbi_uc *stbi__pic_load_core(stbi__context *s,int width,int height,int *comp, stbi_uc *result)
{
   int act_comp=0,num_packets=0,y,chained;
   stbi__pic_packet packets[10];

   // this will (should...) cater for even some bizarre stuff like having data
    // for the same channel in multiple packets.
   do {
      stbi__pic_packet *packet;

      if (num_packets==sizeof(packets)/sizeof(packets[0]))
         return stbi__errpuc("bad format","too many packets");

      packet = &packets[num_packets++];

      chained = stbi__get8(s);
      packet->size    = stbi__get8(s);
      packet->type    = stbi__get8(s);
      packet->channel = stbi__get8(s);

      act_comp |= packet->channel;

      if (stbi__at_eof(s))          return stbi__errpuc("bad file","file too short (reading packets)");
      if (packet->size != 8)  return stbi__errpuc("bad format","packet isn't 8bpp");
   } while (chained);

   *comp = (act_comp & 0x10 ? 4 : 3); // has alpha channel?

   for(y=0; y<height; ++y) {
      int packet_idx;

      for(packet_idx=0; packet_idx < num_packets; ++packet_idx) {
         stbi__pic_packet *packet = &packets[packet_idx];
         stbi_uc *dest = result+y*width*4;

         switch (packet->type) {
            default:
               return stbi__errpuc("bad format","packet has bad compression type");

            case 0: {//uncompressed
               int x;

               for(x=0;x<width;++x, dest+=4)
                  if (!stbi__readval(s,packet->channel,dest))
                     return 0;
               break;
            }

            case 1://Pure RLE
               {
                  int left=width, i;

                  while (left>0) {
                     stbi_uc count,value[4];

                     count=stbi__get8(s);
                     if (stbi__at_eof(s))   return stbi__errpuc("bad file","file too short (pure read count)");

                     if (count > left)
                        count = (stbi_uc) left;

                     if (!stbi__readval(s,packet->channel,value))  return 0;

                     for(i=0; i<count; ++i,dest+=4)
                        stbi__copyval(packet->channel,dest,value);
                     left -= count;
                  }
               }
               break;

            case 2: {//Mixed RLE
               int left=width;
               while (left>0) {
                  int count = stbi__get8(s), i;
                  if (stbi__at_eof(s))  return stbi__errpuc("bad file","file too short (mixed read count)");

                  if (count >= 128) { // Repeated
                     stbi_uc value[4];

                     if (count==128)
                        count = stbi__get16be(s);
                     else
                        count -= 127;
                     if (count > left)
                        return stbi__errpuc("bad file","scanline overrun");

                     if (!stbi__readval(s,packet->channel,value))
                        return 0;

                     for(i=0;i<count;++i, dest += 4)
                        stbi__copyval(packet->channel,dest,value);
                  } else { // Raw
                     ++count;
                     if (count>left) return stbi__errpuc("bad file","scanline overrun");

                     for(i=0;i<count;++i, dest+=4)
                        if (!stbi__readval(s,packet->channel,dest))
                           return 0;
                  }
                  left-=count;
               }
               break;
            }
         }
      }
   }

   return result;
}

static void *stbi__pic_load(stbi__context *s,int *px,int *py,int *comp,int req_comp, stbi__result_info *ri)
{
   stbi_uc *result;
   int i, x,y, internal_comp;
   STBI_NOTUSED(ri);

   if (!comp) comp = &internal_comp;

   for (i=0; i<92; ++i)
      stbi__get8(s);

   x = stbi__get16be(s);
   y = stbi__get16be(s);
   if (stbi__at_eof(s))  return stbi__errpuc("bad file","file too short (pic header)");
   if (!stbi__mad3sizes_valid(x, y, 4, 0)) return stbi__errpuc("too large", "PIC image too large to decode");

   stbi__get32be(s); //skip `ratio'
   stbi__get16be(s); //skip `fields'
   stbi__get16be(s); //skip `pad'

   // intermediate buffer is RGBA
   result = (stbi_uc *) stbi__malloc_mad3(x, y, 4, 0);
   memset(result, 0xff, x*y*4);

   if (!stbi__pic_load_core(s,x,y,comp, result)) {
      STBI_FREE(result);
      result=0;
   }
   *px = x;
   *py = y;
   if (req_comp == 0) req_comp = *comp;
   result=stbi__convert_format(result,4,req_comp,x,y);

   return result;
}

static int stbi__pic_test(stbi__context *s)
{
   int r = stbi__pic_test_core(s);
   stbi__rewind(s);
   return r;
}
#endif

// *************************************************************************************************
// GIF loader -- public domain by Jean-Marc Lienher -- simplified/shrunk by stb

#ifndef STBI_NO_GIF
typedef struct
{
   stbi__int16 prefix;
   stbi_uc first;
   stbi_uc suffix;
} stbi__gif_lzw;

typedef struct
{
   int w,h;
   stbi_uc *out;                 // output buffer (always 4 components)
   stbi_uc *background;          // The current "background" as far as a gif is concerned
   stbi_uc *history;
   int flags, bgindex, ratio, transparent, eflags;
   stbi_uc  pal[256][4];
   stbi_uc lpal[256][4];
   stbi__gif_lzw codes[8192];
   stbi_uc *color_table;
   int parse, step;
   int lflags;
   int start_x, start_y;
   int max_x, max_y;
   int cur_x, cur_y;
   int line_size;
   int delay;
} stbi__gif;

static int stbi__gif_test_raw(stbi__context *s)
{
   int sz;
   if (stbi__get8(s) != 'G' || stbi__get8(s) != 'I' || stbi__get8(s) != 'F' || stbi__get8(s) != '8') return 0;
   sz = stbi__get8(s);
   if (sz != '9' && sz != '7') return 0;
   if (stbi__get8(s) != 'a') return 0;
   return 1;
}

static int stbi__gif_test(stbi__context *s)
{
   int r = stbi__gif_test_raw(s);
   stbi__rewind(s);
   return r;
}

static void stbi__gif_parse_colortable(stbi__context *s, stbi_uc pal[256][4], int num_entries, int transp)
{
   int i;
   for (i=0; i < num_entries; ++i) {
      pal[i][2] = stbi__get8(s);
      pal[i][1] = stbi__get8(s);
      pal[i][0] = stbi__get8(s);
      pal[i][3] = transp == i ? 0 : 255;
   }
}

static int stbi__gif_header(stbi__context *s, stbi__gif *g, int *comp, int is_info)
{
   stbi_uc version;
   if (stbi__get8(s) != 'G' || stbi__get8(s) != 'I' || stbi__get8(s) != 'F' || stbi__get8(s) != '8')
      return stbi__err("not GIF", "Corrupt GIF");

   version = stbi__get8(s);
   if (version != '7' && version != '9')    return stbi__err("not GIF", "Corrupt GIF");
   if (stbi__get8(s) != 'a')                return stbi__err("not GIF", "Corrupt GIF");

   stbi__g_failure_reason = "";
   g->w = stbi__get16le(s);
   g->h = stbi__get16le(s);
   g->flags = stbi__get8(s);
   g->bgindex = stbi__get8(s);
   g->ratio = stbi__get8(s);
   g->transparent = -1;

   if (comp != 0) *comp = 4;  // can't actually tell whether it's 3 or 4 until we parse the comments

   if (is_info) return 1;

   if (g->flags & 0x80)
      stbi__gif_parse_colortable(s,g->pal, 2 << (g->flags & 7), -1);

   return 1;
}

static int stbi__gif_info_raw(stbi__context *s, int *x, int *y, int *comp)
{
   stbi__gif* g = (stbi__gif*) stbi__malloc(sizeof(stbi__gif));
   if (!stbi__gif_header(s, g, comp, 1)) {
      STBI_FREE(g);
      stbi__rewind( s );
      return 0;
   }
   if (x) *x = g->w;
   if (y) *y = g->h;
   STBI_FREE(g);
   return 1;
}

static void stbi__out_gif_code(stbi__gif *g, stbi__uint16 code)
{
   stbi_uc *p, *c;
   int idx;

   // recurse to decode the prefixes, since the linked-list is backwards,
   // and working backwards through an interleaved image would be nasty
   if (g->codes[code].prefix >= 0)
      stbi__out_gif_code(g, g->codes[code].prefix);

   if (g->cur_y >= g->max_y) return;

   idx = g->cur_x + g->cur_y;
   p = &g->out[idx];
   g->history[idx / 4] = 1;

   c = &g->color_table[g->codes[code].suffix * 4];
   if (c[3] > 128) { // don't render transparent pixels;
      p[0] = c[2];
      p[1] = c[1];
      p[2] = c[0];
      p[3] = c[3];
   }
   g->cur_x += 4;

   if (g->cur_x >= g->max_x) {
      g->cur_x = g->start_x;
      g->cur_y += g->step;

      while (g->cur_y >= g->max_y && g->parse > 0) {
         g->step = (1 << g->parse) * g->line_size;
         g->cur_y = g->start_y + (g->step >> 1);
         --g->parse;
      }
   }
}

static stbi_uc *stbi__process_gif_raster(stbi__context *s, stbi__gif *g)
{
   stbi_uc lzw_cs;
   stbi__int32 len, init_code;
   stbi__uint32 first;
   stbi__int32 codesize, codemask, avail, oldcode, bits, valid_bits, clear;
   stbi__gif_lzw *p;

   lzw_cs = stbi__get8(s);
   if (lzw_cs > 12) return NULL;
   clear = 1 << lzw_cs;
   first = 1;
   codesize = lzw_cs + 1;
   codemask = (1 << codesize) - 1;
   bits = 0;
   valid_bits = 0;
   for (init_code = 0; init_code < clear; init_code++) {
      g->codes[init_code].prefix = -1;
      g->codes[init_code].first = (stbi_uc) init_code;
      g->codes[init_code].suffix = (stbi_uc) init_code;
   }

   // support no starting clear code
   avail = clear+2;
   oldcode = -1;

   len = 0;
   for(;;) {
      if (valid_bits < codesize) {
         if (len == 0) {
            len = stbi__get8(s); // start new block
            if (len == 0)
               return g->out;
         }
         --len;
         bits |= (stbi__int32) stbi__get8(s) << valid_bits;
         valid_bits += 8;
      } else {
         stbi__int32 code = bits & codemask;
         bits >>= codesize;
         valid_bits -= codesize;
         // @OPTIMIZE: is there some way we can accelerate the non-clear path?
         if (code == clear) {  // clear code
            codesize = lzw_cs + 1;
            codemask = (1 << codesize) - 1;
            avail = clear + 2;
            oldcode = -1;
            first = 0;
         } else if (code == clear + 1) { // end of stream code
            stbi__skip(s, len);
            while ((len = stbi__get8(s)) > 0)
               stbi__skip(s,len);
            return g->out;
         } else if (code <= avail) {
            if (first) {
               return stbi__errpuc("no clear code", "Corrupt GIF");
            }

            if (oldcode >= 0) {
               p = &g->codes[avail++];
               if (avail > 8192) {
                  return stbi__errpuc("too many codes", "Corrupt GIF");
               }

               p->prefix = (stbi__int16) oldcode;
               p->first = g->codes[oldcode].first;
               p->suffix = (code == avail) ? p->first : g->codes[code].first;
            } else if (code == avail)
               return stbi__errpuc("illegal code in raster", "Corrupt GIF");

            stbi__out_gif_code(g, (stbi__uint16) code);

            if ((avail & codemask) == 0 && avail <= 0x0FFF) {
               codesize++;
               codemask = (1 << codesize) - 1;
            }

            oldcode = code;
         } else {
            return stbi__errpuc("illegal code in raster", "Corrupt GIF");
         }
      }
   }
}

// this function is designed to support animated gifs, although stb_image doesn't support it
// two back is the image from two frames ago, used for a very specific disposal format
static stbi_uc *stbi__gif_load_next(stbi__context *s, stbi__gif *g, int *comp, int req_comp, stbi_uc *two_back)
{
   int dispose;
   int first_frame;
   int pi;
   int pcount;
   STBI_NOTUSED(req_comp);

   // on first frame, any non-written pixels get the background colour (non-transparent)
   first_frame = 0;
   if (g->out == 0) {
      if (!stbi__gif_header(s, g, comp,0)) return 0; // stbi__g_failure_reason set by stbi__gif_header
      if (!stbi__mad3sizes_valid(4, g->w, g->h, 0))
         return stbi__errpuc("too large", "GIF image is too large");
      pcount = g->w * g->h;
      g->out = (stbi_uc *) stbi__malloc(4 * pcount);
      g->background = (stbi_uc *) stbi__malloc(4 * pcount);
      g->history = (stbi_uc *) stbi__malloc(pcount);
      if (!g->out || !g->background || !g->history)
         return stbi__errpuc("outofmem", "Out of memory");

      // image is treated as "transparent" at the start - ie, nothing overwrites the current background;
      // background colour is only used for pixels that are not rendered first frame, after that "background"
      // color refers to the color that was there the previous frame.
      memset(g->out, 0x00, 4 * pcount);
      memset(g->background, 0x00, 4 * pcount); // state of the background (starts transparent)
      memset(g->history, 0x00, pcount);        // pixels that were affected previous frame
      first_frame = 1;
   } else {
      // second frame - how do we dispoase of the previous one?
      dispose = (g->eflags & 0x1C) >> 2;
      pcount = g->w * g->h;

      if ((dispose == 3) && (two_back == 0)) {
         dispose = 2; // if I don't have an image to revert back to, default to the old background
      }

      if (dispose == 3) { // use previous graphic
         for (pi = 0; pi < pcount; ++pi) {
            if (g->history[pi]) {
               memcpy( &g->out[pi * 4], &two_back[pi * 4], 4 );
            }
         }
      } else if (dispose == 2) {
         // restore what was changed last frame to background before that frame;
         for (pi = 0; pi < pcount; ++pi) {
            if (g->history[pi]) {
               memcpy( &g->out[pi * 4], &g->background[pi * 4], 4 );
            }
         }
      } else {
         // This is a non-disposal case eithe way, so just
         // leave the pixels as is, and they will become the new background
         // 1: do not dispose
         // 0:  not specified.
      }

      // background is what out is after the undoing of the previou frame;
      memcpy( g->background, g->out, 4 * g->w * g->h );
   }

   // clear my history;
   memset( g->history, 0x00, g->w * g->h );        // pixels that were affected previous frame

   for (;;) {
      int tag = stbi__get8(s);
      switch (tag) {
         case 0x2C: /* Image Descriptor */
         {
            stbi__int32 x, y, w, h;
            stbi_uc *o;

            x = stbi__get16le(s);
            y = stbi__get16le(s);
            w = stbi__get16le(s);
            h = stbi__get16le(s);
            if (((x + w) > (g->w)) || ((y + h) > (g->h)))
               return stbi__errpuc("bad Image Descriptor", "Corrupt GIF");

            g->line_size = g->w * 4;
            g->start_x = x * 4;
            g->start_y = y * g->line_size;
            g->max_x   = g->start_x + w * 4;
            g->max_y   = g->start_y + h * g->line_size;
            g->cur_x   = g->start_x;
            g->cur_y   = g->start_y;

            // if the width of the specified rectangle is 0, that means
            // we may not see *any* pixels or the image is malformed;
            // to make sure this is caught, move the current y down to
            // max_y (which is what out_gif_code checks).
            if (w == 0)
               g->cur_y = g->max_y;

            g->lflags = stbi__get8(s);

            if (g->lflags & 0x40) {
               g->step = 8 * g->line_size; // first interlaced spacing
               g->parse = 3;
            } else {
               g->step = g->line_size;
               g->parse = 0;
            }

            if (g->lflags & 0x80) {
               stbi__gif_parse_colortable(s,g->lpal, 2 << (g->lflags & 7), g->eflags & 0x01 ? g->transparent : -1);
               g->color_table = (stbi_uc *) g->lpal;
            } else if (g->flags & 0x80) {
               g->color_table = (stbi_uc *) g->pal;
            } else
               return stbi__errpuc("missing color table", "Corrupt GIF");

            o = stbi__process_gif_raster(s, g);
            if (!o) return NULL;

            // if this was the first frame,
            pcount = g->w * g->h;
            if (first_frame && (g->bgindex > 0)) {
               // if first frame, any pixel not drawn to gets the background color
               for (pi = 0; pi < pcount; ++pi) {
                  if (g->history[pi] == 0) {
                     g->pal[g->bgindex][3] = 255; // just in case it was made transparent, undo that; It will be reset next frame if need be;
                     memcpy( &g->out[pi * 4], &g->pal[g->bgindex], 4 );
                  }
               }
            }

            return o;
         }

         case 0x21: // Comment Extension.
         {
            int len;
            int ext = stbi__get8(s);
            if (ext == 0xF9) { // Graphic Control Extension.
               len = stbi__get8(s);
               if (len == 4) {
                  g->eflags = stbi__get8(s);
                  g->delay = 10 * stbi__get16le(s); // delay - 1/100th of a second, saving as 1/1000ths.

                  // unset old transparent
                  if (g->transparent >= 0) {
                     g->pal[g->transparent][3] = 255;
                  }
                  if (g->eflags & 0x01) {
                     g->transparent = stbi__get8(s);
                     if (g->transparent >= 0) {
                        g->pal[g->transparent][3] = 0;
                     }
                  } else {
                     // don't need transparent
                     stbi__skip(s, 1);
                     g->transparent = -1;
                  }
               } else {
                  stbi__skip(s, len);
                  break;
               }
            }
            while ((len = stbi__get8(s)) != 0) {
               stbi__skip(s, len);
            }
            break;
         }

         case 0x3B: // gif stream termination code
            return (stbi_uc *) s; // using '1' causes warning on some compilers

         default:
            return stbi__errpuc("unknown code", "Corrupt GIF");
      }
   }
}

static void *stbi__load_gif_main(stbi__context *s, int **delays, int *x, int *y, int *z, int *comp, int req_comp)
{
   if (stbi__gif_test(s)) {
      int layers = 0;
      stbi_uc *u = 0;
      stbi_uc *out = 0;
      stbi_uc *two_back = 0;
      stbi__gif g;
      int stride;
      memset(&g, 0, sizeof(g));
      if (delays) {
         *delays = 0;
      }

      do {
         u = stbi__gif_load_next(s, &g, comp, req_comp, two_back);
         if (u == (stbi_uc *) s) u = 0;  // end of animated gif marker

         if (u) {
            *x = g.w;
            *y = g.h;
            ++layers;
            stride = g.w * g.h * 4;

            if (out) {
               void *tmp = (stbi_uc*) STBI_REALLOC( out, layers * stride );
               if (NULL == tmp) {
                  STBI_FREE(g.out);
                  STBI_FREE(g.history);
                  STBI_FREE(g.background);
                  return stbi__errpuc("outofmem", "Out of memory");
               }
               else
                  out = (stbi_uc*) tmp;
               if (delays) {
                  *delays = (int*) STBI_REALLOC( *delays, sizeof(int) * layers );
               }
            } else {
               out = (stbi_uc*)stbi__malloc( layers * stride );
               if (delays) {
                  *delays = (int*) stbi__malloc( layers * sizeof(int) );
               }
            }
            memcpy( out + ((layers - 1) * stride), u, stride );
            if (layers >= 2) {
               two_back = out - 2 * stride;
            }

            if (delays) {
               (*delays)[layers - 1U] = g.delay;
            }
         }
      } while (u != 0);

      // free temp buffer;
      STBI_FREE(g.out);
      STBI_FREE(g.history);
      STBI_FREE(g.background);

      // do the final conversion after loading everything;
      if (req_comp && req_comp != 4)
         out = stbi__convert_format(out, 4, req_comp, layers * g.w, g.h);

      *z = layers;
      return out;
   } else {
      return stbi__errpuc("not GIF", "Image was not as a gif type.");
   }
}

static void *stbi__gif_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
{
   stbi_uc *u = 0;
   stbi__gif g;
   memset(&g, 0, sizeof(g));
   STBI_NOTUSED(ri);

   u = stbi__gif_load_next(s, &g, comp, req_comp, 0);
   if (u == (stbi_uc *) s) u = 0;  // end of animated gif marker
   if (u) {
      *x = g.w;
      *y = g.h;

      // moved conversion to after successful load so that the same
      // can be done for multiple frames.
      if (req_comp && req_comp != 4)
         u = stbi__convert_format(u, 4, req_comp, g.w, g.h);
   } else if (g.out) {
      // if there was an error and we allocated an image buffer, free it!
      STBI_FREE(g.out);
   }

   // free buffers needed for multiple frame loading;
   STBI_FREE(g.history);
   STBI_FREE(g.background);

   return u;
}

static int stbi__gif_info(stbi__context *s, int *x, int *y, int *comp)
{
   return stbi__gif_info_raw(s,x,y,comp);
}
#endif

// *************************************************************************************************
// Radiance RGBE HDR loader
// originally by Nicolas Schulz
#ifndef STBI_NO_HDR
static int stbi__hdr_test_core(stbi__context *s, const char *signature)
{
   int i;
   for (i=0; signature[i]; ++i)
      if (stbi__get8(s) != signature[i])
          return 0;
   stbi__rewind(s);
   return 1;
}

static int stbi__hdr_test(stbi__context* s)
{
   int r = stbi__hdr_test_core(s, "#?RADIANCE\n");
   stbi__rewind(s);
   if(!r) {
       r = stbi__hdr_test_core(s, "#?RGBE\n");
       stbi__rewind(s);
   }
   return r;
}

#define STBI__HDR_BUFLEN  1024
static char *stbi__hdr_gettoken(stbi__context *z, char *buffer)
{
   int len=0;
   char c = '\0';

   c = (char) stbi__get8(z);

   while (!stbi__at_eof(z) && c != '\n') {
      buffer[len++] = c;
      if (len == STBI__HDR_BUFLEN-1) {
         // flush to end of line
         while (!stbi__at_eof(z) && stbi__get8(z) != '\n')
            ;
         break;
      }
      c = (char) stbi__get8(z);
   }

   buffer[len] = 0;
   return buffer;
}

static void stbi__hdr_convert(float *output, stbi_uc *input, int req_comp)
{
   if ( input[3] != 0 ) {
      float f1;
      // Exponent
      f1 = (float) ldexp(1.0f, input[3] - (int)(128 + 8));
      if (req_comp <= 2)
         output[0] = (input[0] + input[1] + input[2]) * f1 / 3;
      else {
         output[0] = input[0] * f1;
         output[1] = input[1] * f1;
         output[2] = input[2] * f1;
      }
      if (req_comp == 2) output[1] = 1;
      if (req_comp == 4) output[3] = 1;
   } else {
      switch (req_comp) {
         case 4: output[3] = 1; /* fallthrough */
         case 3: output[0] = output[1] = output[2] = 0;
                 break;
         case 2: output[1] = 1; /* fallthrough */
         case 1: output[0] = 0;
                 break;
      }
   }
}

static float *stbi__hdr_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
{
   char buffer[STBI__HDR_BUFLEN];
   char *token;
   int valid = 0;
   int width, height;
   stbi_uc *scanline;
   float *hdr_data;
   int len;
   unsigned char count, value;
   int i, j, k, c1,c2, z;
   const char *headerToken;
   STBI_NOTUSED(ri);

   // Check identifier
   headerToken = stbi__hdr_gettoken(s,buffer);
   if (strcmp(headerToken, "#?RADIANCE") != 0 && strcmp(headerToken, "#?RGBE") != 0)
      return stbi__errpf("not HDR", "Corrupt HDR image");

   // Parse header
   for(;;) {
      token = stbi__hdr_gettoken(s,buffer);
      if (token[0] == 0) break;
      if (strcmp(token, "FORMAT=32-bit_rle_rgbe") == 0) valid = 1;
   }

   if (!valid)    return stbi__errpf("unsupported format", "Unsupported HDR format");

   // Parse width and height
   // can't use sscanf() if we're not using stdio!
   token = stbi__hdr_gettoken(s,buffer);
   if (strncmp(token, "-Y ", 3))  return stbi__errpf("unsupported data layout", "Unsupported HDR format");
   token += 3;
   height = (int) strtol(token, &token, 10);
   while (*token == ' ') ++token;
   if (strncmp(token, "+X ", 3))  return stbi__errpf("unsupported data layout", "Unsupported HDR format");
   token += 3;
   width = (int) strtol(token, NULL, 10);

   *x = width;
   *y = height;

   if (comp) *comp = 3;
   if (req_comp == 0) req_comp = 3;

   if (!stbi__mad4sizes_valid(width, height, req_comp, sizeof(float), 0))
      return stbi__errpf("too large", "HDR image is too large");

   // Read data
   hdr_data = (float *) stbi__malloc_mad4(width, height, req_comp, sizeof(float), 0);
   if (!hdr_data)
      return stbi__errpf("outofmem", "Out of memory");

   // Load image data
   // image data is stored as some number of sca
   if ( width < 8 || width >= 32768) {
      // Read flat data
      for (j=0; j < height; ++j) {
         for (i=0; i < width; ++i) {
            stbi_uc rgbe[4];
           main_decode_loop:
            stbi__getn(s, rgbe, 4);
            stbi__hdr_convert(hdr_data + j * width * req_comp + i * req_comp, rgbe, req_comp);
         }
      }
   } else {
      // Read RLE-encoded data
      scanline = NULL;

      for (j = 0; j < height; ++j) {
         c1 = stbi__get8(s);
         c2 = stbi__get8(s);
         len = stbi__get8(s);
         if (c1 != 2 || c2 != 2 || (len & 0x80)) {
            // not run-length encoded, so we have to actually use THIS data as a decoded
            // pixel (note this can't be a valid pixel--one of RGB must be >= 128)
            stbi_uc rgbe[4];
            rgbe[0] = (stbi_uc) c1;
            rgbe[1] = (stbi_uc) c2;
            rgbe[2] = (stbi_uc) len;
            rgbe[3] = (stbi_uc) stbi__get8(s);
            stbi__hdr_convert(hdr_data, rgbe, req_comp);
            i = 1;
            j = 0;
            STBI_FREE(scanline);
            goto main_decode_loop; // yes, this makes no sense
         }
         len <<= 8;
         len |= stbi__get8(s);
         if (len != width) { STBI_FREE(hdr_data); STBI_FREE(scanline); return stbi__errpf("invalid decoded scanline length", "corrupt HDR"); }
         if (scanline == NULL) {
            scanline = (stbi_uc *) stbi__malloc_mad2(width, 4, 0);
            if (!scanline) {
               STBI_FREE(hdr_data);
               return stbi__errpf("outofmem", "Out of memory");
            }
         }

         for (k = 0; k < 4; ++k) {
            int nleft;
            i = 0;
            while ((nleft = width - i) > 0) {
               count = stbi__get8(s);
               if (count > 128) {
                  // Run
                  value = stbi__get8(s);
                  count -= 128;
                  if (count > nleft) { STBI_FREE(hdr_data); STBI_FREE(scanline); return stbi__errpf("corrupt", "bad RLE data in HDR"); }
                  for (z = 0; z < count; ++z)
                     scanline[i++ * 4 + k] = value;
               } else {
                  // Dump
                  if (count > nleft) { STBI_FREE(hdr_data); STBI_FREE(scanline); return stbi__errpf("corrupt", "bad RLE data in HDR"); }
                  for (z = 0; z < count; ++z)
                     scanline[i++ * 4 + k] = stbi__get8(s);
               }
            }
         }
         for (i=0; i < width; ++i)
            stbi__hdr_convert(hdr_data+(j*width + i)*req_comp, scanline + i*4, req_comp);
      }
      if (scanline)
         STBI_FREE(scanline);
   }

   return hdr_data;
}

static int stbi__hdr_info(stbi__context *s, int *x, int *y, int *comp)
{
   char buffer[STBI__HDR_BUFLEN];
   char *token;
   int valid = 0;
   int dummy;

   if (!x) x = &dummy;
   if (!y) y = &dummy;
   if (!comp) comp = &dummy;

   if (stbi__hdr_test(s) == 0) {
       stbi__rewind( s );
       return 0;
   }

   for(;;) {
      token = stbi__hdr_gettoken(s,buffer);
      if (token[0] == 0) break;
      if (strcmp(token, "FORMAT=32-bit_rle_rgbe") == 0) valid = 1;
   }

   if (!valid) {
       stbi__rewind( s );
       return 0;
   }
   token = stbi__hdr_gettoken(s,buffer);
   if (strncmp(token, "-Y ", 3)) {
       stbi__rewind( s );
       return 0;
   }
   token += 3;
   *y = (int) strtol(token, &token, 10);
   while (*token == ' ') ++token;
   if (strncmp(token, "+X ", 3)) {
       stbi__rewind( s );
       return 0;
   }
   token += 3;
   *x = (int) strtol(token, NULL, 10);
   *comp = 3;
   return 1;
}
#endif // STBI_NO_HDR

#ifndef STBI_NO_BMP
static int stbi__bmp_info(stbi__context *s, int *x, int *y, int *comp)
{
   void *p;
   stbi__bmp_data info;

   info.all_a = 255;
   p = stbi__bmp_parse_header(s, &info);
   stbi__rewind( s );
   if (p == NULL)
      return 0;
   if (x) *x = s->img_x;
   if (y) *y = s->img_y;
   if (comp) {
      if (info.bpp == 24 && info.ma == 0xff000000)
         *comp = 3;
      else
         *comp = info.ma ? 4 : 3;
   }
   return 1;
}
#endif

#ifndef STBI_NO_PSD
static int stbi__psd_info(stbi__context *s, int *x, int *y, int *comp)
{
   int channelCount, dummy, depth;
   if (!x) x = &dummy;
   if (!y) y = &dummy;
   if (!comp) comp = &dummy;
   if (stbi__get32be(s) != 0x38425053) {
       stbi__rewind( s );
       return 0;
   }
   if (stbi__get16be(s) != 1) {
       stbi__rewind( s );
       return 0;
   }
   stbi__skip(s, 6);
   channelCount = stbi__get16be(s);
   if (channelCount < 0 || channelCount > 16) {
       stbi__rewind( s );
       return 0;
   }
   *y = stbi__get32be(s);
   *x = stbi__get32be(s);
   depth = stbi__get16be(s);
   if (depth != 8 && depth != 16) {
       stbi__rewind( s );
       return 0;
   }
   if (stbi__get16be(s) != 3) {
       stbi__rewind( s );
       return 0;
   }
   *comp = 4;
   return 1;
}

static int stbi__psd_is16(stbi__context *s)
{
   int channelCount, depth;
   if (stbi__get32be(s) != 0x38425053) {
       stbi__rewind( s );
       return 0;
   }
   if (stbi__get16be(s) != 1) {
       stbi__rewind( s );
       return 0;
   }
   stbi__skip(s, 6);
   channelCount = stbi__get16be(s);
   if (channelCount < 0 || channelCount > 16) {
       stbi__rewind( s );
       return 0;
   }
   (void) stbi__get32be(s);
   (void) stbi__get32be(s);
   depth = stbi__get16be(s);
   if (depth != 16) {
       stbi__rewind( s );
       return 0;
   }
   return 1;
}
#endif

#ifndef STBI_NO_PIC
static int stbi__pic_info(stbi__context *s, int *x, int *y, int *comp)
{
   int act_comp=0,num_packets=0,chained,dummy;
   stbi__pic_packet packets[10];

   if (!x) x = &dummy;
   if (!y) y = &dummy;
   if (!comp) comp = &dummy;

   if (!stbi__pic_is4(s,"\x53\x80\xF6\x34")) {
      stbi__rewind(s);
      return 0;
   }

   stbi__skip(s, 88);

   *x = stbi__get16be(s);
   *y = stbi__get16be(s);
   if (stbi__at_eof(s)) {
      stbi__rewind( s);
      return 0;
   }
   if ( (*x) != 0 && (1 << 28) / (*x) < (*y)) {
      stbi__rewind( s );
      return 0;
   }

   stbi__skip(s, 8);

   do {
      stbi__pic_packet *packet;

      if (num_packets==sizeof(packets)/sizeof(packets[0]))
         return 0;

      packet = &packets[num_packets++];
      chained = stbi__get8(s);
      packet->size    = stbi__get8(s);
      packet->type    = stbi__get8(s);
      packet->channel = stbi__get8(s);
      act_comp |= packet->channel;

      if (stbi__at_eof(s)) {
          stbi__rewind( s );
          return 0;
      }
      if (packet->size != 8) {
          stbi__rewind( s );
          return 0;
      }
   } while (chained);

   *comp = (act_comp & 0x10 ? 4 : 3);

   return 1;
}
#endif

// *************************************************************************************************
// Portable Gray Map and Portable Pixel Map loader
// by Ken Miller
//
// PGM: http://netpbm.sourceforge.net/doc/pgm.html
// PPM: http://netpbm.sourceforge.net/doc/ppm.html
//
// Known limitations:
//    Does not support comments in the header section
//    Does not support ASCII image data (formats P2 and P3)
//    Does not support 16-bit-per-channel

#ifndef STBI_NO_PNM

static int      stbi__pnm_test(stbi__context *s)
{
   char p, t;
   p = (char) stbi__get8(s);
   t = (char) stbi__get8(s);
   if (p != 'P' || (t != '5' && t != '6')) {
       stbi__rewind( s );
       return 0;
   }
   return 1;
}

static void *stbi__pnm_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
{
   stbi_uc *out;
   STBI_NOTUSED(ri);

   if (!stbi__pnm_info(s, (int *)&s->img_x, (int *)&s->img_y, (int *)&s->img_n))
      return 0;

   *x = s->img_x;
   *y = s->img_y;
   if (comp) *comp = s->img_n;

   if (!stbi__mad3sizes_valid(s->img_n, s->img_x, s->img_y, 0))
      return stbi__errpuc("too large", "PNM too large");

   out = (stbi_uc *) stbi__malloc_mad3(s->img_n, s->img_x, s->img_y, 0);
   if (!out) return stbi__errpuc("outofmem", "Out of memory");
   stbi__getn(s, out, s->img_n * s->img_x * s->img_y);

   if (req_comp && req_comp != s->img_n) {
      out = stbi__convert_format(out, s->img_n, req_comp, s->img_x, s->img_y);
      if (out == NULL) return out; // stbi__convert_format frees input on failure
   }
   return out;
}

static int      stbi__pnm_isspace(char c)
{
   return c == ' ' || c == '\t' || c == '\n' || c == '\v' || c == '\f' || c == '\r';
}

static void     stbi__pnm_skip_whitespace(stbi__context *s, char *c)
{
   for (;;) {
      while (!stbi__at_eof(s) && stbi__pnm_isspace(*c))
         *c = (char) stbi__get8(s);

      if (stbi__at_eof(s) || *c != '#')
         break;

      while (!stbi__at_eof(s) && *c != '\n' && *c != '\r' )
         *c = (char) stbi__get8(s);
   }
}

static int      stbi__pnm_isdigit(char c)
{
   return c >= '0' && c <= '9';
}

static int      stbi__pnm_getinteger(stbi__context *s, char *c)
{
   int value = 0;

   while (!stbi__at_eof(s) && stbi__pnm_isdigit(*c)) {
      value = value*10 + (*c - '0');
      *c = (char) stbi__get8(s);
   }

   return value;
}

static int      stbi__pnm_info(stbi__context *s, int *x, int *y, int *comp)
{
   int maxv, dummy;
   char c, p, t;

   if (!x) x = &dummy;
   if (!y) y = &dummy;
   if (!comp) comp = &dummy;

   stbi__rewind(s);

   // Get identifier
   p = (char) stbi__get8(s);
   t = (char) stbi__get8(s);
   if (p != 'P' || (t != '5' && t != '6')) {
       stbi__rewind(s);
       return 0;
   }

   *comp = (t == '6') ? 3 : 1;  // '5' is 1-component .pgm; '6' is 3-component .ppm

   c = (char) stbi__get8(s);
   stbi__pnm_skip_whitespace(s, &c);

   *x = stbi__pnm_getinteger(s, &c); // read width
   stbi__pnm_skip_whitespace(s, &c);

   *y = stbi__pnm_getinteger(s, &c); // read height
   stbi__pnm_skip_whitespace(s, &c);

   maxv = stbi__pnm_getinteger(s, &c);  // read max value

   if (maxv > 255)
      return stbi__err("max value > 255", "PPM image not 8-bit");
   else
      return 1;
}
#endif

static int stbi__info_main(stbi__context *s, int *x, int *y, int *comp)
{
   #ifndef STBI_NO_JPEG
   if (stbi__jpeg_info(s, x, y, comp)) return 1;
   #endif

   #ifndef STBI_NO_PNG
   if (stbi__png_info(s, x, y, comp))  return 1;
   #endif

   #ifndef STBI_NO_GIF
   if (stbi__gif_info(s, x, y, comp))  return 1;
   #endif

   #ifndef STBI_NO_BMP
   if (stbi__bmp_info(s, x, y, comp))  return 1;
   #endif

   #ifndef STBI_NO_PSD
   if (stbi__psd_info(s, x, y, comp))  return 1;
   #endif

   #ifndef STBI_NO_PIC
   if (stbi__pic_info(s, x, y, comp))  return 1;
   #endif

   #ifndef STBI_NO_PNM
   if (stbi__pnm_info(s, x, y, comp))  return 1;
   #endif

   #ifndef STBI_NO_HDR
   if (stbi__hdr_info(s, x, y, comp))  return 1;
   #endif

   // test tga last because it's a crappy test!
   #ifndef STBI_NO_TGA
   if (stbi__tga_info(s, x, y, comp))
       return 1;
   #endif
   return stbi__err("unknown image type", "Image not of any known type, or corrupt");
}

static int stbi__is_16_main(stbi__context *s)
{
   #ifndef STBI_NO_PNG
   if (stbi__png_is16(s))  return 1;
   #endif

   #ifndef STBI_NO_PSD
   if (stbi__psd_is16(s))  return 1;
   #endif

   return 0;
}

#ifndef STBI_NO_STDIO
STBIDEF int stbi_info(char const *filename, int *x, int *y, int *comp)
{
    FILE *f = stbi__fopen(filename, "rb");
    int result;
    if (!f) return stbi__err("can't fopen", "Unable to open file");
    result = stbi_info_from_file(f, x, y, comp);
    fclose(f);
    return result;
}

STBIDEF int stbi_info_from_file(FILE *f, int *x, int *y, int *comp)
{
   int r;
   stbi__context s;
   long pos = ftell(f);
   stbi__start_file(&s, f);
   r = stbi__info_main(&s,x,y,comp);
   fseek(f,pos,SEEK_SET);
   return r;
}

STBIDEF int stbi_is_16_bit(char const *filename)
{
    FILE *f = stbi__fopen(filename, "rb");
    int result;
    if (!f) return stbi__err("can't fopen", "Unable to open file");
    result = stbi_is_16_bit_from_file(f);
    fclose(f);
    return result;
}

STBIDEF int stbi_is_16_bit_from_file(FILE *f)
{
   int r;
   stbi__context s;
   long pos = ftell(f);
   stbi__start_file(&s, f);
   r = stbi__is_16_main(&s);
   fseek(f,pos,SEEK_SET);
   return r;
}
#endif // !STBI_NO_STDIO

STBIDEF int stbi_info_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp)
{
   stbi__context s;
   stbi__start_mem(&s,buffer,len);
   return stbi__info_main(&s,x,y,comp);
}

STBIDEF int stbi_info_from_callbacks(stbi_io_callbacks const *c, void *user, int *x, int *y, int *comp)
{
   stbi__context s;
   stbi__start_callbacks(&s, (stbi_io_callbacks *) c, user);
   return stbi__info_main(&s,x,y,comp);
}

STBIDEF int stbi_is_16_bit_from_memory(stbi_uc const *buffer, int len)
{
   stbi__context s;
   stbi__start_mem(&s,buffer,len);
   return stbi__is_16_main(&s);
}

STBIDEF int stbi_is_16_bit_from_callbacks(stbi_io_callbacks const *c, void *user)
{
   stbi__context s;
   stbi__start_callbacks(&s, (stbi_io_callbacks *) c, user);
   return stbi__is_16_main(&s);
}

#endif // STB_IMAGE_IMPLEMENTATION

/*
   revision history:
      2.20  (2019-02-07) support utf8 filenames in Windows; fix warnings and platform ifdefs
      2.19  (2018-02-11) fix warning
      2.18  (2018-01-30) fix warnings
      2.17  (2018-01-29) change sbti__shiftsigned to avoid clang -O2 bug
                         1-bit BMP
                         *_is_16_bit api
                         avoid warnings
      2.16  (2017-07-23) all functions have 16-bit variants;
                         STBI_NO_STDIO works again;
                         compilation fixes;
                         fix rounding in unpremultiply;
                         optimize vertical flip;
                         disable raw_len validation;
                         documentation fixes
      2.15  (2017-03-18) fix png-1,2,4 bug; now all Imagenet JPGs decode;
                         warning fixes; disable run-time SSE detection on gcc;
                         uniform handling of optional "return" values;
                         thread-safe initialization of zlib tables
      2.14  (2017-03-03) remove deprecated STBI_JPEG_OLD; fixes for Imagenet JPGs
      2.13  (2016-11-29) add 16-bit API, only supported for PNG right now
      2.12  (2016-04-02) fix typo in 2.11 PSD fix that caused crashes
      2.11  (2016-04-02) allocate large structures on the stack
                         remove white matting for transparent PSD
                         fix reported channel count for PNG & BMP
                         re-enable SSE2 in non-gcc 64-bit
                         support RGB-formatted JPEG
                         read 16-bit PNGs (only as 8-bit)
      2.10  (2016-01-22) avoid warning introduced in 2.09 by STBI_REALLOC_SIZED
      2.09  (2016-01-16) allow comments in PNM files
                         16-bit-per-pixel TGA (not bit-per-component)
                         info() for TGA could break due to .hdr handling
                         info() for BMP to shares code instead of sloppy parse
                         can use STBI_REALLOC_SIZED if allocator doesn't support realloc
                         code cleanup
      2.08  (2015-09-13) fix to 2.07 cleanup, reading RGB PSD as RGBA
      2.07  (2015-09-13) fix compiler warnings
                         partial animated GIF support
                         limited 16-bpc PSD support
                         #ifdef unused functions
                         bug with < 92 byte PIC,PNM,HDR,TGA
      2.06  (2015-04-19) fix bug where PSD returns wrong '*comp' value
      2.05  (2015-04-19) fix bug in progressive JPEG handling, fix warning
      2.04  (2015-04-15) try to re-enable SIMD on MinGW 64-bit
      2.03  (2015-04-12) extra corruption checking (mmozeiko)
                         stbi_set_flip_vertically_on_load (nguillemot)
                         fix NEON support; fix mingw support
      2.02  (2015-01-19) fix incorrect assert, fix warning
      2.01  (2015-01-17) fix various warnings; suppress SIMD on gcc 32-bit without -msse2
      2.00b (2014-12-25) fix STBI_MALLOC in progressive JPEG
      2.00  (2014-12-25) optimize JPG, including x86 SSE2 & NEON SIMD (ryg)
                         progressive JPEG (stb)
                         PGM/PPM support (Ken Miller)
                         STBI_MALLOC,STBI_REALLOC,STBI_FREE
                         GIF bugfix -- seemingly never worked
                         STBI_NO_*, STBI_ONLY_*
      1.48  (2014-12-14) fix incorrectly-named assert()
      1.47  (2014-12-14) 1/2/4-bit PNG support, both direct and paletted (Omar Cornut & stb)
                         optimize PNG (ryg)
                         fix bug in interlaced PNG with user-specified channel count (stb)
      1.46  (2014-08-26)
              fix broken tRNS chunk (colorkey-style transparency) in non-paletted PNG
      1.45  (2014-08-16)
              fix MSVC-ARM internal compiler error by wrapping malloc
      1.44  (2014-08-07)
              various warning fixes from Ronny Chevalier
      1.43  (2014-07-15)
              fix MSVC-only compiler problem in code changed in 1.42
      1.42  (2014-07-09)
              don't define _CRT_SECURE_NO_WARNINGS (affects user code)
              fixes to stbi__cleanup_jpeg path
              added STBI_ASSERT to avoid requiring assert.h
      1.41  (2014-06-25)
              fix search&replace from 1.36 that messed up comments/error messages
      1.40  (2014-06-22)
              fix gcc struct-initialization warning
      1.39  (2014-06-15)
              fix to TGA optimization when req_comp != number of components in TGA;
              fix to GIF loading because BMP wasn't rewinding (whoops, no GIFs in my test suite)
              add support for BMP version 5 (more ignored fields)
      1.38  (2014-06-06)
              suppress MSVC warnings on integer casts truncating values
              fix accidental rename of 'skip' field of I/O
      1.37  (2014-06-04)
              remove duplicate typedef
      1.36  (2014-06-03)
              convert to header file single-file library
              if de-iphone isn't set, load iphone images color-swapped instead of returning NULL
      1.35  (2014-05-27)
              various warnings
              fix broken STBI_SIMD path
              fix bug where stbi_load_from_file no longer left file pointer in correct place
              fix broken non-easy path for 32-bit BMP (possibly never used)
              TGA optimization by Arseny Kapoulkine
      1.34  (unknown)
              use STBI_NOTUSED in stbi__resample_row_generic(), fix one more leak in tga failure case
      1.33  (2011-07-14)
              make stbi_is_hdr work in STBI_NO_HDR (as specified), minor compiler-friendly improvements
      1.32  (2011-07-13)
              support for "info" function for all supported filetypes (SpartanJ)
      1.31  (2011-06-20)
              a few more leak fixes, bug in PNG handling (SpartanJ)
      1.30  (2011-06-11)
              added ability to load files via callbacks to accomidate custom input streams (Ben Wenger)
              removed deprecated format-specific test/load functions
              removed support for installable file formats (stbi_loader) -- would have been broken for IO callbacks anyway
              error cases in bmp and tga give messages and don't leak (Raymond Barbiero, grisha)
              fix inefficiency in decoding 32-bit BMP (David Woo)
      1.29  (2010-08-16)
              various warning fixes from Aurelien Pocheville
      1.28  (2010-08-01)
              fix bug in GIF palette transparency (SpartanJ)
      1.27  (2010-08-01)
              cast-to-stbi_uc to fix warnings
      1.26  (2010-07-24)
              fix bug in file buffering for PNG reported by SpartanJ
      1.25  (2010-07-17)
              refix trans_data warning (Won Chun)
      1.24  (2010-07-12)
              perf improvements reading from files on platforms with lock-heavy fgetc()
              minor perf improvements for jpeg
              deprecated type-specific functions so we'll get feedback if they're needed
              attempt to fix trans_data warning (Won Chun)
      1.23    fixed bug in iPhone support
      1.22  (2010-07-10)
              removed image *writing* support
              stbi_info support from Jetro Lauha
              GIF support from Jean-Marc Lienher
              iPhone PNG-extensions from James Brown
              warning-fixes from Nicolas Schulz and Janez Zemva (i.stbi__err. Janez (U+017D)emva)
      1.21    fix use of 'stbi_uc' in header (reported by jon blow)
      1.20    added support for Softimage PIC, by Tom Seddon
      1.19    bug in interlaced PNG corruption check (found by ryg)
      1.18  (2008-08-02)
              fix a threading bug (local mutable static)
      1.17    support interlaced PNG
      1.16    major bugfix - stbi__convert_format converted one too many pixels
      1.15    initialize some fields for thread safety
      1.14    fix threadsafe conversion bug
              header-file-only version (#define STBI_HEADER_FILE_ONLY before including)
      1.13    threadsafe
      1.12    const qualifiers in the API
      1.11    Support installable IDCT, colorspace conversion routines
      1.10    Fixes for 64-bit (don't use "unsigned long")
              optimized upsampling by Fabian "ryg" Giesen
      1.09    Fix format-conversion for PSD code (bad global variables!)
      1.08    Thatcher Ulrich's PSD code integrated by Nicolas Schulz
      1.07    attempt to fix C++ warning/errors again
      1.06    attempt to fix C++ warning/errors again
      1.05    fix TGA loading to return correct *comp and use good luminance calc
      1.04    default float alpha is 1, not 255; use 'void *' for stbi_image_free
      1.03    bugfixes to STBI_NO_STDIO, STBI_NO_HDR
      1.02    support for (subset of) HDR files, float interface for preferred access to them
      1.01    fix bug: possible bug in handling right-side up bmps... not sure
              fix bug: the stbi__bmp_load() and stbi__tga_load() functions didn't work at all
      1.00    interface to zlib that skips zlib header
      0.99    correct handling of alpha in palette
      0.98    TGA loader by lonesock; dynamically add loaders (untested)
      0.97    jpeg errors on too large a file; also catch another malloc failure
      0.96    fix detection of invalid v value - particleman@mollyrocket forum
      0.95    during header scan, seek to markers in case of padding
      0.94    STBI_NO_STDIO to disable stdio usage; rename all #defines the same
      0.93    handle jpegtran output; verbose errors
      0.92    read 4,8,16,24,32-bit BMP files of several formats
      0.91    output 24-bit Windows 3.0 BMP files
      0.90    fix a few more warnings; bump version number to approach 1.0
      0.61    bugfixes due to Marc LeBlanc, Christopher Lloyd
      0.60    fix compiling as c++
      0.59    fix warnings: merge Dave Moore's -Wall fixes
      0.58    fix bug: zlib uncompressed mode len/nlen was wrong endian
      0.57    fix bug: jpg last huffman symbol before marker was >9 bits but less than 16 available
      0.56    fix bug: zlib uncompressed mode len vs. nlen
      0.55    fix bug: restart_interval not initialized to 0
      0.54    allow NULL for 'int *comp'
      0.53    fix bug in png 3->4; speedup png decoding
      0.52    png handles req_comp=3,4 directly; minor cleanup; jpeg comments
      0.51    obey req_comp requests, 1-component jpegs return as 1-component,
              on 'test' only check type, not whether we support this variant
      0.50  (2006-11-19)
              first released version
*/


/*
------------------------------------------------------------------------------
This software is available under 2 licenses -- choose whichever you prefer.
------------------------------------------------------------------------------
ALTERNATIVE A - MIT License
Copyright (c) 2017 Sean Barrett
Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
------------------------------------------------------------------------------
ALTERNATIVE B - Public Domain (www.unlicense.org)
This is free and unencumbered software released into the public domain.
Anyone is free to copy, modify, publish, use, compile, sell, or distribute this
software, either in source code form or as a compiled binary, for any purpose,
commercial or non-commercial, and by any means.
In jurisdictions that recognize copyright laws, the author or authors of this
software dedicate any and all copyright interest in the software to the public
domain. We make this dedication for the benefit of the public at large and to
the detriment of our heirs and successors. We intend this dedication to be an
overt act of relinquishment in perpetuity of all present and future rights to
this software under copyright law.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
------------------------------------------------------------------------------
*/

/* stb_image_write - v1.14 - public domain - http://nothings.org/stb
   writes out PNG/BMP/TGA/JPEG/HDR images to C stdio - Sean Barrett 2010-2015
                                     no warranty implied; use at your own risk

   Before #including,

       #define STB_IMAGE_WRITE_IMPLEMENTATION

   in the file that you want to have the implementation.

   Will probably not work correctly with strict-aliasing optimizations.

ABOUT:

   This header file is a library for writing images to C stdio or a callback.

   The PNG output is not optimal; it is 20-50% larger than the file
   written by a decent optimizing implementation; though providing a custom
   zlib compress function (see STBIW_ZLIB_COMPRESS) can mitigate that.
   This library is designed for source code compactness and simplicity,
   not optimal image file size or run-time performance.

BUILDING:

   You can #define STBIW_ASSERT(x) before the #include to avoid using assert.h.
   You can #define STBIW_MALLOC(), STBIW_REALLOC(), and STBIW_FREE() to replace
   malloc,realloc,free.
   You can #define STBIW_MEMMOVE() to replace memmove()
   You can #define STBIW_ZLIB_COMPRESS to use a custom zlib-style compress function
   for PNG compression (instead of the builtin one), it must have the following signature:
   unsigned char * my_compress(unsigned char *data, int data_len, int *out_len, int quality);
   The returned data will be freed with STBIW_FREE() (free() by default),
   so it must be heap allocated with STBIW_MALLOC() (malloc() by default),

UNICODE:

   If compiling for Windows and you wish to use Unicode filenames, compile
   with
       #define STBIW_WINDOWS_UTF8
   and pass utf8-encoded filenames. Call stbiw_convert_wchar_to_utf8 to convert
   Windows wchar_t filenames to utf8.

USAGE:

   There are five functions, one for each image file format:

     int stbi_write_png(char const *filename, int w, int h, int comp, const void *data, int stride_in_bytes);
     int stbi_write_bmp(char const *filename, int w, int h, int comp, const void *data);
     int stbi_write_tga(char const *filename, int w, int h, int comp, const void *data);
     int stbi_write_jpg(char const *filename, int w, int h, int comp, const void *data, int quality);
     int stbi_write_hdr(char const *filename, int w, int h, int comp, const float *data);

     void stbi_flip_vertically_on_write(int flag); // flag is non-zero to flip data vertically

   There are also five equivalent functions that use an arbitrary write function. You are
   expected to open/close your file-equivalent before and after calling these:

     int stbi_write_png_to_func(stbi_write_func *func, void *context, int w, int h, int comp, const void  *data, int stride_in_bytes);
     int stbi_write_bmp_to_func(stbi_write_func *func, void *context, int w, int h, int comp, const void  *data);
     int stbi_write_tga_to_func(stbi_write_func *func, void *context, int w, int h, int comp, const void  *data);
     int stbi_write_hdr_to_func(stbi_write_func *func, void *context, int w, int h, int comp, const float *data);
     int stbi_write_jpg_to_func(stbi_write_func *func, void *context, int x, int y, int comp, const void *data, int quality);

   where the callback is:
      void stbi_write_func(void *context, void *data, int size);

   You can configure it with these global variables:
      int stbi_write_tga_with_rle;             // defaults to true; set to 0 to disable RLE
      int stbi_write_png_compression_level;    // defaults to 8; set to higher for more compression
      int stbi_write_force_png_filter;         // defaults to -1; set to 0..5 to force a filter mode


   You can define STBI_WRITE_NO_STDIO to disable the file variant of these
   functions, so the library will not use stdio.h at all. However, this will
   also disable HDR writing, because it requires stdio for formatted output.

   Each function returns 0 on failure and non-0 on success.

   The functions create an image file defined by the parameters. The image
   is a rectangle of pixels stored from left-to-right, top-to-bottom.
   Each pixel contains 'comp' channels of data stored interleaved with 8-bits
   per channel, in the following order: 1=Y, 2=YA, 3=RGB, 4=RGBA. (Y is
   monochrome color.) The rectangle is 'w' pixels wide and 'h' pixels tall.
   The *data pointer points to the first byte of the top-left-most pixel.
   For PNG, "stride_in_bytes" is the distance in bytes from the first byte of
   a row of pixels to the first byte of the next row of pixels.

   PNG creates output files with the same number of components as the input.
   The BMP format expands Y to RGB in the file format and does not
   output alpha.

   PNG supports writing rectangles of data even when the bytes storing rows of
   data are not consecutive in memory (e.g. sub-rectangles of a larger image),
   by supplying the stride between the beginning of adjacent rows. The other
   formats do not. (Thus you cannot write a native-format BMP through the BMP
   writer, both because it is in BGR order and because it may have padding
   at the end of the line.)

   PNG allows you to set the deflate compression level by setting the global
   variable 'stbi_write_png_compression_level' (it defaults to 8).

   HDR expects linear float data. Since the format is always 32-bit rgb(e)
   data, alpha (if provided) is discarded, and for monochrome data it is
   replicated across all three channels.

   TGA supports RLE or non-RLE compressed data. To use non-RLE-compressed
   data, set the global variable 'stbi_write_tga_with_rle' to 0.

   JPEG does ignore alpha channels in input data; quality is between 1 and 100.
   Higher quality looks better but results in a bigger image.
   JPEG baseline (no JPEG progressive).

CREDITS:


   Sean Barrett           -    PNG/BMP/TGA
   Baldur Karlsson        -    HDR
   Jean-Sebastien Guay    -    TGA monochrome
   Tim Kelsey             -    misc enhancements
   Alan Hickman           -    TGA RLE
   Emmanuel Julien        -    initial file IO callback implementation
   Jon Olick              -    original jo_jpeg.cpp code
   Daniel Gibson          -    integrate JPEG, allow external zlib
   Aarni Koskela          -    allow choosing PNG filter

   bugfixes:
      github:Chribba
      Guillaume Chereau
      github:jry2
      github:romigrou
      Sergio Gonzalez
      Jonas Karlsson
      Filip Wasil
      Thatcher Ulrich
      github:poppolopoppo
      Patrick Boettcher
      github:xeekworx
      Cap Petschulat
      Simon Rodriguez
      Ivan Tikhonov
      github:ignotion
      Adam Schackart

LICENSE

  See end of file for license information.

*/

#ifndef INCLUDE_STB_IMAGE_WRITE_H
#define INCLUDE_STB_IMAGE_WRITE_H

#include <stdlib.h>

// if STB_IMAGE_WRITE_STATIC causes problems, try defining STBIWDEF to 'inline' or 'static inline'
#ifndef STBIWDEF
#ifdef STB_IMAGE_WRITE_STATIC
#define STBIWDEF  static
#else
#ifdef __cplusplus
#define STBIWDEF  extern "C"
#else
#define STBIWDEF  extern
#endif
#endif
#endif

#ifndef STB_IMAGE_WRITE_STATIC  // C++ forbids static forward declarations
extern int stbi_write_tga_with_rle;
extern int stbi_write_png_compression_level;
extern int stbi_write_force_png_filter;
#endif

#ifndef STBI_WRITE_NO_STDIO
STBIWDEF int stbi_write_png(char const *filename, int w, int h, int comp, const void  *data, int stride_in_bytes);
STBIWDEF int stbi_write_bmp(char const *filename, int w, int h, int comp, const void  *data);
STBIWDEF int stbi_write_tga(char const *filename, int w, int h, int comp, const void  *data);
STBIWDEF int stbi_write_hdr(char const *filename, int w, int h, int comp, const float *data);
STBIWDEF int stbi_write_jpg(char const *filename, int x, int y, int comp, const void  *data, int quality);

#ifdef STBI_WINDOWS_UTF8
STBIWDEF int stbiw_convert_wchar_to_utf8(char *buffer, size_t bufferlen, const wchar_t* input);
#endif
#endif

typedef void stbi_write_func(void *context, void *data, int size);

STBIWDEF int stbi_write_png_to_func(stbi_write_func *func, void *context, int w, int h, int comp, const void  *data, int stride_in_bytes);
STBIWDEF int stbi_write_bmp_to_func(stbi_write_func *func, void *context, int w, int h, int comp, const void  *data);
STBIWDEF int stbi_write_tga_to_func(stbi_write_func *func, void *context, int w, int h, int comp, const void  *data);
STBIWDEF int stbi_write_hdr_to_func(stbi_write_func *func, void *context, int w, int h, int comp, const float *data);
STBIWDEF int stbi_write_jpg_to_func(stbi_write_func *func, void *context, int x, int y, int comp, const void  *data, int quality);

STBIWDEF void stbi_flip_vertically_on_write(int flip_boolean);

#endif//INCLUDE_STB_IMAGE_WRITE_H

#ifdef STB_IMAGE_WRITE_IMPLEMENTATION

#ifdef _WIN32
   #ifndef _CRT_SECURE_NO_WARNINGS
   #define _CRT_SECURE_NO_WARNINGS
   #endif
   #ifndef _CRT_NONSTDC_NO_DEPRECATE
   #define _CRT_NONSTDC_NO_DEPRECATE
   #endif
#endif

#ifndef STBI_WRITE_NO_STDIO
#include <stdio.h>
#endif // STBI_WRITE_NO_STDIO

#include <stdarg.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>

#if defined(STBIW_MALLOC) && defined(STBIW_FREE) && (defined(STBIW_REALLOC) || defined(STBIW_REALLOC_SIZED))
// ok
#elif !defined(STBIW_MALLOC) && !defined(STBIW_FREE) && !defined(STBIW_REALLOC) && !defined(STBIW_REALLOC_SIZED)
// ok
#else
#error "Must define all or none of STBIW_MALLOC, STBIW_FREE, and STBIW_REALLOC (or STBIW_REALLOC_SIZED)."
#endif

#ifndef STBIW_MALLOC
#define STBIW_MALLOC(sz)        malloc(sz)
#define STBIW_REALLOC(p,newsz)  realloc(p,newsz)
#define STBIW_FREE(p)           free(p)
#endif

#ifndef STBIW_REALLOC_SIZED
#define STBIW_REALLOC_SIZED(p,oldsz,newsz) STBIW_REALLOC(p,newsz)
#endif


#ifndef STBIW_MEMMOVE
#define STBIW_MEMMOVE(a,b,sz) memmove(a,b,sz)
#endif


#ifndef STBIW_ASSERT
#include <assert.h>
#define STBIW_ASSERT(x) assert(x)
#endif

#define STBIW_UCHAR(x) (unsigned char) ((x) & 0xff)

#ifdef STB_IMAGE_WRITE_STATIC
static int stbi_write_png_compression_level = 8;
static int stbi_write_tga_with_rle = 1;
static int stbi_write_force_png_filter = -1;
#else
int stbi_write_png_compression_level = 8;
int stbi_write_tga_with_rle = 1;
int stbi_write_force_png_filter = -1;
#endif

static int stbi__flip_vertically_on_write = 0;

STBIWDEF void stbi_flip_vertically_on_write(int flag)
{
   stbi__flip_vertically_on_write = flag;
}

typedef struct
{
   stbi_write_func *func;
   void *context;
} stbi__write_context;

// initialize a callback-based context
static void stbi__start_write_callbacks(stbi__write_context *s, stbi_write_func *c, void *context)
{
   s->func    = c;
   s->context = context;
}

#ifndef STBI_WRITE_NO_STDIO

static void stbi__stdio_write(void *context, void *data, int size)
{
   fwrite(data,1,size,(FILE*) context);
}

#if defined(_MSC_VER) && defined(STBI_WINDOWS_UTF8)
#ifdef __cplusplus
#define STBIW_EXTERN extern "C"
#else
#define STBIW_EXTERN extern
#endif
STBIW_EXTERN __declspec(dllimport) int __stdcall MultiByteToWideChar(unsigned int cp, unsigned long flags, const char *str, int cbmb, wchar_t *widestr, int cchwide);
STBIW_EXTERN __declspec(dllimport) int __stdcall WideCharToMultiByte(unsigned int cp, unsigned long flags, const wchar_t *widestr, int cchwide, char *str, int cbmb, const char *defchar, int *used_default);

STBIWDEF int stbiw_convert_wchar_to_utf8(char *buffer, size_t bufferlen, const wchar_t* input)
{
	return WideCharToMultiByte(65001 /* UTF8 */, 0, input, -1, buffer, (int) bufferlen, NULL, NULL);
}
#endif

static FILE *stbiw__fopen(char const *filename, char const *mode)
{
   FILE *f;
#if defined(_MSC_VER) && defined(STBI_WINDOWS_UTF8)
   wchar_t wMode[64];
   wchar_t wFilename[1024];
	if (0 == MultiByteToWideChar(65001 /* UTF8 */, 0, filename, -1, wFilename, sizeof(wFilename)))
      return 0;

	if (0 == MultiByteToWideChar(65001 /* UTF8 */, 0, mode, -1, wMode, sizeof(wMode)))
      return 0;

#if _MSC_VER >= 1400
	if (0 != _wfopen_s(&f, wFilename, wMode))
		f = 0;
#else
   f = _wfopen(wFilename, wMode);
#endif

#elif defined(_MSC_VER) && _MSC_VER >= 1400
   if (0 != fopen_s(&f, filename, mode))
      f=0;
#else
   f = fopen(filename, mode);
#endif
   return f;
}

static int stbi__start_write_file(stbi__write_context *s, const char *filename)
{
   FILE *f = stbiw__fopen(filename, "wb");
   stbi__start_write_callbacks(s, stbi__stdio_write, (void *) f);
   return f != NULL;
}

static void stbi__end_write_file(stbi__write_context *s)
{
   fclose((FILE *)s->context);
}

#endif // !STBI_WRITE_NO_STDIO

typedef unsigned int stbiw_uint32;
typedef int stb_image_write_test[sizeof(stbiw_uint32)==4 ? 1 : -1];

static void stbiw__writefv(stbi__write_context *s, const char *fmt, va_list v)
{
   while (*fmt) {
      switch (*fmt++) {
         case ' ': break;
         case '1': { unsigned char x = STBIW_UCHAR(va_arg(v, int));
                     s->func(s->context,&x,1);
                     break; }
         case '2': { int x = va_arg(v,int);
                     unsigned char b[2];
                     b[0] = STBIW_UCHAR(x);
                     b[1] = STBIW_UCHAR(x>>8);
                     s->func(s->context,b,2);
                     break; }
         case '4': { stbiw_uint32 x = va_arg(v,int);
                     unsigned char b[4];
                     b[0]=STBIW_UCHAR(x);
                     b[1]=STBIW_UCHAR(x>>8);
                     b[2]=STBIW_UCHAR(x>>16);
                     b[3]=STBIW_UCHAR(x>>24);
                     s->func(s->context,b,4);
                     break; }
         default:
            STBIW_ASSERT(0);
            return;
      }
   }
}

static void stbiw__writef(stbi__write_context *s, const char *fmt, ...)
{
   va_list v;
   va_start(v, fmt);
   stbiw__writefv(s, fmt, v);
   va_end(v);
}

static void stbiw__putc(stbi__write_context *s, unsigned char c)
{
   s->func(s->context, &c, 1);
}

static void stbiw__write3(stbi__write_context *s, unsigned char a, unsigned char b, unsigned char c)
{
   unsigned char arr[3];
   arr[0] = a; arr[1] = b; arr[2] = c;
   s->func(s->context, arr, 3);
}

static void stbiw__write_pixel(stbi__write_context *s, int rgb_dir, int comp, int write_alpha, int expand_mono, unsigned char *d)
{
   unsigned char bg[3] = { 255, 0, 255}, px[3];
   int k;

   if (write_alpha < 0)
      s->func(s->context, &d[comp - 1], 1);

   switch (comp) {
      case 2: // 2 pixels = mono + alpha, alpha is written separately, so same as 1-channel case
      case 1:
         if (expand_mono)
            stbiw__write3(s, d[0], d[0], d[0]); // monochrome bmp
         else
            s->func(s->context, d, 1);  // monochrome TGA
         break;
      case 4:
         if (!write_alpha) {
            // composite against pink background
            for (k = 0; k < 3; ++k)
               px[k] = bg[k] + ((d[k] - bg[k]) * d[3]) / 255;
            stbiw__write3(s, px[1 - rgb_dir], px[1], px[1 + rgb_dir]);
            break;
         }
         /* FALLTHROUGH */
      case 3:
         stbiw__write3(s, d[1 - rgb_dir], d[1], d[1 + rgb_dir]);
         break;
   }
   if (write_alpha > 0)
      s->func(s->context, &d[comp - 1], 1);
}

static void stbiw__write_pixels(stbi__write_context *s, int rgb_dir, int vdir, int x, int y, int comp, void *data, int write_alpha, int scanline_pad, int expand_mono)
{
   stbiw_uint32 zero = 0;
   int i,j, j_end;

   if (y <= 0)
      return;

   if (stbi__flip_vertically_on_write)
      vdir *= -1;

   if (vdir < 0) {
      j_end = -1; j = y-1;
   } else {
      j_end =  y; j = 0;
   }

   for (; j != j_end; j += vdir) {
      for (i=0; i < x; ++i) {
         unsigned char *d = (unsigned char *) data + (j*x+i)*comp;
         stbiw__write_pixel(s, rgb_dir, comp, write_alpha, expand_mono, d);
      }
      s->func(s->context, &zero, scanline_pad);
   }
}

static int stbiw__outfile(stbi__write_context *s, int rgb_dir, int vdir, int x, int y, int comp, int expand_mono, void *data, int alpha, int pad, const char *fmt, ...)
{
   if (y < 0 || x < 0) {
      return 0;
   } else {
      va_list v;
      va_start(v, fmt);
      stbiw__writefv(s, fmt, v);
      va_end(v);
      stbiw__write_pixels(s,rgb_dir,vdir,x,y,comp,data,alpha,pad, expand_mono);
      return 1;
   }
}

static int stbi_write_bmp_core(stbi__write_context *s, int x, int y, int comp, const void *data)
{
   int pad = (-x*3) & 3;
   return stbiw__outfile(s,-1,-1,x,y,comp,1,(void *) data,0,pad,
           "11 4 22 4" "4 44 22 444444",
           'B', 'M', 14+40+(x*3+pad)*y, 0,0, 14+40,  // file header
            40, x,y, 1,24, 0,0,0,0,0,0);             // bitmap header
}

STBIWDEF int stbi_write_bmp_to_func(stbi_write_func *func, void *context, int x, int y, int comp, const void *data)
{
   stbi__write_context s;
   stbi__start_write_callbacks(&s, func, context);
   return stbi_write_bmp_core(&s, x, y, comp, data);
}

#ifndef STBI_WRITE_NO_STDIO
STBIWDEF int stbi_write_bmp(char const *filename, int x, int y, int comp, const void *data)
{
   stbi__write_context s;
   if (stbi__start_write_file(&s,filename)) {
      int r = stbi_write_bmp_core(&s, x, y, comp, data);
      stbi__end_write_file(&s);
      return r;
   } else
      return 0;
}
#endif //!STBI_WRITE_NO_STDIO

static int stbi_write_tga_core(stbi__write_context *s, int x, int y, int comp, void *data)
{
   int has_alpha = (comp == 2 || comp == 4);
   int colorbytes = has_alpha ? comp-1 : comp;
   int format = colorbytes < 2 ? 3 : 2; // 3 color channels (RGB/RGBA) = 2, 1 color channel (Y/YA) = 3

   if (y < 0 || x < 0)
      return 0;

   if (!stbi_write_tga_with_rle) {
      return stbiw__outfile(s, -1, -1, x, y, comp, 0, (void *) data, has_alpha, 0,
         "111 221 2222 11", 0, 0, format, 0, 0, 0, 0, 0, x, y, (colorbytes + has_alpha) * 8, has_alpha * 8);
   } else {
      int i,j,k;
      int jend, jdir;

      stbiw__writef(s, "111 221 2222 11", 0,0,format+8, 0,0,0, 0,0,x,y, (colorbytes + has_alpha) * 8, has_alpha * 8);

      if (stbi__flip_vertically_on_write) {
         j = 0;
         jend = y;
         jdir = 1;
      } else {
         j = y-1;
         jend = -1;
         jdir = -1;
      }
      for (; j != jend; j += jdir) {
         unsigned char *row = (unsigned char *) data + j * x * comp;
         int len;

         for (i = 0; i < x; i += len) {
            unsigned char *begin = row + i * comp;
            int diff = 1;
            len = 1;

            if (i < x - 1) {
               ++len;
               diff = memcmp(begin, row + (i + 1) * comp, comp);
               if (diff) {
                  const unsigned char *prev = begin;
                  for (k = i + 2; k < x && len < 128; ++k) {
                     if (memcmp(prev, row + k * comp, comp)) {
                        prev += comp;
                        ++len;
                     } else {
                        --len;
                        break;
                     }
                  }
               } else {
                  for (k = i + 2; k < x && len < 128; ++k) {
                     if (!memcmp(begin, row + k * comp, comp)) {
                        ++len;
                     } else {
                        break;
                     }
                  }
               }
            }

            if (diff) {
               unsigned char header = STBIW_UCHAR(len - 1);
               s->func(s->context, &header, 1);
               for (k = 0; k < len; ++k) {
                  stbiw__write_pixel(s, -1, comp, has_alpha, 0, begin + k * comp);
               }
            } else {
               unsigned char header = STBIW_UCHAR(len - 129);
               s->func(s->context, &header, 1);
               stbiw__write_pixel(s, -1, comp, has_alpha, 0, begin);
            }
         }
      }
   }
   return 1;
}

STBIWDEF int stbi_write_tga_to_func(stbi_write_func *func, void *context, int x, int y, int comp, const void *data)
{
   stbi__write_context s;
   stbi__start_write_callbacks(&s, func, context);
   return stbi_write_tga_core(&s, x, y, comp, (void *) data);
}

#ifndef STBI_WRITE_NO_STDIO
STBIWDEF int stbi_write_tga(char const *filename, int x, int y, int comp, const void *data)
{
   stbi__write_context s;
   if (stbi__start_write_file(&s,filename)) {
      int r = stbi_write_tga_core(&s, x, y, comp, (void *) data);
      stbi__end_write_file(&s);
      return r;
   } else
      return 0;
}
#endif

// *************************************************************************************************
// Radiance RGBE HDR writer
// by Baldur Karlsson

#define stbiw__max(a, b)  ((a) > (b) ? (a) : (b))

static void stbiw__linear_to_rgbe(unsigned char *rgbe, float *linear)
{
   int exponent;
   float maxcomp = stbiw__max(linear[0], stbiw__max(linear[1], linear[2]));

   if (maxcomp < 1e-32f) {
      rgbe[0] = rgbe[1] = rgbe[2] = rgbe[3] = 0;
   } else {
      float normalize = (float) frexp(maxcomp, &exponent) * 256.0f/maxcomp;

      rgbe[0] = (unsigned char)(linear[0] * normalize);
      rgbe[1] = (unsigned char)(linear[1] * normalize);
      rgbe[2] = (unsigned char)(linear[2] * normalize);
      rgbe[3] = (unsigned char)(exponent + 128);
   }
}

static void stbiw__write_run_data(stbi__write_context *s, int length, unsigned char databyte)
{
   unsigned char lengthbyte = STBIW_UCHAR(length+128);
   STBIW_ASSERT(length+128 <= 255);
   s->func(s->context, &lengthbyte, 1);
   s->func(s->context, &databyte, 1);
}

static void stbiw__write_dump_data(stbi__write_context *s, int length, unsigned char *data)
{
   unsigned char lengthbyte = STBIW_UCHAR(length);
   STBIW_ASSERT(length <= 128); // inconsistent with spec but consistent with official code
   s->func(s->context, &lengthbyte, 1);
   s->func(s->context, data, length);
}

static void stbiw__write_hdr_scanline(stbi__write_context *s, int width, int ncomp, unsigned char *scratch, float *scanline)
{
   unsigned char scanlineheader[4] = { 2, 2, 0, 0 };
   unsigned char rgbe[4];
   float linear[3];
   int x;

   scanlineheader[2] = (width&0xff00)>>8;
   scanlineheader[3] = (width&0x00ff);

   /* skip RLE for images too small or large */
   if (width < 8 || width >= 32768) {
      for (x=0; x < width; x++) {
         switch (ncomp) {
            case 4: /* fallthrough */
            case 3: linear[2] = scanline[x*ncomp + 2];
                    linear[1] = scanline[x*ncomp + 1];
                    linear[0] = scanline[x*ncomp + 0];
                    break;
            default:
                    linear[0] = linear[1] = linear[2] = scanline[x*ncomp + 0];
                    break;
         }
         stbiw__linear_to_rgbe(rgbe, linear);
         s->func(s->context, rgbe, 4);
      }
   } else {
      int c,r;
      /* encode into scratch buffer */
      for (x=0; x < width; x++) {
         switch(ncomp) {
            case 4: /* fallthrough */
            case 3: linear[2] = scanline[x*ncomp + 2];
                    linear[1] = scanline[x*ncomp + 1];
                    linear[0] = scanline[x*ncomp + 0];
                    break;
            default:
                    linear[0] = linear[1] = linear[2] = scanline[x*ncomp + 0];
                    break;
         }
         stbiw__linear_to_rgbe(rgbe, linear);
         scratch[x + width*0] = rgbe[0];
         scratch[x + width*1] = rgbe[1];
         scratch[x + width*2] = rgbe[2];
         scratch[x + width*3] = rgbe[3];
      }

      s->func(s->context, scanlineheader, 4);

      /* RLE each component separately */
      for (c=0; c < 4; c++) {
         unsigned char *comp = &scratch[width*c];

         x = 0;
         while (x < width) {
            // find first run
            r = x;
            while (r+2 < width) {
               if (comp[r] == comp[r+1] && comp[r] == comp[r+2])
                  break;
               ++r;
            }
            if (r+2 >= width)
               r = width;
            // dump up to first run
            while (x < r) {
               int len = r-x;
               if (len > 128) len = 128;
               stbiw__write_dump_data(s, len, &comp[x]);
               x += len;
            }
            // if there's a run, output it
            if (r+2 < width) { // same test as what we break out of in search loop, so only true if we break'd
               // find next byte after run
               while (r < width && comp[r] == comp[x])
                  ++r;
               // output run up to r
               while (x < r) {
                  int len = r-x;
                  if (len > 127) len = 127;
                  stbiw__write_run_data(s, len, comp[x]);
                  x += len;
               }
            }
         }
      }
   }
}

static int stbi_write_hdr_core(stbi__write_context *s, int x, int y, int comp, float *data)
{
   if (y <= 0 || x <= 0 || data == NULL)
      return 0;
   else {
      // Each component is stored separately. Allocate scratch space for full output scanline.
      unsigned char *scratch = (unsigned char *) STBIW_MALLOC(x*4);
      int i, len;
      char buffer[128];
      char header[] = "#?RADIANCE\n# Written by stb_image_write.h\nFORMAT=32-bit_rle_rgbe\n";
      s->func(s->context, header, sizeof(header)-1);

#ifdef __STDC_WANT_SECURE_LIB__
      len = sprintf_s(buffer, sizeof(buffer), "EXPOSURE=          1.0000000000000\n\n-Y %d +X %d\n", y, x);
#else
      len = sprintf(buffer, "EXPOSURE=          1.0000000000000\n\n-Y %d +X %d\n", y, x);
#endif
      s->func(s->context, buffer, len);

      for(i=0; i < y; i++)
         stbiw__write_hdr_scanline(s, x, comp, scratch, data + comp*x*(stbi__flip_vertically_on_write ? y-1-i : i));
      STBIW_FREE(scratch);
      return 1;
   }
}

STBIWDEF int stbi_write_hdr_to_func(stbi_write_func *func, void *context, int x, int y, int comp, const float *data)
{
   stbi__write_context s;
   stbi__start_write_callbacks(&s, func, context);
   return stbi_write_hdr_core(&s, x, y, comp, (float *) data);
}

#ifndef STBI_WRITE_NO_STDIO
STBIWDEF int stbi_write_hdr(char const *filename, int x, int y, int comp, const float *data)
{
   stbi__write_context s;
   if (stbi__start_write_file(&s,filename)) {
      int r = stbi_write_hdr_core(&s, x, y, comp, (float *) data);
      stbi__end_write_file(&s);
      return r;
   } else
      return 0;
}
#endif // STBI_WRITE_NO_STDIO


//////////////////////////////////////////////////////////////////////////////
//
// PNG writer
//

#ifndef STBIW_ZLIB_COMPRESS
// stretchy buffer; stbiw__sbpush() == vector<>::push_back() -- stbiw__sbcount() == vector<>::size()
#define stbiw__sbraw(a) ((int *) (void *) (a) - 2)
#define stbiw__sbm(a)   stbiw__sbraw(a)[0]
#define stbiw__sbn(a)   stbiw__sbraw(a)[1]

#define stbiw__sbneedgrow(a,n)  ((a)==0 || stbiw__sbn(a)+n >= stbiw__sbm(a))
#define stbiw__sbmaybegrow(a,n) (stbiw__sbneedgrow(a,(n)) ? stbiw__sbgrow(a,n) : 0)
#define stbiw__sbgrow(a,n)  stbiw__sbgrowf((void **) &(a), (n), sizeof(*(a)))

#define stbiw__sbpush(a, v)      (stbiw__sbmaybegrow(a,1), (a)[stbiw__sbn(a)++] = (v))
#define stbiw__sbcount(a)        ((a) ? stbiw__sbn(a) : 0)
#define stbiw__sbfree(a)         ((a) ? STBIW_FREE(stbiw__sbraw(a)),0 : 0)

static void *stbiw__sbgrowf(void **arr, int increment, int itemsize)
{
   int m = *arr ? 2*stbiw__sbm(*arr)+increment : increment+1;
   void *p = STBIW_REALLOC_SIZED(*arr ? stbiw__sbraw(*arr) : 0, *arr ? (stbiw__sbm(*arr)*itemsize + sizeof(int)*2) : 0, itemsize * m + sizeof(int)*2);
   STBIW_ASSERT(p);
   if (p) {
      if (!*arr) ((int *) p)[1] = 0;
      *arr = (void *) ((int *) p + 2);
      stbiw__sbm(*arr) = m;
   }
   return *arr;
}

static unsigned char *stbiw__zlib_flushf(unsigned char *data, unsigned int *bitbuffer, int *bitcount)
{
   while (*bitcount >= 8) {
      stbiw__sbpush(data, STBIW_UCHAR(*bitbuffer));
      *bitbuffer >>= 8;
      *bitcount -= 8;
   }
   return data;
}

static int stbiw__zlib_bitrev(int code, int codebits)
{
   int res=0;
   while (codebits--) {
      res = (res << 1) | (code & 1);
      code >>= 1;
   }
   return res;
}

static unsigned int stbiw__zlib_countm(unsigned char *a, unsigned char *b, int limit)
{
   int i;
   for (i=0; i < limit && i < 258; ++i)
      if (a[i] != b[i]) break;
   return i;
}

static unsigned int stbiw__zhash(unsigned char *data)
{
   stbiw_uint32 hash = data[0] + (data[1] << 8) + (data[2] << 16);
   hash ^= hash << 3;
   hash += hash >> 5;
   hash ^= hash << 4;
   hash += hash >> 17;
   hash ^= hash << 25;
   hash += hash >> 6;
   return hash;
}

#define stbiw__zlib_flush() (out = stbiw__zlib_flushf(out, &bitbuf, &bitcount))
#define stbiw__zlib_add(code,codebits) \
      (bitbuf |= (code) << bitcount, bitcount += (codebits), stbiw__zlib_flush())
#define stbiw__zlib_huffa(b,c)  stbiw__zlib_add(stbiw__zlib_bitrev(b,c),c)
// default huffman tables
#define stbiw__zlib_huff1(n)  stbiw__zlib_huffa(0x30 + (n), 8)
#define stbiw__zlib_huff2(n)  stbiw__zlib_huffa(0x190 + (n)-144, 9)
#define stbiw__zlib_huff3(n)  stbiw__zlib_huffa(0 + (n)-256,7)
#define stbiw__zlib_huff4(n)  stbiw__zlib_huffa(0xc0 + (n)-280,8)
#define stbiw__zlib_huff(n)  ((n) <= 143 ? stbiw__zlib_huff1(n) : (n) <= 255 ? stbiw__zlib_huff2(n) : (n) <= 279 ? stbiw__zlib_huff3(n) : stbiw__zlib_huff4(n))
#define stbiw__zlib_huffb(n) ((n) <= 143 ? stbiw__zlib_huff1(n) : stbiw__zlib_huff2(n))

#define stbiw__ZHASH   16384

#endif // STBIW_ZLIB_COMPRESS

STBIWDEF unsigned char * stbi_zlib_compress(unsigned char *data, int data_len, int *out_len, int quality)
{
#ifdef STBIW_ZLIB_COMPRESS
   // user provided a zlib compress implementation, use that
   return STBIW_ZLIB_COMPRESS(data, data_len, out_len, quality);
#else // use builtin
   static unsigned short lengthc[] = { 3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258, 259 };
   static unsigned char  lengtheb[]= { 0,0,0,0,0,0,0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4,  4,  5,  5,  5,  5,  0 };
   static unsigned short distc[]   = { 1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577, 32768 };
   static unsigned char  disteb[]  = { 0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13 };
   unsigned int bitbuf=0;
   int i,j, bitcount=0;
   unsigned char *out = NULL;
   unsigned char ***hash_table = (unsigned char***) STBIW_MALLOC(stbiw__ZHASH * sizeof(unsigned char**));
   if (hash_table == NULL)
      return NULL;
   if (quality < 5) quality = 5;

   stbiw__sbpush(out, 0x78);   // DEFLATE 32K window
   stbiw__sbpush(out, 0x5e);   // FLEVEL = 1
   stbiw__zlib_add(1,1);  // BFINAL = 1
   stbiw__zlib_add(1,2);  // BTYPE = 1 -- fixed huffman

   for (i=0; i < stbiw__ZHASH; ++i)
      hash_table[i] = NULL;

   i=0;
   while (i < data_len-3) {
      // hash next 3 bytes of data to be compressed
      int h = stbiw__zhash(data+i)&(stbiw__ZHASH-1), best=3;
      unsigned char *bestloc = 0;
      unsigned char **hlist = hash_table[h];
      int n = stbiw__sbcount(hlist);
      for (j=0; j < n; ++j) {
         if (hlist[j]-data > i-32768) { // if entry lies within window
            int d = stbiw__zlib_countm(hlist[j], data+i, data_len-i);
            if (d >= best) { best=d; bestloc=hlist[j]; }
         }
      }
      // when hash table entry is too long, delete half the entries
      if (hash_table[h] && stbiw__sbn(hash_table[h]) == 2*quality) {
         STBIW_MEMMOVE(hash_table[h], hash_table[h]+quality, sizeof(hash_table[h][0])*quality);
         stbiw__sbn(hash_table[h]) = quality;
      }
      stbiw__sbpush(hash_table[h],data+i);

      if (bestloc) {
         // "lazy matching" - check match at *next* byte, and if it's better, do cur byte as literal
         h = stbiw__zhash(data+i+1)&(stbiw__ZHASH-1);
         hlist = hash_table[h];
         n = stbiw__sbcount(hlist);
         for (j=0; j < n; ++j) {
            if (hlist[j]-data > i-32767) {
               int e = stbiw__zlib_countm(hlist[j], data+i+1, data_len-i-1);
               if (e > best) { // if next match is better, bail on current match
                  bestloc = NULL;
                  break;
               }
            }
         }
      }

      if (bestloc) {
         int d = (int) (data+i - bestloc); // distance back
         STBIW_ASSERT(d <= 32767 && best <= 258);
         for (j=0; best > lengthc[j+1]-1; ++j);
         stbiw__zlib_huff(j+257);
         if (lengtheb[j]) stbiw__zlib_add(best - lengthc[j], lengtheb[j]);
         for (j=0; d > distc[j+1]-1; ++j);
         stbiw__zlib_add(stbiw__zlib_bitrev(j,5),5);
         if (disteb[j]) stbiw__zlib_add(d - distc[j], disteb[j]);
         i += best;
      } else {
         stbiw__zlib_huffb(data[i]);
         ++i;
      }
   }
   // write out final bytes
   for (;i < data_len; ++i)
      stbiw__zlib_huffb(data[i]);
   stbiw__zlib_huff(256); // end of block
   // pad with 0 bits to byte boundary
   while (bitcount)
      stbiw__zlib_add(0,1);

   for (i=0; i < stbiw__ZHASH; ++i)
      (void) stbiw__sbfree(hash_table[i]);
   STBIW_FREE(hash_table);

   {
      // compute adler32 on input
      unsigned int s1=1, s2=0;
      int blocklen = (int) (data_len % 5552);
      j=0;
      while (j < data_len) {
         for (i=0; i < blocklen; ++i) { s1 += data[j+i]; s2 += s1; }
         s1 %= 65521; s2 %= 65521;
         j += blocklen;
         blocklen = 5552;
      }
      stbiw__sbpush(out, STBIW_UCHAR(s2 >> 8));
      stbiw__sbpush(out, STBIW_UCHAR(s2));
      stbiw__sbpush(out, STBIW_UCHAR(s1 >> 8));
      stbiw__sbpush(out, STBIW_UCHAR(s1));
   }
   *out_len = stbiw__sbn(out);
   // make returned pointer freeable
   STBIW_MEMMOVE(stbiw__sbraw(out), out, *out_len);
   return (unsigned char *) stbiw__sbraw(out);
#endif // STBIW_ZLIB_COMPRESS
}

static unsigned int stbiw__crc32(unsigned char *buffer, int len)
{
#ifdef STBIW_CRC32
    return STBIW_CRC32(buffer, len);
#else
   static unsigned int crc_table[256] =
   {
      0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA, 0x076DC419, 0x706AF48F, 0xE963A535, 0x9E6495A3,
      0x0eDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988, 0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91,
      0x1DB71064, 0x6AB020F2, 0xF3B97148, 0x84BE41DE, 0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7,
      0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC, 0x14015C4F, 0x63066CD9, 0xFA0F3D63, 0x8D080DF5,
      0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172, 0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B,
      0x35B5A8FA, 0x42B2986C, 0xDBBBC9D6, 0xACBCF940, 0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59,
      0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116, 0x21B4F4B5, 0x56B3C423, 0xCFBA9599, 0xB8BDA50F,
      0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924, 0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D,
      0x76DC4190, 0x01DB7106, 0x98D220BC, 0xEFD5102A, 0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433,
      0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818, 0x7F6A0DBB, 0x086D3D2D, 0x91646C97, 0xE6635C01,
      0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E, 0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457,
      0x65B0D9C6, 0x12B7E950, 0x8BBEB8EA, 0xFCB9887C, 0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65,
      0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2, 0x4ADFA541, 0x3DD895D7, 0xA4D1C46D, 0xD3D6F4FB,
      0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0, 0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9,
      0x5005713C, 0x270241AA, 0xBE0B1010, 0xC90C2086, 0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F,
      0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4, 0x59B33D17, 0x2EB40D81, 0xB7BD5C3B, 0xC0BA6CAD,
      0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A, 0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683,
      0xE3630B12, 0x94643B84, 0x0D6D6A3E, 0x7A6A5AA8, 0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1,
      0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE, 0xF762575D, 0x806567CB, 0x196C3671, 0x6E6B06E7,
      0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC, 0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5,
      0xD6D6A3E8, 0xA1D1937E, 0x38D8C2C4, 0x4FDFF252, 0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B,
      0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60, 0xDF60EFC3, 0xA867DF55, 0x316E8EEF, 0x4669BE79,
      0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236, 0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F,
      0xC5BA3BBE, 0xB2BD0B28, 0x2BB45A92, 0x5CB36A04, 0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D,
      0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A, 0x9C0906A9, 0xEB0E363F, 0x72076785, 0x05005713,
      0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38, 0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21,
      0x86D3D2D4, 0xF1D4E242, 0x68DDB3F8, 0x1FDA836E, 0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777,
      0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C, 0x8F659EFF, 0xF862AE69, 0x616BFFD3, 0x166CCF45,
      0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2, 0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB,
      0xAED16A4A, 0xD9D65ADC, 0x40DF0B66, 0x37D83BF0, 0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9,
      0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6, 0xBAD03605, 0xCDD70693, 0x54DE5729, 0x23D967BF,
      0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94, 0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D
   };

   unsigned int crc = ~0u;
   int i;
   for (i=0; i < len; ++i)
      crc = (crc >> 8) ^ crc_table[buffer[i] ^ (crc & 0xff)];
   return ~crc;
#endif
}

#define stbiw__wpng4(o,a,b,c,d) ((o)[0]=STBIW_UCHAR(a),(o)[1]=STBIW_UCHAR(b),(o)[2]=STBIW_UCHAR(c),(o)[3]=STBIW_UCHAR(d),(o)+=4)
#define stbiw__wp32(data,v) stbiw__wpng4(data, (v)>>24,(v)>>16,(v)>>8,(v));
#define stbiw__wptag(data,s) stbiw__wpng4(data, s[0],s[1],s[2],s[3])

static void stbiw__wpcrc(unsigned char **data, int len)
{
   unsigned int crc = stbiw__crc32(*data - len - 4, len+4);
   stbiw__wp32(*data, crc);
}

static unsigned char stbiw__paeth(int a, int b, int c)
{
   int p = a + b - c, pa = abs(p-a), pb = abs(p-b), pc = abs(p-c);
   if (pa <= pb && pa <= pc) return STBIW_UCHAR(a);
   if (pb <= pc) return STBIW_UCHAR(b);
   return STBIW_UCHAR(c);
}

// @OPTIMIZE: provide an option that always forces left-predict or paeth predict
static void stbiw__encode_png_line(unsigned char *pixels, int stride_bytes, int width, int height, int y, int n, int filter_type, signed char *line_buffer)
{
   static int mapping[] = { 0,1,2,3,4 };
   static int firstmap[] = { 0,1,0,5,6 };
   int *mymap = (y != 0) ? mapping : firstmap;
   int i;
   int type = mymap[filter_type];
   unsigned char *z = pixels + stride_bytes * (stbi__flip_vertically_on_write ? height-1-y : y);
   int signed_stride = stbi__flip_vertically_on_write ? -stride_bytes : stride_bytes;

   if (type==0) {
      memcpy(line_buffer, z, width*n);
      return;
   }

   // first loop isn't optimized since it's just one pixel
   for (i = 0; i < n; ++i) {
      switch (type) {
         case 1: line_buffer[i] = z[i]; break;
         case 2: line_buffer[i] = z[i] - z[i-signed_stride]; break;
         case 3: line_buffer[i] = z[i] - (z[i-signed_stride]>>1); break;
         case 4: line_buffer[i] = (signed char) (z[i] - stbiw__paeth(0,z[i-signed_stride],0)); break;
         case 5: line_buffer[i] = z[i]; break;
         case 6: line_buffer[i] = z[i]; break;
      }
   }
   switch (type) {
      case 1: for (i=n; i < width*n; ++i) line_buffer[i] = z[i] - z[i-n]; break;
      case 2: for (i=n; i < width*n; ++i) line_buffer[i] = z[i] - z[i-signed_stride]; break;
      case 3: for (i=n; i < width*n; ++i) line_buffer[i] = z[i] - ((z[i-n] + z[i-signed_stride])>>1); break;
      case 4: for (i=n; i < width*n; ++i) line_buffer[i] = z[i] - stbiw__paeth(z[i-n], z[i-signed_stride], z[i-signed_stride-n]); break;
      case 5: for (i=n; i < width*n; ++i) line_buffer[i] = z[i] - (z[i-n]>>1); break;
      case 6: for (i=n; i < width*n; ++i) line_buffer[i] = z[i] - stbiw__paeth(z[i-n], 0,0); break;
   }
}

STBIWDEF unsigned char *stbi_write_png_to_mem(const unsigned char *pixels, int stride_bytes, int x, int y, int n, int *out_len)
{
   int force_filter = stbi_write_force_png_filter;
   int ctype[5] = { -1, 0, 4, 2, 6 };
   unsigned char sig[8] = { 137,80,78,71,13,10,26,10 };
   unsigned char *out,*o, *filt, *zlib;
   signed char *line_buffer;
   int j,zlen;

   if (stride_bytes == 0)
      stride_bytes = x * n;

   if (force_filter >= 5) {
      force_filter = -1;
   }

   filt = (unsigned char *) STBIW_MALLOC((x*n+1) * y); if (!filt) return 0;
   line_buffer = (signed char *) STBIW_MALLOC(x * n); if (!line_buffer) { STBIW_FREE(filt); return 0; }
   for (j=0; j < y; ++j) {
      int filter_type;
      if (force_filter > -1) {
         filter_type = force_filter;
         stbiw__encode_png_line((unsigned char*)(pixels), stride_bytes, x, y, j, n, force_filter, line_buffer);
      } else { // Estimate the best filter by running through all of them:
         int best_filter = 0, best_filter_val = 0x7fffffff, est, i;
         for (filter_type = 0; filter_type < 5; filter_type++) {
            stbiw__encode_png_line((unsigned char*)(pixels), stride_bytes, x, y, j, n, filter_type, line_buffer);

            // Estimate the entropy of the line using this filter; the less, the better.
            est = 0;
            for (i = 0; i < x*n; ++i) {
               est += abs((signed char) line_buffer[i]);
            }
            if (est < best_filter_val) {
               best_filter_val = est;
               best_filter = filter_type;
            }
         }
         if (filter_type != best_filter) {  // If the last iteration already got us the best filter, don't redo it
            stbiw__encode_png_line((unsigned char*)(pixels), stride_bytes, x, y, j, n, best_filter, line_buffer);
            filter_type = best_filter;
         }
      }
      // when we get here, filter_type contains the filter type, and line_buffer contains the data
      filt[j*(x*n+1)] = (unsigned char) filter_type;
      STBIW_MEMMOVE(filt+j*(x*n+1)+1, line_buffer, x*n);
   }
   STBIW_FREE(line_buffer);
   zlib = stbi_zlib_compress(filt, y*( x*n+1), &zlen, stbi_write_png_compression_level);
   STBIW_FREE(filt);
   if (!zlib) return 0;

   // each tag requires 12 bytes of overhead
   out = (unsigned char *) STBIW_MALLOC(8 + 12+13 + 12+zlen + 12);
   if (!out) return 0;
   *out_len = 8 + 12+13 + 12+zlen + 12;

   o=out;
   STBIW_MEMMOVE(o,sig,8); o+= 8;
   stbiw__wp32(o, 13); // header length
   stbiw__wptag(o, "IHDR");
   stbiw__wp32(o, x);
   stbiw__wp32(o, y);
   *o++ = 8;
   *o++ = STBIW_UCHAR(ctype[n]);
   *o++ = 0;
   *o++ = 0;
   *o++ = 0;
   stbiw__wpcrc(&o,13);

   stbiw__wp32(o, zlen);
   stbiw__wptag(o, "IDAT");
   STBIW_MEMMOVE(o, zlib, zlen);
   o += zlen;
   STBIW_FREE(zlib);
   stbiw__wpcrc(&o, zlen);

   stbiw__wp32(o,0);
   stbiw__wptag(o, "IEND");
   stbiw__wpcrc(&o,0);

   STBIW_ASSERT(o == out + *out_len);

   return out;
}

#ifndef STBI_WRITE_NO_STDIO
STBIWDEF int stbi_write_png(char const *filename, int x, int y, int comp, const void *data, int stride_bytes)
{
   FILE *f;
   int len;
   unsigned char *png = stbi_write_png_to_mem((const unsigned char *) data, stride_bytes, x, y, comp, &len);
   if (png == NULL) return 0;

   f = stbiw__fopen(filename, "wb");
   if (!f) { STBIW_FREE(png); return 0; }
   fwrite(png, 1, len, f);
   fclose(f);
   STBIW_FREE(png);
   return 1;
}
#endif

STBIWDEF int stbi_write_png_to_func(stbi_write_func *func, void *context, int x, int y, int comp, const void *data, int stride_bytes)
{
   int len;
   unsigned char *png = stbi_write_png_to_mem((const unsigned char *) data, stride_bytes, x, y, comp, &len);
   if (png == NULL) return 0;
   func(context, png, len);
   STBIW_FREE(png);
   return 1;
}


/* ***************************************************************************
 *
 * JPEG writer
 *
 * This is based on Jon Olick's jo_jpeg.cpp:
 * public domain Simple, Minimalistic JPEG writer - http://www.jonolick.com/code.html
 */

static const unsigned char stbiw__jpg_ZigZag[] = { 0,1,5,6,14,15,27,28,2,4,7,13,16,26,29,42,3,8,12,17,25,30,41,43,9,11,18,
      24,31,40,44,53,10,19,23,32,39,45,52,54,20,22,33,38,46,51,55,60,21,34,37,47,50,56,59,61,35,36,48,49,57,58,62,63 };

static void stbiw__jpg_writeBits(stbi__write_context *s, int *bitBufP, int *bitCntP, const unsigned short *bs) {
   int bitBuf = *bitBufP, bitCnt = *bitCntP;
   bitCnt += bs[1];
   bitBuf |= bs[0] << (24 - bitCnt);
   while(bitCnt >= 8) {
      unsigned char c = (bitBuf >> 16) & 255;
      stbiw__putc(s, c);
      if(c == 255) {
         stbiw__putc(s, 0);
      }
      bitBuf <<= 8;
      bitCnt -= 8;
   }
   *bitBufP = bitBuf;
   *bitCntP = bitCnt;
}

static void stbiw__jpg_DCT(float *d0p, float *d1p, float *d2p, float *d3p, float *d4p, float *d5p, float *d6p, float *d7p) {
   float d0 = *d0p, d1 = *d1p, d2 = *d2p, d3 = *d3p, d4 = *d4p, d5 = *d5p, d6 = *d6p, d7 = *d7p;
   float z1, z2, z3, z4, z5, z11, z13;

   float tmp0 = d0 + d7;
   float tmp7 = d0 - d7;
   float tmp1 = d1 + d6;
   float tmp6 = d1 - d6;
   float tmp2 = d2 + d5;
   float tmp5 = d2 - d5;
   float tmp3 = d3 + d4;
   float tmp4 = d3 - d4;

   // Even part
   float tmp10 = tmp0 + tmp3;   // phase 2
   float tmp13 = tmp0 - tmp3;
   float tmp11 = tmp1 + tmp2;
   float tmp12 = tmp1 - tmp2;

   d0 = tmp10 + tmp11;       // phase 3
   d4 = tmp10 - tmp11;

   z1 = (tmp12 + tmp13) * 0.707106781f; // c4
   d2 = tmp13 + z1;       // phase 5
   d6 = tmp13 - z1;

   // Odd part
   tmp10 = tmp4 + tmp5;       // phase 2
   tmp11 = tmp5 + tmp6;
   tmp12 = tmp6 + tmp7;

   // The rotator is modified from fig 4-8 to avoid extra negations.
   z5 = (tmp10 - tmp12) * 0.382683433f; // c6
   z2 = tmp10 * 0.541196100f + z5; // c2-c6
   z4 = tmp12 * 1.306562965f + z5; // c2+c6
   z3 = tmp11 * 0.707106781f; // c4

   z11 = tmp7 + z3;      // phase 5
   z13 = tmp7 - z3;

   *d5p = z13 + z2;         // phase 6
   *d3p = z13 - z2;
   *d1p = z11 + z4;
   *d7p = z11 - z4;

   *d0p = d0;  *d2p = d2;  *d4p = d4;  *d6p = d6;
}

static void stbiw__jpg_calcBits(int val, unsigned short bits[2]) {
   int tmp1 = val < 0 ? -val : val;
   val = val < 0 ? val-1 : val;
   bits[1] = 1;
   while(tmp1 >>= 1) {
      ++bits[1];
   }
   bits[0] = val & ((1<<bits[1])-1);
}

static int stbiw__jpg_processDU(stbi__write_context *s, int *bitBuf, int *bitCnt, float *CDU, int du_stride, float *fdtbl, int DC, const unsigned short HTDC[256][2], const unsigned short HTAC[256][2]) {
   const unsigned short EOB[2] = { HTAC[0x00][0], HTAC[0x00][1] };
   const unsigned short M16zeroes[2] = { HTAC[0xF0][0], HTAC[0xF0][1] };
   int dataOff, i, j, n, diff, end0pos, x, y;
   int DU[64];

   // DCT rows
   for(dataOff=0, n=du_stride*8; dataOff<n; dataOff+=du_stride) {
      stbiw__jpg_DCT(&CDU[dataOff], &CDU[dataOff+1], &CDU[dataOff+2], &CDU[dataOff+3], &CDU[dataOff+4], &CDU[dataOff+5], &CDU[dataOff+6], &CDU[dataOff+7]);
   }
   // DCT columns
   for(dataOff=0; dataOff<8; ++dataOff) {
      stbiw__jpg_DCT(&CDU[dataOff], &CDU[dataOff+du_stride], &CDU[dataOff+du_stride*2], &CDU[dataOff+du_stride*3], &CDU[dataOff+du_stride*4],
                     &CDU[dataOff+du_stride*5], &CDU[dataOff+du_stride*6], &CDU[dataOff+du_stride*7]);
   }
   // Quantize/descale/zigzag the coefficients
   for(y = 0, j=0; y < 8; ++y) {
      for(x = 0; x < 8; ++x,++j) {
         float v;
         i = y*du_stride+x;
         v = CDU[i]*fdtbl[j];
         // DU[stbiw__jpg_ZigZag[j]] = (int)(v < 0 ? ceilf(v - 0.5f) : floorf(v + 0.5f));
         // ceilf() and floorf() are C99, not C89, but I /think/ they're not needed here anyway?
         DU[stbiw__jpg_ZigZag[j]] = (int)(v < 0 ? v - 0.5f : v + 0.5f);
      }
   }

   // Encode DC
   diff = DU[0] - DC;
   if (diff == 0) {
      stbiw__jpg_writeBits(s, bitBuf, bitCnt, HTDC[0]);
   } else {
      unsigned short bits[2];
      stbiw__jpg_calcBits(diff, bits);
      stbiw__jpg_writeBits(s, bitBuf, bitCnt, HTDC[bits[1]]);
      stbiw__jpg_writeBits(s, bitBuf, bitCnt, bits);
   }
   // Encode ACs
   end0pos = 63;
   for(; (end0pos>0)&&(DU[end0pos]==0); --end0pos) {
   }
   // end0pos = first element in reverse order !=0
   if(end0pos == 0) {
      stbiw__jpg_writeBits(s, bitBuf, bitCnt, EOB);
      return DU[0];
   }
   for(i = 1; i <= end0pos; ++i) {
      int startpos = i;
      int nrzeroes;
      unsigned short bits[2];
      for (; DU[i]==0 && i<=end0pos; ++i) {
      }
      nrzeroes = i-startpos;
      if ( nrzeroes >= 16 ) {
         int lng = nrzeroes>>4;
         int nrmarker;
         for (nrmarker=1; nrmarker <= lng; ++nrmarker)
            stbiw__jpg_writeBits(s, bitBuf, bitCnt, M16zeroes);
         nrzeroes &= 15;
      }
      stbiw__jpg_calcBits(DU[i], bits);
      stbiw__jpg_writeBits(s, bitBuf, bitCnt, HTAC[(nrzeroes<<4)+bits[1]]);
      stbiw__jpg_writeBits(s, bitBuf, bitCnt, bits);
   }
   if(end0pos != 63) {
      stbiw__jpg_writeBits(s, bitBuf, bitCnt, EOB);
   }
   return DU[0];
}

static int stbi_write_jpg_core(stbi__write_context *s, int width, int height, int comp, const void* data, int quality) {
   // Constants that don't pollute global namespace
   static const unsigned char std_dc_luminance_nrcodes[] = {0,0,1,5,1,1,1,1,1,1,0,0,0,0,0,0,0};
   static const unsigned char std_dc_luminance_values[] = {0,1,2,3,4,5,6,7,8,9,10,11};
   static const unsigned char std_ac_luminance_nrcodes[] = {0,0,2,1,3,3,2,4,3,5,5,4,4,0,0,1,0x7d};
   static const unsigned char std_ac_luminance_values[] = {
      0x01,0x02,0x03,0x00,0x04,0x11,0x05,0x12,0x21,0x31,0x41,0x06,0x13,0x51,0x61,0x07,0x22,0x71,0x14,0x32,0x81,0x91,0xa1,0x08,
      0x23,0x42,0xb1,0xc1,0x15,0x52,0xd1,0xf0,0x24,0x33,0x62,0x72,0x82,0x09,0x0a,0x16,0x17,0x18,0x19,0x1a,0x25,0x26,0x27,0x28,
      0x29,0x2a,0x34,0x35,0x36,0x37,0x38,0x39,0x3a,0x43,0x44,0x45,0x46,0x47,0x48,0x49,0x4a,0x53,0x54,0x55,0x56,0x57,0x58,0x59,
      0x5a,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6a,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7a,0x83,0x84,0x85,0x86,0x87,0x88,0x89,
      0x8a,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9a,0xa2,0xa3,0xa4,0xa5,0xa6,0xa7,0xa8,0xa9,0xaa,0xb2,0xb3,0xb4,0xb5,0xb6,
      0xb7,0xb8,0xb9,0xba,0xc2,0xc3,0xc4,0xc5,0xc6,0xc7,0xc8,0xc9,0xca,0xd2,0xd3,0xd4,0xd5,0xd6,0xd7,0xd8,0xd9,0xda,0xe1,0xe2,
      0xe3,0xe4,0xe5,0xe6,0xe7,0xe8,0xe9,0xea,0xf1,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,0xf8,0xf9,0xfa
   };
   static const unsigned char std_dc_chrominance_nrcodes[] = {0,0,3,1,1,1,1,1,1,1,1,1,0,0,0,0,0};
   static const unsigned char std_dc_chrominance_values[] = {0,1,2,3,4,5,6,7,8,9,10,11};
   static const unsigned char std_ac_chrominance_nrcodes[] = {0,0,2,1,2,4,4,3,4,7,5,4,4,0,1,2,0x77};
   static const unsigned char std_ac_chrominance_values[] = {
      0x00,0x01,0x02,0x03,0x11,0x04,0x05,0x21,0x31,0x06,0x12,0x41,0x51,0x07,0x61,0x71,0x13,0x22,0x32,0x81,0x08,0x14,0x42,0x91,
      0xa1,0xb1,0xc1,0x09,0x23,0x33,0x52,0xf0,0x15,0x62,0x72,0xd1,0x0a,0x16,0x24,0x34,0xe1,0x25,0xf1,0x17,0x18,0x19,0x1a,0x26,
      0x27,0x28,0x29,0x2a,0x35,0x36,0x37,0x38,0x39,0x3a,0x43,0x44,0x45,0x46,0x47,0x48,0x49,0x4a,0x53,0x54,0x55,0x56,0x57,0x58,
      0x59,0x5a,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6a,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7a,0x82,0x83,0x84,0x85,0x86,0x87,
      0x88,0x89,0x8a,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9a,0xa2,0xa3,0xa4,0xa5,0xa6,0xa7,0xa8,0xa9,0xaa,0xb2,0xb3,0xb4,
      0xb5,0xb6,0xb7,0xb8,0xb9,0xba,0xc2,0xc3,0xc4,0xc5,0xc6,0xc7,0xc8,0xc9,0xca,0xd2,0xd3,0xd4,0xd5,0xd6,0xd7,0xd8,0xd9,0xda,
      0xe2,0xe3,0xe4,0xe5,0xe6,0xe7,0xe8,0xe9,0xea,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,0xf8,0xf9,0xfa
   };
   // Huffman tables
   static const unsigned short YDC_HT[256][2] = { {0,2},{2,3},{3,3},{4,3},{5,3},{6,3},{14,4},{30,5},{62,6},{126,7},{254,8},{510,9}};
   static const unsigned short UVDC_HT[256][2] = { {0,2},{1,2},{2,2},{6,3},{14,4},{30,5},{62,6},{126,7},{254,8},{510,9},{1022,10},{2046,11}};
   static const unsigned short YAC_HT[256][2] = {
      {10,4},{0,2},{1,2},{4,3},{11,4},{26,5},{120,7},{248,8},{1014,10},{65410,16},{65411,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},
      {12,4},{27,5},{121,7},{502,9},{2038,11},{65412,16},{65413,16},{65414,16},{65415,16},{65416,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},
      {28,5},{249,8},{1015,10},{4084,12},{65417,16},{65418,16},{65419,16},{65420,16},{65421,16},{65422,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},
      {58,6},{503,9},{4085,12},{65423,16},{65424,16},{65425,16},{65426,16},{65427,16},{65428,16},{65429,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},
      {59,6},{1016,10},{65430,16},{65431,16},{65432,16},{65433,16},{65434,16},{65435,16},{65436,16},{65437,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},
      {122,7},{2039,11},{65438,16},{65439,16},{65440,16},{65441,16},{65442,16},{65443,16},{65444,16},{65445,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},
      {123,7},{4086,12},{65446,16},{65447,16},{65448,16},{65449,16},{65450,16},{65451,16},{65452,16},{65453,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},
      {250,8},{4087,12},{65454,16},{65455,16},{65456,16},{65457,16},{65458,16},{65459,16},{65460,16},{65461,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},
      {504,9},{32704,15},{65462,16},{65463,16},{65464,16},{65465,16},{65466,16},{65467,16},{65468,16},{65469,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},
      {505,9},{65470,16},{65471,16},{65472,16},{65473,16},{65474,16},{65475,16},{65476,16},{65477,16},{65478,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},
      {506,9},{65479,16},{65480,16},{65481,16},{65482,16},{65483,16},{65484,16},{65485,16},{65486,16},{65487,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},
      {1017,10},{65488,16},{65489,16},{65490,16},{65491,16},{65492,16},{65493,16},{65494,16},{65495,16},{65496,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},
      {1018,10},{65497,16},{65498,16},{65499,16},{65500,16},{65501,16},{65502,16},{65503,16},{65504,16},{65505,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},
      {2040,11},{65506,16},{65507,16},{65508,16},{65509,16},{65510,16},{65511,16},{65512,16},{65513,16},{65514,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},
      {65515,16},{65516,16},{65517,16},{65518,16},{65519,16},{65520,16},{65521,16},{65522,16},{65523,16},{65524,16},{0,0},{0,0},{0,0},{0,0},{0,0},
      {2041,11},{65525,16},{65526,16},{65527,16},{65528,16},{65529,16},{65530,16},{65531,16},{65532,16},{65533,16},{65534,16},{0,0},{0,0},{0,0},{0,0},{0,0}
   };
   static const unsigned short UVAC_HT[256][2] = {
      {0,2},{1,2},{4,3},{10,4},{24,5},{25,5},{56,6},{120,7},{500,9},{1014,10},{4084,12},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},
      {11,4},{57,6},{246,8},{501,9},{2038,11},{4085,12},{65416,16},{65417,16},{65418,16},{65419,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},
      {26,5},{247,8},{1015,10},{4086,12},{32706,15},{65420,16},{65421,16},{65422,16},{65423,16},{65424,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},
      {27,5},{248,8},{1016,10},{4087,12},{65425,16},{65426,16},{65427,16},{65428,16},{65429,16},{65430,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},
      {58,6},{502,9},{65431,16},{65432,16},{65433,16},{65434,16},{65435,16},{65436,16},{65437,16},{65438,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},
      {59,6},{1017,10},{65439,16},{65440,16},{65441,16},{65442,16},{65443,16},{65444,16},{65445,16},{65446,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},
      {121,7},{2039,11},{65447,16},{65448,16},{65449,16},{65450,16},{65451,16},{65452,16},{65453,16},{65454,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},
      {122,7},{2040,11},{65455,16},{65456,16},{65457,16},{65458,16},{65459,16},{65460,16},{65461,16},{65462,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},
      {249,8},{65463,16},{65464,16},{65465,16},{65466,16},{65467,16},{65468,16},{65469,16},{65470,16},{65471,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},
      {503,9},{65472,16},{65473,16},{65474,16},{65475,16},{65476,16},{65477,16},{65478,16},{65479,16},{65480,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},
      {504,9},{65481,16},{65482,16},{65483,16},{65484,16},{65485,16},{65486,16},{65487,16},{65488,16},{65489,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},
      {505,9},{65490,16},{65491,16},{65492,16},{65493,16},{65494,16},{65495,16},{65496,16},{65497,16},{65498,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},
      {506,9},{65499,16},{65500,16},{65501,16},{65502,16},{65503,16},{65504,16},{65505,16},{65506,16},{65507,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},
      {2041,11},{65508,16},{65509,16},{65510,16},{65511,16},{65512,16},{65513,16},{65514,16},{65515,16},{65516,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},
      {16352,14},{65517,16},{65518,16},{65519,16},{65520,16},{65521,16},{65522,16},{65523,16},{65524,16},{65525,16},{0,0},{0,0},{0,0},{0,0},{0,0},
      {1018,10},{32707,15},{65526,16},{65527,16},{65528,16},{65529,16},{65530,16},{65531,16},{65532,16},{65533,16},{65534,16},{0,0},{0,0},{0,0},{0,0},{0,0}
   };
   static const int YQT[] = {16,11,10,16,24,40,51,61,12,12,14,19,26,58,60,55,14,13,16,24,40,57,69,56,14,17,22,29,51,87,80,62,18,22,
                             37,56,68,109,103,77,24,35,55,64,81,104,113,92,49,64,78,87,103,121,120,101,72,92,95,98,112,100,103,99};
   static const int UVQT[] = {17,18,24,47,99,99,99,99,18,21,26,66,99,99,99,99,24,26,56,99,99,99,99,99,47,66,99,99,99,99,99,99,
                              99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99};
   static const float aasf[] = { 1.0f * 2.828427125f, 1.387039845f * 2.828427125f, 1.306562965f * 2.828427125f, 1.175875602f * 2.828427125f,
                                 1.0f * 2.828427125f, 0.785694958f * 2.828427125f, 0.541196100f * 2.828427125f, 0.275899379f * 2.828427125f };

   int row, col, i, k, subsample;
   float fdtbl_Y[64], fdtbl_UV[64];
   unsigned char YTable[64], UVTable[64];

   if(!data || !width || !height || comp > 4 || comp < 1) {
      return 0;
   }

   quality = quality ? quality : 90;
   subsample = quality <= 90 ? 1 : 0;
   quality = quality < 1 ? 1 : quality > 100 ? 100 : quality;
   quality = quality < 50 ? 5000 / quality : 200 - quality * 2;

   for(i = 0; i < 64; ++i) {
      int uvti, yti = (YQT[i]*quality+50)/100;
      YTable[stbiw__jpg_ZigZag[i]] = (unsigned char) (yti < 1 ? 1 : yti > 255 ? 255 : yti);
      uvti = (UVQT[i]*quality+50)/100;
      UVTable[stbiw__jpg_ZigZag[i]] = (unsigned char) (uvti < 1 ? 1 : uvti > 255 ? 255 : uvti);
   }

   for(row = 0, k = 0; row < 8; ++row) {
      for(col = 0; col < 8; ++col, ++k) {
         fdtbl_Y[k]  = 1 / (YTable [stbiw__jpg_ZigZag[k]] * aasf[row] * aasf[col]);
         fdtbl_UV[k] = 1 / (UVTable[stbiw__jpg_ZigZag[k]] * aasf[row] * aasf[col]);
      }
   }

   // Write Headers
   {
      static const unsigned char head0[] = { 0xFF,0xD8,0xFF,0xE0,0,0x10,'J','F','I','F',0,1,1,0,0,1,0,1,0,0,0xFF,0xDB,0,0x84,0 };
      static const unsigned char head2[] = { 0xFF,0xDA,0,0xC,3,1,0,2,0x11,3,0x11,0,0x3F,0 };
      const unsigned char head1[] = { 0xFF,0xC0,0,0x11,8,(unsigned char)(height>>8),STBIW_UCHAR(height),(unsigned char)(width>>8),STBIW_UCHAR(width),
                                      3,1,(unsigned char)(subsample?0x22:0x11),0,2,0x11,1,3,0x11,1,0xFF,0xC4,0x01,0xA2,0 };
      s->func(s->context, (void*)head0, sizeof(head0));
      s->func(s->context, (void*)YTable, sizeof(YTable));
      stbiw__putc(s, 1);
      s->func(s->context, UVTable, sizeof(UVTable));
      s->func(s->context, (void*)head1, sizeof(head1));
      s->func(s->context, (void*)(std_dc_luminance_nrcodes+1), sizeof(std_dc_luminance_nrcodes)-1);
      s->func(s->context, (void*)std_dc_luminance_values, sizeof(std_dc_luminance_values));
      stbiw__putc(s, 0x10); // HTYACinfo
      s->func(s->context, (void*)(std_ac_luminance_nrcodes+1), sizeof(std_ac_luminance_nrcodes)-1);
      s->func(s->context, (void*)std_ac_luminance_values, sizeof(std_ac_luminance_values));
      stbiw__putc(s, 1); // HTUDCinfo
      s->func(s->context, (void*)(std_dc_chrominance_nrcodes+1), sizeof(std_dc_chrominance_nrcodes)-1);
      s->func(s->context, (void*)std_dc_chrominance_values, sizeof(std_dc_chrominance_values));
      stbiw__putc(s, 0x11); // HTUACinfo
      s->func(s->context, (void*)(std_ac_chrominance_nrcodes+1), sizeof(std_ac_chrominance_nrcodes)-1);
      s->func(s->context, (void*)std_ac_chrominance_values, sizeof(std_ac_chrominance_values));
      s->func(s->context, (void*)head2, sizeof(head2));
   }

   // Encode 8x8 macroblocks
   {
      static const unsigned short fillBits[] = {0x7F, 7};
      int DCY=0, DCU=0, DCV=0;
      int bitBuf=0, bitCnt=0;
      // comp == 2 is grey+alpha (alpha is ignored)
      int ofsG = comp > 2 ? 1 : 0, ofsB = comp > 2 ? 2 : 0;
      const unsigned char *dataR = (const unsigned char *)data;
      const unsigned char *dataG = dataR + ofsG;
      const unsigned char *dataB = dataR + ofsB;
      int x, y, pos;
      if(subsample) {
         for(y = 0; y < height; y += 16) {
            for(x = 0; x < width; x += 16) {
               float Y[256], U[256], V[256];
               for(row = y, pos = 0; row < y+16; ++row) {
                  // row >= height => use last input row
                  int clamped_row = (row < height) ? row : height - 1;
                  int base_p = (stbi__flip_vertically_on_write ? (height-1-clamped_row) : clamped_row)*width*comp;
                  for(col = x; col < x+16; ++col, ++pos) {
                     // if col >= width => use pixel from last input column
                     int p = base_p + ((col < width) ? col : (width-1))*comp;
                     float r = dataR[p], g = dataG[p], b = dataB[p];
                     Y[pos]= +0.29900f*r + 0.58700f*g + 0.11400f*b - 128;
                     U[pos]= -0.16874f*r - 0.33126f*g + 0.50000f*b;
                     V[pos]= +0.50000f*r - 0.41869f*g - 0.08131f*b;
                  }
               }
               DCY = stbiw__jpg_processDU(s, &bitBuf, &bitCnt, Y+0,   16, fdtbl_Y, DCY, YDC_HT, YAC_HT);
               DCY = stbiw__jpg_processDU(s, &bitBuf, &bitCnt, Y+8,   16, fdtbl_Y, DCY, YDC_HT, YAC_HT);
               DCY = stbiw__jpg_processDU(s, &bitBuf, &bitCnt, Y+128, 16, fdtbl_Y, DCY, YDC_HT, YAC_HT);
               DCY = stbiw__jpg_processDU(s, &bitBuf, &bitCnt, Y+136, 16, fdtbl_Y, DCY, YDC_HT, YAC_HT);

               // subsample U,V
               {
                  float subU[64], subV[64];
                  int yy, xx;
                  for(yy = 0, pos = 0; yy < 8; ++yy) {
                     for(xx = 0; xx < 8; ++xx, ++pos) {
                        int j = yy*32+xx*2;
                        subU[pos] = (U[j+0] + U[j+1] + U[j+16] + U[j+17]) * 0.25f;
                        subV[pos] = (V[j+0] + V[j+1] + V[j+16] + V[j+17]) * 0.25f;
                     }
                  }
                  DCU = stbiw__jpg_processDU(s, &bitBuf, &bitCnt, subU, 8, fdtbl_UV, DCU, UVDC_HT, UVAC_HT);
                  DCV = stbiw__jpg_processDU(s, &bitBuf, &bitCnt, subV, 8, fdtbl_UV, DCV, UVDC_HT, UVAC_HT);
               }
            }
         }
      } else {
         for(y = 0; y < height; y += 8) {
            for(x = 0; x < width; x += 8) {
               float Y[64], U[64], V[64];
               for(row = y, pos = 0; row < y+8; ++row) {
                  // row >= height => use last input row
                  int clamped_row = (row < height) ? row : height - 1;
                  int base_p = (stbi__flip_vertically_on_write ? (height-1-clamped_row) : clamped_row)*width*comp;
                  for(col = x; col < x+8; ++col, ++pos) {
                     // if col >= width => use pixel from last input column
                     int p = base_p + ((col < width) ? col : (width-1))*comp;
                     float r = dataR[p], g = dataG[p], b = dataB[p];
                     Y[pos]= +0.29900f*r + 0.58700f*g + 0.11400f*b - 128;
                     U[pos]= -0.16874f*r - 0.33126f*g + 0.50000f*b;
                     V[pos]= +0.50000f*r - 0.41869f*g - 0.08131f*b;
                  }
               }

               DCY = stbiw__jpg_processDU(s, &bitBuf, &bitCnt, Y, 8, fdtbl_Y,  DCY, YDC_HT, YAC_HT);
               DCU = stbiw__jpg_processDU(s, &bitBuf, &bitCnt, U, 8, fdtbl_UV, DCU, UVDC_HT, UVAC_HT);
               DCV = stbiw__jpg_processDU(s, &bitBuf, &bitCnt, V, 8, fdtbl_UV, DCV, UVDC_HT, UVAC_HT);
            }
         }
      }

      // Do the bit alignment of the EOI marker
      stbiw__jpg_writeBits(s, &bitBuf, &bitCnt, fillBits);
   }

   // EOI
   stbiw__putc(s, 0xFF);
   stbiw__putc(s, 0xD9);

   return 1;
}

STBIWDEF int stbi_write_jpg_to_func(stbi_write_func *func, void *context, int x, int y, int comp, const void *data, int quality)
{
   stbi__write_context s;
   stbi__start_write_callbacks(&s, func, context);
   return stbi_write_jpg_core(&s, x, y, comp, (void *) data, quality);
}


#ifndef STBI_WRITE_NO_STDIO
STBIWDEF int stbi_write_jpg(char const *filename, int x, int y, int comp, const void *data, int quality)
{
   stbi__write_context s;
   if (stbi__start_write_file(&s,filename)) {
      int r = stbi_write_jpg_core(&s, x, y, comp, data, quality);
      stbi__end_write_file(&s);
      return r;
   } else
      return 0;
}
#endif

#endif // STB_IMAGE_WRITE_IMPLEMENTATION

/* Revision history
      1.14  (2020-02-02) updated JPEG writer to downsample chroma channels
      1.13
      1.12
      1.11  (2019-08-11)

      1.10  (2019-02-07)
             support utf8 filenames in Windows; fix warnings and platform ifdefs
      1.09  (2018-02-11)
             fix typo in zlib quality API, improve STB_I_W_STATIC in C++
      1.08  (2018-01-29)
             add stbi__flip_vertically_on_write, external zlib, zlib quality, choose PNG filter
      1.07  (2017-07-24)
             doc fix
      1.06 (2017-07-23)
             writing JPEG (using Jon Olick's code)
      1.05   ???
      1.04 (2017-03-03)
             monochrome BMP expansion
      1.03   ???
      1.02 (2016-04-02)
             avoid allocating large structures on the stack
      1.01 (2016-01-16)
             STBIW_REALLOC_SIZED: support allocators with no realloc support
             avoid race-condition in crc initialization
             minor compile issues
      1.00 (2015-09-14)
             installable file IO function
      0.99 (2015-09-13)
             warning fixes; TGA rle support
      0.98 (2015-04-08)
             added STBIW_MALLOC, STBIW_ASSERT etc
      0.97 (2015-01-18)
             fixed HDR asserts, rewrote HDR rle logic
      0.96 (2015-01-17)
             add HDR output
             fix monochrome BMP
      0.95 (2014-08-17)
		       add monochrome TGA output
      0.94 (2014-05-31)
             rename private functions to avoid conflicts with stb_image.h
      0.93 (2014-05-27)
             warning fixes
      0.92 (2010-08-01)
             casts to unsigned char to fix warnings
      0.91 (2010-07-17)
             first public release
      0.90   first internal release
*/

/*
------------------------------------------------------------------------------
This software is available under 2 licenses -- choose whichever you prefer.
------------------------------------------------------------------------------
ALTERNATIVE A - MIT License
Copyright (c) 2017 Sean Barrett
Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
------------------------------------------------------------------------------
ALTERNATIVE B - Public Domain (www.unlicense.org)
This is free and unencumbered software released into the public domain.
Anyone is free to copy, modify, publish, use, compile, sell, or distribute this
software, either in source code form or as a compiled binary, for any purpose,
commercial or non-commercial, and by any means.
In jurisdictions that recognize copyright laws, the author or authors of this
software dedicate any and all copyright interest in the software to the public
domain. We make this dedication for the benefit of the public at large and to
the detriment of our heirs and successors. We intend this dedication to be an
overt act of relinquishment in perpetuity of all present and future rights to
this software under copyright law.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
------------------------------------------------------------------------------
*/

/* stb_image_resize - v0.96 - public domain image resizing
   by Jorge L Rodriguez (@VinoBS) - 2014
   http://github.com/nothings/stb

   Written with emphasis on usability, portability, and efficiency. (No
   SIMD or threads, so it be easily outperformed by libs that use those.)
   Only scaling and translation is supported, no rotations or shears.
   Easy API downsamples w/Mitchell filter, upsamples w/cubic interpolation.

   COMPILING & LINKING
      In one C/C++ file that #includes this file, do this:
         #define STB_IMAGE_RESIZE_IMPLEMENTATION
      before the #include. That will create the implementation in that file.

   QUICKSTART
      stbir_resize_uint8(      input_pixels , in_w , in_h , 0,
                               output_pixels, out_w, out_h, 0, num_channels)
      stbir_resize_float(...)
      stbir_resize_uint8_srgb( input_pixels , in_w , in_h , 0,
                               output_pixels, out_w, out_h, 0,
                               num_channels , alpha_chan  , 0)
      stbir_resize_uint8_srgb_edgemode(
                               input_pixels , in_w , in_h , 0,
                               output_pixels, out_w, out_h, 0,
                               num_channels , alpha_chan  , 0, STBIR_EDGE_CLAMP)
                                                            // WRAP/REFLECT/ZERO

   FULL API
      See the "header file" section of the source for API documentation.

   ADDITIONAL DOCUMENTATION

      SRGB & FLOATING POINT REPRESENTATION
         The sRGB functions presume IEEE floating point. If you do not have
         IEEE floating point, define STBIR_NON_IEEE_FLOAT. This will use
         a slower implementation.

      MEMORY ALLOCATION
         The resize functions here perform a single memory allocation using
         malloc. To control the memory allocation, before the #include that
         triggers the implementation, do:

            #define STBIR_MALLOC(size,context) ...
            #define STBIR_FREE(ptr,context)   ...

         Each resize function makes exactly one call to malloc/free, so to use
         temp memory, store the temp memory in the context and return that.

      ASSERT
         Define STBIR_ASSERT(boolval) to override assert() and not use assert.h

      OPTIMIZATION
         Define STBIR_SATURATE_INT to compute clamp values in-range using
         integer operations instead of float operations. This may be faster
         on some platforms.

      DEFAULT FILTERS
         For functions which don't provide explicit control over what filters
         to use, you can change the compile-time defaults with

            #define STBIR_DEFAULT_FILTER_UPSAMPLE     STBIR_FILTER_something
            #define STBIR_DEFAULT_FILTER_DOWNSAMPLE   STBIR_FILTER_something

         See stbir_filter in the header-file section for the list of filters.

      NEW FILTERS
         A number of 1D filter kernels are used. For a list of
         supported filters see the stbir_filter enum. To add a new filter,
         write a filter function and add it to stbir__filter_info_table.

      PROGRESS
         For interactive use with slow resize operations, you can install
         a progress-report callback:

            #define STBIR_PROGRESS_REPORT(val)   some_func(val)

         The parameter val is a float which goes from 0 to 1 as progress is made.

         For example:

            static void my_progress_report(float progress);
            #define STBIR_PROGRESS_REPORT(val) my_progress_report(val)

            #define STB_IMAGE_RESIZE_IMPLEMENTATION
            #include "stb_image_resize.h"

            static void my_progress_report(float progress)
            {
               printf("Progress: %f%%\n", progress*100);
            }

      MAX CHANNELS
         If your image has more than 64 channels, define STBIR_MAX_CHANNELS
         to the max you'll have.

      ALPHA CHANNEL
         Most of the resizing functions provide the ability to control how
         the alpha channel of an image is processed. The important things
         to know about this:

         1. The best mathematically-behaved version of alpha to use is
         called "premultiplied alpha", in which the other color channels
         have had the alpha value multiplied in. If you use premultiplied
         alpha, linear filtering (such as image resampling done by this
         library, or performed in texture units on GPUs) does the "right
         thing". While premultiplied alpha is standard in the movie CGI
         industry, it is still uncommon in the videogame/real-time world.

         If you linearly filter non-premultiplied alpha, strange effects
         occur. (For example, the 50/50 average of 99% transparent bright green
         and 1% transparent black produces 50% transparent dark green when
         non-premultiplied, whereas premultiplied it produces 50%
         transparent near-black. The former introduces green energy
         that doesn't exist in the source image.)

         2. Artists should not edit premultiplied-alpha images; artists
         want non-premultiplied alpha images. Thus, art tools generally output
         non-premultiplied alpha images.

         3. You will get best results in most cases by converting images
         to premultiplied alpha before processing them mathematically.

         4. If you pass the flag STBIR_FLAG_ALPHA_PREMULTIPLIED, the
         resizer does not do anything special for the alpha channel;
         it is resampled identically to other channels. This produces
         the correct results for premultiplied-alpha images, but produces
         less-than-ideal results for non-premultiplied-alpha images.

         5. If you do not pass the flag STBIR_FLAG_ALPHA_PREMULTIPLIED,
         then the resizer weights the contribution of input pixels
         based on their alpha values, or, equivalently, it multiplies
         the alpha value into the color channels, resamples, then divides
         by the resultant alpha value. Input pixels which have alpha=0 do
         not contribute at all to output pixels unless _all_ of the input
         pixels affecting that output pixel have alpha=0, in which case
         the result for that pixel is the same as it would be without
         STBIR_FLAG_ALPHA_PREMULTIPLIED. However, this is only true for
         input images in integer formats. For input images in float format,
         input pixels with alpha=0 have no effect, and output pixels
         which have alpha=0 will be 0 in all channels. (For float images,
         you can manually achieve the same result by adding a tiny epsilon
         value to the alpha channel of every image, and then subtracting
         or clamping it at the end.)

         6. You can suppress the behavior described in #5 and make
         all-0-alpha pixels have 0 in all channels by #defining
         STBIR_NO_ALPHA_EPSILON.

         7. You can separately control whether the alpha channel is
         interpreted as linear or affected by the colorspace. By default
         it is linear; you almost never want to apply the colorspace.
         (For example, graphics hardware does not apply sRGB conversion
         to the alpha channel.)

   CONTRIBUTORS
      Jorge L Rodriguez: Implementation
      Sean Barrett: API design, optimizations
      Aras Pranckevicius: bugfix
      Nathan Reed: warning fixes

   REVISIONS
      0.97 (2020-02-02) fixed warning
      0.96 (2019-03-04) fixed warnings
      0.95 (2017-07-23) fixed warnings
      0.94 (2017-03-18) fixed warnings
      0.93 (2017-03-03) fixed bug with certain combinations of heights
      0.92 (2017-01-02) fix integer overflow on large (>2GB) images
      0.91 (2016-04-02) fix warnings; fix handling of subpixel regions
      0.90 (2014-09-17) first released version

   LICENSE
     See end of file for license information.

   TODO
      Don't decode all of the image data when only processing a partial tile
      Don't use full-width decode buffers when only processing a partial tile
      When processing wide images, break processing into tiles so data fits in L1 cache
      Installable filters?
      Resize that respects alpha test coverage
         (Reference code: FloatImage::alphaTestCoverage and FloatImage::scaleAlphaToCoverage:
         https://code.google.com/p/nvidia-texture-tools/source/browse/trunk/src/nvimage/FloatImage.cpp )
*/

#ifndef STBIR_INCLUDE_STB_IMAGE_RESIZE_H
#define STBIR_INCLUDE_STB_IMAGE_RESIZE_H

#ifdef _MSC_VER
typedef unsigned char  stbir_uint8;
typedef unsigned short stbir_uint16;
typedef unsigned int   stbir_uint32;
#else
#include <stdint.h>
typedef uint8_t  stbir_uint8;
typedef uint16_t stbir_uint16;
typedef uint32_t stbir_uint32;
#endif

#ifndef STBIRDEF
#ifdef STB_IMAGE_RESIZE_STATIC
#define STBIRDEF static
#else
#ifdef __cplusplus
#define STBIRDEF extern "C"
#else
#define STBIRDEF extern
#endif
#endif
#endif

//////////////////////////////////////////////////////////////////////////////
//
// Easy-to-use API:
//
//     * "input pixels" points to an array of image data with 'num_channels' channels (e.g. RGB=3, RGBA=4)
//     * input_w is input image width (x-axis), input_h is input image height (y-axis)
//     * stride is the offset between successive rows of image data in memory, in bytes. you can
//       specify 0 to mean packed continuously in memory
//     * alpha channel is treated identically to other channels.
//     * colorspace is linear or sRGB as specified by function name
//     * returned result is 1 for success or 0 in case of an error.
//       #define STBIR_ASSERT() to trigger an assert on parameter validation errors.
//     * Memory required grows approximately linearly with input and output size, but with
//       discontinuities at input_w == output_w and input_h == output_h.
//     * These functions use a "default" resampling filter defined at compile time. To change the filter,
//       you can change the compile-time defaults by #defining STBIR_DEFAULT_FILTER_UPSAMPLE
//       and STBIR_DEFAULT_FILTER_DOWNSAMPLE, or you can use the medium-complexity API.

STBIRDEF int stbir_resize_uint8(     const unsigned char *input_pixels , int input_w , int input_h , int input_stride_in_bytes,
                                           unsigned char *output_pixels, int output_w, int output_h, int output_stride_in_bytes,
                                     int num_channels);

STBIRDEF int stbir_resize_float(     const float *input_pixels , int input_w , int input_h , int input_stride_in_bytes,
                                           float *output_pixels, int output_w, int output_h, int output_stride_in_bytes,
                                     int num_channels);


// The following functions interpret image data as gamma-corrected sRGB.
// Specify STBIR_ALPHA_CHANNEL_NONE if you have no alpha channel,
// or otherwise provide the index of the alpha channel. Flags value
// of 0 will probably do the right thing if you're not sure what
// the flags mean.

#define STBIR_ALPHA_CHANNEL_NONE       -1

// Set this flag if your texture has premultiplied alpha. Otherwise, stbir will
// use alpha-weighted resampling (effectively premultiplying, resampling,
// then unpremultiplying).
#define STBIR_FLAG_ALPHA_PREMULTIPLIED    (1 << 0)
// The specified alpha channel should be handled as gamma-corrected value even
// when doing sRGB operations.
#define STBIR_FLAG_ALPHA_USES_COLORSPACE  (1 << 1)

STBIRDEF int stbir_resize_uint8_srgb(const unsigned char *input_pixels , int input_w , int input_h , int input_stride_in_bytes,
                                           unsigned char *output_pixels, int output_w, int output_h, int output_stride_in_bytes,
                                     int num_channels, int alpha_channel, int flags);


typedef enum
{
    STBIR_EDGE_CLAMP   = 1,
    STBIR_EDGE_REFLECT = 2,
    STBIR_EDGE_WRAP    = 3,
    STBIR_EDGE_ZERO    = 4,
} stbir_edge;

// This function adds the ability to specify how requests to sample off the edge of the image are handled.
STBIRDEF int stbir_resize_uint8_srgb_edgemode(const unsigned char *input_pixels , int input_w , int input_h , int input_stride_in_bytes,
                                                    unsigned char *output_pixels, int output_w, int output_h, int output_stride_in_bytes,
                                              int num_channels, int alpha_channel, int flags,
                                              stbir_edge edge_wrap_mode);

//////////////////////////////////////////////////////////////////////////////
//
// Medium-complexity API
//
// This extends the easy-to-use API as follows:
//
//     * Alpha-channel can be processed separately
//       * If alpha_channel is not STBIR_ALPHA_CHANNEL_NONE
//         * Alpha channel will not be gamma corrected (unless flags&STBIR_FLAG_GAMMA_CORRECT)
//         * Filters will be weighted by alpha channel (unless flags&STBIR_FLAG_ALPHA_PREMULTIPLIED)
//     * Filter can be selected explicitly
//     * uint16 image type
//     * sRGB colorspace available for all types
//     * context parameter for passing to STBIR_MALLOC

typedef enum
{
    STBIR_FILTER_DEFAULT      = 0,  // use same filter type that easy-to-use API chooses
    STBIR_FILTER_BOX          = 1,  // A trapezoid w/1-pixel wide ramps, same result as box for integer scale ratios
    STBIR_FILTER_TRIANGLE     = 2,  // On upsampling, produces same results as bilinear texture filtering
    STBIR_FILTER_CUBICBSPLINE = 3,  // The cubic b-spline (aka Mitchell-Netrevalli with B=1,C=0), gaussian-esque
    STBIR_FILTER_CATMULLROM   = 4,  // An interpolating cubic spline
    STBIR_FILTER_MITCHELL     = 5,  // Mitchell-Netrevalli filter with B=1/3, C=1/3
} stbir_filter;

typedef enum
{
    STBIR_COLORSPACE_LINEAR,
    STBIR_COLORSPACE_SRGB,

    STBIR_MAX_COLORSPACES,
} stbir_colorspace;

// The following functions are all identical except for the type of the image data

STBIRDEF int stbir_resize_uint8_generic( const unsigned char *input_pixels , int input_w , int input_h , int input_stride_in_bytes,
                                               unsigned char *output_pixels, int output_w, int output_h, int output_stride_in_bytes,
                                         int num_channels, int alpha_channel, int flags,
                                         stbir_edge edge_wrap_mode, stbir_filter filter, stbir_colorspace space,
                                         void *alloc_context);

STBIRDEF int stbir_resize_uint16_generic(const stbir_uint16 *input_pixels  , int input_w , int input_h , int input_stride_in_bytes,
                                               stbir_uint16 *output_pixels , int output_w, int output_h, int output_stride_in_bytes,
                                         int num_channels, int alpha_channel, int flags,
                                         stbir_edge edge_wrap_mode, stbir_filter filter, stbir_colorspace space,
                                         void *alloc_context);

STBIRDEF int stbir_resize_float_generic( const float *input_pixels         , int input_w , int input_h , int input_stride_in_bytes,
                                               float *output_pixels        , int output_w, int output_h, int output_stride_in_bytes,
                                         int num_channels, int alpha_channel, int flags,
                                         stbir_edge edge_wrap_mode, stbir_filter filter, stbir_colorspace space,
                                         void *alloc_context);



//////////////////////////////////////////////////////////////////////////////
//
// Full-complexity API
//
// This extends the medium API as follows:
//
//       * uint32 image type
//     * not typesafe
//     * separate filter types for each axis
//     * separate edge modes for each axis
//     * can specify scale explicitly for subpixel correctness
//     * can specify image source tile using texture coordinates

typedef enum
{
    STBIR_TYPE_UINT8 ,
    STBIR_TYPE_UINT16,
    STBIR_TYPE_UINT32,
    STBIR_TYPE_FLOAT ,

    STBIR_MAX_TYPES
} stbir_datatype;

STBIRDEF int stbir_resize(         const void *input_pixels , int input_w , int input_h , int input_stride_in_bytes,
                                         void *output_pixels, int output_w, int output_h, int output_stride_in_bytes,
                                   stbir_datatype datatype,
                                   int num_channels, int alpha_channel, int flags,
                                   stbir_edge edge_mode_horizontal, stbir_edge edge_mode_vertical,
                                   stbir_filter filter_horizontal,  stbir_filter filter_vertical,
                                   stbir_colorspace space, void *alloc_context);

STBIRDEF int stbir_resize_subpixel(const void *input_pixels , int input_w , int input_h , int input_stride_in_bytes,
                                         void *output_pixels, int output_w, int output_h, int output_stride_in_bytes,
                                   stbir_datatype datatype,
                                   int num_channels, int alpha_channel, int flags,
                                   stbir_edge edge_mode_horizontal, stbir_edge edge_mode_vertical,
                                   stbir_filter filter_horizontal,  stbir_filter filter_vertical,
                                   stbir_colorspace space, void *alloc_context,
                                   float x_scale, float y_scale,
                                   float x_offset, float y_offset);

STBIRDEF int stbir_resize_region(  const void *input_pixels , int input_w , int input_h , int input_stride_in_bytes,
                                         void *output_pixels, int output_w, int output_h, int output_stride_in_bytes,
                                   stbir_datatype datatype,
                                   int num_channels, int alpha_channel, int flags,
                                   stbir_edge edge_mode_horizontal, stbir_edge edge_mode_vertical,
                                   stbir_filter filter_horizontal,  stbir_filter filter_vertical,
                                   stbir_colorspace space, void *alloc_context,
                                   float s0, float t0, float s1, float t1);
// (s0, t0) & (s1, t1) are the top-left and bottom right corner (uv addressing style: [0, 1]x[0, 1]) of a region of the input image to use.

//
//
////   end header file   /////////////////////////////////////////////////////
#endif // STBIR_INCLUDE_STB_IMAGE_RESIZE_H





#ifdef STB_IMAGE_RESIZE_IMPLEMENTATION

#ifndef STBIR_ASSERT
#include <assert.h>
#define STBIR_ASSERT(x) assert(x)
#endif

// For memset
#include <string.h>

#include <math.h>

#ifndef STBIR_MALLOC
#include <stdlib.h>
// use comma operator to evaluate c, to avoid "unused parameter" warnings
#define STBIR_MALLOC(size,c) ((void)(c), malloc(size))
#define STBIR_FREE(ptr,c)    ((void)(c), free(ptr))
#endif

#ifndef _MSC_VER
#ifdef __cplusplus
#define stbir__inline inline
#else
#define stbir__inline
#endif
#else
#define stbir__inline __forceinline
#endif


// should produce compiler error if size is wrong
typedef unsigned char stbir__validate_uint32[sizeof(stbir_uint32) == 4 ? 1 : -1];

#ifdef _MSC_VER
#define STBIR__NOTUSED(v)  (void)(v)
#else
#define STBIR__NOTUSED(v)  (void)sizeof(v)
#endif

#define STBIR__ARRAY_SIZE(a) (sizeof((a))/sizeof((a)[0]))

#ifndef STBIR_DEFAULT_FILTER_UPSAMPLE
#define STBIR_DEFAULT_FILTER_UPSAMPLE    STBIR_FILTER_CATMULLROM
#endif

#ifndef STBIR_DEFAULT_FILTER_DOWNSAMPLE
#define STBIR_DEFAULT_FILTER_DOWNSAMPLE  STBIR_FILTER_MITCHELL
#endif

#ifndef STBIR_PROGRESS_REPORT
#define STBIR_PROGRESS_REPORT(float_0_to_1)
#endif

#ifndef STBIR_MAX_CHANNELS
#define STBIR_MAX_CHANNELS 64
#endif

#if STBIR_MAX_CHANNELS > 65536
#error "Too many channels; STBIR_MAX_CHANNELS must be no more than 65536."
// because we store the indices in 16-bit variables
#endif

// This value is added to alpha just before premultiplication to avoid
// zeroing out color values. It is equivalent to 2^-80. If you don't want
// that behavior (it may interfere if you have floating point images with
// very small alpha values) then you can define STBIR_NO_ALPHA_EPSILON to
// disable it.
#ifndef STBIR_ALPHA_EPSILON
#define STBIR_ALPHA_EPSILON ((float)1 / (1 << 20) / (1 << 20) / (1 << 20) / (1 << 20))
#endif



#ifdef _MSC_VER
#define STBIR__UNUSED_PARAM(v)  (void)(v)
#else
#define STBIR__UNUSED_PARAM(v)  (void)sizeof(v)
#endif

// must match stbir_datatype
static unsigned char stbir__type_size[] = {
    1, // STBIR_TYPE_UINT8
    2, // STBIR_TYPE_UINT16
    4, // STBIR_TYPE_UINT32
    4, // STBIR_TYPE_FLOAT
};

// Kernel function centered at 0
typedef float (stbir__kernel_fn)(float x, float scale);
typedef float (stbir__support_fn)(float scale);

typedef struct
{
    stbir__kernel_fn* kernel;
    stbir__support_fn* support;
} stbir__filter_info;

// When upsampling, the contributors are which source pixels contribute.
// When downsampling, the contributors are which destination pixels are contributed to.
typedef struct
{
    int n0; // First contributing pixel
    int n1; // Last contributing pixel
} stbir__contributors;

typedef struct
{
    const void* input_data;
    int input_w;
    int input_h;
    int input_stride_bytes;

    void* output_data;
    int output_w;
    int output_h;
    int output_stride_bytes;

    float s0, t0, s1, t1;

    float horizontal_shift; // Units: output pixels
    float vertical_shift;   // Units: output pixels
    float horizontal_scale;
    float vertical_scale;

    int channels;
    int alpha_channel;
    stbir_uint32 flags;
    stbir_datatype type;
    stbir_filter horizontal_filter;
    stbir_filter vertical_filter;
    stbir_edge edge_horizontal;
    stbir_edge edge_vertical;
    stbir_colorspace colorspace;

    stbir__contributors* horizontal_contributors;
    float* horizontal_coefficients;

    stbir__contributors* vertical_contributors;
    float* vertical_coefficients;

    int decode_buffer_pixels;
    float* decode_buffer;

    float* horizontal_buffer;

    // cache these because ceil/floor are inexplicably showing up in profile
    int horizontal_coefficient_width;
    int vertical_coefficient_width;
    int horizontal_filter_pixel_width;
    int vertical_filter_pixel_width;
    int horizontal_filter_pixel_margin;
    int vertical_filter_pixel_margin;
    int horizontal_num_contributors;
    int vertical_num_contributors;

    int ring_buffer_length_bytes;   // The length of an individual entry in the ring buffer. The total number of ring buffers is stbir__get_filter_pixel_width(filter)
    int ring_buffer_num_entries;    // Total number of entries in the ring buffer.
    int ring_buffer_first_scanline;
    int ring_buffer_last_scanline;
    int ring_buffer_begin_index;    // first_scanline is at this index in the ring buffer
    float* ring_buffer;

    float* encode_buffer; // A temporary buffer to store floats so we don't lose precision while we do multiply-adds.

    int horizontal_contributors_size;
    int horizontal_coefficients_size;
    int vertical_contributors_size;
    int vertical_coefficients_size;
    int decode_buffer_size;
    int horizontal_buffer_size;
    int ring_buffer_size;
    int encode_buffer_size;
} stbir__info;


static const float stbir__max_uint8_as_float  = 255.0f;
static const float stbir__max_uint16_as_float = 65535.0f;
static const double stbir__max_uint32_as_float = 4294967295.0;


static stbir__inline int stbir__min(int a, int b)
{
    return a < b ? a : b;
}

static stbir__inline float stbir__saturate(float x)
{
    if (x < 0)
        return 0;

    if (x > 1)
        return 1;

    return x;
}

#ifdef STBIR_SATURATE_INT
static stbir__inline stbir_uint8 stbir__saturate8(int x)
{
    if ((unsigned int) x <= 255)
        return x;

    if (x < 0)
        return 0;

    return 255;
}

static stbir__inline stbir_uint16 stbir__saturate16(int x)
{
    if ((unsigned int) x <= 65535)
        return x;

    if (x < 0)
        return 0;

    return 65535;
}
#endif

static float stbir__srgb_uchar_to_linear_float[256] = {
    0.000000f, 0.000304f, 0.000607f, 0.000911f, 0.001214f, 0.001518f, 0.001821f, 0.002125f, 0.002428f, 0.002732f, 0.003035f,
    0.003347f, 0.003677f, 0.004025f, 0.004391f, 0.004777f, 0.005182f, 0.005605f, 0.006049f, 0.006512f, 0.006995f, 0.007499f,
    0.008023f, 0.008568f, 0.009134f, 0.009721f, 0.010330f, 0.010960f, 0.011612f, 0.012286f, 0.012983f, 0.013702f, 0.014444f,
    0.015209f, 0.015996f, 0.016807f, 0.017642f, 0.018500f, 0.019382f, 0.020289f, 0.021219f, 0.022174f, 0.023153f, 0.024158f,
    0.025187f, 0.026241f, 0.027321f, 0.028426f, 0.029557f, 0.030713f, 0.031896f, 0.033105f, 0.034340f, 0.035601f, 0.036889f,
    0.038204f, 0.039546f, 0.040915f, 0.042311f, 0.043735f, 0.045186f, 0.046665f, 0.048172f, 0.049707f, 0.051269f, 0.052861f,
    0.054480f, 0.056128f, 0.057805f, 0.059511f, 0.061246f, 0.063010f, 0.064803f, 0.066626f, 0.068478f, 0.070360f, 0.072272f,
    0.074214f, 0.076185f, 0.078187f, 0.080220f, 0.082283f, 0.084376f, 0.086500f, 0.088656f, 0.090842f, 0.093059f, 0.095307f,
    0.097587f, 0.099899f, 0.102242f, 0.104616f, 0.107023f, 0.109462f, 0.111932f, 0.114435f, 0.116971f, 0.119538f, 0.122139f,
    0.124772f, 0.127438f, 0.130136f, 0.132868f, 0.135633f, 0.138432f, 0.141263f, 0.144128f, 0.147027f, 0.149960f, 0.152926f,
    0.155926f, 0.158961f, 0.162029f, 0.165132f, 0.168269f, 0.171441f, 0.174647f, 0.177888f, 0.181164f, 0.184475f, 0.187821f,
    0.191202f, 0.194618f, 0.198069f, 0.201556f, 0.205079f, 0.208637f, 0.212231f, 0.215861f, 0.219526f, 0.223228f, 0.226966f,
    0.230740f, 0.234551f, 0.238398f, 0.242281f, 0.246201f, 0.250158f, 0.254152f, 0.258183f, 0.262251f, 0.266356f, 0.270498f,
    0.274677f, 0.278894f, 0.283149f, 0.287441f, 0.291771f, 0.296138f, 0.300544f, 0.304987f, 0.309469f, 0.313989f, 0.318547f,
    0.323143f, 0.327778f, 0.332452f, 0.337164f, 0.341914f, 0.346704f, 0.351533f, 0.356400f, 0.361307f, 0.366253f, 0.371238f,
    0.376262f, 0.381326f, 0.386430f, 0.391573f, 0.396755f, 0.401978f, 0.407240f, 0.412543f, 0.417885f, 0.423268f, 0.428691f,
    0.434154f, 0.439657f, 0.445201f, 0.450786f, 0.456411f, 0.462077f, 0.467784f, 0.473532f, 0.479320f, 0.485150f, 0.491021f,
    0.496933f, 0.502887f, 0.508881f, 0.514918f, 0.520996f, 0.527115f, 0.533276f, 0.539480f, 0.545725f, 0.552011f, 0.558340f,
    0.564712f, 0.571125f, 0.577581f, 0.584078f, 0.590619f, 0.597202f, 0.603827f, 0.610496f, 0.617207f, 0.623960f, 0.630757f,
    0.637597f, 0.644480f, 0.651406f, 0.658375f, 0.665387f, 0.672443f, 0.679543f, 0.686685f, 0.693872f, 0.701102f, 0.708376f,
    0.715694f, 0.723055f, 0.730461f, 0.737911f, 0.745404f, 0.752942f, 0.760525f, 0.768151f, 0.775822f, 0.783538f, 0.791298f,
    0.799103f, 0.806952f, 0.814847f, 0.822786f, 0.830770f, 0.838799f, 0.846873f, 0.854993f, 0.863157f, 0.871367f, 0.879622f,
    0.887923f, 0.896269f, 0.904661f, 0.913099f, 0.921582f, 0.930111f, 0.938686f, 0.947307f, 0.955974f, 0.964686f, 0.973445f,
    0.982251f, 0.991102f, 1.0f
};

static float stbir__srgb_to_linear(float f)
{
    if (f <= 0.04045f)
        return f / 12.92f;
    else
        return (float)pow((f + 0.055f) / 1.055f, 2.4f);
}

static float stbir__linear_to_srgb(float f)
{
    if (f <= 0.0031308f)
        return f * 12.92f;
    else
        return 1.055f * (float)pow(f, 1 / 2.4f) - 0.055f;
}

#ifndef STBIR_NON_IEEE_FLOAT
// From https://gist.github.com/rygorous/2203834

typedef union
{
    stbir_uint32 u;
    float f;
} stbir__FP32;

static const stbir_uint32 fp32_to_srgb8_tab4[104] = {
    0x0073000d, 0x007a000d, 0x0080000d, 0x0087000d, 0x008d000d, 0x0094000d, 0x009a000d, 0x00a1000d,
    0x00a7001a, 0x00b4001a, 0x00c1001a, 0x00ce001a, 0x00da001a, 0x00e7001a, 0x00f4001a, 0x0101001a,
    0x010e0033, 0x01280033, 0x01410033, 0x015b0033, 0x01750033, 0x018f0033, 0x01a80033, 0x01c20033,
    0x01dc0067, 0x020f0067, 0x02430067, 0x02760067, 0x02aa0067, 0x02dd0067, 0x03110067, 0x03440067,
    0x037800ce, 0x03df00ce, 0x044600ce, 0x04ad00ce, 0x051400ce, 0x057b00c5, 0x05dd00bc, 0x063b00b5,
    0x06970158, 0x07420142, 0x07e30130, 0x087b0120, 0x090b0112, 0x09940106, 0x0a1700fc, 0x0a9500f2,
    0x0b0f01cb, 0x0bf401ae, 0x0ccb0195, 0x0d950180, 0x0e56016e, 0x0f0d015e, 0x0fbc0150, 0x10630143,
    0x11070264, 0x1238023e, 0x1357021d, 0x14660201, 0x156601e9, 0x165a01d3, 0x174401c0, 0x182401af,
    0x18fe0331, 0x1a9602fe, 0x1c1502d2, 0x1d7e02ad, 0x1ed4028d, 0x201a0270, 0x21520256, 0x227d0240,
    0x239f0443, 0x25c003fe, 0x27bf03c4, 0x29a10392, 0x2b6a0367, 0x2d1d0341, 0x2ebe031f, 0x304d0300,
    0x31d105b0, 0x34a80555, 0x37520507, 0x39d504c5, 0x3c37048b, 0x3e7c0458, 0x40a8042a, 0x42bd0401,
    0x44c20798, 0x488e071e, 0x4c1c06b6, 0x4f76065d, 0x52a50610, 0x55ac05cc, 0x5892058f, 0x5b590559,
    0x5e0c0a23, 0x631c0980, 0x67db08f6, 0x6c55087f, 0x70940818, 0x74a007bd, 0x787d076c, 0x7c330723,
};

static stbir_uint8 stbir__linear_to_srgb_uchar(float in)
{
    static const stbir__FP32 almostone = { 0x3f7fffff }; // 1-eps
    static const stbir__FP32 minval = { (127-13) << 23 };
    stbir_uint32 tab,bias,scale,t;
    stbir__FP32 f;

    // Clamp to [2^(-13), 1-eps]; these two values map to 0 and 1, respectively.
    // The tests are carefully written so that NaNs map to 0, same as in the reference
    // implementation.
    if (!(in > minval.f)) // written this way to catch NaNs
        in = minval.f;
    if (in > almostone.f)
        in = almostone.f;

    // Do the table lookup and unpack bias, scale
    f.f = in;
    tab = fp32_to_srgb8_tab4[(f.u - minval.u) >> 20];
    bias = (tab >> 16) << 9;
    scale = tab & 0xffff;

    // Grab next-highest mantissa bits and perform linear interpolation
    t = (f.u >> 12) & 0xff;
    return (unsigned char) ((bias + scale*t) >> 16);
}

#else
// sRGB transition values, scaled by 1<<28
static int stbir__srgb_offset_to_linear_scaled[256] =
{
            0,     40738,    122216,    203693,    285170,    366648,    448125,    529603,
       611080,    692557,    774035,    855852,    942009,   1033024,   1128971,   1229926,
      1335959,   1447142,   1563542,   1685229,   1812268,   1944725,   2082664,   2226148,
      2375238,   2529996,   2690481,   2856753,   3028870,   3206888,   3390865,   3580856,
      3776916,   3979100,   4187460,   4402049,   4622919,   4850123,   5083710,   5323731,
      5570236,   5823273,   6082892,   6349140,   6622065,   6901714,   7188133,   7481369,
      7781466,   8088471,   8402427,   8723380,   9051372,   9386448,   9728650,  10078021,
     10434603,  10798439,  11169569,  11548036,  11933879,  12327139,  12727857,  13136073,
     13551826,  13975156,  14406100,  14844697,  15290987,  15745007,  16206795,  16676389,
     17153826,  17639142,  18132374,  18633560,  19142734,  19659934,  20185196,  20718552,
     21260042,  21809696,  22367554,  22933648,  23508010,  24090680,  24681686,  25281066,
     25888850,  26505076,  27129772,  27762974,  28404716,  29055026,  29713942,  30381490,
     31057708,  31742624,  32436272,  33138682,  33849884,  34569912,  35298800,  36036568,
     36783260,  37538896,  38303512,  39077136,  39859796,  40651528,  41452360,  42262316,
     43081432,  43909732,  44747252,  45594016,  46450052,  47315392,  48190064,  49074096,
     49967516,  50870356,  51782636,  52704392,  53635648,  54576432,  55526772,  56486700,
     57456236,  58435408,  59424248,  60422780,  61431036,  62449032,  63476804,  64514376,
     65561776,  66619028,  67686160,  68763192,  69850160,  70947088,  72053992,  73170912,
     74297864,  75434880,  76581976,  77739184,  78906536,  80084040,  81271736,  82469648,
     83677792,  84896192,  86124888,  87363888,  88613232,  89872928,  91143016,  92423512,
     93714432,  95015816,  96327688,  97650056,  98982952, 100326408, 101680440, 103045072,
    104420320, 105806224, 107202800, 108610064, 110028048, 111456776, 112896264, 114346544,
    115807632, 117279552, 118762328, 120255976, 121760536, 123276016, 124802440, 126339832,
    127888216, 129447616, 131018048, 132599544, 134192112, 135795792, 137410592, 139036528,
    140673648, 142321952, 143981456, 145652208, 147334208, 149027488, 150732064, 152447968,
    154175200, 155913792, 157663776, 159425168, 161197984, 162982240, 164777968, 166585184,
    168403904, 170234160, 172075968, 173929344, 175794320, 177670896, 179559120, 181458992,
    183370528, 185293776, 187228736, 189175424, 191133888, 193104112, 195086128, 197079968,
    199085648, 201103184, 203132592, 205173888, 207227120, 209292272, 211369392, 213458480,
    215559568, 217672656, 219797792, 221934976, 224084240, 226245600, 228419056, 230604656,
    232802400, 235012320, 237234432, 239468736, 241715280, 243974080, 246245120, 248528464,
    250824112, 253132064, 255452368, 257785040, 260130080, 262487520, 264857376, 267239664,
};

static stbir_uint8 stbir__linear_to_srgb_uchar(float f)
{
    int x = (int) (f * (1 << 28)); // has headroom so you don't need to clamp
    int v = 0;
    int i;

    // Refine the guess with a short binary search.
    i = v + 128; if (x >= stbir__srgb_offset_to_linear_scaled[i]) v = i;
    i = v +  64; if (x >= stbir__srgb_offset_to_linear_scaled[i]) v = i;
    i = v +  32; if (x >= stbir__srgb_offset_to_linear_scaled[i]) v = i;
    i = v +  16; if (x >= stbir__srgb_offset_to_linear_scaled[i]) v = i;
    i = v +   8; if (x >= stbir__srgb_offset_to_linear_scaled[i]) v = i;
    i = v +   4; if (x >= stbir__srgb_offset_to_linear_scaled[i]) v = i;
    i = v +   2; if (x >= stbir__srgb_offset_to_linear_scaled[i]) v = i;
    i = v +   1; if (x >= stbir__srgb_offset_to_linear_scaled[i]) v = i;

    return (stbir_uint8) v;
}
#endif

static float stbir__filter_trapezoid(float x, float scale)
{
    float halfscale = scale / 2;
    float t = 0.5f + halfscale;
    STBIR_ASSERT(scale <= 1);

    x = (float)fabs(x);

    if (x >= t)
        return 0;
    else
    {
        float r = 0.5f - halfscale;
        if (x <= r)
            return 1;
        else
            return (t - x) / scale;
    }
}

static float stbir__support_trapezoid(float scale)
{
    STBIR_ASSERT(scale <= 1);
    return 0.5f + scale / 2;
}

static float stbir__filter_triangle(float x, float s)
{
    STBIR__UNUSED_PARAM(s);

    x = (float)fabs(x);

    if (x <= 1.0f)
        return 1 - x;
    else
        return 0;
}

static float stbir__filter_cubic(float x, float s)
{
    STBIR__UNUSED_PARAM(s);

    x = (float)fabs(x);

    if (x < 1.0f)
        return (4 + x*x*(3*x - 6))/6;
    else if (x < 2.0f)
        return (8 + x*(-12 + x*(6 - x)))/6;

    return (0.0f);
}

static float stbir__filter_catmullrom(float x, float s)
{
    STBIR__UNUSED_PARAM(s);

    x = (float)fabs(x);

    if (x < 1.0f)
        return 1 - x*x*(2.5f - 1.5f*x);
    else if (x < 2.0f)
        return 2 - x*(4 + x*(0.5f*x - 2.5f));

    return (0.0f);
}

static float stbir__filter_mitchell(float x, float s)
{
    STBIR__UNUSED_PARAM(s);

    x = (float)fabs(x);

    if (x < 1.0f)
        return (16 + x*x*(21 * x - 36))/18;
    else if (x < 2.0f)
        return (32 + x*(-60 + x*(36 - 7*x)))/18;

    return (0.0f);
}

static float stbir__support_zero(float s)
{
    STBIR__UNUSED_PARAM(s);
    return 0;
}

static float stbir__support_one(float s)
{
    STBIR__UNUSED_PARAM(s);
    return 1;
}

static float stbir__support_two(float s)
{
    STBIR__UNUSED_PARAM(s);
    return 2;
}

static stbir__filter_info stbir__filter_info_table[] = {
        { NULL,                     stbir__support_zero },
        { stbir__filter_trapezoid,  stbir__support_trapezoid },
        { stbir__filter_triangle,   stbir__support_one },
        { stbir__filter_cubic,      stbir__support_two },
        { stbir__filter_catmullrom, stbir__support_two },
        { stbir__filter_mitchell,   stbir__support_two },
};

stbir__inline static int stbir__use_upsampling(float ratio)
{
    return ratio > 1;
}

stbir__inline static int stbir__use_width_upsampling(stbir__info* stbir_info)
{
    return stbir__use_upsampling(stbir_info->horizontal_scale);
}

stbir__inline static int stbir__use_height_upsampling(stbir__info* stbir_info)
{
    return stbir__use_upsampling(stbir_info->vertical_scale);
}

// This is the maximum number of input samples that can affect an output sample
// with the given filter
static int stbir__get_filter_pixel_width(stbir_filter filter, float scale)
{
    STBIR_ASSERT(filter != 0);
    STBIR_ASSERT(filter < STBIR__ARRAY_SIZE(stbir__filter_info_table));

    if (stbir__use_upsampling(scale))
        return (int)ceil(stbir__filter_info_table[filter].support(1/scale) * 2);
    else
        return (int)ceil(stbir__filter_info_table[filter].support(scale) * 2 / scale);
}

// This is how much to expand buffers to account for filters seeking outside
// the image boundaries.
static int stbir__get_filter_pixel_margin(stbir_filter filter, float scale)
{
    return stbir__get_filter_pixel_width(filter, scale) / 2;
}

static int stbir__get_coefficient_width(stbir_filter filter, float scale)
{
    if (stbir__use_upsampling(scale))
        return (int)ceil(stbir__filter_info_table[filter].support(1 / scale) * 2);
    else
        return (int)ceil(stbir__filter_info_table[filter].support(scale) * 2);
}

static int stbir__get_contributors(float scale, stbir_filter filter, int input_size, int output_size)
{
    if (stbir__use_upsampling(scale))
        return output_size;
    else
        return (input_size + stbir__get_filter_pixel_margin(filter, scale) * 2);
}

static int stbir__get_total_horizontal_coefficients(stbir__info* info)
{
    return info->horizontal_num_contributors
         * stbir__get_coefficient_width      (info->horizontal_filter, info->horizontal_scale);
}

static int stbir__get_total_vertical_coefficients(stbir__info* info)
{
    return info->vertical_num_contributors
         * stbir__get_coefficient_width      (info->vertical_filter, info->vertical_scale);
}

static stbir__contributors* stbir__get_contributor(stbir__contributors* contributors, int n)
{
    return &contributors[n];
}

// For perf reasons this code is duplicated in stbir__resample_horizontal_upsample/downsample,
// if you change it here change it there too.
static float* stbir__get_coefficient(float* coefficients, stbir_filter filter, float scale, int n, int c)
{
    int width = stbir__get_coefficient_width(filter, scale);
    return &coefficients[width*n + c];
}

static int stbir__edge_wrap_slow(stbir_edge edge, int n, int max)
{
    switch (edge)
    {
    case STBIR_EDGE_ZERO:
        return 0; // we'll decode the wrong pixel here, and then overwrite with 0s later

    case STBIR_EDGE_CLAMP:
        if (n < 0)
            return 0;

        if (n >= max)
            return max - 1;

        return n; // NOTREACHED

    case STBIR_EDGE_REFLECT:
    {
        if (n < 0)
        {
            if (n < max)
                return -n;
            else
                return max - 1;
        }

        if (n >= max)
        {
            int max2 = max * 2;
            if (n >= max2)
                return 0;
            else
                return max2 - n - 1;
        }

        return n; // NOTREACHED
    }

    case STBIR_EDGE_WRAP:
        if (n >= 0)
            return (n % max);
        else
        {
            int m = (-n) % max;

            if (m != 0)
                m = max - m;

            return (m);
        }
        // NOTREACHED

    default:
        STBIR_ASSERT(!"Unimplemented edge type");
        return 0;
    }
}

stbir__inline static int stbir__edge_wrap(stbir_edge edge, int n, int max)
{
    // avoid per-pixel switch
    if (n >= 0 && n < max)
        return n;
    return stbir__edge_wrap_slow(edge, n, max);
}

// What input pixels contribute to this output pixel?
static void stbir__calculate_sample_range_upsample(int n, float out_filter_radius, float scale_ratio, float out_shift, int* in_first_pixel, int* in_last_pixel, float* in_center_of_out)
{
    float out_pixel_center = (float)n + 0.5f;
    float out_pixel_influence_lowerbound = out_pixel_center - out_filter_radius;
    float out_pixel_influence_upperbound = out_pixel_center + out_filter_radius;

    float in_pixel_influence_lowerbound = (out_pixel_influence_lowerbound + out_shift) / scale_ratio;
    float in_pixel_influence_upperbound = (out_pixel_influence_upperbound + out_shift) / scale_ratio;

    *in_center_of_out = (out_pixel_center + out_shift) / scale_ratio;
    *in_first_pixel = (int)(floor(in_pixel_influence_lowerbound + 0.5));
    *in_last_pixel = (int)(floor(in_pixel_influence_upperbound - 0.5));
}

// What output pixels does this input pixel contribute to?
static void stbir__calculate_sample_range_downsample(int n, float in_pixels_radius, float scale_ratio, float out_shift, int* out_first_pixel, int* out_last_pixel, float* out_center_of_in)
{
    float in_pixel_center = (float)n + 0.5f;
    float in_pixel_influence_lowerbound = in_pixel_center - in_pixels_radius;
    float in_pixel_influence_upperbound = in_pixel_center + in_pixels_radius;

    float out_pixel_influence_lowerbound = in_pixel_influence_lowerbound * scale_ratio - out_shift;
    float out_pixel_influence_upperbound = in_pixel_influence_upperbound * scale_ratio - out_shift;

    *out_center_of_in = in_pixel_center * scale_ratio - out_shift;
    *out_first_pixel = (int)(floor(out_pixel_influence_lowerbound + 0.5));
    *out_last_pixel = (int)(floor(out_pixel_influence_upperbound - 0.5));
}

static void stbir__calculate_coefficients_upsample(stbir_filter filter, float scale, int in_first_pixel, int in_last_pixel, float in_center_of_out, stbir__contributors* contributor, float* coefficient_group)
{
    int i;
    float total_filter = 0;
    float filter_scale;

    STBIR_ASSERT(in_last_pixel - in_first_pixel <= (int)ceil(stbir__filter_info_table[filter].support(1/scale) * 2)); // Taken directly from stbir__get_coefficient_width() which we can't call because we don't know if we're horizontal or vertical.

    contributor->n0 = in_first_pixel;
    contributor->n1 = in_last_pixel;

    STBIR_ASSERT(contributor->n1 >= contributor->n0);

    for (i = 0; i <= in_last_pixel - in_first_pixel; i++)
    {
        float in_pixel_center = (float)(i + in_first_pixel) + 0.5f;
        coefficient_group[i] = stbir__filter_info_table[filter].kernel(in_center_of_out - in_pixel_center, 1 / scale);

        // If the coefficient is zero, skip it. (Don't do the <0 check here, we want the influence of those outside pixels.)
        if (i == 0 && !coefficient_group[i])
        {
            contributor->n0 = ++in_first_pixel;
            i--;
            continue;
        }

        total_filter += coefficient_group[i];
    }

    STBIR_ASSERT(stbir__filter_info_table[filter].kernel((float)(in_last_pixel + 1) + 0.5f - in_center_of_out, 1/scale) == 0);

    STBIR_ASSERT(total_filter > 0.9);
    STBIR_ASSERT(total_filter < 1.1f); // Make sure it's not way off.

    // Make sure the sum of all coefficients is 1.
    filter_scale = 1 / total_filter;

    for (i = 0; i <= in_last_pixel - in_first_pixel; i++)
        coefficient_group[i] *= filter_scale;

    for (i = in_last_pixel - in_first_pixel; i >= 0; i--)
    {
        if (coefficient_group[i])
            break;

        // This line has no weight. We can skip it.
        contributor->n1 = contributor->n0 + i - 1;
    }
}

static void stbir__calculate_coefficients_downsample(stbir_filter filter, float scale_ratio, int out_first_pixel, int out_last_pixel, float out_center_of_in, stbir__contributors* contributor, float* coefficient_group)
{
    int i;

     STBIR_ASSERT(out_last_pixel - out_first_pixel <= (int)ceil(stbir__filter_info_table[filter].support(scale_ratio) * 2)); // Taken directly from stbir__get_coefficient_width() which we can't call because we don't know if we're horizontal or vertical.

    contributor->n0 = out_first_pixel;
    contributor->n1 = out_last_pixel;

    STBIR_ASSERT(contributor->n1 >= contributor->n0);

    for (i = 0; i <= out_last_pixel - out_first_pixel; i++)
    {
        float out_pixel_center = (float)(i + out_first_pixel) + 0.5f;
        float x = out_pixel_center - out_center_of_in;
        coefficient_group[i] = stbir__filter_info_table[filter].kernel(x, scale_ratio) * scale_ratio;
    }

    STBIR_ASSERT(stbir__filter_info_table[filter].kernel((float)(out_last_pixel + 1) + 0.5f - out_center_of_in, scale_ratio) == 0);

    for (i = out_last_pixel - out_first_pixel; i >= 0; i--)
    {
        if (coefficient_group[i])
            break;

        // This line has no weight. We can skip it.
        contributor->n1 = contributor->n0 + i - 1;
    }
}

static void stbir__normalize_downsample_coefficients(stbir__contributors* contributors, float* coefficients, stbir_filter filter, float scale_ratio, int input_size, int output_size)
{
    int num_contributors = stbir__get_contributors(scale_ratio, filter, input_size, output_size);
    int num_coefficients = stbir__get_coefficient_width(filter, scale_ratio);
    int i, j;
    int skip;

    for (i = 0; i < output_size; i++)
    {
        float scale;
        float total = 0;

        for (j = 0; j < num_contributors; j++)
        {
            if (i >= contributors[j].n0 && i <= contributors[j].n1)
            {
                float coefficient = *stbir__get_coefficient(coefficients, filter, scale_ratio, j, i - contributors[j].n0);
                total += coefficient;
            }
            else if (i < contributors[j].n0)
                break;
        }

        STBIR_ASSERT(total > 0.9f);
        STBIR_ASSERT(total < 1.1f);

        scale = 1 / total;

        for (j = 0; j < num_contributors; j++)
        {
            if (i >= contributors[j].n0 && i <= contributors[j].n1)
                *stbir__get_coefficient(coefficients, filter, scale_ratio, j, i - contributors[j].n0) *= scale;
            else if (i < contributors[j].n0)
                break;
        }
    }

    // Optimize: Skip zero coefficients and contributions outside of image bounds.
    // Do this after normalizing because normalization depends on the n0/n1 values.
    for (j = 0; j < num_contributors; j++)
    {
        int range, max, width;

        skip = 0;
        while (*stbir__get_coefficient(coefficients, filter, scale_ratio, j, skip) == 0)
            skip++;

        contributors[j].n0 += skip;

        while (contributors[j].n0 < 0)
        {
            contributors[j].n0++;
            skip++;
        }

        range = contributors[j].n1 - contributors[j].n0 + 1;
        max = stbir__min(num_coefficients, range);

        width = stbir__get_coefficient_width(filter, scale_ratio);
        for (i = 0; i < max; i++)
        {
            if (i + skip >= width)
                break;

            *stbir__get_coefficient(coefficients, filter, scale_ratio, j, i) = *stbir__get_coefficient(coefficients, filter, scale_ratio, j, i + skip);
        }

        continue;
    }

    // Using min to avoid writing into invalid pixels.
    for (i = 0; i < num_contributors; i++)
        contributors[i].n1 = stbir__min(contributors[i].n1, output_size - 1);
}

// Each scan line uses the same kernel values so we should calculate the kernel
// values once and then we can use them for every scan line.
static void stbir__calculate_filters(stbir__contributors* contributors, float* coefficients, stbir_filter filter, float scale_ratio, float shift, int input_size, int output_size)
{
    int n;
    int total_contributors = stbir__get_contributors(scale_ratio, filter, input_size, output_size);

    if (stbir__use_upsampling(scale_ratio))
    {
        float out_pixels_radius = stbir__filter_info_table[filter].support(1 / scale_ratio) * scale_ratio;

        // Looping through out pixels
        for (n = 0; n < total_contributors; n++)
        {
            float in_center_of_out; // Center of the current out pixel in the in pixel space
            int in_first_pixel, in_last_pixel;

            stbir__calculate_sample_range_upsample(n, out_pixels_radius, scale_ratio, shift, &in_first_pixel, &in_last_pixel, &in_center_of_out);

            stbir__calculate_coefficients_upsample(filter, scale_ratio, in_first_pixel, in_last_pixel, in_center_of_out, stbir__get_contributor(contributors, n), stbir__get_coefficient(coefficients, filter, scale_ratio, n, 0));
        }
    }
    else
    {
        float in_pixels_radius = stbir__filter_info_table[filter].support(scale_ratio) / scale_ratio;

        // Looping through in pixels
        for (n = 0; n < total_contributors; n++)
        {
            float out_center_of_in; // Center of the current out pixel in the in pixel space
            int out_first_pixel, out_last_pixel;
            int n_adjusted = n - stbir__get_filter_pixel_margin(filter, scale_ratio);

            stbir__calculate_sample_range_downsample(n_adjusted, in_pixels_radius, scale_ratio, shift, &out_first_pixel, &out_last_pixel, &out_center_of_in);

            stbir__calculate_coefficients_downsample(filter, scale_ratio, out_first_pixel, out_last_pixel, out_center_of_in, stbir__get_contributor(contributors, n), stbir__get_coefficient(coefficients, filter, scale_ratio, n, 0));
        }

        stbir__normalize_downsample_coefficients(contributors, coefficients, filter, scale_ratio, input_size, output_size);
    }
}

static float* stbir__get_decode_buffer(stbir__info* stbir_info)
{
    // The 0 index of the decode buffer starts after the margin. This makes
    // it okay to use negative indexes on the decode buffer.
    return &stbir_info->decode_buffer[stbir_info->horizontal_filter_pixel_margin * stbir_info->channels];
}

#define STBIR__DECODE(type, colorspace) ((int)(type) * (STBIR_MAX_COLORSPACES) + (int)(colorspace))

static void stbir__decode_scanline(stbir__info* stbir_info, int n)
{
    int c;
    int channels = stbir_info->channels;
    int alpha_channel = stbir_info->alpha_channel;
    int type = stbir_info->type;
    int colorspace = stbir_info->colorspace;
    int input_w = stbir_info->input_w;
    size_t input_stride_bytes = stbir_info->input_stride_bytes;
    float* decode_buffer = stbir__get_decode_buffer(stbir_info);
    stbir_edge edge_horizontal = stbir_info->edge_horizontal;
    stbir_edge edge_vertical = stbir_info->edge_vertical;
    size_t in_buffer_row_offset = stbir__edge_wrap(edge_vertical, n, stbir_info->input_h) * input_stride_bytes;
    const void* input_data = (char *) stbir_info->input_data + in_buffer_row_offset;
    int max_x = input_w + stbir_info->horizontal_filter_pixel_margin;
    int decode = STBIR__DECODE(type, colorspace);

    int x = -stbir_info->horizontal_filter_pixel_margin;

    // special handling for STBIR_EDGE_ZERO because it needs to return an item that doesn't appear in the input,
    // and we want to avoid paying overhead on every pixel if not STBIR_EDGE_ZERO
    if (edge_vertical == STBIR_EDGE_ZERO && (n < 0 || n >= stbir_info->input_h))
    {
        for (; x < max_x; x++)
            for (c = 0; c < channels; c++)
                decode_buffer[x*channels + c] = 0;
        return;
    }

    switch (decode)
    {
    case STBIR__DECODE(STBIR_TYPE_UINT8, STBIR_COLORSPACE_LINEAR):
        for (; x < max_x; x++)
        {
            int decode_pixel_index = x * channels;
            int input_pixel_index = stbir__edge_wrap(edge_horizontal, x, input_w) * channels;
            for (c = 0; c < channels; c++)
                decode_buffer[decode_pixel_index + c] = ((float)((const unsigned char*)input_data)[input_pixel_index + c]) / stbir__max_uint8_as_float;
        }
        break;

    case STBIR__DECODE(STBIR_TYPE_UINT8, STBIR_COLORSPACE_SRGB):
        for (; x < max_x; x++)
        {
            int decode_pixel_index = x * channels;
            int input_pixel_index = stbir__edge_wrap(edge_horizontal, x, input_w) * channels;
            for (c = 0; c < channels; c++)
                decode_buffer[decode_pixel_index + c] = stbir__srgb_uchar_to_linear_float[((const unsigned char*)input_data)[input_pixel_index + c]];

            if (!(stbir_info->flags&STBIR_FLAG_ALPHA_USES_COLORSPACE))
                decode_buffer[decode_pixel_index + alpha_channel] = ((float)((const unsigned char*)input_data)[input_pixel_index + alpha_channel]) / stbir__max_uint8_as_float;
        }
        break;

    case STBIR__DECODE(STBIR_TYPE_UINT16, STBIR_COLORSPACE_LINEAR):
        for (; x < max_x; x++)
        {
            int decode_pixel_index = x * channels;
            int input_pixel_index = stbir__edge_wrap(edge_horizontal, x, input_w) * channels;
            for (c = 0; c < channels; c++)
                decode_buffer[decode_pixel_index + c] = ((float)((const unsigned short*)input_data)[input_pixel_index + c]) / stbir__max_uint16_as_float;
        }
        break;

    case STBIR__DECODE(STBIR_TYPE_UINT16, STBIR_COLORSPACE_SRGB):
        for (; x < max_x; x++)
        {
            int decode_pixel_index = x * channels;
            int input_pixel_index = stbir__edge_wrap(edge_horizontal, x, input_w) * channels;
            for (c = 0; c < channels; c++)
                decode_buffer[decode_pixel_index + c] = stbir__srgb_to_linear(((float)((const unsigned short*)input_data)[input_pixel_index + c]) / stbir__max_uint16_as_float);

            if (!(stbir_info->flags&STBIR_FLAG_ALPHA_USES_COLORSPACE))
                decode_buffer[decode_pixel_index + alpha_channel] = ((float)((const unsigned short*)input_data)[input_pixel_index + alpha_channel]) / stbir__max_uint16_as_float;
        }
        break;

    case STBIR__DECODE(STBIR_TYPE_UINT32, STBIR_COLORSPACE_LINEAR):
        for (; x < max_x; x++)
        {
            int decode_pixel_index = x * channels;
            int input_pixel_index = stbir__edge_wrap(edge_horizontal, x, input_w) * channels;
            for (c = 0; c < channels; c++)
                decode_buffer[decode_pixel_index + c] = (float)(((double)((const unsigned int*)input_data)[input_pixel_index + c]) / stbir__max_uint32_as_float);
        }
        break;

    case STBIR__DECODE(STBIR_TYPE_UINT32, STBIR_COLORSPACE_SRGB):
        for (; x < max_x; x++)
        {
            int decode_pixel_index = x * channels;
            int input_pixel_index = stbir__edge_wrap(edge_horizontal, x, input_w) * channels;
            for (c = 0; c < channels; c++)
                decode_buffer[decode_pixel_index + c] = stbir__srgb_to_linear((float)(((double)((const unsigned int*)input_data)[input_pixel_index + c]) / stbir__max_uint32_as_float));

            if (!(stbir_info->flags&STBIR_FLAG_ALPHA_USES_COLORSPACE))
                decode_buffer[decode_pixel_index + alpha_channel] = (float)(((double)((const unsigned int*)input_data)[input_pixel_index + alpha_channel]) / stbir__max_uint32_as_float);
        }
        break;

    case STBIR__DECODE(STBIR_TYPE_FLOAT, STBIR_COLORSPACE_LINEAR):
        for (; x < max_x; x++)
        {
            int decode_pixel_index = x * channels;
            int input_pixel_index = stbir__edge_wrap(edge_horizontal, x, input_w) * channels;
            for (c = 0; c < channels; c++)
                decode_buffer[decode_pixel_index + c] = ((const float*)input_data)[input_pixel_index + c];
        }
        break;

    case STBIR__DECODE(STBIR_TYPE_FLOAT, STBIR_COLORSPACE_SRGB):
        for (; x < max_x; x++)
        {
            int decode_pixel_index = x * channels;
            int input_pixel_index = stbir__edge_wrap(edge_horizontal, x, input_w) * channels;
            for (c = 0; c < channels; c++)
                decode_buffer[decode_pixel_index + c] = stbir__srgb_to_linear(((const float*)input_data)[input_pixel_index + c]);

            if (!(stbir_info->flags&STBIR_FLAG_ALPHA_USES_COLORSPACE))
                decode_buffer[decode_pixel_index + alpha_channel] = ((const float*)input_data)[input_pixel_index + alpha_channel];
        }

        break;

    default:
        STBIR_ASSERT(!"Unknown type/colorspace/channels combination.");
        break;
    }

    if (!(stbir_info->flags & STBIR_FLAG_ALPHA_PREMULTIPLIED))
    {
        for (x = -stbir_info->horizontal_filter_pixel_margin; x < max_x; x++)
        {
            int decode_pixel_index = x * channels;

            // If the alpha value is 0 it will clobber the color values. Make sure it's not.
            float alpha = decode_buffer[decode_pixel_index + alpha_channel];
#ifndef STBIR_NO_ALPHA_EPSILON
            if (stbir_info->type != STBIR_TYPE_FLOAT) {
                alpha += STBIR_ALPHA_EPSILON;
                decode_buffer[decode_pixel_index + alpha_channel] = alpha;
            }
#endif
            for (c = 0; c < channels; c++)
            {
                if (c == alpha_channel)
                    continue;

                decode_buffer[decode_pixel_index + c] *= alpha;
            }
        }
    }

    if (edge_horizontal == STBIR_EDGE_ZERO)
    {
        for (x = -stbir_info->horizontal_filter_pixel_margin; x < 0; x++)
        {
            for (c = 0; c < channels; c++)
                decode_buffer[x*channels + c] = 0;
        }
        for (x = input_w; x < max_x; x++)
        {
            for (c = 0; c < channels; c++)
                decode_buffer[x*channels + c] = 0;
        }
    }
}

static float* stbir__get_ring_buffer_entry(float* ring_buffer, int index, int ring_buffer_length)
{
    return &ring_buffer[index * ring_buffer_length];
}

static float* stbir__add_empty_ring_buffer_entry(stbir__info* stbir_info, int n)
{
    int ring_buffer_index;
    float* ring_buffer;

    stbir_info->ring_buffer_last_scanline = n;

    if (stbir_info->ring_buffer_begin_index < 0)
    {
        ring_buffer_index = stbir_info->ring_buffer_begin_index = 0;
        stbir_info->ring_buffer_first_scanline = n;
    }
    else
    {
        ring_buffer_index = (stbir_info->ring_buffer_begin_index + (stbir_info->ring_buffer_last_scanline - stbir_info->ring_buffer_first_scanline)) % stbir_info->ring_buffer_num_entries;
        STBIR_ASSERT(ring_buffer_index != stbir_info->ring_buffer_begin_index);
    }

    ring_buffer = stbir__get_ring_buffer_entry(stbir_info->ring_buffer, ring_buffer_index, stbir_info->ring_buffer_length_bytes / sizeof(float));
    memset(ring_buffer, 0, stbir_info->ring_buffer_length_bytes);

    return ring_buffer;
}


static void stbir__resample_horizontal_upsample(stbir__info* stbir_info, float* output_buffer)
{
    int x, k;
    int output_w = stbir_info->output_w;
    int channels = stbir_info->channels;
    float* decode_buffer = stbir__get_decode_buffer(stbir_info);
    stbir__contributors* horizontal_contributors = stbir_info->horizontal_contributors;
    float* horizontal_coefficients = stbir_info->horizontal_coefficients;
    int coefficient_width = stbir_info->horizontal_coefficient_width;

    for (x = 0; x < output_w; x++)
    {
        int n0 = horizontal_contributors[x].n0;
        int n1 = horizontal_contributors[x].n1;

        int out_pixel_index = x * channels;
        int coefficient_group = coefficient_width * x;
        int coefficient_counter = 0;

        STBIR_ASSERT(n1 >= n0);
        STBIR_ASSERT(n0 >= -stbir_info->horizontal_filter_pixel_margin);
        STBIR_ASSERT(n1 >= -stbir_info->horizontal_filter_pixel_margin);
        STBIR_ASSERT(n0 < stbir_info->input_w + stbir_info->horizontal_filter_pixel_margin);
        STBIR_ASSERT(n1 < stbir_info->input_w + stbir_info->horizontal_filter_pixel_margin);

        switch (channels) {
            case 1:
                for (k = n0; k <= n1; k++)
                {
                    int in_pixel_index = k * 1;
                    float coefficient = horizontal_coefficients[coefficient_group + coefficient_counter++];
                    STBIR_ASSERT(coefficient != 0);
                    output_buffer[out_pixel_index + 0] += decode_buffer[in_pixel_index + 0] * coefficient;
                }
                break;
            case 2:
                for (k = n0; k <= n1; k++)
                {
                    int in_pixel_index = k * 2;
                    float coefficient = horizontal_coefficients[coefficient_group + coefficient_counter++];
                    STBIR_ASSERT(coefficient != 0);
                    output_buffer[out_pixel_index + 0] += decode_buffer[in_pixel_index + 0] * coefficient;
                    output_buffer[out_pixel_index + 1] += decode_buffer[in_pixel_index + 1] * coefficient;
                }
                break;
            case 3:
                for (k = n0; k <= n1; k++)
                {
                    int in_pixel_index = k * 3;
                    float coefficient = horizontal_coefficients[coefficient_group + coefficient_counter++];
                    STBIR_ASSERT(coefficient != 0);
                    output_buffer[out_pixel_index + 0] += decode_buffer[in_pixel_index + 0] * coefficient;
                    output_buffer[out_pixel_index + 1] += decode_buffer[in_pixel_index + 1] * coefficient;
                    output_buffer[out_pixel_index + 2] += decode_buffer[in_pixel_index + 2] * coefficient;
                }
                break;
            case 4:
                for (k = n0; k <= n1; k++)
                {
                    int in_pixel_index = k * 4;
                    float coefficient = horizontal_coefficients[coefficient_group + coefficient_counter++];
                    STBIR_ASSERT(coefficient != 0);
                    output_buffer[out_pixel_index + 0] += decode_buffer[in_pixel_index + 0] * coefficient;
                    output_buffer[out_pixel_index + 1] += decode_buffer[in_pixel_index + 1] * coefficient;
                    output_buffer[out_pixel_index + 2] += decode_buffer[in_pixel_index + 2] * coefficient;
                    output_buffer[out_pixel_index + 3] += decode_buffer[in_pixel_index + 3] * coefficient;
                }
                break;
            default:
                for (k = n0; k <= n1; k++)
                {
                    int in_pixel_index = k * channels;
                    float coefficient = horizontal_coefficients[coefficient_group + coefficient_counter++];
                    int c;
                    STBIR_ASSERT(coefficient != 0);
                    for (c = 0; c < channels; c++)
                        output_buffer[out_pixel_index + c] += decode_buffer[in_pixel_index + c] * coefficient;
                }
                break;
        }
    }
}

static void stbir__resample_horizontal_downsample(stbir__info* stbir_info, float* output_buffer)
{
    int x, k;
    int input_w = stbir_info->input_w;
    int channels = stbir_info->channels;
    float* decode_buffer = stbir__get_decode_buffer(stbir_info);
    stbir__contributors* horizontal_contributors = stbir_info->horizontal_contributors;
    float* horizontal_coefficients = stbir_info->horizontal_coefficients;
    int coefficient_width = stbir_info->horizontal_coefficient_width;
    int filter_pixel_margin = stbir_info->horizontal_filter_pixel_margin;
    int max_x = input_w + filter_pixel_margin * 2;

    STBIR_ASSERT(!stbir__use_width_upsampling(stbir_info));

    switch (channels) {
        case 1:
            for (x = 0; x < max_x; x++)
            {
                int n0 = horizontal_contributors[x].n0;
                int n1 = horizontal_contributors[x].n1;

                int in_x = x - filter_pixel_margin;
                int in_pixel_index = in_x * 1;
                int max_n = n1;
                int coefficient_group = coefficient_width * x;

                for (k = n0; k <= max_n; k++)
                {
                    int out_pixel_index = k * 1;
                    float coefficient = horizontal_coefficients[coefficient_group + k - n0];
                    STBIR_ASSERT(coefficient != 0);
                    output_buffer[out_pixel_index + 0] += decode_buffer[in_pixel_index + 0] * coefficient;
                }
            }
            break;

        case 2:
            for (x = 0; x < max_x; x++)
            {
                int n0 = horizontal_contributors[x].n0;
                int n1 = horizontal_contributors[x].n1;

                int in_x = x - filter_pixel_margin;
                int in_pixel_index = in_x * 2;
                int max_n = n1;
                int coefficient_group = coefficient_width * x;

                for (k = n0; k <= max_n; k++)
                {
                    int out_pixel_index = k * 2;
                    float coefficient = horizontal_coefficients[coefficient_group + k - n0];
                    STBIR_ASSERT(coefficient != 0);
                    output_buffer[out_pixel_index + 0] += decode_buffer[in_pixel_index + 0] * coefficient;
                    output_buffer[out_pixel_index + 1] += decode_buffer[in_pixel_index + 1] * coefficient;
                }
            }
            break;

        case 3:
            for (x = 0; x < max_x; x++)
            {
                int n0 = horizontal_contributors[x].n0;
                int n1 = horizontal_contributors[x].n1;

                int in_x = x - filter_pixel_margin;
                int in_pixel_index = in_x * 3;
                int max_n = n1;
                int coefficient_group = coefficient_width * x;

                for (k = n0; k <= max_n; k++)
                {
                    int out_pixel_index = k * 3;
                    float coefficient = horizontal_coefficients[coefficient_group + k - n0];
                    STBIR_ASSERT(coefficient != 0);
                    output_buffer[out_pixel_index + 0] += decode_buffer[in_pixel_index + 0] * coefficient;
                    output_buffer[out_pixel_index + 1] += decode_buffer[in_pixel_index + 1] * coefficient;
                    output_buffer[out_pixel_index + 2] += decode_buffer[in_pixel_index + 2] * coefficient;
                }
            }
            break;

        case 4:
            for (x = 0; x < max_x; x++)
            {
                int n0 = horizontal_contributors[x].n0;
                int n1 = horizontal_contributors[x].n1;

                int in_x = x - filter_pixel_margin;
                int in_pixel_index = in_x * 4;
                int max_n = n1;
                int coefficient_group = coefficient_width * x;

                for (k = n0; k <= max_n; k++)
                {
                    int out_pixel_index = k * 4;
                    float coefficient = horizontal_coefficients[coefficient_group + k - n0];
                    STBIR_ASSERT(coefficient != 0);
                    output_buffer[out_pixel_index + 0] += decode_buffer[in_pixel_index + 0] * coefficient;
                    output_buffer[out_pixel_index + 1] += decode_buffer[in_pixel_index + 1] * coefficient;
                    output_buffer[out_pixel_index + 2] += decode_buffer[in_pixel_index + 2] * coefficient;
                    output_buffer[out_pixel_index + 3] += decode_buffer[in_pixel_index + 3] * coefficient;
                }
            }
            break;

        default:
            for (x = 0; x < max_x; x++)
            {
                int n0 = horizontal_contributors[x].n0;
                int n1 = horizontal_contributors[x].n1;

                int in_x = x - filter_pixel_margin;
                int in_pixel_index = in_x * channels;
                int max_n = n1;
                int coefficient_group = coefficient_width * x;

                for (k = n0; k <= max_n; k++)
                {
                    int c;
                    int out_pixel_index = k * channels;
                    float coefficient = horizontal_coefficients[coefficient_group + k - n0];
                    STBIR_ASSERT(coefficient != 0);
                    for (c = 0; c < channels; c++)
                        output_buffer[out_pixel_index + c] += decode_buffer[in_pixel_index + c] * coefficient;
                }
            }
            break;
    }
}

static void stbir__decode_and_resample_upsample(stbir__info* stbir_info, int n)
{
    // Decode the nth scanline from the source image into the decode buffer.
    stbir__decode_scanline(stbir_info, n);

    // Now resample it into the ring buffer.
    if (stbir__use_width_upsampling(stbir_info))
        stbir__resample_horizontal_upsample(stbir_info, stbir__add_empty_ring_buffer_entry(stbir_info, n));
    else
        stbir__resample_horizontal_downsample(stbir_info, stbir__add_empty_ring_buffer_entry(stbir_info, n));

    // Now it's sitting in the ring buffer ready to be used as source for the vertical sampling.
}

static void stbir__decode_and_resample_downsample(stbir__info* stbir_info, int n)
{
    // Decode the nth scanline from the source image into the decode buffer.
    stbir__decode_scanline(stbir_info, n);

    memset(stbir_info->horizontal_buffer, 0, stbir_info->output_w * stbir_info->channels * sizeof(float));

    // Now resample it into the horizontal buffer.
    if (stbir__use_width_upsampling(stbir_info))
        stbir__resample_horizontal_upsample(stbir_info, stbir_info->horizontal_buffer);
    else
        stbir__resample_horizontal_downsample(stbir_info, stbir_info->horizontal_buffer);

    // Now it's sitting in the horizontal buffer ready to be distributed into the ring buffers.
}

// Get the specified scan line from the ring buffer.
static float* stbir__get_ring_buffer_scanline(int get_scanline, float* ring_buffer, int begin_index, int first_scanline, int ring_buffer_num_entries, int ring_buffer_length)
{
    int ring_buffer_index = (begin_index + (get_scanline - first_scanline)) % ring_buffer_num_entries;
    return stbir__get_ring_buffer_entry(ring_buffer, ring_buffer_index, ring_buffer_length);
}


static void stbir__encode_scanline(stbir__info* stbir_info, int num_pixels, void *output_buffer, float *encode_buffer, int channels, int alpha_channel, int decode)
{
    int x;
    int n;
    int num_nonalpha;
    stbir_uint16 nonalpha[STBIR_MAX_CHANNELS];

    if (!(stbir_info->flags&STBIR_FLAG_ALPHA_PREMULTIPLIED))
    {
        for (x=0; x < num_pixels; ++x)
        {
            int pixel_index = x*channels;

            float alpha = encode_buffer[pixel_index + alpha_channel];
            float reciprocal_alpha = alpha ? 1.0f / alpha : 0;

            // unrolling this produced a 1% slowdown upscaling a large RGBA linear-space image on my machine - stb
            for (n = 0; n < channels; n++)
                if (n != alpha_channel)
                    encode_buffer[pixel_index + n] *= reciprocal_alpha;

            // We added in a small epsilon to prevent the color channel from being deleted with zero alpha.
            // Because we only add it for integer types, it will automatically be discarded on integer
            // conversion, so we don't need to subtract it back out (which would be problematic for
            // numeric precision reasons).
        }
    }

    // build a table of all channels that need colorspace correction, so
    // we don't perform colorspace correction on channels that don't need it.
    for (x = 0, num_nonalpha = 0; x < channels; ++x)
    {
        if (x != alpha_channel || (stbir_info->flags & STBIR_FLAG_ALPHA_USES_COLORSPACE))
        {
            nonalpha[num_nonalpha++] = (stbir_uint16)x;
        }
    }

    #define STBIR__ROUND_INT(f)    ((int)          ((f)+0.5))
    #define STBIR__ROUND_UINT(f)   ((stbir_uint32) ((f)+0.5))

    #ifdef STBIR__SATURATE_INT
    #define STBIR__ENCODE_LINEAR8(f)   stbir__saturate8 (STBIR__ROUND_INT((f) * stbir__max_uint8_as_float ))
    #define STBIR__ENCODE_LINEAR16(f)  stbir__saturate16(STBIR__ROUND_INT((f) * stbir__max_uint16_as_float))
    #else
    #define STBIR__ENCODE_LINEAR8(f)   (unsigned char ) STBIR__ROUND_INT(stbir__saturate(f) * stbir__max_uint8_as_float )
    #define STBIR__ENCODE_LINEAR16(f)  (unsigned short) STBIR__ROUND_INT(stbir__saturate(f) * stbir__max_uint16_as_float)
    #endif

    switch (decode)
    {
        case STBIR__DECODE(STBIR_TYPE_UINT8, STBIR_COLORSPACE_LINEAR):
            for (x=0; x < num_pixels; ++x)
            {
                int pixel_index = x*channels;

                for (n = 0; n < channels; n++)
                {
                    int index = pixel_index + n;
                    ((unsigned char*)output_buffer)[index] = STBIR__ENCODE_LINEAR8(encode_buffer[index]);
                }
            }
            break;

        case STBIR__DECODE(STBIR_TYPE_UINT8, STBIR_COLORSPACE_SRGB):
            for (x=0; x < num_pixels; ++x)
            {
                int pixel_index = x*channels;

                for (n = 0; n < num_nonalpha; n++)
                {
                    int index = pixel_index + nonalpha[n];
                    ((unsigned char*)output_buffer)[index] = stbir__linear_to_srgb_uchar(encode_buffer[index]);
                }

                if (!(stbir_info->flags & STBIR_FLAG_ALPHA_USES_COLORSPACE))
                    ((unsigned char *)output_buffer)[pixel_index + alpha_channel] = STBIR__ENCODE_LINEAR8(encode_buffer[pixel_index+alpha_channel]);
            }
            break;

        case STBIR__DECODE(STBIR_TYPE_UINT16, STBIR_COLORSPACE_LINEAR):
            for (x=0; x < num_pixels; ++x)
            {
                int pixel_index = x*channels;

                for (n = 0; n < channels; n++)
                {
                    int index = pixel_index + n;
                    ((unsigned short*)output_buffer)[index] = STBIR__ENCODE_LINEAR16(encode_buffer[index]);
                }
            }
            break;

        case STBIR__DECODE(STBIR_TYPE_UINT16, STBIR_COLORSPACE_SRGB):
            for (x=0; x < num_pixels; ++x)
            {
                int pixel_index = x*channels;

                for (n = 0; n < num_nonalpha; n++)
                {
                    int index = pixel_index + nonalpha[n];
                    ((unsigned short*)output_buffer)[index] = (unsigned short)STBIR__ROUND_INT(stbir__linear_to_srgb(stbir__saturate(encode_buffer[index])) * stbir__max_uint16_as_float);
                }

                if (!(stbir_info->flags&STBIR_FLAG_ALPHA_USES_COLORSPACE))
                    ((unsigned short*)output_buffer)[pixel_index + alpha_channel] = STBIR__ENCODE_LINEAR16(encode_buffer[pixel_index + alpha_channel]);
            }

            break;

        case STBIR__DECODE(STBIR_TYPE_UINT32, STBIR_COLORSPACE_LINEAR):
            for (x=0; x < num_pixels; ++x)
            {
                int pixel_index = x*channels;

                for (n = 0; n < channels; n++)
                {
                    int index = pixel_index + n;
                    ((unsigned int*)output_buffer)[index] = (unsigned int)STBIR__ROUND_UINT(((double)stbir__saturate(encode_buffer[index])) * stbir__max_uint32_as_float);
                }
            }
            break;

        case STBIR__DECODE(STBIR_TYPE_UINT32, STBIR_COLORSPACE_SRGB):
            for (x=0; x < num_pixels; ++x)
            {
                int pixel_index = x*channels;

                for (n = 0; n < num_nonalpha; n++)
                {
                    int index = pixel_index + nonalpha[n];
                    ((unsigned int*)output_buffer)[index] = (unsigned int)STBIR__ROUND_UINT(((double)stbir__linear_to_srgb(stbir__saturate(encode_buffer[index]))) * stbir__max_uint32_as_float);
                }

                if (!(stbir_info->flags&STBIR_FLAG_ALPHA_USES_COLORSPACE))
                    ((unsigned int*)output_buffer)[pixel_index + alpha_channel] = (unsigned int)STBIR__ROUND_INT(((double)stbir__saturate(encode_buffer[pixel_index + alpha_channel])) * stbir__max_uint32_as_float);
            }
            break;

        case STBIR__DECODE(STBIR_TYPE_FLOAT, STBIR_COLORSPACE_LINEAR):
            for (x=0; x < num_pixels; ++x)
            {
                int pixel_index = x*channels;

                for (n = 0; n < channels; n++)
                {
                    int index = pixel_index + n;
                    ((float*)output_buffer)[index] = encode_buffer[index];
                }
            }
            break;

        case STBIR__DECODE(STBIR_TYPE_FLOAT, STBIR_COLORSPACE_SRGB):
            for (x=0; x < num_pixels; ++x)
            {
                int pixel_index = x*channels;

                for (n = 0; n < num_nonalpha; n++)
                {
                    int index = pixel_index + nonalpha[n];
                    ((float*)output_buffer)[index] = stbir__linear_to_srgb(encode_buffer[index]);
                }

                if (!(stbir_info->flags&STBIR_FLAG_ALPHA_USES_COLORSPACE))
                    ((float*)output_buffer)[pixel_index + alpha_channel] = encode_buffer[pixel_index + alpha_channel];
            }
            break;

        default:
            STBIR_ASSERT(!"Unknown type/colorspace/channels combination.");
            break;
    }
}

static void stbir__resample_vertical_upsample(stbir__info* stbir_info, int n)
{
    int x, k;
    int output_w = stbir_info->output_w;
    stbir__contributors* vertical_contributors = stbir_info->vertical_contributors;
    float* vertical_coefficients = stbir_info->vertical_coefficients;
    int channels = stbir_info->channels;
    int alpha_channel = stbir_info->alpha_channel;
    int type = stbir_info->type;
    int colorspace = stbir_info->colorspace;
    int ring_buffer_entries = stbir_info->ring_buffer_num_entries;
    void* output_data = stbir_info->output_data;
    float* encode_buffer = stbir_info->encode_buffer;
    int decode = STBIR__DECODE(type, colorspace);
    int coefficient_width = stbir_info->vertical_coefficient_width;
    int coefficient_counter;
    int contributor = n;

    float* ring_buffer = stbir_info->ring_buffer;
    int ring_buffer_begin_index = stbir_info->ring_buffer_begin_index;
    int ring_buffer_first_scanline = stbir_info->ring_buffer_first_scanline;
    int ring_buffer_length = stbir_info->ring_buffer_length_bytes/sizeof(float);

    int n0,n1, output_row_start;
    int coefficient_group = coefficient_width * contributor;

    n0 = vertical_contributors[contributor].n0;
    n1 = vertical_contributors[contributor].n1;

    output_row_start = n * stbir_info->output_stride_bytes;

    STBIR_ASSERT(stbir__use_height_upsampling(stbir_info));

    memset(encode_buffer, 0, output_w * sizeof(float) * channels);

    // I tried reblocking this for better cache usage of encode_buffer
    // (using x_outer, k, x_inner), but it lost speed. -- stb

    coefficient_counter = 0;
    switch (channels) {
        case 1:
            for (k = n0; k <= n1; k++)
            {
                int coefficient_index = coefficient_counter++;
                float* ring_buffer_entry = stbir__get_ring_buffer_scanline(k, ring_buffer, ring_buffer_begin_index, ring_buffer_first_scanline, ring_buffer_entries, ring_buffer_length);
                float coefficient = vertical_coefficients[coefficient_group + coefficient_index];
                for (x = 0; x < output_w; ++x)
                {
                    int in_pixel_index = x * 1;
                    encode_buffer[in_pixel_index + 0] += ring_buffer_entry[in_pixel_index + 0] * coefficient;
                }
            }
            break;
        case 2:
            for (k = n0; k <= n1; k++)
            {
                int coefficient_index = coefficient_counter++;
                float* ring_buffer_entry = stbir__get_ring_buffer_scanline(k, ring_buffer, ring_buffer_begin_index, ring_buffer_first_scanline, ring_buffer_entries, ring_buffer_length);
                float coefficient = vertical_coefficients[coefficient_group + coefficient_index];
                for (x = 0; x < output_w; ++x)
                {
                    int in_pixel_index = x * 2;
                    encode_buffer[in_pixel_index + 0] += ring_buffer_entry[in_pixel_index + 0] * coefficient;
                    encode_buffer[in_pixel_index + 1] += ring_buffer_entry[in_pixel_index + 1] * coefficient;
                }
            }
            break;
        case 3:
            for (k = n0; k <= n1; k++)
            {
                int coefficient_index = coefficient_counter++;
                float* ring_buffer_entry = stbir__get_ring_buffer_scanline(k, ring_buffer, ring_buffer_begin_index, ring_buffer_first_scanline, ring_buffer_entries, ring_buffer_length);
                float coefficient = vertical_coefficients[coefficient_group + coefficient_index];
                for (x = 0; x < output_w; ++x)
                {
                    int in_pixel_index = x * 3;
                    encode_buffer[in_pixel_index + 0] += ring_buffer_entry[in_pixel_index + 0] * coefficient;
                    encode_buffer[in_pixel_index + 1] += ring_buffer_entry[in_pixel_index + 1] * coefficient;
                    encode_buffer[in_pixel_index + 2] += ring_buffer_entry[in_pixel_index + 2] * coefficient;
                }
            }
            break;
        case 4:
            for (k = n0; k <= n1; k++)
            {
                int coefficient_index = coefficient_counter++;
                float* ring_buffer_entry = stbir__get_ring_buffer_scanline(k, ring_buffer, ring_buffer_begin_index, ring_buffer_first_scanline, ring_buffer_entries, ring_buffer_length);
                float coefficient = vertical_coefficients[coefficient_group + coefficient_index];
                for (x = 0; x < output_w; ++x)
                {
                    int in_pixel_index = x * 4;
                    encode_buffer[in_pixel_index + 0] += ring_buffer_entry[in_pixel_index + 0] * coefficient;
                    encode_buffer[in_pixel_index + 1] += ring_buffer_entry[in_pixel_index + 1] * coefficient;
                    encode_buffer[in_pixel_index + 2] += ring_buffer_entry[in_pixel_index + 2] * coefficient;
                    encode_buffer[in_pixel_index + 3] += ring_buffer_entry[in_pixel_index + 3] * coefficient;
                }
            }
            break;
        default:
            for (k = n0; k <= n1; k++)
            {
                int coefficient_index = coefficient_counter++;
                float* ring_buffer_entry = stbir__get_ring_buffer_scanline(k, ring_buffer, ring_buffer_begin_index, ring_buffer_first_scanline, ring_buffer_entries, ring_buffer_length);
                float coefficient = vertical_coefficients[coefficient_group + coefficient_index];
                for (x = 0; x < output_w; ++x)
                {
                    int in_pixel_index = x * channels;
                    int c;
                    for (c = 0; c < channels; c++)
                        encode_buffer[in_pixel_index + c] += ring_buffer_entry[in_pixel_index + c] * coefficient;
                }
            }
            break;
    }
    stbir__encode_scanline(stbir_info, output_w, (char *) output_data + output_row_start, encode_buffer, channels, alpha_channel, decode);
}

static void stbir__resample_vertical_downsample(stbir__info* stbir_info, int n)
{
    int x, k;
    int output_w = stbir_info->output_w;
    stbir__contributors* vertical_contributors = stbir_info->vertical_contributors;
    float* vertical_coefficients = stbir_info->vertical_coefficients;
    int channels = stbir_info->channels;
    int ring_buffer_entries = stbir_info->ring_buffer_num_entries;
    float* horizontal_buffer = stbir_info->horizontal_buffer;
    int coefficient_width = stbir_info->vertical_coefficient_width;
    int contributor = n + stbir_info->vertical_filter_pixel_margin;

    float* ring_buffer = stbir_info->ring_buffer;
    int ring_buffer_begin_index = stbir_info->ring_buffer_begin_index;
    int ring_buffer_first_scanline = stbir_info->ring_buffer_first_scanline;
    int ring_buffer_length = stbir_info->ring_buffer_length_bytes/sizeof(float);
    int n0,n1;

    n0 = vertical_contributors[contributor].n0;
    n1 = vertical_contributors[contributor].n1;

    STBIR_ASSERT(!stbir__use_height_upsampling(stbir_info));

    for (k = n0; k <= n1; k++)
    {
        int coefficient_index = k - n0;
        int coefficient_group = coefficient_width * contributor;
        float coefficient = vertical_coefficients[coefficient_group + coefficient_index];

        float* ring_buffer_entry = stbir__get_ring_buffer_scanline(k, ring_buffer, ring_buffer_begin_index, ring_buffer_first_scanline, ring_buffer_entries, ring_buffer_length);

        switch (channels) {
            case 1:
                for (x = 0; x < output_w; x++)
                {
                    int in_pixel_index = x * 1;
                    ring_buffer_entry[in_pixel_index + 0] += horizontal_buffer[in_pixel_index + 0] * coefficient;
                }
                break;
            case 2:
                for (x = 0; x < output_w; x++)
                {
                    int in_pixel_index = x * 2;
                    ring_buffer_entry[in_pixel_index + 0] += horizontal_buffer[in_pixel_index + 0] * coefficient;
                    ring_buffer_entry[in_pixel_index + 1] += horizontal_buffer[in_pixel_index + 1] * coefficient;
                }
                break;
            case 3:
                for (x = 0; x < output_w; x++)
                {
                    int in_pixel_index = x * 3;
                    ring_buffer_entry[in_pixel_index + 0] += horizontal_buffer[in_pixel_index + 0] * coefficient;
                    ring_buffer_entry[in_pixel_index + 1] += horizontal_buffer[in_pixel_index + 1] * coefficient;
                    ring_buffer_entry[in_pixel_index + 2] += horizontal_buffer[in_pixel_index + 2] * coefficient;
                }
                break;
            case 4:
                for (x = 0; x < output_w; x++)
                {
                    int in_pixel_index = x * 4;
                    ring_buffer_entry[in_pixel_index + 0] += horizontal_buffer[in_pixel_index + 0] * coefficient;
                    ring_buffer_entry[in_pixel_index + 1] += horizontal_buffer[in_pixel_index + 1] * coefficient;
                    ring_buffer_entry[in_pixel_index + 2] += horizontal_buffer[in_pixel_index + 2] * coefficient;
                    ring_buffer_entry[in_pixel_index + 3] += horizontal_buffer[in_pixel_index + 3] * coefficient;
                }
                break;
            default:
                for (x = 0; x < output_w; x++)
                {
                    int in_pixel_index = x * channels;

                    int c;
                    for (c = 0; c < channels; c++)
                        ring_buffer_entry[in_pixel_index + c] += horizontal_buffer[in_pixel_index + c] * coefficient;
                }
                break;
        }
    }
}

static void stbir__buffer_loop_upsample(stbir__info* stbir_info)
{
    int y;
    float scale_ratio = stbir_info->vertical_scale;
    float out_scanlines_radius = stbir__filter_info_table[stbir_info->vertical_filter].support(1/scale_ratio) * scale_ratio;

    STBIR_ASSERT(stbir__use_height_upsampling(stbir_info));

    for (y = 0; y < stbir_info->output_h; y++)
    {
        float in_center_of_out = 0; // Center of the current out scanline in the in scanline space
        int in_first_scanline = 0, in_last_scanline = 0;

        stbir__calculate_sample_range_upsample(y, out_scanlines_radius, scale_ratio, stbir_info->vertical_shift, &in_first_scanline, &in_last_scanline, &in_center_of_out);

        STBIR_ASSERT(in_last_scanline - in_first_scanline + 1 <= stbir_info->ring_buffer_num_entries);

        if (stbir_info->ring_buffer_begin_index >= 0)
        {
            // Get rid of whatever we don't need anymore.
            while (in_first_scanline > stbir_info->ring_buffer_first_scanline)
            {
                if (stbir_info->ring_buffer_first_scanline == stbir_info->ring_buffer_last_scanline)
                {
                    // We just popped the last scanline off the ring buffer.
                    // Reset it to the empty state.
                    stbir_info->ring_buffer_begin_index = -1;
                    stbir_info->ring_buffer_first_scanline = 0;
                    stbir_info->ring_buffer_last_scanline = 0;
                    break;
                }
                else
                {
                    stbir_info->ring_buffer_first_scanline++;
                    stbir_info->ring_buffer_begin_index = (stbir_info->ring_buffer_begin_index + 1) % stbir_info->ring_buffer_num_entries;
                }
            }
        }

        // Load in new ones.
        if (stbir_info->ring_buffer_begin_index < 0)
            stbir__decode_and_resample_upsample(stbir_info, in_first_scanline);

        while (in_last_scanline > stbir_info->ring_buffer_last_scanline)
            stbir__decode_and_resample_upsample(stbir_info, stbir_info->ring_buffer_last_scanline + 1);

        // Now all buffers should be ready to write a row of vertical sampling.
        stbir__resample_vertical_upsample(stbir_info, y);

        STBIR_PROGRESS_REPORT((float)y / stbir_info->output_h);
    }
}

static void stbir__empty_ring_buffer(stbir__info* stbir_info, int first_necessary_scanline)
{
    int output_stride_bytes = stbir_info->output_stride_bytes;
    int channels = stbir_info->channels;
    int alpha_channel = stbir_info->alpha_channel;
    int type = stbir_info->type;
    int colorspace = stbir_info->colorspace;
    int output_w = stbir_info->output_w;
    void* output_data = stbir_info->output_data;
    int decode = STBIR__DECODE(type, colorspace);

    float* ring_buffer = stbir_info->ring_buffer;
    int ring_buffer_length = stbir_info->ring_buffer_length_bytes/sizeof(float);

    if (stbir_info->ring_buffer_begin_index >= 0)
    {
        // Get rid of whatever we don't need anymore.
        while (first_necessary_scanline > stbir_info->ring_buffer_first_scanline)
        {
            if (stbir_info->ring_buffer_first_scanline >= 0 && stbir_info->ring_buffer_first_scanline < stbir_info->output_h)
            {
                int output_row_start = stbir_info->ring_buffer_first_scanline * output_stride_bytes;
                float* ring_buffer_entry = stbir__get_ring_buffer_entry(ring_buffer, stbir_info->ring_buffer_begin_index, ring_buffer_length);
                stbir__encode_scanline(stbir_info, output_w, (char *) output_data + output_row_start, ring_buffer_entry, channels, alpha_channel, decode);
                STBIR_PROGRESS_REPORT((float)stbir_info->ring_buffer_first_scanline / stbir_info->output_h);
            }

            if (stbir_info->ring_buffer_first_scanline == stbir_info->ring_buffer_last_scanline)
            {
                // We just popped the last scanline off the ring buffer.
                // Reset it to the empty state.
                stbir_info->ring_buffer_begin_index = -1;
                stbir_info->ring_buffer_first_scanline = 0;
                stbir_info->ring_buffer_last_scanline = 0;
                break;
            }
            else
            {
                stbir_info->ring_buffer_first_scanline++;
                stbir_info->ring_buffer_begin_index = (stbir_info->ring_buffer_begin_index + 1) % stbir_info->ring_buffer_num_entries;
            }
        }
    }
}

static void stbir__buffer_loop_downsample(stbir__info* stbir_info)
{
    int y;
    float scale_ratio = stbir_info->vertical_scale;
    int output_h = stbir_info->output_h;
    float in_pixels_radius = stbir__filter_info_table[stbir_info->vertical_filter].support(scale_ratio) / scale_ratio;
    int pixel_margin = stbir_info->vertical_filter_pixel_margin;
    int max_y = stbir_info->input_h + pixel_margin;

    STBIR_ASSERT(!stbir__use_height_upsampling(stbir_info));

    for (y = -pixel_margin; y < max_y; y++)
    {
        float out_center_of_in; // Center of the current out scanline in the in scanline space
        int out_first_scanline, out_last_scanline;

        stbir__calculate_sample_range_downsample(y, in_pixels_radius, scale_ratio, stbir_info->vertical_shift, &out_first_scanline, &out_last_scanline, &out_center_of_in);

        STBIR_ASSERT(out_last_scanline - out_first_scanline + 1 <= stbir_info->ring_buffer_num_entries);

        if (out_last_scanline < 0 || out_first_scanline >= output_h)
            continue;

        stbir__empty_ring_buffer(stbir_info, out_first_scanline);

        stbir__decode_and_resample_downsample(stbir_info, y);

        // Load in new ones.
        if (stbir_info->ring_buffer_begin_index < 0)
            stbir__add_empty_ring_buffer_entry(stbir_info, out_first_scanline);

        while (out_last_scanline > stbir_info->ring_buffer_last_scanline)
            stbir__add_empty_ring_buffer_entry(stbir_info, stbir_info->ring_buffer_last_scanline + 1);

        // Now the horizontal buffer is ready to write to all ring buffer rows.
        stbir__resample_vertical_downsample(stbir_info, y);
    }

    stbir__empty_ring_buffer(stbir_info, stbir_info->output_h);
}

static void stbir__setup(stbir__info *info, int input_w, int input_h, int output_w, int output_h, int channels)
{
    info->input_w = input_w;
    info->input_h = input_h;
    info->output_w = output_w;
    info->output_h = output_h;
    info->channels = channels;
}

static void stbir__calculate_transform(stbir__info *info, float s0, float t0, float s1, float t1, float *transform)
{
    info->s0 = s0;
    info->t0 = t0;
    info->s1 = s1;
    info->t1 = t1;

    if (transform)
    {
        info->horizontal_scale = transform[0];
        info->vertical_scale   = transform[1];
        info->horizontal_shift = transform[2];
        info->vertical_shift   = transform[3];
    }
    else
    {
        info->horizontal_scale = ((float)info->output_w / info->input_w) / (s1 - s0);
        info->vertical_scale = ((float)info->output_h / info->input_h) / (t1 - t0);

        info->horizontal_shift = s0 * info->output_w / (s1 - s0);
        info->vertical_shift = t0 * info->output_h / (t1 - t0);
    }
}

static void stbir__choose_filter(stbir__info *info, stbir_filter h_filter, stbir_filter v_filter)
{
    if (h_filter == 0)
        h_filter = stbir__use_upsampling(info->horizontal_scale) ? STBIR_DEFAULT_FILTER_UPSAMPLE : STBIR_DEFAULT_FILTER_DOWNSAMPLE;
    if (v_filter == 0)
        v_filter = stbir__use_upsampling(info->vertical_scale)   ? STBIR_DEFAULT_FILTER_UPSAMPLE : STBIR_DEFAULT_FILTER_DOWNSAMPLE;
    info->horizontal_filter = h_filter;
    info->vertical_filter = v_filter;
}

static stbir_uint32 stbir__calculate_memory(stbir__info *info)
{
    int pixel_margin = stbir__get_filter_pixel_margin(info->horizontal_filter, info->horizontal_scale);
    int filter_height = stbir__get_filter_pixel_width(info->vertical_filter, info->vertical_scale);

    info->horizontal_num_contributors = stbir__get_contributors(info->horizontal_scale, info->horizontal_filter, info->input_w, info->output_w);
    info->vertical_num_contributors   = stbir__get_contributors(info->vertical_scale  , info->vertical_filter  , info->input_h, info->output_h);

    // One extra entry because floating point precision problems sometimes cause an extra to be necessary.
    info->ring_buffer_num_entries = filter_height + 1;

    info->horizontal_contributors_size = info->horizontal_num_contributors * sizeof(stbir__contributors);
    info->horizontal_coefficients_size = stbir__get_total_horizontal_coefficients(info) * sizeof(float);
    info->vertical_contributors_size = info->vertical_num_contributors * sizeof(stbir__contributors);
    info->vertical_coefficients_size = stbir__get_total_vertical_coefficients(info) * sizeof(float);
    info->decode_buffer_size = (info->input_w + pixel_margin * 2) * info->channels * sizeof(float);
    info->horizontal_buffer_size = info->output_w * info->channels * sizeof(float);
    info->ring_buffer_size = info->output_w * info->channels * info->ring_buffer_num_entries * sizeof(float);
    info->encode_buffer_size = info->output_w * info->channels * sizeof(float);

    STBIR_ASSERT(info->horizontal_filter != 0);
    STBIR_ASSERT(info->horizontal_filter < STBIR__ARRAY_SIZE(stbir__filter_info_table)); // this now happens too late
    STBIR_ASSERT(info->vertical_filter != 0);
    STBIR_ASSERT(info->vertical_filter < STBIR__ARRAY_SIZE(stbir__filter_info_table)); // this now happens too late

    if (stbir__use_height_upsampling(info))
        // The horizontal buffer is for when we're downsampling the height and we
        // can't output the result of sampling the decode buffer directly into the
        // ring buffers.
        info->horizontal_buffer_size = 0;
    else
        // The encode buffer is to retain precision in the height upsampling method
        // and isn't used when height downsampling.
        info->encode_buffer_size = 0;

    return info->horizontal_contributors_size + info->horizontal_coefficients_size
        + info->vertical_contributors_size + info->vertical_coefficients_size
        + info->decode_buffer_size + info->horizontal_buffer_size
        + info->ring_buffer_size + info->encode_buffer_size;
}

static int stbir__resize_allocated(stbir__info *info,
    const void* input_data, int input_stride_in_bytes,
    void* output_data, int output_stride_in_bytes,
    int alpha_channel, stbir_uint32 flags, stbir_datatype type,
    stbir_edge edge_horizontal, stbir_edge edge_vertical, stbir_colorspace colorspace,
    void* tempmem, size_t tempmem_size_in_bytes)
{
    size_t memory_required = stbir__calculate_memory(info);

    int width_stride_input = input_stride_in_bytes ? input_stride_in_bytes : info->channels * info->input_w * stbir__type_size[type];
    int width_stride_output = output_stride_in_bytes ? output_stride_in_bytes : info->channels * info->output_w * stbir__type_size[type];

#ifdef STBIR_DEBUG_OVERWRITE_TEST
#define OVERWRITE_ARRAY_SIZE 8
    unsigned char overwrite_output_before_pre[OVERWRITE_ARRAY_SIZE];
    unsigned char overwrite_tempmem_before_pre[OVERWRITE_ARRAY_SIZE];
    unsigned char overwrite_output_after_pre[OVERWRITE_ARRAY_SIZE];
    unsigned char overwrite_tempmem_after_pre[OVERWRITE_ARRAY_SIZE];

    size_t begin_forbidden = width_stride_output * (info->output_h - 1) + info->output_w * info->channels * stbir__type_size[type];
    memcpy(overwrite_output_before_pre, &((unsigned char*)output_data)[-OVERWRITE_ARRAY_SIZE], OVERWRITE_ARRAY_SIZE);
    memcpy(overwrite_output_after_pre, &((unsigned char*)output_data)[begin_forbidden], OVERWRITE_ARRAY_SIZE);
    memcpy(overwrite_tempmem_before_pre, &((unsigned char*)tempmem)[-OVERWRITE_ARRAY_SIZE], OVERWRITE_ARRAY_SIZE);
    memcpy(overwrite_tempmem_after_pre, &((unsigned char*)tempmem)[tempmem_size_in_bytes], OVERWRITE_ARRAY_SIZE);
#endif

    STBIR_ASSERT(info->channels >= 0);
    STBIR_ASSERT(info->channels <= STBIR_MAX_CHANNELS);

    if (info->channels < 0 || info->channels > STBIR_MAX_CHANNELS)
        return 0;

    STBIR_ASSERT(info->horizontal_filter < STBIR__ARRAY_SIZE(stbir__filter_info_table));
    STBIR_ASSERT(info->vertical_filter < STBIR__ARRAY_SIZE(stbir__filter_info_table));

    if (info->horizontal_filter >= STBIR__ARRAY_SIZE(stbir__filter_info_table))
        return 0;
    if (info->vertical_filter >= STBIR__ARRAY_SIZE(stbir__filter_info_table))
        return 0;

    if (alpha_channel < 0)
        flags |= STBIR_FLAG_ALPHA_USES_COLORSPACE | STBIR_FLAG_ALPHA_PREMULTIPLIED;

    if (!(flags&STBIR_FLAG_ALPHA_USES_COLORSPACE) || !(flags&STBIR_FLAG_ALPHA_PREMULTIPLIED)) {
        STBIR_ASSERT(alpha_channel >= 0 && alpha_channel < info->channels);
    }

    if (alpha_channel >= info->channels)
        return 0;

    STBIR_ASSERT(tempmem);

    if (!tempmem)
        return 0;

    STBIR_ASSERT(tempmem_size_in_bytes >= memory_required);

    if (tempmem_size_in_bytes < memory_required)
        return 0;

    memset(tempmem, 0, tempmem_size_in_bytes);

    info->input_data = input_data;
    info->input_stride_bytes = width_stride_input;

    info->output_data = output_data;
    info->output_stride_bytes = width_stride_output;

    info->alpha_channel = alpha_channel;
    info->flags = flags;
    info->type = type;
    info->edge_horizontal = edge_horizontal;
    info->edge_vertical = edge_vertical;
    info->colorspace = colorspace;

    info->horizontal_coefficient_width   = stbir__get_coefficient_width  (info->horizontal_filter, info->horizontal_scale);
    info->vertical_coefficient_width     = stbir__get_coefficient_width  (info->vertical_filter  , info->vertical_scale  );
    info->horizontal_filter_pixel_width  = stbir__get_filter_pixel_width (info->horizontal_filter, info->horizontal_scale);
    info->vertical_filter_pixel_width    = stbir__get_filter_pixel_width (info->vertical_filter  , info->vertical_scale  );
    info->horizontal_filter_pixel_margin = stbir__get_filter_pixel_margin(info->horizontal_filter, info->horizontal_scale);
    info->vertical_filter_pixel_margin   = stbir__get_filter_pixel_margin(info->vertical_filter  , info->vertical_scale  );

    info->ring_buffer_length_bytes = info->output_w * info->channels * sizeof(float);
    info->decode_buffer_pixels = info->input_w + info->horizontal_filter_pixel_margin * 2;

#define STBIR__NEXT_MEMPTR(current, newtype) (newtype*)(((unsigned char*)current) + current##_size)

    info->horizontal_contributors = (stbir__contributors *) tempmem;
    info->horizontal_coefficients = STBIR__NEXT_MEMPTR(info->horizontal_contributors, float);
    info->vertical_contributors = STBIR__NEXT_MEMPTR(info->horizontal_coefficients, stbir__contributors);
    info->vertical_coefficients = STBIR__NEXT_MEMPTR(info->vertical_contributors, float);
    info->decode_buffer = STBIR__NEXT_MEMPTR(info->vertical_coefficients, float);

    if (stbir__use_height_upsampling(info))
    {
        info->horizontal_buffer = NULL;
        info->ring_buffer = STBIR__NEXT_MEMPTR(info->decode_buffer, float);
        info->encode_buffer = STBIR__NEXT_MEMPTR(info->ring_buffer, float);

        STBIR_ASSERT((size_t)STBIR__NEXT_MEMPTR(info->encode_buffer, unsigned char) == (size_t)tempmem + tempmem_size_in_bytes);
    }
    else
    {
        info->horizontal_buffer = STBIR__NEXT_MEMPTR(info->decode_buffer, float);
        info->ring_buffer = STBIR__NEXT_MEMPTR(info->horizontal_buffer, float);
        info->encode_buffer = NULL;

        STBIR_ASSERT((size_t)STBIR__NEXT_MEMPTR(info->ring_buffer, unsigned char) == (size_t)tempmem + tempmem_size_in_bytes);
    }

#undef STBIR__NEXT_MEMPTR

    // This signals that the ring buffer is empty
    info->ring_buffer_begin_index = -1;

    stbir__calculate_filters(info->horizontal_contributors, info->horizontal_coefficients, info->horizontal_filter, info->horizontal_scale, info->horizontal_shift, info->input_w, info->output_w);
    stbir__calculate_filters(info->vertical_contributors, info->vertical_coefficients, info->vertical_filter, info->vertical_scale, info->vertical_shift, info->input_h, info->output_h);

    STBIR_PROGRESS_REPORT(0);

    if (stbir__use_height_upsampling(info))
        stbir__buffer_loop_upsample(info);
    else
        stbir__buffer_loop_downsample(info);

    STBIR_PROGRESS_REPORT(1);

#ifdef STBIR_DEBUG_OVERWRITE_TEST
    STBIR_ASSERT(memcmp(overwrite_output_before_pre, &((unsigned char*)output_data)[-OVERWRITE_ARRAY_SIZE], OVERWRITE_ARRAY_SIZE) == 0);
    STBIR_ASSERT(memcmp(overwrite_output_after_pre, &((unsigned char*)output_data)[begin_forbidden], OVERWRITE_ARRAY_SIZE) == 0);
    STBIR_ASSERT(memcmp(overwrite_tempmem_before_pre, &((unsigned char*)tempmem)[-OVERWRITE_ARRAY_SIZE], OVERWRITE_ARRAY_SIZE) == 0);
    STBIR_ASSERT(memcmp(overwrite_tempmem_after_pre, &((unsigned char*)tempmem)[tempmem_size_in_bytes], OVERWRITE_ARRAY_SIZE) == 0);
#endif

    return 1;
}


static int stbir__resize_arbitrary(
    void *alloc_context,
    const void* input_data, int input_w, int input_h, int input_stride_in_bytes,
    void* output_data, int output_w, int output_h, int output_stride_in_bytes,
    float s0, float t0, float s1, float t1, float *transform,
    int channels, int alpha_channel, stbir_uint32 flags, stbir_datatype type,
    stbir_filter h_filter, stbir_filter v_filter,
    stbir_edge edge_horizontal, stbir_edge edge_vertical, stbir_colorspace colorspace)
{
    stbir__info info;
    int result;
    size_t memory_required;
    void* extra_memory;

    stbir__setup(&info, input_w, input_h, output_w, output_h, channels);
    stbir__calculate_transform(&info, s0,t0,s1,t1,transform);
    stbir__choose_filter(&info, h_filter, v_filter);
    memory_required = stbir__calculate_memory(&info);
    extra_memory = STBIR_MALLOC(memory_required, alloc_context);

    if (!extra_memory)
        return 0;

    result = stbir__resize_allocated(&info, input_data, input_stride_in_bytes,
                                            output_data, output_stride_in_bytes,
                                            alpha_channel, flags, type,
                                            edge_horizontal, edge_vertical,
                                            colorspace, extra_memory, memory_required);

    STBIR_FREE(extra_memory, alloc_context);

    return result;
}

STBIRDEF int stbir_resize_uint8(     const unsigned char *input_pixels , int input_w , int input_h , int input_stride_in_bytes,
                                           unsigned char *output_pixels, int output_w, int output_h, int output_stride_in_bytes,
                                     int num_channels)
{
    return stbir__resize_arbitrary(NULL, input_pixels, input_w, input_h, input_stride_in_bytes,
        output_pixels, output_w, output_h, output_stride_in_bytes,
        0,0,1,1,NULL,num_channels,-1,0, STBIR_TYPE_UINT8, STBIR_FILTER_DEFAULT, STBIR_FILTER_DEFAULT,
        STBIR_EDGE_CLAMP, STBIR_EDGE_CLAMP, STBIR_COLORSPACE_LINEAR);
}

STBIRDEF int stbir_resize_float(     const float *input_pixels , int input_w , int input_h , int input_stride_in_bytes,
                                           float *output_pixels, int output_w, int output_h, int output_stride_in_bytes,
                                     int num_channels)
{
    return stbir__resize_arbitrary(NULL, input_pixels, input_w, input_h, input_stride_in_bytes,
        output_pixels, output_w, output_h, output_stride_in_bytes,
        0,0,1,1,NULL,num_channels,-1,0, STBIR_TYPE_FLOAT, STBIR_FILTER_DEFAULT, STBIR_FILTER_DEFAULT,
        STBIR_EDGE_CLAMP, STBIR_EDGE_CLAMP, STBIR_COLORSPACE_LINEAR);
}

STBIRDEF int stbir_resize_uint8_srgb(const unsigned char *input_pixels , int input_w , int input_h , int input_stride_in_bytes,
                                           unsigned char *output_pixels, int output_w, int output_h, int output_stride_in_bytes,
                                     int num_channels, int alpha_channel, int flags)
{
    return stbir__resize_arbitrary(NULL, input_pixels, input_w, input_h, input_stride_in_bytes,
        output_pixels, output_w, output_h, output_stride_in_bytes,
        0,0,1,1,NULL,num_channels,alpha_channel,flags, STBIR_TYPE_UINT8, STBIR_FILTER_DEFAULT, STBIR_FILTER_DEFAULT,
        STBIR_EDGE_CLAMP, STBIR_EDGE_CLAMP, STBIR_COLORSPACE_SRGB);
}

STBIRDEF int stbir_resize_uint8_srgb_edgemode(const unsigned char *input_pixels , int input_w , int input_h , int input_stride_in_bytes,
                                                    unsigned char *output_pixels, int output_w, int output_h, int output_stride_in_bytes,
                                              int num_channels, int alpha_channel, int flags,
                                              stbir_edge edge_wrap_mode)
{
    return stbir__resize_arbitrary(NULL, input_pixels, input_w, input_h, input_stride_in_bytes,
        output_pixels, output_w, output_h, output_stride_in_bytes,
        0,0,1,1,NULL,num_channels,alpha_channel,flags, STBIR_TYPE_UINT8, STBIR_FILTER_DEFAULT, STBIR_FILTER_DEFAULT,
        edge_wrap_mode, edge_wrap_mode, STBIR_COLORSPACE_SRGB);
}

STBIRDEF int stbir_resize_uint8_generic( const unsigned char *input_pixels , int input_w , int input_h , int input_stride_in_bytes,
                                               unsigned char *output_pixels, int output_w, int output_h, int output_stride_in_bytes,
                                         int num_channels, int alpha_channel, int flags,
                                         stbir_edge edge_wrap_mode, stbir_filter filter, stbir_colorspace space,
                                         void *alloc_context)
{
    return stbir__resize_arbitrary(alloc_context, input_pixels, input_w, input_h, input_stride_in_bytes,
        output_pixels, output_w, output_h, output_stride_in_bytes,
        0,0,1,1,NULL,num_channels,alpha_channel,flags, STBIR_TYPE_UINT8, filter, filter,
        edge_wrap_mode, edge_wrap_mode, space);
}

STBIRDEF int stbir_resize_uint16_generic(const stbir_uint16 *input_pixels  , int input_w , int input_h , int input_stride_in_bytes,
                                               stbir_uint16 *output_pixels , int output_w, int output_h, int output_stride_in_bytes,
                                         int num_channels, int alpha_channel, int flags,
                                         stbir_edge edge_wrap_mode, stbir_filter filter, stbir_colorspace space,
                                         void *alloc_context)
{
    return stbir__resize_arbitrary(alloc_context, input_pixels, input_w, input_h, input_stride_in_bytes,
        output_pixels, output_w, output_h, output_stride_in_bytes,
        0,0,1,1,NULL,num_channels,alpha_channel,flags, STBIR_TYPE_UINT16, filter, filter,
        edge_wrap_mode, edge_wrap_mode, space);
}


STBIRDEF int stbir_resize_float_generic( const float *input_pixels         , int input_w , int input_h , int input_stride_in_bytes,
                                               float *output_pixels        , int output_w, int output_h, int output_stride_in_bytes,
                                         int num_channels, int alpha_channel, int flags,
                                         stbir_edge edge_wrap_mode, stbir_filter filter, stbir_colorspace space,
                                         void *alloc_context)
{
    return stbir__resize_arbitrary(alloc_context, input_pixels, input_w, input_h, input_stride_in_bytes,
        output_pixels, output_w, output_h, output_stride_in_bytes,
        0,0,1,1,NULL,num_channels,alpha_channel,flags, STBIR_TYPE_FLOAT, filter, filter,
        edge_wrap_mode, edge_wrap_mode, space);
}


STBIRDEF int stbir_resize(         const void *input_pixels , int input_w , int input_h , int input_stride_in_bytes,
                                         void *output_pixels, int output_w, int output_h, int output_stride_in_bytes,
                                   stbir_datatype datatype,
                                   int num_channels, int alpha_channel, int flags,
                                   stbir_edge edge_mode_horizontal, stbir_edge edge_mode_vertical,
                                   stbir_filter filter_horizontal,  stbir_filter filter_vertical,
                                   stbir_colorspace space, void *alloc_context)
{
    return stbir__resize_arbitrary(alloc_context, input_pixels, input_w, input_h, input_stride_in_bytes,
        output_pixels, output_w, output_h, output_stride_in_bytes,
        0,0,1,1,NULL,num_channels,alpha_channel,flags, datatype, filter_horizontal, filter_vertical,
        edge_mode_horizontal, edge_mode_vertical, space);
}


STBIRDEF int stbir_resize_subpixel(const void *input_pixels , int input_w , int input_h , int input_stride_in_bytes,
                                         void *output_pixels, int output_w, int output_h, int output_stride_in_bytes,
                                   stbir_datatype datatype,
                                   int num_channels, int alpha_channel, int flags,
                                   stbir_edge edge_mode_horizontal, stbir_edge edge_mode_vertical,
                                   stbir_filter filter_horizontal,  stbir_filter filter_vertical,
                                   stbir_colorspace space, void *alloc_context,
                                   float x_scale, float y_scale,
                                   float x_offset, float y_offset)
{
    float transform[4];
    transform[0] = x_scale;
    transform[1] = y_scale;
    transform[2] = x_offset;
    transform[3] = y_offset;
    return stbir__resize_arbitrary(alloc_context, input_pixels, input_w, input_h, input_stride_in_bytes,
        output_pixels, output_w, output_h, output_stride_in_bytes,
        0,0,1,1,transform,num_channels,alpha_channel,flags, datatype, filter_horizontal, filter_vertical,
        edge_mode_horizontal, edge_mode_vertical, space);
}

STBIRDEF int stbir_resize_region(  const void *input_pixels , int input_w , int input_h , int input_stride_in_bytes,
                                         void *output_pixels, int output_w, int output_h, int output_stride_in_bytes,
                                   stbir_datatype datatype,
                                   int num_channels, int alpha_channel, int flags,
                                   stbir_edge edge_mode_horizontal, stbir_edge edge_mode_vertical,
                                   stbir_filter filter_horizontal,  stbir_filter filter_vertical,
                                   stbir_colorspace space, void *alloc_context,
                                   float s0, float t0, float s1, float t1)
{
    return stbir__resize_arbitrary(alloc_context, input_pixels, input_w, input_h, input_stride_in_bytes,
        output_pixels, output_w, output_h, output_stride_in_bytes,
        s0,t0,s1,t1,NULL,num_channels,alpha_channel,flags, datatype, filter_horizontal, filter_vertical,
        edge_mode_horizontal, edge_mode_vertical, space);
}

#endif // STB_IMAGE_RESIZE_IMPLEMENTATION

/*
------------------------------------------------------------------------------
This software is available under 2 licenses -- choose whichever you prefer.
------------------------------------------------------------------------------
ALTERNATIVE A - MIT License
Copyright (c) 2017 Sean Barrett
Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
------------------------------------------------------------------------------
ALTERNATIVE B - Public Domain (www.unlicense.org)
This is free and unencumbered software released into the public domain.
Anyone is free to copy, modify, publish, use, compile, sell, or distribute this
software, either in source code form or as a compiled binary, for any purpose,
commercial or non-commercial, and by any means.
In jurisdictions that recognize copyright laws, the author or authors of this
software dedicate any and all copyright interest in the software to the public
domain. We make this dedication for the benefit of the public at large and to
the detriment of our heirs and successors. We intend this dedication to be an
overt act of relinquishment in perpetuity of all present and future rights to
this software under copyright law.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
------------------------------------------------------------------------------
*/

#include <fstream>
#include <iostream>
#include <string>

std::string get_file_contents(const char *filename)
{
	std::ifstream in(filename, std::ios::in | std::ios::binary);
	if (in)
	{
		std::string contents;
		in.seekg(0, std::ios::end);
		contents.resize(in.tellg());
		in.seekg(0, std::ios::beg);
		in.read(&contents[0], contents.size());
		in.close();
		return(contents);
	}
}

std::ifstream::pos_type getFileSize(const char* filename)
{
	std::ifstream in(filename, std::ifstream::ate | std::ifstream::binary);
	return in.tellg(); 
}

void _CreateIcon(String srcFilename, String dstFilename, int w, int h,int round) {
	int width,height,n;
	
	stbi_uc *input_pixels = stbi_load(C_STR(srcFilename), &width, &height, &n, 4);
	stbi_uc output_pixels[4*w*h];
	
	stbir_resize_uint8(input_pixels,width,height,0, output_pixels, w,h,0,4);
	
	if (round) {
		int i,r;
		for (int x = 0; x < w; x++) {
			for (int y = 0; y < h; y++) {
				i = x + y*w;
				r = sqrt(((w/2-x)*(w/2-x)) + ((h/2-y)*(h/2-y)));
				if (r>w/2-1) {
					output_pixels[i*4+3] = 0;
				}
			}
		}
	}
	
	stbi_write_png(C_STR(dstFilename), w, h, 4, &output_pixels, 0);
}

// crudely build the icon file... file format on wiki
// https://en.wikipedia.org/wiki/ICO_(file_format)
void _ConvertToIco(String srcFilename,String destFilename) {
	// widths for icons
	int widths[] = {16,32,48,64,128,256};
	
	// build indiviual icon files for icon file
	int num_of_images=sizeof(widths) / sizeof(widths[0]);;
	int size_of_files[num_of_images];
	int width;
	int size_of_data=0;
	int i=0;
	while (i<num_of_images) {
		width = widths[i];
		
		String tmpname = srcFilename+".tmp."+width;
		_CreateIcon(srcFilename, tmpname, width,width,0);

		size_of_files[i] = getFileSize(C_STR(tmpname));
		size_of_data=size_of_data+size_of_files[i];

		i++;
	}

	// final file data
	int size_of_file=6+size_of_data+16*num_of_images;
	char* new_data=new char[size_of_file];
	// header
	new_data[0]=0;
	new_data[1]=0;
	new_data[2]=1;
	new_data[3]=0;
	// number of images
	new_data[4]=num_of_images & 255;
	new_data[5]=(num_of_images >> 8) & 255;

	// image headers
	int offset=6;
	int data_pointer = 6+num_of_images*16;
	
	i=0;
	while (i<num_of_images) {
		width = widths[i];

		// image header
		new_data[offset+0] = width;
		new_data[offset+1] = width;
		new_data[offset+2] = 0;
		new_data[offset+3] = 0;
		new_data[offset+4] = 0;
		new_data[offset+5] = 0;
		new_data[offset+6] = 32;
		new_data[offset+7] = 0;
		// size of data (little endian)
		new_data[offset+8] = (size_of_files[i] >> 0) & 255;
		new_data[offset+9] = (size_of_files[i] >> 8) & 255;
		new_data[offset+10] = (size_of_files[i] >> 16) & 255;
		new_data[offset+11] = (size_of_files[i] >> 24) & 255;
		// offset to image data (little endian)
		new_data[offset+12] = (data_pointer >> 0) & 255;
		new_data[offset+13] = (data_pointer >> 8) & 255;
		new_data[offset+14] = (data_pointer >> 16) & 255;
		new_data[offset+15] = (data_pointer >> 24) & 255;
		
		offset = offset+16;
		data_pointer = data_pointer + size_of_files[i];
		i++;
	}
	
	// add data
	data_pointer = 6+num_of_images*16;	// end of header
	
	i=0;
	while (i<num_of_images) {
		width = widths[i];

		String tmpname = srcFilename+".tmp."+width;
		std::ifstream infile (C_STR(tmpname),std::ifstream::binary);
		char* buffer = new char[size_of_files[i]];
		infile.read (buffer,size_of_files[i]);
		infile.close();

		// copy image data in
		for (int j = 0; j < size_of_files[i]; j++) {
			new_data[data_pointer+j] = buffer[j];
		}

		// delete temp file
		// this bit of code from stb_image as i struggled to convert string to *wchar
#if _WIN32
		wchar_t wFilename[1024];
		if (0 != MultiByteToWideChar(65001 /* UTF8 */, 0, C_STR(tmpname), -1, wFilename, sizeof(wFilename)))
			remove(wFilename);
#else
		remove(OS_STR(tmpname));
#endif
		data_pointer = data_pointer + size_of_files[i];
		i++;
	}
	

	// write file
	std::ofstream outfile (C_STR(destFilename),std::ofstream::binary);
	outfile.write (new_data,size_of_file);
	outfile.close();
}



// ***** thread.h *****

#if __cplusplus_winrt

using namespace Windows::System::Threading;

#endif

class BBThread : public Object{
public:
	Object *result;
	
	BBThread();
	
	virtual void Start();
	virtual bool IsRunning();
	
	virtual Object *Result();
	virtual void SetResult( Object *result );
	
	static  String Strdup( const String &str );
	
	virtual void Run__UNSAFE__();
	
	
private:

	enum{
		INIT=0,
		RUNNING=1,
		FINISHED=2
	};

	
	int _state;
	Object *_result;
	
#if __cplusplus_winrt

	friend class Launcher;

	class Launcher{
	
		friend class BBThread;
		BBThread *_thread;
		
		Launcher( BBThread *thread ):_thread(thread){
		}
		
		public:
		
		void operator()( IAsyncAction ^operation ){
			_thread->Run__UNSAFE__();
			_thread->_state=FINISHED;
		} 
	};
	
#elif _WIN32

	static DWORD WINAPI run( void *p );
	
#else

	static void *run( void *p );
	
#endif

};

// ***** thread.cpp *****

BBThread::BBThread():_state( INIT ),_result( 0 ){
}

bool BBThread::IsRunning(){
	return _state==RUNNING;
}

Object *BBThread::Result(){
	return _result;
}

void BBThread::SetResult( Object *result ){
	_result=result;
}

String BBThread::Strdup( const String &str ){
	return str.Copy();
}

void BBThread::Run__UNSAFE__(){
}

#if __cplusplus_winrt

void BBThread::Start(){
	if( _state==RUNNING ) return;
	
	_result=0;
	_state=RUNNING;
	
	Launcher launcher( this );
	
	auto handler=ref new WorkItemHandler( launcher );
	
	ThreadPool::RunAsync( handler );
}

#elif _WIN32

void BBThread::Start(){
	if( _state==RUNNING ) return;
	
	_result=0;
	_state=RUNNING;
	
	DWORD _id;
	HANDLE _handle;

	if( _handle=CreateThread( 0,0,run,this,0,&_id ) ){
		CloseHandle( _handle );
		return;
	}
	
	puts( "CreateThread failed!" );
	exit( -1 );
}

DWORD WINAPI BBThread::run( void *p ){
	BBThread *thread=(BBThread*)p;

	thread->Run__UNSAFE__();
	
	thread->_state=FINISHED;
	return 0;
}

#else

void BBThread::Start(){
	if( _state==RUNNING ) return;
	
	_result=0;
	_state=RUNNING;
	
	pthread_t _handle;
	
	if( !pthread_create( &_handle,0,run,this ) ){
		pthread_detach( _handle );
		return;
	}
	
	puts( "pthread_create failed!" );
	exit( -1 );
}

void *BBThread::run( void *p ){
	BBThread *thread=(BBThread*)p;

	thread->Run__UNSAFE__();

	thread->_state=FINISHED;
	return 0;
}

#endif


// ***** databuffer.h *****

class BBDataBuffer : public Object{
public:
	
	BBDataBuffer();
	
	~BBDataBuffer();
	
	bool _New( int length,void *data=0 );
	
	bool _Load( String path );
	
	void _LoadAsync( const String &path,BBThread *thread );

	void Discard();
	
	const void *ReadPointer( int offset=0 ){
		return _data+offset;
	}
	
	void *WritePointer( int offset=0 ){
		return _data+offset;
	}
	
	int Length(){
		return _length;
	}
	
	void PokeByte( int addr,int value ){
		*(_data+addr)=value;
	}

	void PokeShort( int addr,int value ){
		*(short*)(_data+addr)=value;
	}
	
	void PokeInt( int addr,int value ){
		*(int*)(_data+addr)=value;
	}
	
	void PokeFloat( int addr,float value ){
		*(float*)(_data+addr)=value;
	}

	int PeekByte( int addr ){
		return *(_data+addr);
	}
	
	int PeekShort( int addr ){
		return *(short*)(_data+addr);
	}
	
	int PeekInt( int addr ){
		return *(int*)(_data+addr);
	}
	
	float PeekFloat( int addr ){
		return *(float*)(_data+addr);
	}
	
private:
	signed char *_data;
	int _length;
};

// ***** databuffer.cpp *****

BBDataBuffer::BBDataBuffer():_data(0),_length(0){
}

BBDataBuffer::~BBDataBuffer(){
	if( _data ) free( _data );
}

bool BBDataBuffer::_New( int length,void *data ){
	if( _data ) return false;
	if( !data ) data=malloc( length );
	_data=(signed char*)data;
	_length=length;
	return true;
}

bool BBDataBuffer::_Load( String path ){
	if( _data ) return false;
	
	_data=(signed char*)BBGame::Game()->LoadData( path,&_length );
	if( !_data ) return false;
	
	return true;
}

void BBDataBuffer::_LoadAsync( const String &cpath,BBThread *thread ){

	String path=cpath.Copy();
	
	if( _Load( path ) ) thread->SetResult( this );
}

void BBDataBuffer::Discard(){
	if( !_data ) return;
	free( _data );
	_data=0;
	_length=0;
}


// ***** stream.h *****

class BBStream : public Object{
public:

	virtual int Eof(){
		return 0;
	}

	virtual void Close(){
	}

	virtual int Length(){
		return 0;
	}
	
	virtual int Position(){
		return 0;
	}
	
	virtual int Seek( int position ){
		return 0;
	}
	
	virtual int Read( BBDataBuffer *buffer,int offset,int count ){
		return 0;
	}

	virtual int Write( BBDataBuffer *buffer,int offset,int count ){
		return 0;
	}
};

// ***** stream.cpp *****


// ***** filestream.h *****

class BBFileStream : public BBStream{
public:

	BBFileStream();
	~BBFileStream();

	void Close();
	int Eof();
	int Length();
	int Position();
	int Seek( int position );
	int Read( BBDataBuffer *buffer,int offset,int count );
	int Write( BBDataBuffer *buffer,int offset,int count );

	bool Open( String path,String mode );
	
private:
	FILE *_file;
	int _position;
	int _length;
};

// ***** filestream.cpp *****

BBFileStream::BBFileStream():_file(0),_position(0),_length(0){
}

BBFileStream::~BBFileStream(){
	if( _file ) fclose( _file );
}

bool BBFileStream::Open( String path,String mode ){
	if( _file ) return false;

	String fmode;	
	if( mode=="r" ){
		fmode="rb";
	}else if( mode=="w" ){
		fmode="wb";
	}else if( mode=="u" ){
		fmode="rb+";
	}else{
		return false;
	}

	_file=BBGame::Game()->OpenFile( path,fmode );
	if( !_file && mode=="u" ) _file=BBGame::Game()->OpenFile( path,"wb+" );
	if( !_file ) return false;
	
	fseek( _file,0,SEEK_END );
	_length=ftell( _file );
	fseek( _file,0,SEEK_SET );
	_position=0;
	
	return true;
}

void BBFileStream::Close(){
	if( !_file ) return;
	
	fclose( _file );
	_file=0;
	_position=0;
	_length=0;
}

int BBFileStream::Eof(){
	if( !_file ) return -1;
	
	return _position==_length;
}

int BBFileStream::Length(){
	return _length;
}

int BBFileStream::Position(){
	return _position;
}

int BBFileStream::Seek( int position ){
	if( !_file ) return 0;
	
	fseek( _file,position,SEEK_SET );
	_position=ftell( _file );
	return _position;
}

int BBFileStream::Read( BBDataBuffer *buffer,int offset,int count ){
	if( !_file ) return 0;
	
	int n=fread( buffer->WritePointer(offset),1,count,_file );
	_position+=n;
	return n;
}

int BBFileStream::Write( BBDataBuffer *buffer,int offset,int count ){
	if( !_file ) return 0;
	
	int n=fwrite( buffer->ReadPointer(offset),1,count,_file );
	_position+=n;
	if( _position>_length ) _length=_position;
	return n;
}

class c_TransCC;
class c_Type;
class c_StringType;
class c_Decl;
class c_ScopeDecl;
class c_ConfigScope;
class c_ValDecl;
class c_ConstDecl;
class c_Map;
class c_StringMap;
class c_Node;
class c_Expr;
class c_BoolType;
class c_Map2;
class c_StringMap2;
class c_Node2;
class c_Stack;
class c_StringStack;
class c_Builder;
class c_Map3;
class c_StringMap3;
class c_AndroidBuilder;
class c_Node3;
class c_AndroidNdkBuilder;
class c_GlfwBuilder;
class c_Html5Builder;
class c_IosBuilder;
class c_FlashBuilder;
class c_PsmBuilder;
class c_StdcppBuilder;
class c_WinrtBuilder;
class c_XnaBuilder;
class c_AGKBuilder;
class c_AGKBuilder_ios;
class c_NodeEnumerator;
class c_List;
class c_StringList;
class c_Node4;
class c_HeadNode;
class c_Enumerator;
class c_Stack2;
class c_ModuleDecl;
class c_Stack3;
class c_IntStack;
class c_List2;
class c_Node5;
class c_HeadNode2;
class c_Toker;
class c_Set;
class c_StringSet;
class c_Map4;
class c_StringMap4;
class c_Node6;
class c_AppDecl;
class c_Map5;
class c_StringMap5;
class c_Node7;
class c_Parser;
class c_BlockTrace;
class c_List3;
class c_IntList;
class c_Map6;
class c_IntMap;
class c_Node8;
class c_TraceRecord;
class c_List4;
class c_Node9;
class c_HeadNode3;
class c_NumericType;
class c_IntType;
class c_FloatType;
class c_AliasDecl;
class c_List5;
class c_Node10;
class c_HeadNode4;
class c_BlockDecl;
class c_FuncDecl;
class c_List6;
class c_FuncDeclList;
class c_Node11;
class c_HeadNode5;
class c_ClassDecl;
class c_VoidType;
class c_IdentType;
class c_Stack4;
class c_ArrayType;
class c_UnaryExpr;
class c_ArrayExpr;
class c_Stack5;
class c_ConstExpr;
class c_ScopeExpr;
class c_NewArrayExpr;
class c_NewObjectExpr;
class c_CastExpr;
class c_IdentExpr;
class c_SelfExpr;
class c_Stmt;
class c_List7;
class c_Node12;
class c_HeadNode6;
class c_InvokeSuperExpr;
class c_IdentTypeExpr;
class c_Node13;
class c_HeadNode7;
class c_Enumerator2;
class c_MapKeys;
class c_KeyEnumerator;
class c_FuncCallExpr;
class c_SliceExpr;
class c_IndexExpr;
class c_BinaryExpr;
class c_BinaryMathExpr;
class c_BinaryCompareExpr;
class c_BinaryLogicExpr;
class c_VarDecl;
class c_GlobalDecl;
class c_FieldDecl;
class c_LocalDecl;
class c_Enumerator3;
class c_DeclStmt;
class c_Stack6;
class c_ObjectType;
class c_List8;
class c_Node14;
class c_HeadNode8;
class c_ArgDecl;
class c_Stack7;
class c_List9;
class c_Node15;
class c_HeadNode9;
class c_ReturnStmt;
class c_BreakStmt;
class c_ContinueStmt;
class c_IfStmt;
class c_WhileStmt;
class c_RepeatStmt;
class c_ForEachinStmt;
class c_AssignStmt;
class c_ForStmt;
class c_CatchStmt;
class c_Stack8;
class c_TryStmt;
class c_ThrowStmt;
class c_ExprStmt;
class c_Enumerator4;
class c_List10;
class c_Node16;
class c_HeadNode10;
class c_InvokeMemberExpr;
class c_Target;
class c_Map7;
class c_StringMap6;
class c_Node17;
class c_NodeEnumerator2;
class c_Reflector;
class c_MapValues;
class c_ValueEnumerator;
class c_Map8;
class c_StringMap7;
class c_Node18;
class c_Enumerator5;
class c_Stack9;
class c_Translator;
class c_CTranslator;
class c_JavaTranslator;
class c_NodeEnumerator3;
class c_CppTranslator;
class c_JsTranslator;
class c_Stream;
class c_FileStream;
class c_DataBuffer;
class c_AsTranslator;
class c_CsTranslator;
class c_List11;
class c_Node19;
class c_HeadNode11;
class c_Enumerator6;
class c_InvokeExpr;
class c_StmtExpr;
class c_MemberVarExpr;
class c_VarExpr;
class c_Map9;
class c_StringMap8;
class c_Node20;
class c_Map10;
class c_StringMap9;
class c_Node21;
class c_Map11;
class c_StringMap10;
class c_Node22;
class c_Enumerator7;
class c_Stack10;
class c_Enumerator8;
class c_TransCC : public Object{
	public:
	Array<String > m_args;
	String m_cerberusdir;
	String m_opt_srcpath;
	bool m_opt_safe;
	bool m_opt_clean;
	bool m_opt_check;
	bool m_opt_update;
	bool m_opt_build;
	bool m_opt_run;
	String m_opt_cfgfile;
	String m_opt_output;
	String m_opt_config;
	String m_opt_target;
	String m_opt_modpath;
	String m_opt_builddir;
	String m_ANDROID_PATH;
	String m_ANDROID_NDK_PATH;
	String m_JDK_PATH;
	String m_ANT_PATH;
	String m_FLEX_PATH;
	String m_MINGW_PATH;
	String m_PSM_PATH;
	String m_MSBUILD_PATH;
	String m_AGK_PATH;
	String m_HTML_PLAYER;
	String m_FLASH_PLAYER;
	String m__libs;
	c_StringMap3* m__builders;
	c_StringMap6* m__targets;
	c_Target* m_target;
	c_TransCC();
	c_TransCC* m_new();
	void p_ParseArgs();
	void p_LoadConfig();
	void p_EnumBuilders();
	void p_EnumTargets(String);
	String p_GetReleaseVersion();
	void p_Run(Array<String >);
	bool p_Execute(String,bool);
	void mark();
};
String bb_os_ExtractDir(String);
String bb_transcc_StripQuotes(String);
int bb_transcc_Die(String);
class c_Type : public Object{
	public:
	c_ArrayType* m_arrayOf;
	c_Type();
	c_Type* m_new();
	static c_StringType* m_stringType;
	static c_IntType* m_intType;
	static c_FloatType* m_floatType;
	static c_BoolType* m_boolType;
	static c_VoidType* m_voidType;
	static c_IdentType* m_objectType;
	static c_IdentType* m_throwableType;
	c_ArrayType* p_ArrayOf();
	static c_ArrayType* m_emptyArrayType;
	static c_IdentType* m_nullObjectType;
	virtual String p_ToString();
	virtual int p_EqualsType(c_Type*);
	virtual c_Type* p_Semant();
	virtual int p_ExtendsType(c_Type*);
	virtual c_ClassDecl* p_GetClass();
	void mark();
};
class c_StringType : public c_Type{
	public:
	c_StringType();
	c_StringType* m_new();
	int p_EqualsType(c_Type*);
	int p_ExtendsType(c_Type*);
	c_ClassDecl* p_GetClass();
	String p_ToString();
	void mark();
};
class c_Decl : public Object{
	public:
	String m_errInfo;
	String m_ident;
	String m_munged;
	int m_attrs;
	c_ScopeDecl* m_scope;
	c_Decl();
	c_Decl* m_new();
	int p_IsSemanted();
	int p_IsPublic();
	c_ModuleDecl* p_ModuleScope();
	int p_IsProtected();
	c_ClassDecl* p_ClassScope();
	c_FuncDecl* p_FuncScope();
	int p_CheckAccess();
	int p_IsExtern();
	virtual String p_ToString();
	int p_IsAbstract();
	int p_IsSemanting();
	virtual int p_OnSemant()=0;
	c_AppDecl* p_AppScope();
	int p_Semant();
	int p_IsPrivate();
	int p_AssertAccess();
	virtual c_Decl* p_OnCopy()=0;
	c_Decl* p_Copy();
	int p_IsFinal();
	void mark();
};
class c_ScopeDecl : public c_Decl{
	public:
	c_List5* m_decls;
	c_StringMap4* m_declsMap;
	c_List5* m_semanted;
	c_ScopeDecl();
	c_ScopeDecl* m_new();
	int p_InsertDecl(c_Decl*);
	virtual Object* p_GetDecl(String);
	Object* p_FindDecl(String);
	int p_InsertDecls(c_List5*);
	virtual c_FuncDecl* p_FindFuncDecl(String,Array<c_Expr* >,int);
	c_List5* p_Decls();
	c_Type* p_FindType(String,Array<c_Type* >);
	c_List6* p_MethodDecls(String);
	c_List5* p_Semanted();
	c_List6* p_SemantedMethods(String);
	virtual c_ValDecl* p_FindValDecl(String);
	c_Decl* p_OnCopy();
	int p_OnSemant();
	c_List6* p_SemantedFuncs(String);
	c_ModuleDecl* p_FindModuleDecl(String);
	c_List6* p_FuncDecls(String);
	c_ScopeDecl* p_FindScopeDecl(String);
	void mark();
};
class c_ConfigScope : public c_ScopeDecl{
	public:
	c_StringMap* m_cdecls;
	c_StringMap2* m_vars;
	c_ConfigScope();
	c_ConfigScope* m_new();
	c_ValDecl* p_FindValDecl(String);
	void mark();
};
extern String bb_config__errInfo;
extern c_ConfigScope* bb_config__cfgScope;
class c_ValDecl : public c_Decl{
	public:
	c_Type* m_type;
	c_Expr* m_init;
	c_ValDecl();
	c_ValDecl* m_new();
	String p_ToString();
	int p_OnSemant();
	c_Expr* p_CopyInit();
	void mark();
};
class c_ConstDecl : public c_ValDecl{
	public:
	String m_value;
	c_ConstDecl();
	c_ConstDecl* m_new(String,int,c_Type*,c_Expr*);
	c_ConstDecl* m_new2();
	c_Decl* p_OnCopy();
	int p_OnSemant();
	void mark();
};
class c_Map : public Object{
	public:
	c_Node* m_root;
	c_Map();
	c_Map* m_new();
	virtual int p_Compare(String,String)=0;
	c_Node* p_FindNode(String);
	c_ConstDecl* p_Get(String);
	int p_RotateLeft(c_Node*);
	int p_RotateRight(c_Node*);
	int p_InsertFixup(c_Node*);
	bool p_Set(String,c_ConstDecl*);
	bool p_Contains(String);
	void mark();
};
class c_StringMap : public c_Map{
	public:
	c_StringMap();
	c_StringMap* m_new();
	int p_Compare(String,String);
	void mark();
};
class c_Node : public Object{
	public:
	String m_key;
	c_Node* m_right;
	c_Node* m_left;
	c_ConstDecl* m_value;
	int m_color;
	c_Node* m_parent;
	c_Node();
	c_Node* m_new(String,c_ConstDecl*,int,c_Node*);
	c_Node* m_new2();
	void mark();
};
class c_Expr : public Object{
	public:
	c_Type* m_exprType;
	c_Expr();
	c_Expr* m_new();
	virtual c_Expr* p_Copy();
	virtual c_Expr* p_Semant();
	Array<c_Expr* > p_SemantArgs(Array<c_Expr* >);
	c_Expr* p_Cast(c_Type*,int);
	Array<c_Expr* > p_CastArgs(Array<c_Expr* >,c_FuncDecl*);
	virtual String p_ToString();
	virtual String p_Eval();
	virtual c_Expr* p_EvalConst();
	c_Expr* p_Semant2(c_Type*,int);
	c_Expr* p_CopyExpr(c_Expr*);
	Array<c_Expr* > p_CopyArgs(Array<c_Expr* >);
	c_Type* p_BalanceTypes(c_Type*,c_Type*);
	virtual c_Expr* p_SemantSet(String,c_Expr*);
	virtual c_ScopeDecl* p_SemantScope();
	virtual c_Expr* p_SemantFunc(Array<c_Expr* >);
	virtual bool p_SideEffects();
	virtual String p_Trans();
	virtual String p_TransStmt();
	virtual String p_TransVar();
	void mark();
};
class c_BoolType : public c_Type{
	public:
	c_BoolType();
	c_BoolType* m_new();
	int p_EqualsType(c_Type*);
	int p_ExtendsType(c_Type*);
	c_ClassDecl* p_GetClass();
	String p_ToString();
	void mark();
};
class c_Map2 : public Object{
	public:
	c_Node2* m_root;
	c_Map2();
	c_Map2* m_new();
	virtual int p_Compare(String,String)=0;
	int p_RotateLeft2(c_Node2*);
	int p_RotateRight2(c_Node2*);
	int p_InsertFixup2(c_Node2*);
	bool p_Set2(String,String);
	c_Node2* p_FindNode(String);
	String p_Get(String);
	bool p_Contains(String);
	c_Node2* p_FirstNode();
	c_NodeEnumerator3* p_ObjectEnumerator();
	void mark();
};
class c_StringMap2 : public c_Map2{
	public:
	c_StringMap2();
	c_StringMap2* m_new();
	int p_Compare(String,String);
	void mark();
};
class c_Node2 : public Object{
	public:
	String m_key;
	c_Node2* m_right;
	c_Node2* m_left;
	String m_value;
	int m_color;
	c_Node2* m_parent;
	c_Node2();
	c_Node2* m_new(String,String,int,c_Node2*);
	c_Node2* m_new2();
	c_Node2* p_NextNode();
	String p_Key();
	String p_Value();
	void mark();
};
int bb_config_SetConfigVar(String,String,c_Type*);
int bb_config_SetConfigVar2(String,String);
class c_Stack : public Object{
	public:
	Array<String > m_data;
	int m_length;
	c_Stack();
	c_Stack* m_new();
	c_Stack* m_new2(Array<String >);
	void p_Push(String);
	void p_Push2(Array<String >,int,int);
	void p_Push3(Array<String >,int);
	bool p_IsEmpty();
	Array<String > p_ToArray();
	static String m_NIL;
	void p_Length(int);
	int p_Length2();
	String p_Get2(int);
	String p_Pop();
	void p_Clear();
	void mark();
};
class c_StringStack : public c_Stack{
	public:
	c_StringStack();
	c_StringStack* m_new(Array<String >);
	c_StringStack* m_new2();
	String p_Join(String);
	void mark();
};
String bb_config_GetConfigVar(String);
String bb_transcc_ReplaceEnv(String);
class c_Builder : public Object{
	public:
	c_TransCC* m_tcc;
	String m_casedConfig;
	c_AppDecl* m_app;
	String m_transCode;
	String m_TEXT_FILES;
	String m_IMAGE_FILES;
	String m_SOUND_FILES;
	String m_MUSIC_FILES;
	String m_BINARY_FILES;
	String m_DATA_FILES;
	bool m_syncData;
	c_StringMap2* m_dataFiles;
	c_Builder();
	c_Builder* m_new(c_TransCC*);
	c_Builder* m_new2();
	virtual bool p_IsValid()=0;
	virtual void p_Begin()=0;
	virtual void p_MakeTarget()=0;
	void p_Make();
	void p_CCopyFile(String,String);
	void p_CreateDataDir(String);
	void p_MakeIcons(String,Array<String >,int);
	bool p_Execute(String,bool);
	void p_CopySourceFiles(String);
	void p_CopyIcon(String,String);
	void mark();
};
class c_Map3 : public Object{
	public:
	c_Node3* m_root;
	c_Map3();
	c_Map3* m_new();
	virtual int p_Compare(String,String)=0;
	int p_RotateLeft3(c_Node3*);
	int p_RotateRight3(c_Node3*);
	int p_InsertFixup3(c_Node3*);
	bool p_Set3(String,c_Builder*);
	c_Node3* p_FirstNode();
	c_NodeEnumerator* p_ObjectEnumerator();
	c_Node3* p_FindNode(String);
	c_Builder* p_Get(String);
	void mark();
};
class c_StringMap3 : public c_Map3{
	public:
	c_StringMap3();
	c_StringMap3* m_new();
	int p_Compare(String,String);
	void mark();
};
class c_AndroidBuilder : public c_Builder{
	public:
	c_AndroidBuilder();
	c_AndroidBuilder* m_new(c_TransCC*);
	c_AndroidBuilder* m_new2();
	bool p_IsValid();
	void p_Begin();
	bool p_CreateDirRecursive(String);
	String p_Config();
	void p_MakeTarget();
	void mark();
};
class c_Node3 : public Object{
	public:
	String m_key;
	c_Node3* m_right;
	c_Node3* m_left;
	c_Builder* m_value;
	int m_color;
	c_Node3* m_parent;
	c_Node3();
	c_Node3* m_new(String,c_Builder*,int,c_Node3*);
	c_Node3* m_new2();
	c_Node3* p_NextNode();
	c_Builder* p_Value();
	String p_Key();
	void mark();
};
class c_AndroidNdkBuilder : public c_Builder{
	public:
	c_AndroidNdkBuilder();
	c_AndroidNdkBuilder* m_new(c_TransCC*);
	c_AndroidNdkBuilder* m_new2();
	bool p_IsValid();
	void p_Begin();
	String p_Config();
	bool p_CreateDirRecursive(String);
	void p_MakeTarget();
	void mark();
};
class c_GlfwBuilder : public c_Builder{
	public:
	c_GlfwBuilder();
	c_GlfwBuilder* m_new(c_TransCC*);
	c_GlfwBuilder* m_new2();
	bool p_IsValid();
	void p_Begin();
	String p_Config();
	int p_ProcessExternalLibs(String,String,String);
	void p_MakeGcc();
	void p_MakeVc2010();
	void p_MakeMsvc();
	void p_MakeXcode();
	void p_MakeTarget();
	void mark();
};
class c_Html5Builder : public c_Builder{
	public:
	c_Html5Builder();
	c_Html5Builder* m_new(c_TransCC*);
	c_Html5Builder* m_new2();
	bool p_IsValid();
	void p_Begin();
	String p_MetaData();
	String p_Config();
	void p_MakeTarget();
	void mark();
};
class c_IosBuilder : public c_Builder{
	public:
	c_StringMap2* m__buildFiles;
	int m__nextFileId;
	c_StringMap2* m__fileRefs;
	c_IosBuilder();
	c_IosBuilder* m_new(c_TransCC*);
	c_IosBuilder* m_new2();
	bool p_IsValid();
	void p_Begin();
	String p_Config();
	String p_FileId(String,c_StringMap2*);
	void p_AddBuildFile(String);
	int p_FindEol(String,String,int);
	String p_BuildFiles();
	String p_FileRefs();
	String p_FrameworksBuildPhase();
	String p_FrameworksGroup();
	String p_LibsGroup();
	String p_MungProj(String);
	void p_MungProj2();
	void p_MakeTarget();
	void mark();
};
class c_FlashBuilder : public c_Builder{
	public:
	c_FlashBuilder();
	c_FlashBuilder* m_new(c_TransCC*);
	c_FlashBuilder* m_new2();
	bool p_IsValid();
	void p_Begin();
	String p_Assets();
	String p_Config();
	void p_MakeTarget();
	void mark();
};
class c_PsmBuilder : public c_Builder{
	public:
	c_PsmBuilder();
	c_PsmBuilder* m_new(c_TransCC*);
	c_PsmBuilder* m_new2();
	bool p_IsValid();
	void p_Begin();
	String p_Content();
	String p_Config();
	void p_MakeTarget();
	void mark();
};
class c_StdcppBuilder : public c_Builder{
	public:
	c_StdcppBuilder();
	c_StdcppBuilder* m_new(c_TransCC*);
	c_StdcppBuilder* m_new2();
	bool p_IsValid();
	void p_Begin();
	String p_Config();
	void p_MakeTarget();
	void mark();
};
class c_WinrtBuilder : public c_Builder{
	public:
	c_WinrtBuilder();
	c_WinrtBuilder* m_new(c_TransCC*);
	c_WinrtBuilder* m_new2();
	bool p_IsValid();
	void p_Begin();
	String p_Content2(bool);
	String p_Config();
	void p_MakeTarget();
	void mark();
};
class c_XnaBuilder : public c_Builder{
	public:
	c_XnaBuilder();
	c_XnaBuilder* m_new(c_TransCC*);
	c_XnaBuilder* m_new2();
	bool p_IsValid();
	void p_Begin();
	String p_Content();
	String p_Config();
	void p_MakeTarget();
	void mark();
};
class c_AGKBuilder : public c_Builder{
	public:
	c_AGKBuilder();
	c_AGKBuilder* m_new(c_TransCC*);
	c_AGKBuilder* m_new2();
	bool p_IsValid();
	void p_Begin();
	String p_Config();
	void p_CreateMediaDir(String);
	void p_MakeVc2017();
	void p_MakeXcode();
	void p_MakeTarget();
	void mark();
};
class c_AGKBuilder_ios : public c_Builder{
	public:
	c_AGKBuilder_ios();
	c_AGKBuilder_ios* m_new(c_TransCC*);
	c_AGKBuilder_ios* m_new2();
	bool p_IsValid();
	void p_Begin();
	String p_Config();
	void p_CreateMediaDir(String);
	void p_MakeXcode();
	void p_MakeTarget();
	void mark();
};
c_StringMap3* bb_builders_Builders(c_TransCC*);
class c_NodeEnumerator : public Object{
	public:
	c_Node3* m_node;
	c_NodeEnumerator();
	c_NodeEnumerator* m_new(c_Node3*);
	c_NodeEnumerator* m_new2();
	bool p_HasNext();
	c_Node3* p_NextObject();
	void mark();
};
class c_List : public Object{
	public:
	c_Node4* m__head;
	c_List();
	c_List* m_new();
	c_Node4* p_AddLast(String);
	c_List* m_new2(Array<String >);
	bool p_IsEmpty();
	String p_RemoveFirst();
	virtual bool p_Equals(String,String);
	c_Node4* p_Find(String,c_Node4*);
	c_Node4* p_Find2(String);
	void p_RemoveFirst2(String);
	int p_Count();
	c_Enumerator* p_ObjectEnumerator();
	Array<String > p_ToArray();
	String p_RemoveLast();
	c_Node4* p_FindLast(String,c_Node4*);
	c_Node4* p_FindLast2(String);
	void p_RemoveLast2(String);
	void mark();
};
class c_StringList : public c_List{
	public:
	c_StringList();
	c_StringList* m_new(Array<String >);
	c_StringList* m_new2();
	bool p_Equals(String,String);
	void mark();
};
class c_Node4 : public Object{
	public:
	c_Node4* m__succ;
	c_Node4* m__pred;
	String m__data;
	c_Node4();
	c_Node4* m_new(c_Node4*,c_Node4*,String);
	c_Node4* m_new2();
	int p_Remove();
	void mark();
};
class c_HeadNode : public c_Node4{
	public:
	c_HeadNode();
	c_HeadNode* m_new();
	void mark();
};
class c_Enumerator : public Object{
	public:
	c_List* m__list;
	c_Node4* m__curr;
	c_Enumerator();
	c_Enumerator* m_new(c_List*);
	c_Enumerator* m_new2();
	bool p_HasNext();
	String p_NextObject();
	void mark();
};
Array<String > bb_os_LoadDir(String,bool,bool);
class c_Stack2 : public Object{
	public:
	Array<c_ConfigScope* > m_data;
	int m_length;
	c_Stack2();
	c_Stack2* m_new();
	c_Stack2* m_new2(Array<c_ConfigScope* >);
	void p_Push4(c_ConfigScope*);
	void p_Push5(Array<c_ConfigScope* >,int,int);
	void p_Push6(Array<c_ConfigScope* >,int);
	static c_ConfigScope* m_NIL;
	c_ConfigScope* p_Pop();
	void mark();
};
extern c_Stack2* bb_config__cfgScopeStack;
void bb_config_PushConfigScope();
class c_ModuleDecl : public c_ScopeDecl{
	public:
	String m_rmodpath;
	String m_filepath;
	String m_modpath;
	c_StringMap5* m_imported;
	c_StringSet* m_friends;
	c_StringMap5* m_pubImported;
	c_ModuleDecl();
	c_ModuleDecl* m_new(String,int,String,String,String,c_AppDecl*);
	c_ModuleDecl* m_new2();
	int p_IsStrict();
	int p_ImportModule(String,int);
	int p_SemantAll();
	String p_ToString();
	Object* p_GetDecl2(String);
	Object* p_GetDecl(String);
	int p_OnSemant();
	void mark();
};
class c_Stack3 : public Object{
	public:
	Array<int > m_data;
	int m_length;
	c_Stack3();
	c_Stack3* m_new();
	c_Stack3* m_new2(Array<int >);
	void p_Push7(int);
	void p_Push8(Array<int >,int,int);
	void p_Push9(Array<int >,int);
	bool p_IsEmpty();
	static int m_NIL;
	int p_Pop();
	void p_Length(int);
	int p_Length2();
	int p_Get2(int);
	void p_Clear();
	void mark();
};
class c_IntStack : public c_Stack3{
	public:
	c_IntStack();
	c_IntStack* m_new(Array<int >);
	c_IntStack* m_new2();
	void mark();
};
c_ScopeDecl* bb_config_GetConfigScope();
extern c_ScopeDecl* bb_decl__env;
class c_List2 : public Object{
	public:
	c_Node5* m__head;
	c_List2();
	c_List2* m_new();
	c_Node5* p_AddLast2(c_ScopeDecl*);
	c_List2* m_new2(Array<c_ScopeDecl* >);
	bool p_IsEmpty();
	c_ScopeDecl* p_RemoveLast();
	bool p_Equals2(c_ScopeDecl*,c_ScopeDecl*);
	c_Node5* p_FindLast3(c_ScopeDecl*,c_Node5*);
	c_Node5* p_FindLast4(c_ScopeDecl*);
	void p_RemoveLast3(c_ScopeDecl*);
	void mark();
};
class c_Node5 : public Object{
	public:
	c_Node5* m__succ;
	c_Node5* m__pred;
	c_ScopeDecl* m__data;
	c_Node5();
	c_Node5* m_new(c_Node5*,c_Node5*,c_ScopeDecl*);
	c_Node5* m_new2();
	int p_Remove();
	void mark();
};
class c_HeadNode2 : public c_Node5{
	public:
	c_HeadNode2();
	c_HeadNode2* m_new();
	void mark();
};
extern c_List2* bb_decl__envStack;
int bb_decl_PushEnv(c_ScopeDecl*);
class c_Toker : public Object{
	public:
	String m__path;
	int m__line;
	String m__source;
	int m__length;
	String m__toke;
	int m__tokeType;
	int m__tokePos;
	c_Toker();
	static c_StringSet* m__keywords;
	static c_StringSet* m__symbols;
	int p__init();
	c_Toker* m_new(String,String);
	c_Toker* m_new2(c_Toker*);
	c_Toker* m_new3();
	int p_TCHR(int);
	String p_TSTR(int);
	static int m__tokenFlags;
	static bool m_Remarks();
	String p_NextToke();
	String p_Toke();
	int p_TokeType();
	String p_Path();
	int p_Line();
	int p_SkipSpace();
	static int m_RemarksOn();
	static int m_RemarksOff();
	void mark();
};
class c_Set : public Object{
	public:
	c_Map4* m_map;
	c_Set();
	c_Set* m_new(c_Map4*);
	c_Set* m_new2();
	int p_Insert(String);
	bool p_Contains(String);
	void mark();
};
class c_StringSet : public c_Set{
	public:
	c_StringSet();
	c_StringSet* m_new();
	void mark();
};
class c_Map4 : public Object{
	public:
	c_Node6* m_root;
	c_Map4();
	c_Map4* m_new();
	virtual int p_Compare(String,String)=0;
	int p_RotateLeft4(c_Node6*);
	int p_RotateRight4(c_Node6*);
	int p_InsertFixup4(c_Node6*);
	bool p_Set4(String,Object*);
	bool p_Insert2(String,Object*);
	c_Node6* p_FindNode(String);
	bool p_Contains(String);
	Object* p_Get(String);
	void mark();
};
class c_StringMap4 : public c_Map4{
	public:
	c_StringMap4();
	c_StringMap4* m_new();
	int p_Compare(String,String);
	void mark();
};
class c_Node6 : public Object{
	public:
	String m_key;
	c_Node6* m_right;
	c_Node6* m_left;
	Object* m_value;
	int m_color;
	c_Node6* m_parent;
	c_Node6();
	c_Node6* m_new(String,Object*,int,c_Node6*);
	c_Node6* m_new2();
	void mark();
};
int bb_config_IsSpace(int);
int bb_config_IsAlpha(int);
int bb_config_IsDigit(int);
int bb_config_IsBinDigit(int);
int bb_config_IsHexDigit(int);
extern String bb_config_ENV_MODPATH;
String bb_os_StripExt(String);
String bb_os_StripDir(String);
extern String bb_parser_FILE_EXT;
extern String bb_parser_FILE_EXT_OLD;
int bb_config_Err(String);
String bb_os_ExtractExt(String);
class c_AppDecl : public c_ScopeDecl{
	public:
	c_StringMap5* m_imported;
	c_ModuleDecl* m_mainModule;
	c_StringList* m_fileImports;
	c_StringList* m_fileIncludes;
	c_StringList* m_dirIncludes;
	c_List5* m_allSemantedDecls;
	c_List10* m_semantedGlobals;
	c_List8* m_semantedClasses;
	c_FuncDecl* m_mainFunc;
	c_AppDecl();
	int p_InsertModule(c_ModuleDecl*);
	c_AppDecl* m_new();
	int p_FinalizeClasses();
	int p_OnSemant();
	void mark();
};
class c_Map5 : public Object{
	public:
	c_Node7* m_root;
	c_Map5();
	c_Map5* m_new();
	virtual int p_Compare(String,String)=0;
	c_Node7* p_FindNode(String);
	c_ModuleDecl* p_Get(String);
	bool p_Contains(String);
	int p_RotateLeft5(c_Node7*);
	int p_RotateRight5(c_Node7*);
	int p_InsertFixup5(c_Node7*);
	bool p_Set5(String,c_ModuleDecl*);
	bool p_Insert3(String,c_ModuleDecl*);
	c_MapValues* p_Values();
	c_Node7* p_FirstNode();
	void mark();
};
class c_StringMap5 : public c_Map5{
	public:
	c_StringMap5();
	c_StringMap5* m_new();
	int p_Compare(String,String);
	void mark();
};
class c_Node7 : public Object{
	public:
	String m_key;
	c_Node7* m_right;
	c_Node7* m_left;
	c_ModuleDecl* m_value;
	int m_color;
	c_Node7* m_parent;
	c_Node7();
	c_Node7* m_new(String,c_ModuleDecl*,int,c_Node7*);
	c_Node7* m_new2();
	c_Node7* p_NextNode();
	void mark();
};
class c_Parser : public Object{
	public:
	String m__toke;
	c_Toker* m__toker;
	c_AppDecl* m__app;
	c_ModuleDecl* m__module;
	int m__defattrs;
	int m__tokeType;
	c_BlockDecl* m__block;
	c_List9* m__blockStack;
	c_StringList* m__errStack;
	int m__selTmpId;
	c_Parser();
	int p_SetErr(int);
	int p_CParse(String);
	int p_SkipEols();
	String p_NextToke();
	c_Parser* m_new(c_Toker*,c_AppDecl*,c_ModuleDecl*,int);
	c_Parser* m_new2();
	String p_ParseStringLit();
	String p_RealPath(String);
	int p_ImportFile(String);
	String p_ParseIdent();
	String p_ParseModPath();
	int p_ImportModule(String,int);
	int p_IncludeFiles(String);
	int p_IncludeDirs(String);
	int p_Parse(String);
	c_Type* p_CParsePrimitiveType();
	c_IdentType* p_ParseIdentType();
	c_Type* p_ParseType();
	c_Type* p_ParseDeclType();
	c_ArrayExpr* p_ParseArrayExpr();
	int p_AtEos();
	Array<c_Expr* > p_ParseArgs2(int);
	c_IdentType* p_CParseIdentType(bool);
	c_TraceRecord* p_BackTrace(int);
	c_Expr* p_ParsePrimaryExpr(int);
	c_Expr* p_ParseUnaryExpr();
	c_Expr* p_ParseMulDivExpr();
	c_Expr* p_ParseAddSubExpr();
	c_Expr* p_ParseBitandExpr();
	c_Expr* p_ParseBitorExpr();
	c_Expr* p_ParseCompareExpr();
	c_Expr* p_ParseAndExpr();
	c_Expr* p_ParseOrExpr();
	c_Expr* p_ParseExpr();
	c_Decl* p_ParseDecl(String,int);
	c_List5* p_ParseDecls(String,int);
	c_List5* p_ParseEnumStmt(int,bool);
	c_List5* p_ParseEnum(String,int);
	int p_PushBlock(c_BlockDecl*);
	int p_ParseDeclStmts();
	int p_ParseReturnStmt();
	int p_ParseExitStmt();
	int p_ParseContinueStmt();
	int p_AtEOF(int,String);
	int p_AtEOF2(String,String);
	int p_PopBlock();
	int p_AtEos2();
	int p_ParseBlockEnd(String,String,int);
	int p_ParseIfStmt(String);
	int p_ParseWhileStmt();
	int p_PushErr();
	int p_PopErr();
	int p_ParseRepeatStmt();
	int p_ParseForStmt();
	int p_ParseSelectStmt();
	int p_ParseTryStmt();
	int p_ParseThrowStmt();
	int p_ParseStmt();
	c_FuncDecl* p_ParseFuncDecl(int);
	c_ClassDecl* p_ParseClassDecl(int);
	int p_ParseMain();
	void mark();
};
class c_BlockTrace : public Object{
	public:
	c_IntMap* m__map;
	c_List4* m__record;
	c_BlockTrace();
	c_BlockTrace* m_new();
	static c_BlockTrace* m__Blocks;
	static int m_Clear();
	c_TraceRecord* p_LastBlockItem();
	c_IntList* p_BlockLineList(int);
	int p_Unwind(int);
	static int m_TraceLog(int);
	static int m_Str2Code(String);
	static int m_TraceLog2(String);
	c_TraceRecord* p_RemoveRecord();
	static c_TraceRecord* m_Pop();
	static String m_Code2Str(int);
	int p_AddRecord(c_TraceRecord*);
	static int m_Push(int,int);
	static int m_Push2(String,int);
	void mark();
};
class c_List3 : public Object{
	public:
	c_Node13* m__head;
	c_List3();
	c_List3* m_new();
	c_Node13* p_AddLast3(int);
	c_List3* m_new2(Array<int >);
	c_Enumerator2* p_ObjectEnumerator();
	virtual int p_Compare2(int,int);
	int p_Sort(int);
	int p_Count();
	Array<int > p_ToArray();
	void mark();
};
class c_IntList : public c_List3{
	public:
	c_IntList();
	c_IntList* m_new(Array<int >);
	c_IntList* m_new2();
	int p_Compare2(int,int);
	void mark();
};
class c_Map6 : public Object{
	public:
	c_Node8* m_root;
	c_Map6();
	c_Map6* m_new();
	int p_Clear();
	virtual int p_Compare2(int,int)=0;
	c_Node8* p_FindNode2(int);
	c_IntList* p_Get2(int);
	c_MapKeys* p_Keys();
	c_Node8* p_FirstNode();
	bool p_Contains2(int);
	int p_RotateLeft6(c_Node8*);
	int p_RotateRight6(c_Node8*);
	int p_InsertFixup6(c_Node8*);
	bool p_Add(int,c_IntList*);
	void mark();
};
class c_IntMap : public c_Map6{
	public:
	c_IntMap();
	c_IntMap* m_new();
	int p_Compare2(int,int);
	void mark();
};
class c_Node8 : public Object{
	public:
	int m_key;
	c_Node8* m_right;
	c_Node8* m_left;
	c_IntList* m_value;
	c_Node8* m_parent;
	int m_color;
	c_Node8();
	c_Node8* p_NextNode();
	c_Node8* m_new(int,c_IntList*,int,c_Node8*);
	c_Node8* m_new2();
	void mark();
};
class c_TraceRecord : public Object{
	public:
	int m__line;
	int m__toke;
	c_TraceRecord();
	int p_Line();
	int p_Toke();
	c_TraceRecord* m_new(int,int);
	c_TraceRecord* m_new2();
	void mark();
};
class c_List4 : public Object{
	public:
	c_Node9* m__head;
	c_List4();
	c_List4* m_new();
	c_Node9* p_AddLast4(c_TraceRecord*);
	c_List4* m_new2(Array<c_TraceRecord* >);
	int p_Clear();
	bool p_IsEmpty();
	c_TraceRecord* p_Last();
	c_TraceRecord* p_RemoveLast();
	bool p_Equals3(c_TraceRecord*,c_TraceRecord*);
	c_Node9* p_FindLast5(c_TraceRecord*,c_Node9*);
	c_Node9* p_FindLast6(c_TraceRecord*);
	void p_RemoveLast4(c_TraceRecord*);
	void mark();
};
class c_Node9 : public Object{
	public:
	c_Node9* m__succ;
	c_Node9* m__pred;
	c_TraceRecord* m__data;
	c_Node9();
	c_Node9* m_new(c_Node9*,c_Node9*,c_TraceRecord*);
	c_Node9* m_new2();
	int p_Remove();
	void mark();
};
class c_HeadNode3 : public c_Node9{
	public:
	c_HeadNode3();
	c_HeadNode3* m_new();
	void mark();
};
int bb_config_InternalErr(String);
int bb_config_StringToInt(String,int);
String bb_config_Dequote(String,String);
String bb_config_EvalConfigTags(String);
extern int bb_config_ENV_SAFEMODE;
class c_NumericType : public c_Type{
	public:
	c_NumericType();
	c_NumericType* m_new();
	void mark();
};
class c_IntType : public c_NumericType{
	public:
	c_IntType();
	c_IntType* m_new();
	int p_EqualsType(c_Type*);
	int p_ExtendsType(c_Type*);
	c_ClassDecl* p_GetClass();
	String p_ToString();
	void mark();
};
class c_FloatType : public c_NumericType{
	public:
	c_FloatType();
	c_FloatType* m_new();
	int p_EqualsType(c_Type*);
	int p_ExtendsType(c_Type*);
	c_ClassDecl* p_GetClass();
	String p_ToString();
	void mark();
};
class c_AliasDecl : public c_Decl{
	public:
	Object* m_decl;
	c_AliasDecl();
	c_AliasDecl* m_new(String,int,Object*);
	c_AliasDecl* m_new2();
	c_Decl* p_OnCopy();
	int p_OnSemant();
	void mark();
};
class c_List5 : public Object{
	public:
	c_Node10* m__head;
	c_List5();
	c_List5* m_new();
	c_Node10* p_AddLast5(c_Decl*);
	c_List5* m_new2(Array<c_Decl* >);
	c_Enumerator3* p_ObjectEnumerator();
	int p_Count();
	void mark();
};
class c_Node10 : public Object{
	public:
	c_Node10* m__succ;
	c_Node10* m__pred;
	c_Decl* m__data;
	c_Node10();
	c_Node10* m_new(c_Node10*,c_Node10*,c_Decl*);
	c_Node10* m_new2();
	void mark();
};
class c_HeadNode4 : public c_Node10{
	public:
	c_HeadNode4();
	c_HeadNode4* m_new();
	void mark();
};
class c_BlockDecl : public c_ScopeDecl{
	public:
	c_List7* m_stmts;
	c_BlockDecl();
	int p_AddStmt(c_Stmt*);
	c_BlockDecl* m_new(c_ScopeDecl*);
	c_BlockDecl* m_new2();
	c_Decl* p_OnCopy();
	int p_OnSemant();
	c_BlockDecl* p_CopyBlock(c_ScopeDecl*);
	void mark();
};
class c_FuncDecl : public c_BlockDecl{
	public:
	c_Type* m_retType;
	Array<c_ArgDecl* > m_argDecls;
	c_FuncDecl* m_overrides;
	c_FuncDecl();
	bool p_IsCtor();
	c_FuncDecl* m_new(String,int,c_Type*,Array<c_ArgDecl* >);
	c_FuncDecl* m_new2();
	bool p_IsMethod();
	String p_ToString();
	bool p_EqualsArgs(c_FuncDecl*);
	bool p_EqualsFunc(c_FuncDecl*);
	c_Decl* p_OnCopy();
	int p_OnSemant();
	bool p_IsStatic();
	bool p_IsProperty();
	bool p_IsVirtual();
	void mark();
};
class c_List6 : public Object{
	public:
	c_Node11* m__head;
	c_List6();
	c_List6* m_new();
	c_Node11* p_AddLast6(c_FuncDecl*);
	c_List6* m_new2(Array<c_FuncDecl* >);
	c_Enumerator4* p_ObjectEnumerator();
	void mark();
};
class c_FuncDeclList : public c_List6{
	public:
	c_FuncDeclList();
	c_FuncDeclList* m_new();
	void mark();
};
class c_Node11 : public Object{
	public:
	c_Node11* m__succ;
	c_Node11* m__pred;
	c_FuncDecl* m__data;
	c_Node11();
	c_Node11* m_new(c_Node11*,c_Node11*,c_FuncDecl*);
	c_Node11* m_new2();
	void mark();
};
class c_HeadNode5 : public c_Node11{
	public:
	c_HeadNode5();
	c_HeadNode5* m_new();
	void mark();
};
class c_ClassDecl : public c_ScopeDecl{
	public:
	c_ClassDecl* m_superClass;
	Array<String > m_args;
	c_IdentType* m_superTy;
	Array<c_IdentType* > m_impltys;
	c_ObjectType* m_objectType;
	c_List8* m_instances;
	c_ClassDecl* m_instanceof;
	Array<c_Type* > m_instArgs;
	Array<c_ClassDecl* > m_implmentsAll;
	Array<c_ClassDecl* > m_implments;
	c_ClassDecl();
	c_ClassDecl* m_new(String,int,Array<String >,c_IdentType*,Array<c_IdentType* >);
	c_ClassDecl* m_new2();
	int p_IsInterface();
	String p_ToString();
	c_FuncDecl* p_FindFuncDecl2(String,Array<c_Expr* >,int);
	c_FuncDecl* p_FindFuncDecl(String,Array<c_Expr* >,int);
	int p_ExtendsObject();
	c_ClassDecl* p_GenClassInstance(Array<c_Type* >);
	int p_IsFinalized();
	int p_UpdateLiveMethods();
	int p_IsInstanced();
	int p_FinalizeClass();
	c_Decl* p_OnCopy();
	Object* p_GetDecl2(String);
	Object* p_GetDecl(String);
	static c_ClassDecl* m_nullObjectClass;
	int p_IsThrowable();
	int p_OnSemant();
	int p_ExtendsClass(c_ClassDecl*);
	void mark();
};
int bb_decl_PopEnv();
class c_VoidType : public c_Type{
	public:
	c_VoidType();
	c_VoidType* m_new();
	int p_EqualsType(c_Type*);
	String p_ToString();
	void mark();
};
class c_IdentType : public c_Type{
	public:
	String m_ident;
	Array<c_Type* > m_args;
	c_IdentType();
	c_IdentType* m_new(String,Array<c_Type* >);
	c_IdentType* m_new2();
	c_Type* p_Semant();
	c_ClassDecl* p_SemantClass();
	int p_EqualsType(c_Type*);
	int p_ExtendsType(c_Type*);
	String p_ToString();
	void mark();
};
class c_Stack4 : public Object{
	public:
	Array<c_Type* > m_data;
	int m_length;
	c_Stack4();
	c_Stack4* m_new();
	c_Stack4* m_new2(Array<c_Type* >);
	void p_Push10(c_Type*);
	void p_Push11(Array<c_Type* >,int,int);
	void p_Push12(Array<c_Type* >,int);
	Array<c_Type* > p_ToArray();
	void mark();
};
class c_ArrayType : public c_Type{
	public:
	c_Type* m_elemType;
	c_ArrayType();
	c_ArrayType* m_new(c_Type*);
	c_ArrayType* m_new2();
	int p_EqualsType(c_Type*);
	int p_ExtendsType(c_Type*);
	c_Type* p_Semant();
	c_ClassDecl* p_GetClass();
	String p_ToString();
	void mark();
};
class c_UnaryExpr : public c_Expr{
	public:
	String m_op;
	c_Expr* m_expr;
	c_UnaryExpr();
	c_UnaryExpr* m_new(String,c_Expr*);
	c_UnaryExpr* m_new2();
	c_Expr* p_Copy();
	c_Expr* p_Semant();
	String p_Eval();
	String p_Trans();
	void mark();
};
class c_ArrayExpr : public c_Expr{
	public:
	Array<c_Expr* > m_exprs;
	c_ArrayExpr();
	c_ArrayExpr* m_new(Array<c_Expr* >);
	c_ArrayExpr* m_new2();
	c_Expr* p_Copy();
	c_Expr* p_Semant();
	String p_Trans();
	void mark();
};
class c_Stack5 : public Object{
	public:
	Array<c_Expr* > m_data;
	int m_length;
	c_Stack5();
	c_Stack5* m_new();
	c_Stack5* m_new2(Array<c_Expr* >);
	void p_Push13(c_Expr*);
	void p_Push14(Array<c_Expr* >,int,int);
	void p_Push15(Array<c_Expr* >,int);
	Array<c_Expr* > p_ToArray();
	void mark();
};
class c_ConstExpr : public c_Expr{
	public:
	c_Type* m_ty;
	String m_value;
	c_ConstExpr();
	c_ConstExpr* m_new(c_Type*,String);
	c_ConstExpr* m_new2();
	c_Expr* p_Semant();
	c_Expr* p_Copy();
	String p_ToString();
	String p_Eval();
	c_Expr* p_EvalConst();
	bool p_SideEffects();
	String p_Trans();
	void mark();
};
class c_ScopeExpr : public c_Expr{
	public:
	c_ScopeDecl* m_scope;
	c_ScopeExpr();
	c_ScopeExpr* m_new(c_ScopeDecl*);
	c_ScopeExpr* m_new2();
	c_Expr* p_Copy();
	String p_ToString();
	c_Expr* p_Semant();
	c_ScopeDecl* p_SemantScope();
	void mark();
};
class c_NewArrayExpr : public c_Expr{
	public:
	c_Type* m_ty;
	c_Expr* m_expr;
	c_NewArrayExpr();
	c_NewArrayExpr* m_new(c_Type*,c_Expr*);
	c_NewArrayExpr* m_new2();
	c_Expr* p_Copy();
	c_Expr* p_Semant();
	String p_Trans();
	void mark();
};
class c_NewObjectExpr : public c_Expr{
	public:
	c_Type* m_ty;
	Array<c_Expr* > m_args;
	c_ClassDecl* m_classDecl;
	c_FuncDecl* m_ctor;
	c_NewObjectExpr();
	c_NewObjectExpr* m_new(c_Type*,Array<c_Expr* >);
	c_NewObjectExpr* m_new2();
	c_Expr* p_Semant();
	c_Expr* p_Copy();
	String p_Trans();
	void mark();
};
class c_CastExpr : public c_Expr{
	public:
	c_Type* m_ty;
	c_Expr* m_expr;
	int m_flags;
	c_CastExpr();
	c_CastExpr* m_new(c_Type*,c_Expr*,int);
	c_CastExpr* m_new2();
	c_Expr* p_Semant();
	c_Expr* p_Copy();
	String p_Eval();
	String p_Trans();
	void mark();
};
class c_IdentExpr : public c_Expr{
	public:
	String m_ident;
	c_Expr* m_expr;
	c_ScopeDecl* m_scope;
	bool m_static;
	c_IdentExpr();
	c_IdentExpr* m_new(String,c_Expr*);
	c_IdentExpr* m_new2();
	c_Expr* p_Copy();
	String p_ToString();
	int p__Semant();
	int p_IdentErr();
	c_Expr* p_SemantSet(String,c_Expr*);
	c_Expr* p_Semant();
	c_ScopeDecl* p_SemantScope();
	c_Expr* p_SemantFunc(Array<c_Expr* >);
	void mark();
};
class c_SelfExpr : public c_Expr{
	public:
	c_SelfExpr();
	c_SelfExpr* m_new();
	c_Expr* p_Copy();
	c_Expr* p_Semant();
	bool p_SideEffects();
	String p_Trans();
	void mark();
};
class c_Stmt : public Object{
	public:
	String m_errInfo;
	c_Stmt();
	c_Stmt* m_new();
	virtual c_Stmt* p_OnCopy2(c_ScopeDecl*)=0;
	c_Stmt* p_Copy2(c_ScopeDecl*);
	virtual int p_OnSemant()=0;
	int p_Semant();
	virtual String p_Trans()=0;
	void mark();
};
class c_List7 : public Object{
	public:
	c_Node12* m__head;
	c_List7();
	c_List7* m_new();
	c_Node12* p_AddLast7(c_Stmt*);
	c_List7* m_new2(Array<c_Stmt* >);
	bool p_IsEmpty();
	c_Enumerator6* p_ObjectEnumerator();
	c_Node12* p_AddFirst(c_Stmt*);
	void mark();
};
class c_Node12 : public Object{
	public:
	c_Node12* m__succ;
	c_Node12* m__pred;
	c_Stmt* m__data;
	c_Node12();
	c_Node12* m_new(c_Node12*,c_Node12*,c_Stmt*);
	c_Node12* m_new2();
	void mark();
};
class c_HeadNode6 : public c_Node12{
	public:
	c_HeadNode6();
	c_HeadNode6* m_new();
	void mark();
};
class c_InvokeSuperExpr : public c_Expr{
	public:
	String m_ident;
	Array<c_Expr* > m_args;
	c_FuncDecl* m_funcDecl;
	c_InvokeSuperExpr();
	c_InvokeSuperExpr* m_new(String,Array<c_Expr* >);
	c_InvokeSuperExpr* m_new2();
	c_Expr* p_Copy();
	c_Expr* p_Semant();
	String p_Trans();
	void mark();
};
class c_IdentTypeExpr : public c_Expr{
	public:
	c_ClassDecl* m_cdecl;
	c_IdentTypeExpr();
	c_IdentTypeExpr* m_new(c_Type*);
	c_IdentTypeExpr* m_new2();
	c_Expr* p_Copy();
	int p__Semant();
	c_Expr* p_Semant();
	c_ScopeDecl* p_SemantScope();
	c_Expr* p_SemantFunc(Array<c_Expr* >);
	void mark();
};
class c_Node13 : public Object{
	public:
	c_Node13* m__succ;
	c_Node13* m__pred;
	int m__data;
	c_Node13();
	c_Node13* m_new(c_Node13*,c_Node13*,int);
	c_Node13* m_new2();
	void mark();
};
class c_HeadNode7 : public c_Node13{
	public:
	c_HeadNode7();
	c_HeadNode7* m_new();
	void mark();
};
class c_Enumerator2 : public Object{
	public:
	c_List3* m__list;
	c_Node13* m__curr;
	c_Enumerator2();
	c_Enumerator2* m_new(c_List3*);
	c_Enumerator2* m_new2();
	bool p_HasNext();
	int p_NextObject();
	void mark();
};
class c_MapKeys : public Object{
	public:
	c_Map6* m_map;
	c_MapKeys();
	c_MapKeys* m_new(c_Map6*);
	c_MapKeys* m_new2();
	c_KeyEnumerator* p_ObjectEnumerator();
	void mark();
};
class c_KeyEnumerator : public Object{
	public:
	c_Node8* m_node;
	c_KeyEnumerator();
	c_KeyEnumerator* m_new(c_Node8*);
	c_KeyEnumerator* m_new2();
	bool p_HasNext();
	int p_NextObject();
	void mark();
};
class c_FuncCallExpr : public c_Expr{
	public:
	c_Expr* m_expr;
	Array<c_Expr* > m_args;
	c_FuncCallExpr();
	c_FuncCallExpr* m_new(c_Expr*,Array<c_Expr* >);
	c_FuncCallExpr* m_new2();
	c_Expr* p_Copy();
	String p_ToString();
	c_Expr* p_Semant();
	void mark();
};
class c_SliceExpr : public c_Expr{
	public:
	c_Expr* m_expr;
	c_Expr* m_from;
	c_Expr* m_term;
	c_SliceExpr();
	c_SliceExpr* m_new(c_Expr*,c_Expr*,c_Expr*);
	c_SliceExpr* m_new2();
	c_Expr* p_Copy();
	c_Expr* p_Semant();
	String p_Eval();
	String p_Trans();
	void mark();
};
class c_IndexExpr : public c_Expr{
	public:
	c_Expr* m_expr;
	c_Expr* m_index;
	c_IndexExpr();
	c_IndexExpr* m_new(c_Expr*,c_Expr*);
	c_IndexExpr* m_new2();
	c_Expr* p_Copy();
	c_Expr* p_Semant();
	String p_Eval();
	c_Expr* p_SemantSet(String,c_Expr*);
	bool p_SideEffects();
	String p_Trans();
	String p_TransVar();
	void mark();
};
class c_BinaryExpr : public c_Expr{
	public:
	String m_op;
	c_Expr* m_lhs;
	c_Expr* m_rhs;
	c_BinaryExpr();
	c_BinaryExpr* m_new(String,c_Expr*,c_Expr*);
	c_BinaryExpr* m_new2();
	String p_Trans();
	void mark();
};
class c_BinaryMathExpr : public c_BinaryExpr{
	public:
	c_BinaryMathExpr();
	c_BinaryMathExpr* m_new(String,c_Expr*,c_Expr*);
	c_BinaryMathExpr* m_new2();
	c_Expr* p_Copy();
	c_Expr* p_Semant();
	String p_Eval();
	void mark();
};
class c_BinaryCompareExpr : public c_BinaryExpr{
	public:
	c_Type* m_ty;
	c_BinaryCompareExpr();
	c_BinaryCompareExpr* m_new(String,c_Expr*,c_Expr*);
	c_BinaryCompareExpr* m_new2();
	c_Expr* p_Copy();
	c_Expr* p_Semant();
	String p_Eval();
	void mark();
};
class c_BinaryLogicExpr : public c_BinaryExpr{
	public:
	c_BinaryLogicExpr();
	c_BinaryLogicExpr* m_new(String,c_Expr*,c_Expr*);
	c_BinaryLogicExpr* m_new2();
	c_Expr* p_Copy();
	c_Expr* p_Semant();
	String p_Eval();
	void mark();
};
class c_VarDecl : public c_ValDecl{
	public:
	c_VarDecl();
	c_VarDecl* m_new();
	void mark();
};
class c_GlobalDecl : public c_VarDecl{
	public:
	c_GlobalDecl();
	c_GlobalDecl* m_new(String,int,c_Type*,c_Expr*);
	c_GlobalDecl* m_new2();
	String p_ToString();
	c_Decl* p_OnCopy();
	void mark();
};
class c_FieldDecl : public c_VarDecl{
	public:
	c_FieldDecl();
	c_FieldDecl* m_new(String,int,c_Type*,c_Expr*);
	c_FieldDecl* m_new2();
	String p_ToString();
	c_Decl* p_OnCopy();
	void mark();
};
class c_LocalDecl : public c_VarDecl{
	public:
	c_LocalDecl();
	c_LocalDecl* m_new(String,int,c_Type*,c_Expr*);
	c_LocalDecl* m_new2();
	String p_ToString();
	c_Decl* p_OnCopy();
	void mark();
};
class c_Enumerator3 : public Object{
	public:
	c_List5* m__list;
	c_Node10* m__curr;
	c_Enumerator3();
	c_Enumerator3* m_new(c_List5*);
	c_Enumerator3* m_new2();
	bool p_HasNext();
	c_Decl* p_NextObject();
	void mark();
};
class c_DeclStmt : public c_Stmt{
	public:
	c_Decl* m_decl;
	c_DeclStmt();
	c_DeclStmt* m_new(c_Decl*);
	c_DeclStmt* m_new2(String,c_Type*,c_Expr*);
	c_DeclStmt* m_new3();
	c_Stmt* p_OnCopy2(c_ScopeDecl*);
	int p_OnSemant();
	String p_Trans();
	void mark();
};
class c_Stack6 : public Object{
	public:
	Array<c_IdentType* > m_data;
	int m_length;
	c_Stack6();
	c_Stack6* m_new();
	c_Stack6* m_new2(Array<c_IdentType* >);
	void p_Push16(c_IdentType*);
	void p_Push17(Array<c_IdentType* >,int,int);
	void p_Push18(Array<c_IdentType* >,int);
	Array<c_IdentType* > p_ToArray();
	void mark();
};
class c_ObjectType : public c_Type{
	public:
	c_ClassDecl* m_classDecl;
	c_ObjectType();
	c_ObjectType* m_new(c_ClassDecl*);
	c_ObjectType* m_new2();
	int p_EqualsType(c_Type*);
	c_ClassDecl* p_GetClass();
	int p_ExtendsType(c_Type*);
	String p_ToString();
	void mark();
};
class c_List8 : public Object{
	public:
	c_Node14* m__head;
	c_List8();
	c_List8* m_new();
	c_Node14* p_AddLast8(c_ClassDecl*);
	c_List8* m_new2(Array<c_ClassDecl* >);
	c_Enumerator5* p_ObjectEnumerator();
	void mark();
};
class c_Node14 : public Object{
	public:
	c_Node14* m__succ;
	c_Node14* m__pred;
	c_ClassDecl* m__data;
	c_Node14();
	c_Node14* m_new(c_Node14*,c_Node14*,c_ClassDecl*);
	c_Node14* m_new2();
	void mark();
};
class c_HeadNode8 : public c_Node14{
	public:
	c_HeadNode8();
	c_HeadNode8* m_new();
	void mark();
};
class c_ArgDecl : public c_LocalDecl{
	public:
	c_ArgDecl();
	c_ArgDecl* m_new(String,int,c_Type*,c_Expr*);
	c_ArgDecl* m_new2();
	String p_ToString();
	c_Decl* p_OnCopy();
	void mark();
};
class c_Stack7 : public Object{
	public:
	Array<c_ArgDecl* > m_data;
	int m_length;
	c_Stack7();
	c_Stack7* m_new();
	c_Stack7* m_new2(Array<c_ArgDecl* >);
	void p_Push19(c_ArgDecl*);
	void p_Push20(Array<c_ArgDecl* >,int,int);
	void p_Push21(Array<c_ArgDecl* >,int);
	Array<c_ArgDecl* > p_ToArray();
	void mark();
};
class c_List9 : public Object{
	public:
	c_Node15* m__head;
	c_List9();
	c_List9* m_new();
	c_Node15* p_AddLast9(c_BlockDecl*);
	c_List9* m_new2(Array<c_BlockDecl* >);
	c_BlockDecl* p_RemoveLast();
	bool p_Equals4(c_BlockDecl*,c_BlockDecl*);
	c_Node15* p_FindLast7(c_BlockDecl*,c_Node15*);
	c_Node15* p_FindLast8(c_BlockDecl*);
	void p_RemoveLast5(c_BlockDecl*);
	void mark();
};
class c_Node15 : public Object{
	public:
	c_Node15* m__succ;
	c_Node15* m__pred;
	c_BlockDecl* m__data;
	c_Node15();
	c_Node15* m_new(c_Node15*,c_Node15*,c_BlockDecl*);
	c_Node15* m_new2();
	int p_Remove();
	void mark();
};
class c_HeadNode9 : public c_Node15{
	public:
	c_HeadNode9();
	c_HeadNode9* m_new();
	void mark();
};
class c_ReturnStmt : public c_Stmt{
	public:
	c_Expr* m_expr;
	c_ReturnStmt();
	c_ReturnStmt* m_new(c_Expr*);
	c_ReturnStmt* m_new2();
	c_Stmt* p_OnCopy2(c_ScopeDecl*);
	int p_OnSemant();
	String p_Trans();
	void mark();
};
class c_BreakStmt : public c_Stmt{
	public:
	c_BreakStmt();
	c_BreakStmt* m_new();
	c_Stmt* p_OnCopy2(c_ScopeDecl*);
	int p_OnSemant();
	String p_Trans();
	void mark();
};
class c_ContinueStmt : public c_Stmt{
	public:
	c_ContinueStmt();
	c_ContinueStmt* m_new();
	c_Stmt* p_OnCopy2(c_ScopeDecl*);
	int p_OnSemant();
	String p_Trans();
	void mark();
};
class c_IfStmt : public c_Stmt{
	public:
	c_Expr* m_expr;
	c_BlockDecl* m_thenBlock;
	c_BlockDecl* m_elseBlock;
	c_IfStmt();
	c_IfStmt* m_new(c_Expr*,c_BlockDecl*,c_BlockDecl*);
	c_IfStmt* m_new2();
	c_Stmt* p_OnCopy2(c_ScopeDecl*);
	int p_OnSemant();
	String p_Trans();
	void mark();
};
class c_WhileStmt : public c_Stmt{
	public:
	c_Expr* m_expr;
	c_BlockDecl* m_block;
	c_WhileStmt();
	c_WhileStmt* m_new(c_Expr*,c_BlockDecl*);
	c_WhileStmt* m_new2();
	c_Stmt* p_OnCopy2(c_ScopeDecl*);
	int p_OnSemant();
	String p_Trans();
	void mark();
};
class c_RepeatStmt : public c_Stmt{
	public:
	c_BlockDecl* m_block;
	c_Expr* m_expr;
	c_RepeatStmt();
	c_RepeatStmt* m_new(c_BlockDecl*,c_Expr*);
	c_RepeatStmt* m_new2();
	c_Stmt* p_OnCopy2(c_ScopeDecl*);
	int p_OnSemant();
	String p_Trans();
	void mark();
};
class c_ForEachinStmt : public c_Stmt{
	public:
	String m_varid;
	c_Type* m_varty;
	int m_varlocal;
	c_Expr* m_expr;
	c_BlockDecl* m_block;
	c_ForEachinStmt();
	c_ForEachinStmt* m_new(String,c_Type*,int,c_Expr*,c_BlockDecl*);
	c_ForEachinStmt* m_new2();
	c_Stmt* p_OnCopy2(c_ScopeDecl*);
	int p_OnSemant();
	String p_Trans();
	void mark();
};
class c_AssignStmt : public c_Stmt{
	public:
	String m_op;
	c_Expr* m_lhs;
	c_Expr* m_rhs;
	c_LocalDecl* m_tmp1;
	c_LocalDecl* m_tmp2;
	c_AssignStmt();
	c_AssignStmt* m_new(String,c_Expr*,c_Expr*);
	c_AssignStmt* m_new2();
	c_Stmt* p_OnCopy2(c_ScopeDecl*);
	int p_FixSideEffects();
	int p_OnSemant();
	String p_Trans();
	void mark();
};
class c_ForStmt : public c_Stmt{
	public:
	c_Stmt* m_init;
	c_Expr* m_expr;
	c_Stmt* m_incr;
	c_BlockDecl* m_block;
	c_ForStmt();
	c_ForStmt* m_new(c_Stmt*,c_Expr*,c_Stmt*,c_BlockDecl*);
	c_ForStmt* m_new2();
	c_Stmt* p_OnCopy2(c_ScopeDecl*);
	int p_OnSemant();
	String p_Trans();
	void mark();
};
class c_CatchStmt : public c_Stmt{
	public:
	c_LocalDecl* m_init;
	c_BlockDecl* m_block;
	c_CatchStmt();
	c_CatchStmt* m_new(c_LocalDecl*,c_BlockDecl*);
	c_CatchStmt* m_new2();
	c_Stmt* p_OnCopy2(c_ScopeDecl*);
	int p_OnSemant();
	String p_Trans();
	void mark();
};
class c_Stack8 : public Object{
	public:
	Array<c_CatchStmt* > m_data;
	int m_length;
	c_Stack8();
	c_Stack8* m_new();
	c_Stack8* m_new2(Array<c_CatchStmt* >);
	void p_Push22(c_CatchStmt*);
	void p_Push23(Array<c_CatchStmt* >,int,int);
	void p_Push24(Array<c_CatchStmt* >,int);
	static c_CatchStmt* m_NIL;
	void p_Length(int);
	int p_Length2();
	Array<c_CatchStmt* > p_ToArray();
	void mark();
};
int bb_math_Max(int,int);
Float bb_math_Max2(Float,Float);
class c_TryStmt : public c_Stmt{
	public:
	c_BlockDecl* m_block;
	Array<c_CatchStmt* > m_catches;
	c_TryStmt();
	c_TryStmt* m_new(c_BlockDecl*,Array<c_CatchStmt* >);
	c_TryStmt* m_new2();
	c_Stmt* p_OnCopy2(c_ScopeDecl*);
	int p_OnSemant();
	String p_Trans();
	void mark();
};
class c_ThrowStmt : public c_Stmt{
	public:
	c_Expr* m_expr;
	c_ThrowStmt();
	c_ThrowStmt* m_new(c_Expr*);
	c_ThrowStmt* m_new2();
	c_Stmt* p_OnCopy2(c_ScopeDecl*);
	int p_OnSemant();
	String p_Trans();
	void mark();
};
class c_ExprStmt : public c_Stmt{
	public:
	c_Expr* m_expr;
	c_ExprStmt();
	c_ExprStmt* m_new(c_Expr*);
	c_ExprStmt* m_new2();
	c_Stmt* p_OnCopy2(c_ScopeDecl*);
	int p_OnSemant();
	String p_Trans();
	void mark();
};
c_ModuleDecl* bb_parser_ParseModule(String,String,c_AppDecl*);
class c_Enumerator4 : public Object{
	public:
	c_List6* m__list;
	c_Node11* m__curr;
	c_Enumerator4();
	c_Enumerator4* m_new(c_List6*);
	c_Enumerator4* m_new2();
	bool p_HasNext();
	c_FuncDecl* p_NextObject();
	void mark();
};
extern c_StringList* bb_config__errStack;
int bb_config_PushErr(String);
class c_List10 : public Object{
	public:
	c_Node16* m__head;
	c_List10();
	c_List10* m_new();
	c_Node16* p_AddLast10(c_GlobalDecl*);
	c_List10* m_new2(Array<c_GlobalDecl* >);
	c_Enumerator7* p_ObjectEnumerator();
	void mark();
};
class c_Node16 : public Object{
	public:
	c_Node16* m__succ;
	c_Node16* m__pred;
	c_GlobalDecl* m__data;
	c_Node16();
	c_Node16* m_new(c_Node16*,c_Node16*,c_GlobalDecl*);
	c_Node16* m_new2();
	void mark();
};
class c_HeadNode10 : public c_Node16{
	public:
	c_HeadNode10();
	c_HeadNode10* m_new();
	void mark();
};
int bb_config_PopErr();
class c_InvokeMemberExpr : public c_Expr{
	public:
	c_Expr* m_expr;
	c_FuncDecl* m_decl;
	Array<c_Expr* > m_args;
	int m_isResize;
	c_InvokeMemberExpr();
	c_InvokeMemberExpr* m_new(c_Expr*,c_FuncDecl*,Array<c_Expr* >);
	c_InvokeMemberExpr* m_new2();
	c_Expr* p_Semant();
	String p_ToString();
	String p_Trans();
	String p_TransStmt();
	void mark();
};
c_Expr* bb_preprocessor_EvalExpr(c_Toker*);
bool bb_preprocessor_EvalBool(c_Toker*);
String bb_preprocessor_EvalText(c_Toker*);
c_StringMap2* bb_config_GetConfigVars();
c_Type* bb_config_GetConfigVarType(String);
String bb_preprocessor_PreProcess(String,c_ModuleDecl*);
class c_Target : public Object{
	public:
	String m_dir;
	String m_name;
	String m_system;
	c_Builder* m_builder;
	c_Target();
	c_Target* m_new(String,String,String,c_Builder*);
	c_Target* m_new2();
	void mark();
};
class c_Map7 : public Object{
	public:
	c_Node17* m_root;
	c_Map7();
	c_Map7* m_new();
	virtual int p_Compare(String,String)=0;
	int p_RotateLeft7(c_Node17*);
	int p_RotateRight7(c_Node17*);
	int p_InsertFixup7(c_Node17*);
	bool p_Set6(String,c_Target*);
	c_Node17* p_FirstNode();
	c_NodeEnumerator2* p_ObjectEnumerator();
	c_Node17* p_FindNode(String);
	c_Target* p_Get(String);
	void mark();
};
class c_StringMap6 : public c_Map7{
	public:
	c_StringMap6();
	c_StringMap6* m_new();
	int p_Compare(String,String);
	void mark();
};
class c_Node17 : public Object{
	public:
	String m_key;
	c_Node17* m_right;
	c_Node17* m_left;
	c_Target* m_value;
	int m_color;
	c_Node17* m_parent;
	c_Node17();
	c_Node17* m_new(String,c_Target*,int,c_Node17*);
	c_Node17* m_new2();
	c_Node17* p_NextNode();
	String p_Key();
	void mark();
};
void bb_config_PopConfigScope();
class c_NodeEnumerator2 : public Object{
	public:
	c_Node17* m_node;
	c_NodeEnumerator2();
	c_NodeEnumerator2* m_new(c_Node17*);
	c_NodeEnumerator2* m_new2();
	bool p_HasNext();
	c_Node17* p_NextObject();
	void mark();
};
extern String bb_config_ENV_HOST;
extern String bb_config_ENV_CONFIG;
extern String bb_config_ENV_TARGET;
extern String bb_config_ENV_LANG;
String bb_os_StripAll(String);
c_AppDecl* bb_parser_ParseApp(String);
class c_Reflector : public Object{
	public:
	bool m_debug;
	c_ModuleDecl* m_refmod;
	c_ModuleDecl* m_langmod;
	c_ModuleDecl* m_boxesmod;
	c_StringMap7* m_munged;
	c_StringMap2* m_modexprs;
	c_StringSet* m_refmods;
	c_Stack9* m_classdecls;
	c_StringMap7* m_classids;
	c_StringStack* m_output;
	c_Reflector();
	c_Reflector* m_new();
	static bool m_MatchPath(String,String);
	String p_Mung(String);
	bool p_ValidClass(c_ClassDecl*);
	String p_TypeExpr(c_Type*,bool);
	String p_DeclExpr(c_Decl*,bool);
	int p_Emit(String);
	bool p_ValidType(c_Type*);
	String p_TypeInfo(c_Type*);
	int p_Attrs(c_Decl*);
	String p_Box(c_Type*,String);
	String p_Emit2(c_ConstDecl*);
	String p_Unbox(c_Type*,String);
	String p_Emit3(c_ClassDecl*);
	String p_Emit4(c_FuncDecl*);
	String p_Emit5(c_FieldDecl*);
	String p_Emit6(c_GlobalDecl*);
	int p_Semant3(c_AppDecl*);
	void mark();
};
class c_MapValues : public Object{
	public:
	c_Map5* m_map;
	c_MapValues();
	c_MapValues* m_new(c_Map5*);
	c_MapValues* m_new2();
	c_ValueEnumerator* p_ObjectEnumerator();
	void mark();
};
class c_ValueEnumerator : public Object{
	public:
	c_Node7* m_node;
	c_ValueEnumerator();
	c_ValueEnumerator* m_new(c_Node7*);
	c_ValueEnumerator* m_new2();
	bool p_HasNext();
	c_ModuleDecl* p_NextObject();
	void mark();
};
class c_Map8 : public Object{
	public:
	c_Node18* m_root;
	c_Map8();
	c_Map8* m_new();
	virtual int p_Compare(String,String)=0;
	c_Node18* p_FindNode(String);
	bool p_Contains(String);
	int p_Get(String);
	int p_RotateLeft8(c_Node18*);
	int p_RotateRight8(c_Node18*);
	int p_InsertFixup8(c_Node18*);
	bool p_Set7(String,int);
	void mark();
};
class c_StringMap7 : public c_Map8{
	public:
	c_StringMap7();
	c_StringMap7* m_new();
	int p_Compare(String,String);
	void mark();
};
class c_Node18 : public Object{
	public:
	String m_key;
	c_Node18* m_right;
	c_Node18* m_left;
	int m_value;
	int m_color;
	c_Node18* m_parent;
	c_Node18();
	c_Node18* m_new(String,int,int,c_Node18*);
	c_Node18* m_new2();
	void mark();
};
class c_Enumerator5 : public Object{
	public:
	c_List8* m__list;
	c_Node14* m__curr;
	c_Enumerator5();
	c_Enumerator5* m_new(c_List8*);
	c_Enumerator5* m_new2();
	bool p_HasNext();
	c_ClassDecl* p_NextObject();
	void mark();
};
class c_Stack9 : public Object{
	public:
	Array<c_ClassDecl* > m_data;
	int m_length;
	c_Stack9();
	c_Stack9* m_new();
	c_Stack9* m_new2(Array<c_ClassDecl* >);
	static c_ClassDecl* m_NIL;
	void p_Length(int);
	int p_Length2();
	void p_Push25(c_ClassDecl*);
	void p_Push26(Array<c_ClassDecl* >,int,int);
	void p_Push27(Array<c_ClassDecl* >,int);
	c_ClassDecl* p_Get2(int);
	void mark();
};
int bb_parser_ParseSource(String,c_AppDecl*,c_ModuleDecl*,int);
class c_Translator : public Object{
	public:
	c_Translator();
	virtual String p_TransApp(c_AppDecl*)=0;
	c_Translator* m_new();
	virtual String p_TransInvokeExpr(c_InvokeExpr*)=0;
	virtual String p_TransStmtExpr(c_StmtExpr*)=0;
	virtual String p_TransMemberVarExpr(c_MemberVarExpr*)=0;
	virtual String p_TransVarExpr(c_VarExpr*)=0;
	virtual String p_TransUnaryExpr(c_UnaryExpr*)=0;
	virtual String p_TransArrayExpr(c_ArrayExpr*)=0;
	virtual String p_TransConstExpr(c_ConstExpr*)=0;
	virtual String p_TransNewArrayExpr(c_NewArrayExpr*)=0;
	virtual String p_TransNewObjectExpr(c_NewObjectExpr*)=0;
	virtual String p_TransCastExpr(c_CastExpr*)=0;
	virtual String p_TransSelfExpr(c_SelfExpr*)=0;
	virtual String p_TransInvokeSuperExpr(c_InvokeSuperExpr*)=0;
	virtual String p_TransSliceExpr(c_SliceExpr*)=0;
	virtual String p_TransIndexExpr(c_IndexExpr*)=0;
	virtual String p_TransBinaryExpr(c_BinaryExpr*)=0;
	virtual String p_TransDeclStmt(c_DeclStmt*)=0;
	virtual String p_TransReturnStmt(c_ReturnStmt*)=0;
	virtual String p_TransBreakStmt(c_BreakStmt*)=0;
	virtual String p_TransContinueStmt(c_ContinueStmt*)=0;
	virtual String p_TransIfStmt(c_IfStmt*)=0;
	virtual String p_TransWhileStmt(c_WhileStmt*)=0;
	virtual String p_TransRepeatStmt(c_RepeatStmt*)=0;
	virtual String p_TransBlock(c_BlockDecl*)=0;
	virtual String p_TransAssignStmt(c_AssignStmt*)=0;
	virtual String p_TransForStmt(c_ForStmt*)=0;
	virtual String p_TransTryStmt(c_TryStmt*)=0;
	virtual String p_TransThrowStmt(c_ThrowStmt*)=0;
	virtual String p_TransExprStmt(c_ExprStmt*)=0;
	virtual String p_TransInvokeMemberExpr(c_InvokeMemberExpr*)=0;
	void mark();
};
extern c_Translator* bb_translator__trans;
int bb_os_DeleteDir(String,bool);
int bb_os_CopyDir(String,String,bool,bool);
int bbMain();
class c_CTranslator : public c_Translator{
	public:
	c_StringMap8* m_funcMungs;
	c_StringMap9* m_mungedFuncs;
	c_StringMap10* m_mungedScopes;
	String m_indent;
	c_StringStack* m_lines;
	bool m_emitDebugInfo;
	int m_unreachable;
	int m_broken;
	c_CTranslator();
	c_CTranslator* m_new();
	int p_MungMethodDecl(c_FuncDecl*);
	int p_MungDecl(c_Decl*);
	int p_Emit(String);
	virtual int p_BeginLocalScope();
	String p_Bra(String);
	virtual int p_EmitEnter(c_FuncDecl*);
	virtual int p_EmitEnterBlock();
	virtual int p_EmitSetErr(String);
	virtual String p_TransLocalDecl(String,c_Expr*)=0;
	String p_CreateLocal(c_Expr*);
	String p_TransExprNS(c_Expr*);
	virtual int p_EmitLeave();
	virtual String p_TransValue(c_Type*,String)=0;
	virtual int p_EmitLeaveBlock();
	int p_EmitBlock(c_BlockDecl*,bool);
	virtual int p_EndLocalScope();
	virtual String p_TransGlobal(c_GlobalDecl*)=0;
	String p_JoinLines();
	String p_Enquote(String);
	virtual int p_BeginLoop();
	virtual int p_EndLoop();
	virtual String p_TransField(c_FieldDecl*,c_Expr*)=0;
	int p_ExprPri(c_Expr*);
	String p_TransSubExpr(c_Expr*,int);
	String p_TransStmtExpr(c_StmtExpr*);
	virtual String p_TransIntrinsicExpr(c_Decl*,c_Expr*,Array<c_Expr* >)=0;
	String p_TransVarExpr(c_VarExpr*);
	String p_TransMemberVarExpr(c_MemberVarExpr*);
	virtual String p_TransFunc(c_FuncDecl*,Array<c_Expr* >,c_Expr*)=0;
	String p_TransInvokeExpr(c_InvokeExpr*);
	String p_TransInvokeMemberExpr(c_InvokeMemberExpr*);
	virtual String p_TransSuperFunc(c_FuncDecl*,Array<c_Expr* >)=0;
	String p_TransInvokeSuperExpr(c_InvokeSuperExpr*);
	String p_TransExprStmt(c_ExprStmt*);
	String p_TransAssignOp(String);
	virtual String p_TransAssignStmt2(c_AssignStmt*);
	String p_TransAssignStmt(c_AssignStmt*);
	String p_TransReturnStmt(c_ReturnStmt*);
	String p_TransContinueStmt(c_ContinueStmt*);
	String p_TransBreakStmt(c_BreakStmt*);
	String p_TransBlock(c_BlockDecl*);
	String p_TransDeclStmt(c_DeclStmt*);
	String p_TransIfStmt(c_IfStmt*);
	String p_TransWhileStmt(c_WhileStmt*);
	String p_TransRepeatStmt(c_RepeatStmt*);
	String p_TransForStmt(c_ForStmt*);
	String p_TransTryStmt(c_TryStmt*);
	String p_TransThrowStmt(c_ThrowStmt*);
	String p_TransUnaryOp(String);
	String p_TransBinaryOp(String,String);
	void mark();
};
class c_JavaTranslator : public c_CTranslator{
	public:
	bool m_langutil;
	int m_unsafe;
	c_JavaTranslator();
	c_JavaTranslator* m_new();
	String p_TransType(c_Type*);
	int p_EmitFuncDecl(c_FuncDecl*);
	String p_TransDecl(c_Decl*);
	int p_EmitClassDecl(c_ClassDecl*);
	String p_TransStatic(c_Decl*);
	String p_TransGlobal(c_GlobalDecl*);
	String p_TransApp(c_AppDecl*);
	String p_TransValue(c_Type*,String);
	String p_TransLocalDecl(String,c_Expr*);
	int p_EmitEnter(c_FuncDecl*);
	int p_EmitSetErr(String);
	int p_EmitLeave();
	String p_TransField(c_FieldDecl*,c_Expr*);
	String p_TransArgs(Array<c_Expr* >);
	String p_TransFunc(c_FuncDecl*,Array<c_Expr* >,c_Expr*);
	String p_TransSuperFunc(c_FuncDecl*,Array<c_Expr* >);
	String p_TransConstExpr(c_ConstExpr*);
	String p_TransNewObjectExpr(c_NewObjectExpr*);
	String p_TransNewArrayExpr(c_NewArrayExpr*);
	String p_TransSelfExpr(c_SelfExpr*);
	String p_TransCastExpr(c_CastExpr*);
	String p_TransUnaryExpr(c_UnaryExpr*);
	String p_TransBinaryExpr(c_BinaryExpr*);
	String p_TransIndexExpr(c_IndexExpr*);
	String p_TransSliceExpr(c_SliceExpr*);
	String p_TransArrayExpr(c_ArrayExpr*);
	String p_TransIntrinsicExpr(c_Decl*,c_Expr*,Array<c_Expr* >);
	String p_TransTryStmt(c_TryStmt*);
	void mark();
};
bool bb_transcc_MatchPathAlt(String,String);
bool bb_transcc_MatchPath(String,String);
String bb_transcc_ReplaceBlock(String,String,String,String);
class c_NodeEnumerator3 : public Object{
	public:
	c_Node2* m_node;
	c_NodeEnumerator3();
	c_NodeEnumerator3* m_new(c_Node2*);
	c_NodeEnumerator3* m_new2();
	bool p_HasNext();
	c_Node2* p_NextObject();
	void mark();
};
String bb_config_Enquote(String,String);
class c_CppTranslator : public c_CTranslator{
	public:
	bool m_unsafe;
	int m_gc_mode;
	c_Stack10* m_dbgLocals;
	String m_lastDbgInfo;
	int m_pure;
	c_CppTranslator();
	c_CppTranslator* m_new();
	String p_TransType(c_Type*);
	String p_TransRefType(c_Type*);
	String p_TransValue(c_Type*,String);
	c_Expr* p_Uncast(c_Expr*);
	bool p_IsGcObject(c_Expr*);
	String p_GcRetain(c_Expr*,String);
	String p_TransLocalDecl(String,c_Expr*);
	int p_BeginLocalScope();
	int p_EndLocalScope();
	int p_EmitEnter(c_FuncDecl*);
	int p_EmitEnterBlock();
	bool p_IsDebuggable(c_Type*);
	int p_EmitSetErr(String);
	int p_EmitLeaveBlock();
	String p_TransStatic(c_Decl*);
	String p_TransGlobal(c_GlobalDecl*);
	int p_EmitFuncProto(c_FuncDecl*);
	int p_EmitClassProto(c_ClassDecl*);
	int p_BeginLoop();
	int p_EndLoop();
	int p_EmitFuncDecl(c_FuncDecl*);
	String p_TransField(c_FieldDecl*,c_Expr*);
	int p_EmitMark(String,c_Type*,bool);
	int p_EmitClassDecl(c_ClassDecl*);
	String p_TransApp(c_AppDecl*);
	int p_CheckSafe(c_Decl*);
	String p_TransArgs2(Array<c_Expr* >,c_FuncDecl*);
	String p_TransFunc(c_FuncDecl*,Array<c_Expr* >,c_Expr*);
	String p_TransSuperFunc(c_FuncDecl*,Array<c_Expr* >);
	String p_TransConstExpr(c_ConstExpr*);
	String p_TransNewObjectExpr(c_NewObjectExpr*);
	String p_TransNewArrayExpr(c_NewArrayExpr*);
	String p_TransSelfExpr(c_SelfExpr*);
	String p_TransCastExpr(c_CastExpr*);
	String p_TransUnaryExpr(c_UnaryExpr*);
	String p_TransBinaryExpr(c_BinaryExpr*);
	String p_TransIndexExpr(c_IndexExpr*);
	String p_TransSliceExpr(c_SliceExpr*);
	String p_TransArrayExpr(c_ArrayExpr*);
	String p_TransIntrinsicExpr(c_Decl*,c_Expr*,Array<c_Expr* >);
	String p_TransTryStmt(c_TryStmt*);
	String p_TransDeclStmt(c_DeclStmt*);
	bool p_IsLocalVar(c_Expr*);
	String p_TransAssignStmt2(c_AssignStmt*);
	void mark();
};
class c_JsTranslator : public c_CTranslator{
	public:
	c_JsTranslator();
	c_JsTranslator* m_new();
	String p_TransValue(c_Type*,String);
	String p_TransLocalDecl(String,c_Expr*);
	int p_EmitEnter(c_FuncDecl*);
	int p_EmitSetErr(String);
	int p_EmitLeave();
	String p_TransStatic(c_Decl*);
	String p_TransGlobal(c_GlobalDecl*);
	String p_TransField(c_FieldDecl*,c_Expr*);
	int p_EmitFuncDecl(c_FuncDecl*);
	int p_EmitClassDecl(c_ClassDecl*);
	String p_TransApp(c_AppDecl*);
	String p_TransArgs3(Array<c_Expr* >,String);
	String p_TransFunc(c_FuncDecl*,Array<c_Expr* >,c_Expr*);
	String p_TransSuperFunc(c_FuncDecl*,Array<c_Expr* >);
	String p_TransConstExpr(c_ConstExpr*);
	String p_TransNewObjectExpr(c_NewObjectExpr*);
	String p_TransNewArrayExpr(c_NewArrayExpr*);
	String p_TransSelfExpr(c_SelfExpr*);
	String p_TransCastExpr(c_CastExpr*);
	String p_TransUnaryExpr(c_UnaryExpr*);
	String p_TransBinaryExpr(c_BinaryExpr*);
	String p_TransIndexExpr(c_IndexExpr*);
	String p_TransSliceExpr(c_SliceExpr*);
	String p_TransArrayExpr(c_ArrayExpr*);
	String p_TransTryStmt(c_TryStmt*);
	String p_TransIntrinsicExpr(c_Decl*,c_Expr*,Array<c_Expr* >);
	void mark();
};
extern int bb_html5_Info_Width;
extern int bb_html5_Info_Height;
class c_Stream : public Object{
	public:
	c_Stream();
	c_Stream* m_new();
	virtual int p_Read(c_DataBuffer*,int,int)=0;
	virtual void p_Close()=0;
	virtual int p_Eof()=0;
	virtual int p_Position()=0;
	virtual int p_Seek(int)=0;
	void mark();
};
class c_FileStream : public c_Stream{
	public:
	BBFileStream* m__stream;
	c_FileStream();
	static BBFileStream* m_OpenStream(String,String);
	c_FileStream* m_new(String,String);
	c_FileStream* m_new2(BBFileStream*);
	c_FileStream* m_new3();
	static c_FileStream* m_Open(String,String);
	int p_Read(c_DataBuffer*,int,int);
	void p_Close();
	int p_Eof();
	int p_Position();
	int p_Seek(int);
	void mark();
};
class c_DataBuffer : public BBDataBuffer{
	public:
	c_DataBuffer();
	c_DataBuffer* m_new(int,bool);
	c_DataBuffer* m_new2();
	void mark();
};
int bb_html5_GetInfo_PNG(String);
int bb_html5_GetInfo_JPG(String);
int bb_html5_GetInfo_GIF(String);
class c_AsTranslator : public c_CTranslator{
	public:
	c_AsTranslator();
	c_AsTranslator* m_new();
	String p_TransValue(c_Type*,String);
	String p_TransType(c_Type*);
	String p_TransLocalDecl(String,c_Expr*);
	int p_EmitEnter(c_FuncDecl*);
	int p_EmitSetErr(String);
	int p_EmitLeave();
	String p_TransStatic(c_Decl*);
	String p_TransGlobal(c_GlobalDecl*);
	String p_TransField(c_FieldDecl*,c_Expr*);
	String p_TransValDecl(c_ValDecl*);
	int p_EmitFuncDecl(c_FuncDecl*);
	int p_EmitClassDecl(c_ClassDecl*);
	String p_TransApp(c_AppDecl*);
	String p_TransArgs(Array<c_Expr* >);
	String p_TransFunc(c_FuncDecl*,Array<c_Expr* >,c_Expr*);
	String p_TransSuperFunc(c_FuncDecl*,Array<c_Expr* >);
	String p_TransConstExpr(c_ConstExpr*);
	String p_TransNewObjectExpr(c_NewObjectExpr*);
	String p_TransNewArrayExpr(c_NewArrayExpr*);
	String p_TransSelfExpr(c_SelfExpr*);
	String p_TransCastExpr(c_CastExpr*);
	String p_TransUnaryExpr(c_UnaryExpr*);
	String p_TransBinaryExpr(c_BinaryExpr*);
	String p_TransIndexExpr(c_IndexExpr*);
	String p_TransSliceExpr(c_SliceExpr*);
	String p_TransArrayExpr(c_ArrayExpr*);
	String p_TransIntrinsicExpr(c_Decl*,c_Expr*,Array<c_Expr* >);
	String p_TransTryStmt(c_TryStmt*);
	void mark();
};
class c_CsTranslator : public c_CTranslator{
	public:
	c_CsTranslator();
	c_CsTranslator* m_new();
	String p_TransType(c_Type*);
	String p_TransValue(c_Type*,String);
	String p_TransLocalDecl(String,c_Expr*);
	int p_EmitEnter(c_FuncDecl*);
	int p_EmitSetErr(String);
	int p_EmitLeave();
	String p_TransStatic(c_Decl*);
	String p_TransGlobal(c_GlobalDecl*);
	String p_TransField(c_FieldDecl*,c_Expr*);
	int p_EmitFuncDecl(c_FuncDecl*);
	String p_TransDecl(c_Decl*);
	int p_EmitClassDecl(c_ClassDecl*);
	String p_TransApp(c_AppDecl*);
	String p_TransArgs(Array<c_Expr* >);
	String p_TransFunc(c_FuncDecl*,Array<c_Expr* >,c_Expr*);
	String p_TransSuperFunc(c_FuncDecl*,Array<c_Expr* >);
	String p_TransConstExpr(c_ConstExpr*);
	String p_TransNewObjectExpr(c_NewObjectExpr*);
	String p_TransNewArrayExpr(c_NewArrayExpr*);
	String p_TransSelfExpr(c_SelfExpr*);
	String p_TransCastExpr(c_CastExpr*);
	String p_TransUnaryExpr(c_UnaryExpr*);
	String p_TransBinaryExpr(c_BinaryExpr*);
	String p_TransIndexExpr(c_IndexExpr*);
	String p_TransSliceExpr(c_SliceExpr*);
	String p_TransArrayExpr(c_ArrayExpr*);
	String p_TransIntrinsicExpr(c_Decl*,c_Expr*,Array<c_Expr* >);
	String p_TransTryStmt(c_TryStmt*);
	void mark();
};
class c_List11 : public Object{
	public:
	c_Node19* m__head;
	c_List11();
	c_List11* m_new();
	c_Node19* p_AddLast11(c_ModuleDecl*);
	c_List11* m_new2(Array<c_ModuleDecl* >);
	bool p_IsEmpty();
	c_ModuleDecl* p_RemoveLast();
	bool p_Equals5(c_ModuleDecl*,c_ModuleDecl*);
	c_Node19* p_FindLast9(c_ModuleDecl*,c_Node19*);
	c_Node19* p_FindLast10(c_ModuleDecl*);
	void p_RemoveLast6(c_ModuleDecl*);
	void mark();
};
class c_Node19 : public Object{
	public:
	c_Node19* m__succ;
	c_Node19* m__pred;
	c_ModuleDecl* m__data;
	c_Node19();
	c_Node19* m_new(c_Node19*,c_Node19*,c_ModuleDecl*);
	c_Node19* m_new2();
	int p_Remove();
	void mark();
};
class c_HeadNode11 : public c_Node19{
	public:
	c_HeadNode11();
	c_HeadNode11* m_new();
	void mark();
};
class c_Enumerator6 : public Object{
	public:
	c_List7* m__list;
	c_Node12* m__curr;
	c_Enumerator6();
	c_Enumerator6* m_new(c_List7*);
	c_Enumerator6* m_new2();
	bool p_HasNext();
	c_Stmt* p_NextObject();
	void mark();
};
class c_InvokeExpr : public c_Expr{
	public:
	c_FuncDecl* m_decl;
	Array<c_Expr* > m_args;
	c_InvokeExpr();
	c_InvokeExpr* m_new(c_FuncDecl*,Array<c_Expr* >);
	c_InvokeExpr* m_new2();
	c_Expr* p_Semant();
	String p_ToString();
	String p_Trans();
	String p_TransStmt();
	void mark();
};
class c_StmtExpr : public c_Expr{
	public:
	c_Stmt* m_stmt;
	c_Expr* m_expr;
	c_StmtExpr();
	c_StmtExpr* m_new(c_Stmt*,c_Expr*);
	c_StmtExpr* m_new2();
	c_Expr* p_Semant();
	c_Expr* p_Copy();
	String p_ToString();
	String p_Trans();
	void mark();
};
class c_MemberVarExpr : public c_Expr{
	public:
	c_Expr* m_expr;
	c_VarDecl* m_decl;
	c_MemberVarExpr();
	c_MemberVarExpr* m_new(c_Expr*,c_VarDecl*);
	c_MemberVarExpr* m_new2();
	c_Expr* p_Semant();
	String p_ToString();
	bool p_SideEffects();
	c_Expr* p_SemantSet(String,c_Expr*);
	String p_Trans();
	String p_TransVar();
	void mark();
};
class c_VarExpr : public c_Expr{
	public:
	c_VarDecl* m_decl;
	c_VarExpr();
	c_VarExpr* m_new(c_VarDecl*);
	c_VarExpr* m_new2();
	c_Expr* p_Semant();
	String p_ToString();
	bool p_SideEffects();
	c_Expr* p_SemantSet(String,c_Expr*);
	String p_Trans();
	String p_TransVar();
	void mark();
};
extern int bb_decl__loopnest;
class c_Map9 : public Object{
	public:
	c_Node20* m_root;
	c_Map9();
	c_Map9* m_new();
	virtual int p_Compare(String,String)=0;
	c_Node20* p_FindNode(String);
	c_FuncDeclList* p_Get(String);
	int p_RotateLeft9(c_Node20*);
	int p_RotateRight9(c_Node20*);
	int p_InsertFixup9(c_Node20*);
	bool p_Set8(String,c_FuncDeclList*);
	void mark();
};
class c_StringMap8 : public c_Map9{
	public:
	c_StringMap8();
	c_StringMap8* m_new();
	int p_Compare(String,String);
	void mark();
};
class c_Node20 : public Object{
	public:
	String m_key;
	c_Node20* m_right;
	c_Node20* m_left;
	c_FuncDeclList* m_value;
	int m_color;
	c_Node20* m_parent;
	c_Node20();
	c_Node20* m_new(String,c_FuncDeclList*,int,c_Node20*);
	c_Node20* m_new2();
	void mark();
};
class c_Map10 : public Object{
	public:
	c_Node21* m_root;
	c_Map10();
	c_Map10* m_new();
	virtual int p_Compare(String,String)=0;
	c_Node21* p_FindNode(String);
	bool p_Contains(String);
	int p_RotateLeft10(c_Node21*);
	int p_RotateRight10(c_Node21*);
	int p_InsertFixup10(c_Node21*);
	bool p_Set9(String,c_FuncDecl*);
	void mark();
};
class c_StringMap9 : public c_Map10{
	public:
	c_StringMap9();
	c_StringMap9* m_new();
	int p_Compare(String,String);
	void mark();
};
class c_Node21 : public Object{
	public:
	String m_key;
	c_Node21* m_right;
	c_Node21* m_left;
	c_FuncDecl* m_value;
	int m_color;
	c_Node21* m_parent;
	c_Node21();
	c_Node21* m_new(String,c_FuncDecl*,int,c_Node21*);
	c_Node21* m_new2();
	void mark();
};
class c_Map11 : public Object{
	public:
	c_Node22* m_root;
	c_Map11();
	c_Map11* m_new();
	virtual int p_Compare(String,String)=0;
	c_Node22* p_FindNode(String);
	c_StringSet* p_Get(String);
	int p_RotateLeft11(c_Node22*);
	int p_RotateRight11(c_Node22*);
	int p_InsertFixup11(c_Node22*);
	bool p_Set10(String,c_StringSet*);
	void mark();
};
class c_StringMap10 : public c_Map11{
	public:
	c_StringMap10();
	c_StringMap10* m_new();
	int p_Compare(String,String);
	void mark();
};
class c_Node22 : public Object{
	public:
	String m_key;
	c_Node22* m_right;
	c_Node22* m_left;
	c_StringSet* m_value;
	int m_color;
	c_Node22* m_parent;
	c_Node22();
	c_Node22* m_new(String,c_StringSet*,int,c_Node22*);
	c_Node22* m_new2();
	void mark();
};
class c_Enumerator7 : public Object{
	public:
	c_List10* m__list;
	c_Node16* m__curr;
	c_Enumerator7();
	c_Enumerator7* m_new(c_List10*);
	c_Enumerator7* m_new2();
	bool p_HasNext();
	c_GlobalDecl* p_NextObject();
	void mark();
};
class c_Stack10 : public Object{
	public:
	Array<c_LocalDecl* > m_data;
	int m_length;
	c_Stack10();
	c_Stack10* m_new();
	c_Stack10* m_new2(Array<c_LocalDecl* >);
	static c_LocalDecl* m_NIL;
	void p_Clear();
	c_Enumerator8* p_ObjectEnumerator();
	void p_Length(int);
	int p_Length2();
	void p_Push28(c_LocalDecl*);
	void p_Push29(Array<c_LocalDecl* >,int,int);
	void p_Push30(Array<c_LocalDecl* >,int);
	void mark();
};
class c_Enumerator8 : public Object{
	public:
	c_Stack10* m_stack;
	int m_index;
	c_Enumerator8();
	c_Enumerator8* m_new(c_Stack10*);
	c_Enumerator8* m_new2();
	bool p_HasNext();
	c_LocalDecl* p_NextObject();
	void mark();
};
c_TransCC::c_TransCC(){
	m_args=Array<String >();
	m_cerberusdir=String();
	m_opt_srcpath=String();
	m_opt_safe=false;
	m_opt_clean=false;
	m_opt_check=false;
	m_opt_update=false;
	m_opt_build=false;
	m_opt_run=false;
	m_opt_cfgfile=String();
	m_opt_output=String();
	m_opt_config=String();
	m_opt_target=String();
	m_opt_modpath=String();
	m_opt_builddir=String();
	m_ANDROID_PATH=String();
	m_ANDROID_NDK_PATH=String();
	m_JDK_PATH=String();
	m_ANT_PATH=String();
	m_FLEX_PATH=String();
	m_MINGW_PATH=String();
	m_PSM_PATH=String();
	m_MSBUILD_PATH=String();
	m_AGK_PATH=String();
	m_HTML_PLAYER=String();
	m_FLASH_PLAYER=String();
	m__libs=String();
	m__builders=(new c_StringMap3)->m_new();
	m__targets=(new c_StringMap6)->m_new();
	m_target=0;
}
c_TransCC* c_TransCC::m_new(){
	return this;
}
void c_TransCC::p_ParseArgs(){
	if(m_args.Length()>1){
		m_opt_srcpath=bb_transcc_StripQuotes(m_args[m_args.Length()-1].Trim());
	}
	for(int t_i=1;t_i<m_args.Length()-1;t_i=t_i+1){
		String t_arg=m_args[t_i].Trim();
		String t_rhs=String();
		int t_j=t_arg.Find(String(L"=",1),0);
		if(t_j!=-1){
			t_rhs=bb_transcc_StripQuotes(t_arg.Slice(t_j+1));
			t_arg=t_arg.Slice(0,t_j);
		}
		if(t_j==-1){
			String t_1=t_arg.ToLower();
			if(t_1==String(L"-safe",5)){
				m_opt_safe=true;
			}else{
				if(t_1==String(L"-clean",6)){
					m_opt_clean=true;
				}else{
					if(t_1==String(L"-check",6)){
						m_opt_check=true;
					}else{
						if(t_1==String(L"-update",7)){
							m_opt_check=true;
							m_opt_update=true;
						}else{
							if(t_1==String(L"-build",6)){
								m_opt_check=true;
								m_opt_update=true;
								m_opt_build=true;
							}else{
								if(t_1==String(L"-run",4)){
									m_opt_check=true;
									m_opt_update=true;
									m_opt_build=true;
									m_opt_run=true;
								}else{
									bb_transcc_Die(String(L"Unrecognized command line option: ",34)+t_arg);
								}
							}
						}
					}
				}
			}
		}else{
			if(t_arg.StartsWith(String(L"-",1))){
				String t_2=t_arg.ToLower();
				if(t_2==String(L"-cfgfile",8)){
					m_opt_cfgfile=t_rhs;
				}else{
					if(t_2==String(L"-output",7)){
						m_opt_output=t_rhs;
					}else{
						if(t_2==String(L"-config",7)){
							m_opt_config=t_rhs.ToLower();
						}else{
							if(t_2==String(L"-target",7)){
								m_opt_target=t_rhs;
							}else{
								if(t_2==String(L"-modpath",8)){
									m_opt_modpath=t_rhs;
								}else{
									if(t_2==String(L"-builddir",9)){
										m_opt_builddir=t_rhs;
									}else{
										bb_transcc_Die(String(L"Unrecognized command line option: ",34)+t_arg);
									}
								}
							}
						}
					}
				}
			}else{
				if(t_arg.StartsWith(String(L"+",1))){
					bb_config_SetConfigVar2(t_arg.Slice(1),t_rhs);
				}else{
					bb_transcc_Die(String(L"Command line arg error: ",24)+t_arg);
				}
			}
		}
	}
}
void c_TransCC::p_LoadConfig(){
	String t_cfgpath=m_cerberusdir+String(L"/bin/",5);
	if((m_opt_cfgfile).Length()!=0){
		t_cfgpath=t_cfgpath+m_opt_cfgfile;
	}else{
		t_cfgpath=t_cfgpath+(String(L"config.",7)+HostOS()+String(L".txt",4));
	}
	if(FileType(t_cfgpath)!=1){
		bb_transcc_Die(String(L"Failed to open config file",26));
	}
	String t_cfg=LoadString(t_cfgpath);
	Array<String > t_=t_cfg.Split(String(L"\n",1));
	int t_2=0;
	while(t_2<t_.Length()){
		String t_line=t_[t_2];
		t_2=t_2+1;
		t_line=t_line.Trim();
		if(!((t_line).Length()!=0) || t_line.StartsWith(String(L"'",1))){
			continue;
		}
		int t_i=t_line.Find(String(L"=",1),0);
		if(t_i==-1){
			bb_transcc_Die(String(L"Error in config file, line=",27)+t_line);
		}
		String t_lhs=t_line.Slice(0,t_i).Trim();
		String t_rhs=t_line.Slice(t_i+1).Trim();
		t_rhs=bb_transcc_ReplaceEnv(t_rhs);
		String t_path=bb_transcc_StripQuotes(t_rhs);
		while(t_path.EndsWith(String(L"/",1)) || t_path.EndsWith(String(L"\\",1))){
			t_path=t_path.Slice(0,-1);
		}
		String t_3=t_lhs;
		if(t_3==String(L"MODPATH",7)){
			if(!((m_opt_modpath).Length()!=0)){
				m_opt_modpath=t_path;
			}
		}else{
			if(t_3==String(L"ANDROID_PATH",12)){
				if(!((m_ANDROID_PATH).Length()!=0) && FileType(t_path)==2){
					m_ANDROID_PATH=t_path;
				}
			}else{
				if(t_3==String(L"ANDROID_NDK_PATH",16)){
					if(!((m_ANDROID_NDK_PATH).Length()!=0) && FileType(t_path)==2){
						m_ANDROID_NDK_PATH=t_path;
					}
				}else{
					if(t_3==String(L"JDK_PATH",8)){
						if(!((m_JDK_PATH).Length()!=0) && FileType(t_path)==2){
							m_JDK_PATH=t_path;
						}
					}else{
						if(t_3==String(L"ANT_PATH",8)){
							if(!((m_ANT_PATH).Length()!=0) && FileType(t_path)==2){
								m_ANT_PATH=t_path;
							}
						}else{
							if(t_3==String(L"FLEX_PATH",9)){
								if(!((m_FLEX_PATH).Length()!=0) && FileType(t_path)==2){
									m_FLEX_PATH=t_path;
								}
							}else{
								if(t_3==String(L"MINGW_PATH",10)){
									if(!((m_MINGW_PATH).Length()!=0) && FileType(t_path)==2){
										m_MINGW_PATH=t_path;
									}
								}else{
									if(t_3==String(L"PSM_PATH",8)){
										if(!((m_PSM_PATH).Length()!=0) && FileType(t_path)==2){
											m_PSM_PATH=t_path;
										}
									}else{
										if(t_3==String(L"MSBUILD_PATH",12)){
											if(!((m_MSBUILD_PATH).Length()!=0) && FileType(t_path)==1){
												m_MSBUILD_PATH=t_path;
											}
										}else{
											if(t_3==String(L"AGK_PATH",8)){
												if(!((m_AGK_PATH).Length()!=0) && FileType(t_path)==2){
													m_AGK_PATH=t_path;
												}
											}else{
												if(t_3==String(L"HTML_PLAYER",11)){
													m_HTML_PLAYER=t_rhs;
												}else{
													if(t_3==String(L"FLASH_PLAYER",12)){
														m_FLASH_PLAYER=t_rhs;
													}else{
														bbPrint(String(L"Trans: ignoring unrecognized config var: ",41)+t_lhs);
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
	String t_4=HostOS();
	if(t_4==String(L"winnt",5)){
		String t_path2=GetEnv(String(L"PATH",4));
		if((m_ANDROID_PATH).Length()!=0){
			t_path2=t_path2+(String(L";",1)+m_ANDROID_PATH+String(L"/tools",6));
		}
		if((m_ANDROID_PATH).Length()!=0){
			t_path2=t_path2+(String(L";",1)+m_ANDROID_PATH+String(L"/platform-tools",15));
		}
		if((m_JDK_PATH).Length()!=0){
			t_path2=t_path2+(String(L";",1)+m_JDK_PATH+String(L"/bin",4));
		}
		if((m_ANT_PATH).Length()!=0){
			t_path2=t_path2+(String(L";",1)+m_ANT_PATH+String(L"/bin",4));
		}
		if((m_FLEX_PATH).Length()!=0){
			t_path2=t_path2+(String(L";",1)+m_FLEX_PATH+String(L"/bin",4));
		}
		if((m_MINGW_PATH).Length()!=0){
			t_path2=m_MINGW_PATH+String(L"/bin;",5)+t_path2;
		}
		SetEnv(String(L"PATH",4),t_path2);
		if((m_JDK_PATH).Length()!=0){
			SetEnv(String(L"JAVA_HOME",9),m_JDK_PATH);
		}
		m__libs=AppPath();
		m__libs=m__libs.Slice(0,m__libs.Find(String(L"bin/transcc_winnt.exe",21),0))+String(L"libs/",5);
	}else{
		if(t_4==String(L"macos",5)){
			String t_path3=GetEnv(String(L"PATH",4));
			if((m_ANDROID_PATH).Length()!=0){
				t_path3=t_path3+(String(L":",1)+m_ANDROID_PATH+String(L"/tools",6));
			}
			if((m_ANDROID_PATH).Length()!=0){
				t_path3=t_path3+(String(L":",1)+m_ANDROID_PATH+String(L"/platform-tools",15));
			}
			if((m_ANT_PATH).Length()!=0){
				t_path3=t_path3+(String(L":",1)+m_ANT_PATH+String(L"/bin",4));
			}
			if((m_FLEX_PATH).Length()!=0){
				t_path3=t_path3+(String(L":",1)+m_FLEX_PATH+String(L"/bin",4));
			}
			SetEnv(String(L"PATH",4),t_path3);
		}else{
			if(t_4==String(L"linux",5)){
				String t_path4=GetEnv(String(L"PATH",4));
				if((m_JDK_PATH).Length()!=0){
					t_path4=m_JDK_PATH+String(L"/bin:",5)+t_path4;
				}
				if((m_ANDROID_PATH).Length()!=0){
					t_path4=m_ANDROID_PATH+String(L"/platform-tools:",16)+t_path4;
				}
				if((m_FLEX_PATH).Length()!=0){
					t_path4=m_FLEX_PATH+String(L"/bin:",5)+t_path4;
				}
				SetEnv(String(L"PATH",4),t_path4);
			}
		}
	}
}
void c_TransCC::p_EnumBuilders(){
	c_NodeEnumerator* t_=bb_builders_Builders(this)->p_ObjectEnumerator();
	while(t_->p_HasNext()){
		c_Node3* t_it=t_->p_NextObject();
		if(t_it->p_Value()->p_IsValid()){
			m__builders->p_Set3(t_it->p_Key(),t_it->p_Value());
		}
	}
}
void c_TransCC::p_EnumTargets(String t_dir){
	String t_p=m_cerberusdir+String(L"/",1)+t_dir;
	Array<String > t_=LoadDir(t_p);
	int t_2=0;
	while(t_2<t_.Length()){
		String t_f=t_[t_2];
		t_2=t_2+1;
		String t_t=t_p+String(L"/",1)+t_f+String(L"/target.cxs",11);
		if(FileType(t_t)!=1){
			t_t=t_p+String(L"/",1)+t_f+String(L"/TARGET.MONKEY",14);
			if(FileType(t_t)!=1){
				continue;
			}
		}
		bb_config_PushConfigScope();
		bb_preprocessor_PreProcess(t_t,0);
		String t_name=bb_config_GetConfigVar(String(L"TARGET_NAME",11));
		if((t_name).Length()!=0){
			String t_system=bb_config_GetConfigVar(String(L"TARGET_SYSTEM",13));
			if((t_system).Length()!=0){
				c_Builder* t_builder=m__builders->p_Get(bb_config_GetConfigVar(String(L"TARGET_BUILDER",14)));
				if((t_builder)!=0){
					String t_host=bb_config_GetConfigVar(String(L"TARGET_HOST",11));
					if(!((t_host).Length()!=0) || t_host==HostOS()){
						m__targets->p_Set6(t_name,(new c_Target)->m_new(t_f,t_name,t_system,t_builder));
					}
				}
			}
		}
		bb_config_PopConfigScope();
	}
}
String c_TransCC::p_GetReleaseVersion(){
	String t_f=LoadString(m_cerberusdir+String(L"/VERSIONS.TXT",13));
	Array<String > t_=t_f.Split(String(L"\n",1));
	int t_2=0;
	while(t_2<t_.Length()){
		String t_t=t_[t_2];
		t_2=t_2+1;
		t_t=t_t.Trim();
		if(t_t.StartsWith(String(L"***** v",7)) && t_t.EndsWith(String(L" *****",6))){
			return t_t.Slice(6,-6);
		}
	}
	return String();
}
void c_TransCC::p_Run(Array<String > t_args){
	this->m_args=t_args;
	bbPrint(String(L"TRANS cerberus compiler V2020-05-01",35));
	m_cerberusdir=RealPath(bb_os_ExtractDir(AppPath())+String(L"/..",3));
	SetEnv(String(L"CERBERUSDIR",11),m_cerberusdir);
	SetEnv(String(L"MONKEYDIR",9),m_cerberusdir);
	SetEnv(String(L"TRANSDIR",8),m_cerberusdir+String(L"/bin",4));
	p_ParseArgs();
	p_LoadConfig();
	p_EnumBuilders();
	p_EnumTargets(String(L"targets",7));
	if(t_args.Length()<2){
		String t_valid=String();
		c_NodeEnumerator2* t_=m__targets->p_ObjectEnumerator();
		while(t_->p_HasNext()){
			c_Node17* t_it=t_->p_NextObject();
			t_valid=t_valid+(String(L" ",1)+t_it->p_Key().Replace(String(L" ",1),String(L"_",1)));
		}
		bbPrint(String(L"TRANS Usage: transcc [-update] [-build] [-run] [-clean] [-config=...] [-target=...] [-cfgfile=...] [-modpath=...] <main_cerberus_source_file>",141));
		bbPrint(String(L"Valid targets:",14)+t_valid);
		bbPrint(String(L"Valid configs: debug release",28));
		ExitApp(0);
	}
	m_target=m__targets->p_Get(m_opt_target.Replace(String(L"_",1),String(L" ",1)));
	if(!((m_target)!=0)){
		bb_transcc_Die(String(L"Invalid target",14));
	}
	m_target->m_builder->p_Make();
}
bool c_TransCC::p_Execute(String t_cmd,bool t_failHard){
	int t_r=Execute(t_cmd);
	if(!((t_r)!=0)){
		return true;
	}
	if(t_failHard){
		bb_transcc_Die(String(L"Error executing '",17)+t_cmd+String(L"', return code=",15)+String(t_r));
	}
	return false;
}
void c_TransCC::mark(){
	Object::mark();
}
String bb_os_ExtractDir(String t_path){
	int t_i=t_path.FindLast(String(L"/",1));
	if(t_i==-1){
		t_i=t_path.FindLast(String(L"\\",1));
	}
	if(t_i!=-1){
		return t_path.Slice(0,t_i);
	}
	return String();
}
String bb_transcc_StripQuotes(String t_str){
	if(t_str.Length()>=2 && t_str.StartsWith(String(L"\"",1)) && t_str.EndsWith(String(L"\"",1))){
		return t_str.Slice(1,-1);
	}
	return t_str;
}
int bb_transcc_Die(String t_msg){
	bbPrint(String(L"TRANS FAILED: ",14)+t_msg);
	ExitApp(-1);
	return 0;
}
c_Type::c_Type(){
	m_arrayOf=0;
}
c_Type* c_Type::m_new(){
	return this;
}
c_StringType* c_Type::m_stringType;
c_IntType* c_Type::m_intType;
c_FloatType* c_Type::m_floatType;
c_BoolType* c_Type::m_boolType;
c_VoidType* c_Type::m_voidType;
c_IdentType* c_Type::m_objectType;
c_IdentType* c_Type::m_throwableType;
c_ArrayType* c_Type::p_ArrayOf(){
	if(!((m_arrayOf)!=0)){
		m_arrayOf=(new c_ArrayType)->m_new(this);
	}
	return m_arrayOf;
}
c_ArrayType* c_Type::m_emptyArrayType;
c_IdentType* c_Type::m_nullObjectType;
String c_Type::p_ToString(){
	return String(L"??Type??",8);
}
int c_Type::p_EqualsType(c_Type* t_ty){
	return 0;
}
c_Type* c_Type::p_Semant(){
	return this;
}
int c_Type::p_ExtendsType(c_Type* t_ty){
	return p_EqualsType(t_ty);
}
c_ClassDecl* c_Type::p_GetClass(){
	return 0;
}
void c_Type::mark(){
	Object::mark();
}
c_StringType::c_StringType(){
}
c_StringType* c_StringType::m_new(){
	c_Type::m_new();
	return this;
}
int c_StringType::p_EqualsType(c_Type* t_ty){
	return ((dynamic_cast<c_StringType*>(t_ty)!=0)?1:0);
}
int c_StringType::p_ExtendsType(c_Type* t_ty){
	if((dynamic_cast<c_ObjectType*>(t_ty))!=0){
		c_Expr* t_expr=((new c_ConstExpr)->m_new((this),String()))->p_Semant();
		c_Expr* t_[]={t_expr};
		c_FuncDecl* t_ctor=t_ty->p_GetClass()->p_FindFuncDecl(String(L"new",3),Array<c_Expr* >(t_,1),1);
		return ((((t_ctor)!=0) && t_ctor->p_IsCtor())?1:0);
	}
	return p_EqualsType(t_ty);
}
c_ClassDecl* c_StringType::p_GetClass(){
	return dynamic_cast<c_ClassDecl*>(bb_decl__env->p_FindDecl(String(L"string",6)));
}
String c_StringType::p_ToString(){
	return String(L"String",6);
}
void c_StringType::mark(){
	c_Type::mark();
}
c_Decl::c_Decl(){
	m_errInfo=String();
	m_ident=String();
	m_munged=String();
	m_attrs=0;
	m_scope=0;
}
c_Decl* c_Decl::m_new(){
	m_errInfo=bb_config__errInfo;
	return this;
}
int c_Decl::p_IsSemanted(){
	return (((m_attrs&1048576)!=0)?1:0);
}
int c_Decl::p_IsPublic(){
	return (((m_attrs&16896)==0)?1:0);
}
c_ModuleDecl* c_Decl::p_ModuleScope(){
	if((dynamic_cast<c_ModuleDecl*>(this))!=0){
		return dynamic_cast<c_ModuleDecl*>(this);
	}
	if((m_scope)!=0){
		return m_scope->p_ModuleScope();
	}
	return 0;
}
int c_Decl::p_IsProtected(){
	return (((m_attrs&16384)!=0)?1:0);
}
c_ClassDecl* c_Decl::p_ClassScope(){
	if((dynamic_cast<c_ClassDecl*>(this))!=0){
		return dynamic_cast<c_ClassDecl*>(this);
	}
	if((m_scope)!=0){
		return m_scope->p_ClassScope();
	}
	return 0;
}
c_FuncDecl* c_Decl::p_FuncScope(){
	if((dynamic_cast<c_FuncDecl*>(this))!=0){
		return dynamic_cast<c_FuncDecl*>(this);
	}
	if((m_scope)!=0){
		return m_scope->p_FuncScope();
	}
	return 0;
}
int c_Decl::p_CheckAccess(){
	if(!((bb_decl__env)!=0)){
		return 1;
	}
	if((p_IsPublic())!=0){
		return 1;
	}
	c_ModuleDecl* t_mdecl=p_ModuleScope();
	if((t_mdecl)!=0){
		c_ModuleDecl* t_mdecl2=bb_decl__env->p_ModuleScope();
		if(t_mdecl==t_mdecl2){
			return 1;
		}
		if(((t_mdecl2)!=0) && t_mdecl->m_friends->p_Contains(t_mdecl2->m_rmodpath)){
			return 1;
		}
	}
	if((p_IsProtected())!=0){
		c_ClassDecl* t_thisClass=p_ClassScope();
		c_ClassDecl* t_currentClass=bb_decl__env->p_ClassScope();
		while((t_currentClass)!=0){
			if(t_currentClass==t_thisClass){
				return 1;
			}
			t_currentClass=t_currentClass->m_superClass;
		}
	}
	c_FuncDecl* t_fdecl=bb_decl__env->p_FuncScope();
	if(((t_fdecl)!=0) && ((t_fdecl->m_attrs&8388608)!=0)){
		return 1;
	}
	return 0;
}
int c_Decl::p_IsExtern(){
	return (((m_attrs&256)!=0)?1:0);
}
String c_Decl::p_ToString(){
	if((dynamic_cast<c_ClassDecl*>(m_scope))!=0){
		return m_scope->p_ToString()+String(L".",1)+m_ident;
	}
	return m_ident;
}
int c_Decl::p_IsAbstract(){
	return (((m_attrs&1024)!=0)?1:0);
}
int c_Decl::p_IsSemanting(){
	return (((m_attrs&2097152)!=0)?1:0);
}
c_AppDecl* c_Decl::p_AppScope(){
	if((dynamic_cast<c_AppDecl*>(this))!=0){
		return dynamic_cast<c_AppDecl*>(this);
	}
	if((m_scope)!=0){
		return m_scope->p_AppScope();
	}
	return 0;
}
int c_Decl::p_Semant(){
	if((p_IsSemanted())!=0){
		return 0;
	}
	if((p_IsSemanting())!=0){
		bb_config_Err(String(L"Cyclic declaration of '",23)+m_ident+String(L"'.",2));
	}
	c_ClassDecl* t_cscope=dynamic_cast<c_ClassDecl*>(m_scope);
	if((t_cscope)!=0){
		t_cscope->m_attrs&=-5;
	}
	bb_config_PushErr(m_errInfo);
	if((m_scope)!=0){
		bb_decl_PushEnv(m_scope);
	}
	m_attrs|=2097152;
	p_OnSemant();
	m_attrs&=-2097153;
	m_attrs|=1048576;
	if((m_scope)!=0){
		if((p_IsExtern())!=0){
			if((dynamic_cast<c_ModuleDecl*>(m_scope))!=0){
				p_AppScope()->m_allSemantedDecls->p_AddLast5(this);
			}
		}else{
			m_scope->m_semanted->p_AddLast5(this);
			if((dynamic_cast<c_GlobalDecl*>(this))!=0){
				p_AppScope()->m_semantedGlobals->p_AddLast10(dynamic_cast<c_GlobalDecl*>(this));
			}
			if((dynamic_cast<c_ModuleDecl*>(m_scope))!=0){
				p_AppScope()->m_semanted->p_AddLast5(this);
				p_AppScope()->m_allSemantedDecls->p_AddLast5(this);
			}
		}
		bb_decl_PopEnv();
	}
	bb_config_PopErr();
	return 0;
}
int c_Decl::p_IsPrivate(){
	return (((m_attrs&512)!=0)?1:0);
}
int c_Decl::p_AssertAccess(){
	if((p_CheckAccess())!=0){
		return 0;
	}
	if((p_IsPrivate())!=0){
		bb_config_Err(p_ToString()+String(L" is private.",12));
	}
	if((p_IsProtected())!=0){
		bb_config_Err(p_ToString()+String(L" is protected.",14));
	}
	bb_config_Err(p_ToString()+String(L" is inaccessible.",17));
	return 0;
}
c_Decl* c_Decl::p_Copy(){
	c_Decl* t_t=p_OnCopy();
	t_t->m_munged=m_munged;
	t_t->m_errInfo=m_errInfo;
	return t_t;
}
int c_Decl::p_IsFinal(){
	return (((m_attrs&2048)!=0)?1:0);
}
void c_Decl::mark(){
	Object::mark();
}
c_ScopeDecl::c_ScopeDecl(){
	m_decls=(new c_List5)->m_new();
	m_declsMap=(new c_StringMap4)->m_new();
	m_semanted=(new c_List5)->m_new();
}
c_ScopeDecl* c_ScopeDecl::m_new(){
	c_Decl::m_new();
	return this;
}
int c_ScopeDecl::p_InsertDecl(c_Decl* t_decl){
	if((t_decl->m_scope)!=0){
		bb_config_InternalErr(String(L"Internal error",14));
	}
	String t_ident=t_decl->m_ident;
	if(!((t_ident).Length()!=0)){
		return 0;
	}
	t_decl->m_scope=this;
	m_decls->p_AddLast5(t_decl);
	c_StringMap4* t_decls=0;
	Object* t_tdecl=m_declsMap->p_Get(t_ident);
	if((dynamic_cast<c_FuncDecl*>(t_decl))!=0){
		c_FuncDeclList* t_funcs=dynamic_cast<c_FuncDeclList*>(t_tdecl);
		if(((t_funcs)!=0) || !((t_tdecl)!=0)){
			if(!((t_funcs)!=0)){
				t_funcs=(new c_FuncDeclList)->m_new();
				m_declsMap->p_Insert2(t_ident,(t_funcs));
			}
			t_funcs->p_AddLast6(dynamic_cast<c_FuncDecl*>(t_decl));
		}else{
			bb_config_Err(String(L"Duplicate identifier '",22)+t_ident+String(L"'.",2));
		}
	}else{
		if(!((t_tdecl)!=0)){
			m_declsMap->p_Insert2(t_ident,(t_decl));
		}else{
			bb_config_Err(String(L"Duplicate identifier '",22)+t_ident+String(L"'.",2));
		}
	}
	if((t_decl->p_IsSemanted())!=0){
		m_semanted->p_AddLast5(t_decl);
	}
	return 0;
}
Object* c_ScopeDecl::p_GetDecl(String t_ident){
	Object* t_decl=m_declsMap->p_Get(t_ident);
	if(!((t_decl)!=0)){
		return 0;
	}
	c_AliasDecl* t_adecl=dynamic_cast<c_AliasDecl*>(t_decl);
	if(!((t_adecl)!=0)){
		return t_decl;
	}
	if((t_adecl->p_CheckAccess())!=0){
		return t_adecl->m_decl;
	}
	return 0;
}
Object* c_ScopeDecl::p_FindDecl(String t_ident){
	if(bb_decl__env!=this){
		return p_GetDecl(t_ident);
	}
	c_ScopeDecl* t_tscope=this;
	while((t_tscope)!=0){
		Object* t_decl=t_tscope->p_GetDecl(t_ident);
		if((t_decl)!=0){
			return t_decl;
		}
		t_tscope=t_tscope->m_scope;
	}
	return 0;
}
int c_ScopeDecl::p_InsertDecls(c_List5* t_decls){
	c_Enumerator3* t_=t_decls->p_ObjectEnumerator();
	while(t_->p_HasNext()){
		c_Decl* t_decl=t_->p_NextObject();
		p_InsertDecl(t_decl);
	}
	return 0;
}
c_FuncDecl* c_ScopeDecl::p_FindFuncDecl(String t_ident,Array<c_Expr* > t_argExprs,int t_explicit){
	c_FuncDeclList* t_funcs=dynamic_cast<c_FuncDeclList*>(p_FindDecl(t_ident));
	if(!((t_funcs)!=0)){
		return 0;
	}
	c_Enumerator4* t_=t_funcs->p_ObjectEnumerator();
	while(t_->p_HasNext()){
		c_FuncDecl* t_func=t_->p_NextObject();
		t_func->p_Semant();
	}
	c_FuncDecl* t_match=0;
	int t_isexact=0;
	String t_err=String();
	c_Enumerator4* t_2=t_funcs->p_ObjectEnumerator();
	while(t_2->p_HasNext()){
		c_FuncDecl* t_func2=t_2->p_NextObject();
		Array<c_ArgDecl* > t_argDecls=t_func2->m_argDecls;
		if(t_argExprs.Length()>t_argDecls.Length()){
			continue;
		}
		int t_exact=1;
		int t_possible=1;
		for(int t_i=0;t_i<t_argDecls.Length();t_i=t_i+1){
			if(t_i<t_argExprs.Length() && ((t_argExprs[t_i])!=0)){
				c_Type* t_declTy=t_argDecls[t_i]->m_type;
				c_Type* t_exprTy=t_argExprs[t_i]->m_exprType;
				if((t_exprTy->p_EqualsType(t_declTy))!=0){
					continue;
				}
				t_exact=0;
				if(!((t_explicit)!=0) && ((t_exprTy->p_ExtendsType(t_declTy))!=0)){
					continue;
				}
			}else{
				if((t_argDecls[t_i]->m_init)!=0){
					if(!((t_explicit)!=0)){
						continue;
					}
				}
			}
			t_possible=0;
			break;
		}
		if(!((t_possible)!=0)){
			continue;
		}
		if((t_exact)!=0){
			if((t_isexact)!=0){
				bb_config_Err(String(L"Unable to determine overload to use: ",37)+t_match->p_ToString()+String(L" or ",4)+t_func2->p_ToString()+String(L".",1));
			}else{
				t_err=String();
				t_match=t_func2;
				t_isexact=1;
			}
		}else{
			if(!((t_isexact)!=0)){
				if((t_match)!=0){
					t_err=String(L"Unable to determine overload to use: ",37)+t_match->p_ToString()+String(L" or ",4)+t_func2->p_ToString()+String(L".",1);
				}else{
					t_match=t_func2;
				}
			}
		}
	}
	if(!((t_isexact)!=0)){
		if((t_err).Length()!=0){
			bb_config_Err(t_err);
		}
		if((t_explicit)!=0){
			return 0;
		}
	}
	if(!((t_match)!=0)){
		String t_t=String();
		for(int t_i2=0;t_i2<t_argExprs.Length();t_i2=t_i2+1){
			if((t_t).Length()!=0){
				t_t=t_t+String(L",",1);
			}
			if((t_argExprs[t_i2])!=0){
				t_t=t_t+t_argExprs[t_i2]->m_exprType->p_ToString();
			}
		}
		bb_config_Err(String(L"Unable to find overload for ",28)+t_ident+String(L"(",1)+t_t+String(L").",2));
	}
	t_match->p_AssertAccess();
	return t_match;
}
c_List5* c_ScopeDecl::p_Decls(){
	return m_decls;
}
c_Type* c_ScopeDecl::p_FindType(String t_ident,Array<c_Type* > t_args){
	Object* t_decl=p_GetDecl(t_ident);
	if((t_decl)!=0){
		c_Type* t_type=dynamic_cast<c_Type*>(t_decl);
		if((t_type)!=0){
			if((t_args.Length())!=0){
				bb_config_Err(String(L"Wrong number of type arguments",30));
			}
			return t_type;
		}
		c_ClassDecl* t_cdecl=dynamic_cast<c_ClassDecl*>(t_decl);
		if((t_cdecl)!=0){
			t_cdecl->p_AssertAccess();
			t_cdecl=t_cdecl->p_GenClassInstance(t_args);
			t_cdecl->p_Semant();
			return (t_cdecl->m_objectType);
		}
	}
	if((m_scope)!=0){
		return m_scope->p_FindType(t_ident,t_args);
	}
	return 0;
}
c_List6* c_ScopeDecl::p_MethodDecls(String t_id){
	c_List6* t_fdecls=(new c_List6)->m_new();
	c_Enumerator3* t_=m_decls->p_ObjectEnumerator();
	while(t_->p_HasNext()){
		c_Decl* t_decl=t_->p_NextObject();
		if(((t_id).Length()!=0) && t_decl->m_ident!=t_id){
			continue;
		}
		c_FuncDecl* t_fdecl=dynamic_cast<c_FuncDecl*>(t_decl);
		if(((t_fdecl)!=0) && t_fdecl->p_IsMethod()){
			t_fdecls->p_AddLast6(t_fdecl);
		}
	}
	return t_fdecls;
}
c_List5* c_ScopeDecl::p_Semanted(){
	return m_semanted;
}
c_List6* c_ScopeDecl::p_SemantedMethods(String t_id){
	c_List6* t_fdecls=(new c_List6)->m_new();
	c_Enumerator3* t_=m_semanted->p_ObjectEnumerator();
	while(t_->p_HasNext()){
		c_Decl* t_decl=t_->p_NextObject();
		if(((t_id).Length()!=0) && t_decl->m_ident!=t_id){
			continue;
		}
		c_FuncDecl* t_fdecl=dynamic_cast<c_FuncDecl*>(t_decl);
		if(((t_fdecl)!=0) && t_fdecl->p_IsMethod()){
			t_fdecls->p_AddLast6(t_fdecl);
		}
	}
	return t_fdecls;
}
c_ValDecl* c_ScopeDecl::p_FindValDecl(String t_ident){
	c_ValDecl* t_decl=dynamic_cast<c_ValDecl*>(p_FindDecl(t_ident));
	if(!((t_decl)!=0)){
		return 0;
	}
	t_decl->p_AssertAccess();
	t_decl->p_Semant();
	return t_decl;
}
c_Decl* c_ScopeDecl::p_OnCopy(){
	bb_config_InternalErr(String(L"Internal error",14));
	return 0;
}
int c_ScopeDecl::p_OnSemant(){
	return 0;
}
c_List6* c_ScopeDecl::p_SemantedFuncs(String t_id){
	c_List6* t_fdecls=(new c_List6)->m_new();
	c_Enumerator3* t_=m_semanted->p_ObjectEnumerator();
	while(t_->p_HasNext()){
		c_Decl* t_decl=t_->p_NextObject();
		if(((t_id).Length()!=0) && t_decl->m_ident!=t_id){
			continue;
		}
		c_FuncDecl* t_fdecl=dynamic_cast<c_FuncDecl*>(t_decl);
		if((t_fdecl)!=0){
			t_fdecls->p_AddLast6(t_fdecl);
		}
	}
	return t_fdecls;
}
c_ModuleDecl* c_ScopeDecl::p_FindModuleDecl(String t_ident){
	c_ModuleDecl* t_decl=dynamic_cast<c_ModuleDecl*>(p_GetDecl(t_ident));
	if((t_decl)!=0){
		t_decl->p_AssertAccess();
		t_decl->p_Semant();
		return t_decl;
	}
	if((m_scope)!=0){
		return m_scope->p_FindModuleDecl(t_ident);
	}
	return 0;
}
c_List6* c_ScopeDecl::p_FuncDecls(String t_id){
	c_List6* t_fdecls=(new c_List6)->m_new();
	c_Enumerator3* t_=m_decls->p_ObjectEnumerator();
	while(t_->p_HasNext()){
		c_Decl* t_decl=t_->p_NextObject();
		if(((t_id).Length()!=0) && t_decl->m_ident!=t_id){
			continue;
		}
		c_FuncDecl* t_fdecl=dynamic_cast<c_FuncDecl*>(t_decl);
		if((t_fdecl)!=0){
			t_fdecls->p_AddLast6(t_fdecl);
		}
	}
	return t_fdecls;
}
c_ScopeDecl* c_ScopeDecl::p_FindScopeDecl(String t_ident){
	Object* t_decl=p_FindDecl(t_ident);
	c_Type* t_type=dynamic_cast<c_Type*>(t_decl);
	if((t_type)!=0){
		if(!((dynamic_cast<c_ObjectType*>(t_type))!=0)){
			return 0;
		}
		return (t_type->p_GetClass());
	}
	c_ScopeDecl* t_scope=dynamic_cast<c_ScopeDecl*>(t_decl);
	if((t_scope)!=0){
		c_ClassDecl* t_cdecl=dynamic_cast<c_ClassDecl*>(t_scope);
		if(((t_cdecl)!=0) && ((t_cdecl->m_args).Length()!=0)){
			return 0;
		}
		t_scope->p_AssertAccess();
		t_scope->p_Semant();
		return t_scope;
	}
	return 0;
}
void c_ScopeDecl::mark(){
	c_Decl::mark();
}
c_ConfigScope::c_ConfigScope(){
	m_cdecls=(new c_StringMap)->m_new();
	m_vars=(new c_StringMap2)->m_new();
}
c_ConfigScope* c_ConfigScope::m_new(){
	c_ScopeDecl::m_new();
	return this;
}
c_ValDecl* c_ConfigScope::p_FindValDecl(String t_ident){
	if(m_cdecls->p_Contains(t_ident)){
		return (m_cdecls->p_Get(t_ident));
	}
	return ((new c_ConstDecl)->m_new(t_ident,1048576,(c_Type::m_boolType),0));
}
void c_ConfigScope::mark(){
	c_ScopeDecl::mark();
}
String bb_config__errInfo;
c_ConfigScope* bb_config__cfgScope;
c_ValDecl::c_ValDecl(){
	m_type=0;
	m_init=0;
}
c_ValDecl* c_ValDecl::m_new(){
	c_Decl::m_new();
	return this;
}
String c_ValDecl::p_ToString(){
	String t_t=c_Decl::p_ToString();
	if((m_type)!=0){
		return t_t+String(L":",1)+m_type->p_ToString();
	}
	return t_t;
}
int c_ValDecl::p_OnSemant(){
	if((m_type)!=0){
		m_type=m_type->p_Semant();
		if((m_init)!=0){
			m_init=m_init->p_Semant2(m_type,0);
		}
	}else{
		if((m_init)!=0){
			m_init=m_init->p_Semant();
			m_type=m_init->m_exprType;
		}else{
			bb_config_InternalErr(String(L"Internal error",14));
		}
	}
	if((dynamic_cast<c_VoidType*>(m_type))!=0){
		bb_config_Err(String(L"Declaration has void type.",26));
	}
	return 0;
}
c_Expr* c_ValDecl::p_CopyInit(){
	if((m_init)!=0){
		return m_init->p_Copy();
	}
	return 0;
}
void c_ValDecl::mark(){
	c_Decl::mark();
}
c_ConstDecl::c_ConstDecl(){
	m_value=String();
}
c_ConstDecl* c_ConstDecl::m_new(String t_ident,int t_attrs,c_Type* t_type,c_Expr* t_init){
	c_ValDecl::m_new();
	this->m_ident=t_ident;
	this->m_munged=t_ident;
	this->m_attrs=t_attrs;
	this->m_type=t_type;
	this->m_init=t_init;
	return this;
}
c_ConstDecl* c_ConstDecl::m_new2(){
	c_ValDecl::m_new();
	return this;
}
c_Decl* c_ConstDecl::p_OnCopy(){
	return ((new c_ConstDecl)->m_new(m_ident,m_attrs,m_type,p_CopyInit()));
}
int c_ConstDecl::p_OnSemant(){
	c_ValDecl::p_OnSemant();
	if(!((p_IsExtern())!=0)){
		m_value=m_init->p_Eval();
	}
	return 0;
}
void c_ConstDecl::mark(){
	c_ValDecl::mark();
}
c_Map::c_Map(){
	m_root=0;
}
c_Map* c_Map::m_new(){
	return this;
}
c_Node* c_Map::p_FindNode(String t_key){
	c_Node* t_node=m_root;
	while((t_node)!=0){
		int t_cmp=p_Compare(t_key,t_node->m_key);
		if(t_cmp>0){
			t_node=t_node->m_right;
		}else{
			if(t_cmp<0){
				t_node=t_node->m_left;
			}else{
				return t_node;
			}
		}
	}
	return t_node;
}
c_ConstDecl* c_Map::p_Get(String t_key){
	c_Node* t_node=p_FindNode(t_key);
	if((t_node)!=0){
		return t_node->m_value;
	}
	return 0;
}
int c_Map::p_RotateLeft(c_Node* t_node){
	c_Node* t_child=t_node->m_right;
	t_node->m_right=t_child->m_left;
	if((t_child->m_left)!=0){
		t_child->m_left->m_parent=t_node;
	}
	t_child->m_parent=t_node->m_parent;
	if((t_node->m_parent)!=0){
		if(t_node==t_node->m_parent->m_left){
			t_node->m_parent->m_left=t_child;
		}else{
			t_node->m_parent->m_right=t_child;
		}
	}else{
		m_root=t_child;
	}
	t_child->m_left=t_node;
	t_node->m_parent=t_child;
	return 0;
}
int c_Map::p_RotateRight(c_Node* t_node){
	c_Node* t_child=t_node->m_left;
	t_node->m_left=t_child->m_right;
	if((t_child->m_right)!=0){
		t_child->m_right->m_parent=t_node;
	}
	t_child->m_parent=t_node->m_parent;
	if((t_node->m_parent)!=0){
		if(t_node==t_node->m_parent->m_right){
			t_node->m_parent->m_right=t_child;
		}else{
			t_node->m_parent->m_left=t_child;
		}
	}else{
		m_root=t_child;
	}
	t_child->m_right=t_node;
	t_node->m_parent=t_child;
	return 0;
}
int c_Map::p_InsertFixup(c_Node* t_node){
	while(((t_node->m_parent)!=0) && t_node->m_parent->m_color==-1 && ((t_node->m_parent->m_parent)!=0)){
		if(t_node->m_parent==t_node->m_parent->m_parent->m_left){
			c_Node* t_uncle=t_node->m_parent->m_parent->m_right;
			if(((t_uncle)!=0) && t_uncle->m_color==-1){
				t_node->m_parent->m_color=1;
				t_uncle->m_color=1;
				t_uncle->m_parent->m_color=-1;
				t_node=t_uncle->m_parent;
			}else{
				if(t_node==t_node->m_parent->m_right){
					t_node=t_node->m_parent;
					p_RotateLeft(t_node);
				}
				t_node->m_parent->m_color=1;
				t_node->m_parent->m_parent->m_color=-1;
				p_RotateRight(t_node->m_parent->m_parent);
			}
		}else{
			c_Node* t_uncle2=t_node->m_parent->m_parent->m_left;
			if(((t_uncle2)!=0) && t_uncle2->m_color==-1){
				t_node->m_parent->m_color=1;
				t_uncle2->m_color=1;
				t_uncle2->m_parent->m_color=-1;
				t_node=t_uncle2->m_parent;
			}else{
				if(t_node==t_node->m_parent->m_left){
					t_node=t_node->m_parent;
					p_RotateRight(t_node);
				}
				t_node->m_parent->m_color=1;
				t_node->m_parent->m_parent->m_color=-1;
				p_RotateLeft(t_node->m_parent->m_parent);
			}
		}
	}
	m_root->m_color=1;
	return 0;
}
bool c_Map::p_Set(String t_key,c_ConstDecl* t_value){
	c_Node* t_node=m_root;
	c_Node* t_parent=0;
	int t_cmp=0;
	while((t_node)!=0){
		t_parent=t_node;
		t_cmp=p_Compare(t_key,t_node->m_key);
		if(t_cmp>0){
			t_node=t_node->m_right;
		}else{
			if(t_cmp<0){
				t_node=t_node->m_left;
			}else{
				t_node->m_value=t_value;
				return false;
			}
		}
	}
	t_node=(new c_Node)->m_new(t_key,t_value,-1,t_parent);
	if((t_parent)!=0){
		if(t_cmp>0){
			t_parent->m_right=t_node;
		}else{
			t_parent->m_left=t_node;
		}
		p_InsertFixup(t_node);
	}else{
		m_root=t_node;
	}
	return true;
}
bool c_Map::p_Contains(String t_key){
	return p_FindNode(t_key)!=0;
}
void c_Map::mark(){
	Object::mark();
}
c_StringMap::c_StringMap(){
}
c_StringMap* c_StringMap::m_new(){
	c_Map::m_new();
	return this;
}
int c_StringMap::p_Compare(String t_lhs,String t_rhs){
	return t_lhs.Compare(t_rhs);
}
void c_StringMap::mark(){
	c_Map::mark();
}
c_Node::c_Node(){
	m_key=String();
	m_right=0;
	m_left=0;
	m_value=0;
	m_color=0;
	m_parent=0;
}
c_Node* c_Node::m_new(String t_key,c_ConstDecl* t_value,int t_color,c_Node* t_parent){
	this->m_key=t_key;
	this->m_value=t_value;
	this->m_color=t_color;
	this->m_parent=t_parent;
	return this;
}
c_Node* c_Node::m_new2(){
	return this;
}
void c_Node::mark(){
	Object::mark();
}
c_Expr::c_Expr(){
	m_exprType=0;
}
c_Expr* c_Expr::m_new(){
	return this;
}
c_Expr* c_Expr::p_Copy(){
	bb_config_InternalErr(String(L"Internal error",14));
	return 0;
}
c_Expr* c_Expr::p_Semant(){
	bb_config_InternalErr(String(L"Internal error",14));
	return 0;
}
Array<c_Expr* > c_Expr::p_SemantArgs(Array<c_Expr* > t_args){
	t_args=t_args.Slice(0);
	for(int t_i=0;t_i<t_args.Length();t_i=t_i+1){
		if((t_args[t_i])!=0){
			t_args[t_i]=t_args[t_i]->p_Semant();
		}
	}
	return t_args;
}
c_Expr* c_Expr::p_Cast(c_Type* t_ty,int t_castFlags){
	if((m_exprType->p_EqualsType(t_ty))!=0){
		return this;
	}
	return ((new c_CastExpr)->m_new(t_ty,this,t_castFlags))->p_Semant();
}
Array<c_Expr* > c_Expr::p_CastArgs(Array<c_Expr* > t_args,c_FuncDecl* t_funcDecl){
	if(t_args.Length()>t_funcDecl->m_argDecls.Length()){
		bb_config_InternalErr(String(L"Internal error",14));
	}
	t_args=t_args.Resize(t_funcDecl->m_argDecls.Length());
	for(int t_i=0;t_i<t_args.Length();t_i=t_i+1){
		if((t_args[t_i])!=0){
			t_args[t_i]=t_args[t_i]->p_Cast(t_funcDecl->m_argDecls[t_i]->m_type,0);
		}else{
			if((t_funcDecl->m_argDecls[t_i]->m_init)!=0){
				t_args[t_i]=t_funcDecl->m_argDecls[t_i]->m_init;
			}else{
				bb_config_Err(String(L"Missing function argument '",27)+t_funcDecl->m_argDecls[t_i]->m_ident+String(L"'.",2));
			}
		}
	}
	return t_args;
}
String c_Expr::p_ToString(){
	return String(L"<Expr>",6);
}
String c_Expr::p_Eval(){
	bb_config_Err(p_ToString()+String(L" cannot be statically evaluated.",32));
	return String();
}
c_Expr* c_Expr::p_EvalConst(){
	return ((new c_ConstExpr)->m_new(m_exprType,p_Eval()))->p_Semant();
}
c_Expr* c_Expr::p_Semant2(c_Type* t_ty,int t_castFlags){
	c_Expr* t_expr=p_Semant();
	if((t_expr->m_exprType->p_EqualsType(t_ty))!=0){
		return t_expr;
	}
	return ((new c_CastExpr)->m_new(t_ty,t_expr,t_castFlags))->p_Semant();
}
c_Expr* c_Expr::p_CopyExpr(c_Expr* t_expr){
	if(!((t_expr)!=0)){
		return 0;
	}
	return t_expr->p_Copy();
}
Array<c_Expr* > c_Expr::p_CopyArgs(Array<c_Expr* > t_exprs){
	t_exprs=t_exprs.Slice(0);
	for(int t_i=0;t_i<t_exprs.Length();t_i=t_i+1){
		t_exprs[t_i]=p_CopyExpr(t_exprs[t_i]);
	}
	return t_exprs;
}
c_Type* c_Expr::p_BalanceTypes(c_Type* t_lhs,c_Type* t_rhs){
	if(((dynamic_cast<c_StringType*>(t_lhs))!=0) || ((dynamic_cast<c_StringType*>(t_rhs))!=0)){
		return (c_Type::m_stringType);
	}
	if(((dynamic_cast<c_FloatType*>(t_lhs))!=0) || ((dynamic_cast<c_FloatType*>(t_rhs))!=0)){
		return (c_Type::m_floatType);
	}
	if(((dynamic_cast<c_IntType*>(t_lhs))!=0) || ((dynamic_cast<c_IntType*>(t_rhs))!=0)){
		return (c_Type::m_intType);
	}
	if((t_lhs->p_ExtendsType(t_rhs))!=0){
		return t_rhs;
	}
	if((t_rhs->p_ExtendsType(t_lhs))!=0){
		return t_lhs;
	}
	bb_config_Err(String(L"Can't balance types ",20)+t_lhs->p_ToString()+String(L" and ",5)+t_rhs->p_ToString()+String(L".",1));
	return 0;
}
c_Expr* c_Expr::p_SemantSet(String t_op,c_Expr* t_rhs){
	bb_config_Err(p_ToString()+String(L" cannot be assigned to.",23));
	return 0;
}
c_ScopeDecl* c_Expr::p_SemantScope(){
	return 0;
}
c_Expr* c_Expr::p_SemantFunc(Array<c_Expr* > t_args){
	bb_config_Err(p_ToString()+String(L" cannot be invoked.",19));
	return 0;
}
bool c_Expr::p_SideEffects(){
	return true;
}
String c_Expr::p_Trans(){
	bb_config_Err(String(L"TODO!",5));
	return String();
}
String c_Expr::p_TransStmt(){
	return p_Trans();
}
String c_Expr::p_TransVar(){
	bb_config_InternalErr(String(L"Internal error",14));
	return String();
}
void c_Expr::mark(){
	Object::mark();
}
c_BoolType::c_BoolType(){
}
c_BoolType* c_BoolType::m_new(){
	c_Type::m_new();
	return this;
}
int c_BoolType::p_EqualsType(c_Type* t_ty){
	return ((dynamic_cast<c_BoolType*>(t_ty)!=0)?1:0);
}
int c_BoolType::p_ExtendsType(c_Type* t_ty){
	if((dynamic_cast<c_ObjectType*>(t_ty))!=0){
		c_Expr* t_expr=((new c_ConstExpr)->m_new((this),String()))->p_Semant();
		c_Expr* t_[]={t_expr};
		c_FuncDecl* t_ctor=t_ty->p_GetClass()->p_FindFuncDecl(String(L"new",3),Array<c_Expr* >(t_,1),1);
		return ((((t_ctor)!=0) && t_ctor->p_IsCtor())?1:0);
	}
	return ((dynamic_cast<c_IntType*>(t_ty)!=0 || dynamic_cast<c_BoolType*>(t_ty)!=0)?1:0);
}
c_ClassDecl* c_BoolType::p_GetClass(){
	return dynamic_cast<c_ClassDecl*>(bb_decl__env->p_FindDecl(String(L"bool",4)));
}
String c_BoolType::p_ToString(){
	return String(L"Bool",4);
}
void c_BoolType::mark(){
	c_Type::mark();
}
c_Map2::c_Map2(){
	m_root=0;
}
c_Map2* c_Map2::m_new(){
	return this;
}
int c_Map2::p_RotateLeft2(c_Node2* t_node){
	c_Node2* t_child=t_node->m_right;
	t_node->m_right=t_child->m_left;
	if((t_child->m_left)!=0){
		t_child->m_left->m_parent=t_node;
	}
	t_child->m_parent=t_node->m_parent;
	if((t_node->m_parent)!=0){
		if(t_node==t_node->m_parent->m_left){
			t_node->m_parent->m_left=t_child;
		}else{
			t_node->m_parent->m_right=t_child;
		}
	}else{
		m_root=t_child;
	}
	t_child->m_left=t_node;
	t_node->m_parent=t_child;
	return 0;
}
int c_Map2::p_RotateRight2(c_Node2* t_node){
	c_Node2* t_child=t_node->m_left;
	t_node->m_left=t_child->m_right;
	if((t_child->m_right)!=0){
		t_child->m_right->m_parent=t_node;
	}
	t_child->m_parent=t_node->m_parent;
	if((t_node->m_parent)!=0){
		if(t_node==t_node->m_parent->m_right){
			t_node->m_parent->m_right=t_child;
		}else{
			t_node->m_parent->m_left=t_child;
		}
	}else{
		m_root=t_child;
	}
	t_child->m_right=t_node;
	t_node->m_parent=t_child;
	return 0;
}
int c_Map2::p_InsertFixup2(c_Node2* t_node){
	while(((t_node->m_parent)!=0) && t_node->m_parent->m_color==-1 && ((t_node->m_parent->m_parent)!=0)){
		if(t_node->m_parent==t_node->m_parent->m_parent->m_left){
			c_Node2* t_uncle=t_node->m_parent->m_parent->m_right;
			if(((t_uncle)!=0) && t_uncle->m_color==-1){
				t_node->m_parent->m_color=1;
				t_uncle->m_color=1;
				t_uncle->m_parent->m_color=-1;
				t_node=t_uncle->m_parent;
			}else{
				if(t_node==t_node->m_parent->m_right){
					t_node=t_node->m_parent;
					p_RotateLeft2(t_node);
				}
				t_node->m_parent->m_color=1;
				t_node->m_parent->m_parent->m_color=-1;
				p_RotateRight2(t_node->m_parent->m_parent);
			}
		}else{
			c_Node2* t_uncle2=t_node->m_parent->m_parent->m_left;
			if(((t_uncle2)!=0) && t_uncle2->m_color==-1){
				t_node->m_parent->m_color=1;
				t_uncle2->m_color=1;
				t_uncle2->m_parent->m_color=-1;
				t_node=t_uncle2->m_parent;
			}else{
				if(t_node==t_node->m_parent->m_left){
					t_node=t_node->m_parent;
					p_RotateRight2(t_node);
				}
				t_node->m_parent->m_color=1;
				t_node->m_parent->m_parent->m_color=-1;
				p_RotateLeft2(t_node->m_parent->m_parent);
			}
		}
	}
	m_root->m_color=1;
	return 0;
}
bool c_Map2::p_Set2(String t_key,String t_value){
	c_Node2* t_node=m_root;
	c_Node2* t_parent=0;
	int t_cmp=0;
	while((t_node)!=0){
		t_parent=t_node;
		t_cmp=p_Compare(t_key,t_node->m_key);
		if(t_cmp>0){
			t_node=t_node->m_right;
		}else{
			if(t_cmp<0){
				t_node=t_node->m_left;
			}else{
				t_node->m_value=t_value;
				return false;
			}
		}
	}
	t_node=(new c_Node2)->m_new(t_key,t_value,-1,t_parent);
	if((t_parent)!=0){
		if(t_cmp>0){
			t_parent->m_right=t_node;
		}else{
			t_parent->m_left=t_node;
		}
		p_InsertFixup2(t_node);
	}else{
		m_root=t_node;
	}
	return true;
}
c_Node2* c_Map2::p_FindNode(String t_key){
	c_Node2* t_node=m_root;
	while((t_node)!=0){
		int t_cmp=p_Compare(t_key,t_node->m_key);
		if(t_cmp>0){
			t_node=t_node->m_right;
		}else{
			if(t_cmp<0){
				t_node=t_node->m_left;
			}else{
				return t_node;
			}
		}
	}
	return t_node;
}
String c_Map2::p_Get(String t_key){
	c_Node2* t_node=p_FindNode(t_key);
	if((t_node)!=0){
		return t_node->m_value;
	}
	return String();
}
bool c_Map2::p_Contains(String t_key){
	return p_FindNode(t_key)!=0;
}
c_Node2* c_Map2::p_FirstNode(){
	if(!((m_root)!=0)){
		return 0;
	}
	c_Node2* t_node=m_root;
	while((t_node->m_left)!=0){
		t_node=t_node->m_left;
	}
	return t_node;
}
c_NodeEnumerator3* c_Map2::p_ObjectEnumerator(){
	return (new c_NodeEnumerator3)->m_new(p_FirstNode());
}
void c_Map2::mark(){
	Object::mark();
}
c_StringMap2::c_StringMap2(){
}
c_StringMap2* c_StringMap2::m_new(){
	c_Map2::m_new();
	return this;
}
int c_StringMap2::p_Compare(String t_lhs,String t_rhs){
	return t_lhs.Compare(t_rhs);
}
void c_StringMap2::mark(){
	c_Map2::mark();
}
c_Node2::c_Node2(){
	m_key=String();
	m_right=0;
	m_left=0;
	m_value=String();
	m_color=0;
	m_parent=0;
}
c_Node2* c_Node2::m_new(String t_key,String t_value,int t_color,c_Node2* t_parent){
	this->m_key=t_key;
	this->m_value=t_value;
	this->m_color=t_color;
	this->m_parent=t_parent;
	return this;
}
c_Node2* c_Node2::m_new2(){
	return this;
}
c_Node2* c_Node2::p_NextNode(){
	c_Node2* t_node=0;
	if((m_right)!=0){
		t_node=m_right;
		while((t_node->m_left)!=0){
			t_node=t_node->m_left;
		}
		return t_node;
	}
	t_node=this;
	c_Node2* t_parent=this->m_parent;
	while(((t_parent)!=0) && t_node==t_parent->m_right){
		t_node=t_parent;
		t_parent=t_parent->m_parent;
	}
	return t_parent;
}
String c_Node2::p_Key(){
	return m_key;
}
String c_Node2::p_Value(){
	return m_value;
}
void c_Node2::mark(){
	Object::mark();
}
int bb_config_SetConfigVar(String t_key,String t_val,c_Type* t_type){
	c_ConstDecl* t_decl=bb_config__cfgScope->m_cdecls->p_Get(t_key);
	if((t_decl)!=0){
		t_decl->m_type=t_type;
	}else{
		t_decl=(new c_ConstDecl)->m_new(t_key,1048576,t_type,0);
		bb_config__cfgScope->m_cdecls->p_Set(t_key,t_decl);
	}
	t_decl->m_value=t_val;
	if((dynamic_cast<c_BoolType*>(t_type))!=0){
		if((t_val).Length()!=0){
			t_val=String(L"1",1);
		}else{
			t_val=String(L"0",1);
		}
	}
	bb_config__cfgScope->m_vars->p_Set2(t_key,t_val);
	return 0;
}
int bb_config_SetConfigVar2(String t_key,String t_val){
	bb_config_SetConfigVar(t_key,t_val,(c_Type::m_stringType));
	return 0;
}
c_Stack::c_Stack(){
	m_data=Array<String >();
	m_length=0;
}
c_Stack* c_Stack::m_new(){
	return this;
}
c_Stack* c_Stack::m_new2(Array<String > t_data){
	this->m_data=t_data.Slice(0);
	this->m_length=t_data.Length();
	return this;
}
void c_Stack::p_Push(String t_value){
	if(m_length==m_data.Length()){
		m_data=m_data.Resize(m_length*2+10);
	}
	m_data[m_length]=t_value;
	m_length+=1;
}
void c_Stack::p_Push2(Array<String > t_values,int t_offset,int t_count){
	for(int t_i=0;t_i<t_count;t_i=t_i+1){
		p_Push(t_values[t_offset+t_i]);
	}
}
void c_Stack::p_Push3(Array<String > t_values,int t_offset){
	p_Push2(t_values,t_offset,t_values.Length()-t_offset);
}
bool c_Stack::p_IsEmpty(){
	return m_length==0;
}
Array<String > c_Stack::p_ToArray(){
	Array<String > t_t=Array<String >(m_length);
	for(int t_i=0;t_i<m_length;t_i=t_i+1){
		t_t[t_i]=m_data[t_i];
	}
	return t_t;
}
String c_Stack::m_NIL;
void c_Stack::p_Length(int t_newlength){
	if(t_newlength<m_length){
		for(int t_i=t_newlength;t_i<m_length;t_i=t_i+1){
			m_data[t_i]=m_NIL;
		}
	}else{
		if(t_newlength>m_data.Length()){
			m_data=m_data.Resize(bb_math_Max(m_length*2+10,t_newlength));
		}
	}
	m_length=t_newlength;
}
int c_Stack::p_Length2(){
	return m_length;
}
String c_Stack::p_Get2(int t_index){
	return m_data[t_index];
}
String c_Stack::p_Pop(){
	m_length-=1;
	String t_v=m_data[m_length];
	m_data[m_length]=m_NIL;
	return t_v;
}
void c_Stack::p_Clear(){
	for(int t_i=0;t_i<m_length;t_i=t_i+1){
		m_data[t_i]=m_NIL;
	}
	m_length=0;
}
void c_Stack::mark(){
	Object::mark();
}
c_StringStack::c_StringStack(){
}
c_StringStack* c_StringStack::m_new(Array<String > t_data){
	c_Stack::m_new2(t_data);
	return this;
}
c_StringStack* c_StringStack::m_new2(){
	c_Stack::m_new();
	return this;
}
String c_StringStack::p_Join(String t_separator){
	return t_separator.Join(p_ToArray());
}
void c_StringStack::mark(){
	c_Stack::mark();
}
String bb_config_GetConfigVar(String t_key){
	return bb_config__cfgScope->m_vars->p_Get(t_key);
}
String bb_transcc_ReplaceEnv(String t_str){
	c_StringStack* t_bits=(new c_StringStack)->m_new2();
	do{
		int t_i=t_str.Find(String(L"${",2),0);
		if(t_i==-1){
			break;
		}
		int t_e=t_str.Find(String(L"}",1),t_i+2);
		if(t_e==-1){
			break;
		}
		if(t_i>=2 && t_str.Slice(t_i-2,t_i)==String(L"//",2)){
			t_bits->p_Push(t_str.Slice(0,t_e+1));
			t_str=t_str.Slice(t_e+1);
			continue;
		}
		String t_t=t_str.Slice(t_i+2,t_e);
		String t_v=bb_config_GetConfigVar(t_t);
		if(!((t_v).Length()!=0)){
			t_v=GetEnv(t_t);
		}
		t_bits->p_Push(t_str.Slice(0,t_i));
		t_bits->p_Push(t_v);
		t_str=t_str.Slice(t_e+1);
	}while(!(false));
	if(t_bits->p_IsEmpty()){
		return t_str;
	}
	t_bits->p_Push(t_str);
	return t_bits->p_Join(String());
}
c_Builder::c_Builder(){
	m_tcc=0;
	m_casedConfig=String();
	m_app=0;
	m_transCode=String();
	m_TEXT_FILES=String();
	m_IMAGE_FILES=String();
	m_SOUND_FILES=String();
	m_MUSIC_FILES=String();
	m_BINARY_FILES=String();
	m_DATA_FILES=String();
	m_syncData=false;
	m_dataFiles=(new c_StringMap2)->m_new();
}
c_Builder* c_Builder::m_new(c_TransCC* t_tcc){
	this->m_tcc=t_tcc;
	return this;
}
c_Builder* c_Builder::m_new2(){
	return this;
}
void c_Builder::p_Make(){
	String t_1=m_tcc->m_opt_config;
	if(t_1==String() || t_1==String(L"debug",5)){
		m_tcc->m_opt_config=String(L"debug",5);
		m_casedConfig=String(L"Debug",5);
	}else{
		if(t_1==String(L"release",7)){
			m_casedConfig=String(L"Release",7);
		}else{
			bb_transcc_Die(String(L"Invalid config",14));
		}
	}
	if(FileType(m_tcc->m_opt_srcpath)!=1){
		bb_transcc_Die(String(L"Invalid source file",19));
	}
	m_tcc->m_opt_srcpath=RealPath(m_tcc->m_opt_srcpath);
	if(!((m_tcc->m_opt_modpath).Length()!=0)){
		m_tcc->m_opt_modpath=m_tcc->m_cerberusdir+String(L"/modules",8);
	}
	m_tcc->m_opt_modpath=String(L".;",2)+bb_os_ExtractDir(m_tcc->m_opt_srcpath)+String(L";",1)+m_tcc->m_opt_modpath+String(L";",1)+m_tcc->m_cerberusdir+String(L"/targets/",9)+m_tcc->m_target->m_dir+String(L"/modules",8);
	if(!m_tcc->m_opt_check){
		m_tcc->m_opt_check=true;
		m_tcc->m_opt_update=true;
		m_tcc->m_opt_build=true;
	}
	bb_config_ENV_HOST=HostOS();
	bb_config_ENV_CONFIG=m_tcc->m_opt_config;
	bb_config_ENV_SAFEMODE=((m_tcc->m_opt_safe)?1:0);
	bb_config_ENV_MODPATH=m_tcc->m_opt_modpath;
	bb_config_ENV_TARGET=m_tcc->m_target->m_system;
	this->p_Begin();
	if(!m_tcc->m_opt_check){
		return;
	}
	bbPrint(String(L"Parsing...",10));
	bb_config_SetConfigVar2(String(L"HOST",4),bb_config_ENV_HOST);
	bb_config_SetConfigVar2(String(L"LANG",4),bb_config_ENV_LANG);
	bb_config_SetConfigVar2(String(L"TARGET",6),bb_config_ENV_TARGET);
	bb_config_SetConfigVar2(String(L"CONFIG",6),bb_config_ENV_CONFIG);
	bb_config_SetConfigVar2(String(L"SAFEMODE",8),String(bb_config_ENV_SAFEMODE));
	m_app=bb_parser_ParseApp(m_tcc->m_opt_srcpath);
	bbPrint(String(L"Semanting...",12));
	if((bb_config_GetConfigVar(String(L"REFLECTION_FILTER",17))).Length()!=0){
		c_Reflector* t_r=(new c_Reflector)->m_new();
		t_r->p_Semant3(m_app);
	}else{
		m_app->p_Semant();
	}
	bbPrint(String(L"Translating...",14));
	c_StringStack* t_transbuf=(new c_StringStack)->m_new2();
	c_Enumerator* t_=m_app->m_fileImports->p_ObjectEnumerator();
	while(t_->p_HasNext()){
		String t_file=t_->p_NextObject();
		if(bb_os_ExtractExt(t_file).ToLower()==bb_config_ENV_LANG){
			t_transbuf->p_Push(LoadString(t_file));
			t_transbuf->p_Push(String(L"\n",1));
		}
		if(bb_config_ENV_LANG==String(L"cpp",3) && (bb_os_ExtractExt(t_file).ToLower()==String(L"h",1) || bb_os_ExtractExt(t_file).ToLower()==String(L"c",1))){
			t_transbuf->p_Push(LoadString(t_file));
			t_transbuf->p_Push(String(L"\n",1));
		}
	}
	t_transbuf->p_Push(bb_translator__trans->p_TransApp(m_app));
	if(!m_tcc->m_opt_update){
		return;
	}
	bbPrint(String(L"Building...",11));
	m_transCode=t_transbuf->p_Join(String());
	String t_buildPath=String();
	if((m_tcc->m_opt_builddir).Length()!=0){
		t_buildPath=bb_os_ExtractDir(m_tcc->m_opt_srcpath)+String(L"/",1)+m_tcc->m_opt_builddir;
	}else{
		t_buildPath=bb_os_StripExt(m_tcc->m_opt_srcpath)+String(L".build",6)+m_tcc->p_GetReleaseVersion();
	}
	String t_targetPath=t_buildPath+String(L"/",1)+m_tcc->m_target->m_dir;
	if(m_tcc->m_opt_clean){
		bb_os_DeleteDir(t_targetPath,true);
		if(FileType(t_targetPath)!=0){
			bb_transcc_Die(String(L"Failed to clean target dir",26));
		}
	}
	if(FileType(t_targetPath)==0){
		if(FileType(t_buildPath)==0){
			CreateDir(t_buildPath);
		}
		if(FileType(t_buildPath)!=2){
			bb_transcc_Die(String(L"Failed to create build dir: ",28)+t_buildPath);
		}
		if(!((bb_os_CopyDir(m_tcc->m_cerberusdir+String(L"/targets/",9)+m_tcc->m_target->m_dir+String(L"/template",9),t_targetPath,true,false))!=0)){
			bb_transcc_Die(String(L"Failed to copy target dir",25));
		}
	}
	if(FileType(t_targetPath)!=2){
		bb_transcc_Die(String(L"Failed to create target dir: ",29)+t_targetPath);
	}
	String t_cfgPath=t_targetPath+String(L"/config.cxs",11);
	if(FileType(t_cfgPath)==1){
		bb_preprocessor_PreProcess(t_cfgPath,0);
	}
	m_TEXT_FILES=bb_config_GetConfigVar(String(L"TEXT_FILES",10));
	m_IMAGE_FILES=bb_config_GetConfigVar(String(L"IMAGE_FILES",11));
	m_SOUND_FILES=bb_config_GetConfigVar(String(L"SOUND_FILES",11));
	m_MUSIC_FILES=bb_config_GetConfigVar(String(L"MUSIC_FILES",11));
	m_BINARY_FILES=bb_config_GetConfigVar(String(L"BINARY_FILES",12));
	m_DATA_FILES=m_TEXT_FILES;
	if((m_IMAGE_FILES).Length()!=0){
		m_DATA_FILES=m_DATA_FILES+(String(L"|",1)+m_IMAGE_FILES);
	}
	if((m_SOUND_FILES).Length()!=0){
		m_DATA_FILES=m_DATA_FILES+(String(L"|",1)+m_SOUND_FILES);
	}
	if((m_MUSIC_FILES).Length()!=0){
		m_DATA_FILES=m_DATA_FILES+(String(L"|",1)+m_MUSIC_FILES);
	}
	if((m_BINARY_FILES).Length()!=0){
		m_DATA_FILES=m_DATA_FILES+(String(L"|",1)+m_BINARY_FILES);
	}
	m_DATA_FILES=m_DATA_FILES.Replace(String(L";",1),String(L"|",1));
	m_syncData=bb_config_GetConfigVar(String(L"FAST_SYNC_PROJECT_DATA",22))==String(L"1",1);
	String t_cd=CurrentDir();
	ChangeDir(t_targetPath);
	this->p_MakeTarget();
	ChangeDir(t_cd);
}
void c_Builder::p_CCopyFile(String t_src,String t_dst){
	if(FileTime(t_src)>FileTime(t_dst) || FileSize(t_src)!=FileSize(t_dst)){
		DeleteFile(t_dst);
		CopyFile(t_src,t_dst);
	}
}
void c_Builder::p_CreateDataDir(String t_dir){
	t_dir=RealPath(t_dir);
	if(!m_syncData){
		bb_os_DeleteDir(t_dir,true);
	}
	CreateDir(t_dir);
	if(FileType(t_dir)!=2){
		bb_transcc_Die(String(L"Failed to create target project data dir: ",42)+t_dir);
	}
	String t_dataPath=bb_os_StripExt(m_tcc->m_opt_srcpath)+String(L".data",5);
	if(FileType(t_dataPath)!=2){
		t_dataPath=String();
	}
	c_StringSet* t_udata=(new c_StringSet)->m_new();
	if((t_dataPath).Length()!=0){
		c_StringStack* t_srcs=(new c_StringStack)->m_new2();
		t_srcs->p_Push(t_dataPath);
		while(!t_srcs->p_IsEmpty()){
			String t_src=t_srcs->p_Pop();
			Array<String > t_=LoadDir(t_src);
			int t_2=0;
			while(t_2<t_.Length()){
				String t_f=t_[t_2];
				t_2=t_2+1;
				if(t_f.StartsWith(String(L".",1))){
					continue;
				}
				String t_p=t_src+String(L"/",1)+t_f;
				String t_r=t_p.Slice(t_dataPath.Length()+1);
				String t_t=t_dir+String(L"/",1)+t_r;
				int t_22=FileType(t_p);
				if(t_22==1){
					if(bb_transcc_MatchPath(t_r.ToLower(),m_DATA_FILES.ToLower())){
						p_CCopyFile(t_p,t_t);
						t_udata->p_Insert(t_t);
						m_dataFiles->p_Set2(t_p,t_r);
					}
				}else{
					if(t_22==2){
						CreateDir(t_t);
						t_srcs->p_Push(t_p);
					}
				}
			}
		}
	}
	c_Enumerator* t_3=m_app->m_fileImports->p_ObjectEnumerator();
	while(t_3->p_HasNext()){
		String t_p2=t_3->p_NextObject();
		String t_r2=bb_os_StripDir(t_p2);
		String t_t2=t_dir+String(L"/",1)+t_r2;
		if(bb_transcc_MatchPath(t_r2.ToLower(),m_DATA_FILES.ToLower())){
			p_CCopyFile(t_p2,t_t2);
			t_udata->p_Insert(t_t2);
			m_dataFiles->p_Set2(t_p2,t_r2);
		}
	}
	if((t_dataPath).Length()!=0){
		c_StringStack* t_dsts=(new c_StringStack)->m_new2();
		t_dsts->p_Push(t_dir);
		while(!t_dsts->p_IsEmpty()){
			String t_dst=t_dsts->p_Pop();
			Array<String > t_4=LoadDir(t_dst);
			int t_5=0;
			while(t_5<t_4.Length()){
				String t_f2=t_4[t_5];
				t_5=t_5+1;
				if(t_f2.StartsWith(String(L".",1))){
					continue;
				}
				String t_p3=t_dst+String(L"/",1)+t_f2;
				String t_r3=t_p3.Slice(t_dir.Length()+1);
				String t_t3=t_dataPath+String(L"/",1)+t_r3;
				int t_32=FileType(t_p3);
				if(t_32==1){
					if(!t_udata->p_Contains(t_p3)){
						DeleteFile(t_p3);
					}
				}else{
					if(t_32==2){
						if(FileType(t_t3)==2){
							t_dsts->p_Push(t_p3);
						}else{
							bb_os_DeleteDir(t_p3,true);
						}
					}
				}
			}
		}
	}
}
void c_Builder::p_MakeIcons(String t_srcFilename,Array<String > t_icons,int t_round){
	String t_iconPath=bb_os_ExtractDir(bb_os_StripExt(m_tcc->m_opt_srcpath));
	String t_iconFile=RealPath(t_iconPath+String(L"\\",1)+t_srcFilename);
	if(((!((FileType(t_iconFile))!=0))?1:0)==1){
		t_iconFile=RealPath(t_srcFilename);
	}
	if(FileType(t_iconFile)==1){
		for(int t_i=0;t_i<t_icons.Length();t_i=t_i+3){
			_CreateIcon(t_iconFile,CurrentDir()+String(L"/",1)+t_icons[t_i],(t_icons[t_i+1]).ToInt(),(t_icons[t_i+2]).ToInt(),t_round);
		}
	}
}
bool c_Builder::p_Execute(String t_cmd,bool t_failHard){
	return m_tcc->p_Execute(t_cmd,t_failHard);
}
void c_Builder::p_CopySourceFiles(String t_dir){
	t_dir=RealPath(t_dir);
	c_Enumerator* t_=m_app->m_fileIncludes->p_ObjectEnumerator();
	while(t_->p_HasNext()){
		String t_p=t_->p_NextObject();
		String t_r=bb_os_StripDir(t_p);
		String t_t=t_dir+String(L"/",1)+t_r;
		p_CCopyFile(t_p,t_t);
	}
	c_Enumerator* t_2=m_app->m_dirIncludes->p_ObjectEnumerator();
	while(t_2->p_HasNext()){
		String t_p2=t_2->p_NextObject();
		bb_os_CopyDir(t_p2,t_dir,true,true);
	}
}
void c_Builder::p_CopyIcon(String t_iFile,String t_targetIcon){
	if(HostOS()==String(L"winnt",5)){
		String t_iconPath=bb_os_ExtractDir(bb_os_StripExt(m_tcc->m_opt_srcpath));
		String t_iconFile=RealPath(t_iconPath+String(L"\\",1)+t_iFile);
		if(FileType(t_iconFile)==1){
			if(bb_os_ExtractExt(t_iconFile).ToLower()==String(L"ico",3)){
				CopyFile(t_iconFile,t_targetIcon);
			}else{
				_ConvertToIco(t_iconFile,t_targetIcon);
			}
		}else{
			t_iconFile=t_iFile;
			if(FileType(t_iconFile)==1){
				if(bb_os_ExtractExt(t_iconFile).ToLower()==String(L"ico",3)){
					CopyFile(t_iconFile,t_targetIcon);
				}else{
					_ConvertToIco(t_iconFile,t_targetIcon);
				}
			}
		}
	}
}
void c_Builder::mark(){
	Object::mark();
}
c_Map3::c_Map3(){
	m_root=0;
}
c_Map3* c_Map3::m_new(){
	return this;
}
int c_Map3::p_RotateLeft3(c_Node3* t_node){
	c_Node3* t_child=t_node->m_right;
	t_node->m_right=t_child->m_left;
	if((t_child->m_left)!=0){
		t_child->m_left->m_parent=t_node;
	}
	t_child->m_parent=t_node->m_parent;
	if((t_node->m_parent)!=0){
		if(t_node==t_node->m_parent->m_left){
			t_node->m_parent->m_left=t_child;
		}else{
			t_node->m_parent->m_right=t_child;
		}
	}else{
		m_root=t_child;
	}
	t_child->m_left=t_node;
	t_node->m_parent=t_child;
	return 0;
}
int c_Map3::p_RotateRight3(c_Node3* t_node){
	c_Node3* t_child=t_node->m_left;
	t_node->m_left=t_child->m_right;
	if((t_child->m_right)!=0){
		t_child->m_right->m_parent=t_node;
	}
	t_child->m_parent=t_node->m_parent;
	if((t_node->m_parent)!=0){
		if(t_node==t_node->m_parent->m_right){
			t_node->m_parent->m_right=t_child;
		}else{
			t_node->m_parent->m_left=t_child;
		}
	}else{
		m_root=t_child;
	}
	t_child->m_right=t_node;
	t_node->m_parent=t_child;
	return 0;
}
int c_Map3::p_InsertFixup3(c_Node3* t_node){
	while(((t_node->m_parent)!=0) && t_node->m_parent->m_color==-1 && ((t_node->m_parent->m_parent)!=0)){
		if(t_node->m_parent==t_node->m_parent->m_parent->m_left){
			c_Node3* t_uncle=t_node->m_parent->m_parent->m_right;
			if(((t_uncle)!=0) && t_uncle->m_color==-1){
				t_node->m_parent->m_color=1;
				t_uncle->m_color=1;
				t_uncle->m_parent->m_color=-1;
				t_node=t_uncle->m_parent;
			}else{
				if(t_node==t_node->m_parent->m_right){
					t_node=t_node->m_parent;
					p_RotateLeft3(t_node);
				}
				t_node->m_parent->m_color=1;
				t_node->m_parent->m_parent->m_color=-1;
				p_RotateRight3(t_node->m_parent->m_parent);
			}
		}else{
			c_Node3* t_uncle2=t_node->m_parent->m_parent->m_left;
			if(((t_uncle2)!=0) && t_uncle2->m_color==-1){
				t_node->m_parent->m_color=1;
				t_uncle2->m_color=1;
				t_uncle2->m_parent->m_color=-1;
				t_node=t_uncle2->m_parent;
			}else{
				if(t_node==t_node->m_parent->m_left){
					t_node=t_node->m_parent;
					p_RotateRight3(t_node);
				}
				t_node->m_parent->m_color=1;
				t_node->m_parent->m_parent->m_color=-1;
				p_RotateLeft3(t_node->m_parent->m_parent);
			}
		}
	}
	m_root->m_color=1;
	return 0;
}
bool c_Map3::p_Set3(String t_key,c_Builder* t_value){
	c_Node3* t_node=m_root;
	c_Node3* t_parent=0;
	int t_cmp=0;
	while((t_node)!=0){
		t_parent=t_node;
		t_cmp=p_Compare(t_key,t_node->m_key);
		if(t_cmp>0){
			t_node=t_node->m_right;
		}else{
			if(t_cmp<0){
				t_node=t_node->m_left;
			}else{
				t_node->m_value=t_value;
				return false;
			}
		}
	}
	t_node=(new c_Node3)->m_new(t_key,t_value,-1,t_parent);
	if((t_parent)!=0){
		if(t_cmp>0){
			t_parent->m_right=t_node;
		}else{
			t_parent->m_left=t_node;
		}
		p_InsertFixup3(t_node);
	}else{
		m_root=t_node;
	}
	return true;
}
c_Node3* c_Map3::p_FirstNode(){
	if(!((m_root)!=0)){
		return 0;
	}
	c_Node3* t_node=m_root;
	while((t_node->m_left)!=0){
		t_node=t_node->m_left;
	}
	return t_node;
}
c_NodeEnumerator* c_Map3::p_ObjectEnumerator(){
	return (new c_NodeEnumerator)->m_new(p_FirstNode());
}
c_Node3* c_Map3::p_FindNode(String t_key){
	c_Node3* t_node=m_root;
	while((t_node)!=0){
		int t_cmp=p_Compare(t_key,t_node->m_key);
		if(t_cmp>0){
			t_node=t_node->m_right;
		}else{
			if(t_cmp<0){
				t_node=t_node->m_left;
			}else{
				return t_node;
			}
		}
	}
	return t_node;
}
c_Builder* c_Map3::p_Get(String t_key){
	c_Node3* t_node=p_FindNode(t_key);
	if((t_node)!=0){
		return t_node->m_value;
	}
	return 0;
}
void c_Map3::mark(){
	Object::mark();
}
c_StringMap3::c_StringMap3(){
}
c_StringMap3* c_StringMap3::m_new(){
	c_Map3::m_new();
	return this;
}
int c_StringMap3::p_Compare(String t_lhs,String t_rhs){
	return t_lhs.Compare(t_rhs);
}
void c_StringMap3::mark(){
	c_Map3::mark();
}
c_AndroidBuilder::c_AndroidBuilder(){
}
c_AndroidBuilder* c_AndroidBuilder::m_new(c_TransCC* t_tcc){
	c_Builder::m_new(t_tcc);
	return this;
}
c_AndroidBuilder* c_AndroidBuilder::m_new2(){
	c_Builder::m_new2();
	return this;
}
bool c_AndroidBuilder::p_IsValid(){
	return m_tcc->m_ANDROID_PATH!=String();
}
void c_AndroidBuilder::p_Begin(){
	bb_config_ENV_LANG=String(L"java",4);
	bb_translator__trans=((new c_JavaTranslator)->m_new());
}
bool c_AndroidBuilder::p_CreateDirRecursive(String t_path){
	int t_i=0;
	do{
		t_i=t_path.Find(String(L"/",1),t_i);
		if(t_i==-1){
			CreateDir(t_path);
			return FileType(t_path)==2;
		}
		String t_t=t_path.Slice(0,t_i);
		CreateDir(t_t);
		if(FileType(t_t)!=2){
			return false;
		}
		t_i+=1;
	}while(!(false));
}
String c_AndroidBuilder::p_Config(){
	c_StringStack* t_config=(new c_StringStack)->m_new2();
	c_NodeEnumerator3* t_=bb_config_GetConfigVars()->p_ObjectEnumerator();
	while(t_->p_HasNext()){
		c_Node2* t_kv=t_->p_NextObject();
		t_config->p_Push(String(L"static final String ",20)+t_kv->p_Key()+String(L"=",1)+bb_config_Enquote(t_kv->p_Value(),String(L"java",4))+String(L";",1));
	}
	return t_config->p_Join(String(L"\n",1));
}
void c_AndroidBuilder::p_MakeTarget(){
	p_CreateDirRecursive(String(L"app/src/main/assets",19));
	p_CreateDataDir(String(L"app/src/main/assets/cerberus",28));
	String t_app_label=bb_config_GetConfigVar(String(L"ANDROID_APP_LABEL",17));
	String t_app_package=bb_config_GetConfigVar(String(L"ANDROID_APP_PACKAGE",19));
	SetEnv(String(L"ANDROID_SDK_DIR",15),m_tcc->m_ANDROID_PATH.Replace(String(L"\\",1),String(L"\\\\",2)));
	SetEnv(String(L"ANDROID_NDK_DIR",15),m_tcc->m_ANDROID_NDK_PATH.Replace(String(L"\\",1),String(L"\\\\",2)));
	bb_config_SetConfigVar2(String(L"ANDROID_MANIFEST_MAIN",21),bb_config_GetConfigVar(String(L"ANDROID_MANIFEST_MAIN",21)).Replace(String(L";",1),String(L"\n",1))+String(L"\n",1));
	bb_config_SetConfigVar2(String(L"ANDROID_MANIFEST_APPLICATION",28),bb_config_GetConfigVar(String(L"ANDROID_MANIFEST_APPLICATION",28)).Replace(String(L";",1),String(L"\n",1))+String(L"\n",1));
	bb_config_SetConfigVar2(String(L"ANDROID_MANIFEST_ACTIVITY",25),bb_config_GetConfigVar(String(L"ANDROID_MANIFEST_ACTIVITY",25)).Replace(String(L";",1),String(L"\n",1))+String(L"\n",1));
	String t_jpath=String(L"app/src/main/java",17);
	bb_os_DeleteDir(t_jpath,true);
	CreateDir(t_jpath);
	Array<String > t_=t_app_package.Split(String(L".",1));
	int t_2=0;
	while(t_2<t_.Length()){
		String t_t=t_[t_2];
		t_2=t_2+1;
		t_jpath=t_jpath+(String(L"/",1)+t_t);
		CreateDir(t_jpath);
	}
	t_jpath=t_jpath+String(L"/CerberusGame.java",18);
	Array<String > t_3=bb_os_LoadDir(String(L"gradletemplate",14),true,false);
	int t_4=0;
	while(t_4<t_3.Length()){
		String t_file=t_3[t_4];
		t_4=t_4+1;
		int t_i=0;
		do{
			t_i=t_file.Find(String(L"/",1),t_i);
			if(t_i==-1){
				break;
			}
			CreateDir(t_file.Slice(0,t_i));
			if(FileType(t_file.Slice(0,t_i))!=2){
				t_file=String();
				break;
			}
			t_i+=1;
		}while(!(false));
		if(!((t_file).Length()!=0)){
			continue;
		}
		String t_1=bb_os_ExtractExt(t_file).ToLower();
		if(t_1==String(L"xml",3) || t_1==String(L"properties",10) || t_1==String(L"java",4) || t_1==String(L"gradle",6)){
			String t_str=LoadString(String(L"gradletemplate/",15)+t_file);
			t_str=bb_transcc_ReplaceEnv(t_str);
			SaveString(t_str,t_file);
		}else{
			CopyFile(String(L"gradletemplate/",15)+t_file,t_file);
		}
	}
	String t_main=LoadString(String(L"CerberusGame.java",17));
	t_main=bb_transcc_ReplaceBlock(t_main,String(L"TRANSCODE",9),m_transCode,String(L"\n//",3));
	t_main=bb_transcc_ReplaceBlock(t_main,String(L"CONFIG",6),p_Config(),String(L"\n//",3));
	c_StringStack* t_imps=(new c_StringStack)->m_new2();
	c_StringSet* t_done=(new c_StringSet)->m_new();
	c_StringStack* t_out=(new c_StringStack)->m_new2();
	Array<String > t_5=t_main.Split(String(L"\n",1));
	int t_6=0;
	while(t_6<t_5.Length()){
		String t_line=t_5[t_6];
		t_6=t_6+1;
		if(t_line.StartsWith(String(L"import ",7))){
			int t_i2=t_line.Find(String(L";",1),7);
			if(t_i2!=-1){
				String t_id=t_line.Slice(7,t_i2+1);
				if(!t_done->p_Contains(t_id)){
					t_done->p_Insert(t_id);
					t_imps->p_Push(String(L"import ",7)+t_id);
				}
			}
		}else{
			t_out->p_Push(t_line);
		}
	}
	t_main=t_out->p_Join(String(L"\n",1));
	t_main=bb_transcc_ReplaceBlock(t_main,String(L"IMPORTS",7),t_imps->p_Join(String(L"\n",1)),String(L"\n//",3));
	t_main=bb_transcc_ReplaceBlock(t_main,String(L"PACKAGE",7),String(L"package ",8)+t_app_package+String(L";",1),String(L"\n//",3));
	SaveString(t_main,t_jpath);
	Array<String > t_7=bb_config_GetConfigVar(String(L"LIBS",4)).Split(String(L";",1));
	int t_8=0;
	while(t_8<t_7.Length()){
		String t_lib=t_7[t_8];
		t_8=t_8+1;
		String t_22=bb_os_ExtractExt(t_lib);
		if(t_22==String(L"jar",3) || t_22==String(L"so",2)){
			String t_tdir=String();
			if(t_lib.Contains(String(L"/",1))){
				t_tdir=bb_os_ExtractDir(t_lib);
				if(t_tdir.Contains(String(L"/",1))){
					t_tdir=bb_os_StripDir(t_tdir);
				}
				String t_32=t_tdir;
				if(t_32==String(L"x86",3) || t_32==String(L"mips",4) || t_32==String(L"armeabi",7) || t_32==String(L"armeabi-v7a",11)){
					CreateDir(String(L"libs/",5)+t_tdir);
					t_tdir=t_tdir+String(L"/",1);
				}else{
					t_tdir=String();
				}
			}
			CopyFile(t_lib,String(L"libs/",5)+t_tdir+bb_os_StripDir(t_lib));
		}
	}
	Array<String > t_9=bb_config_GetConfigVar(String(L"SRCS",4)).Split(String(L";",1));
	int t_10=0;
	while(t_10<t_9.Length()){
		String t_src=t_9[t_10];
		t_10=t_10+1;
		String t_42=bb_os_ExtractExt(t_src);
		if(t_42==String(L"java",4) || t_42==String(L"aidl",4)){
			int t_i3=t_src.FindLast(String(L"/src/",5));
			if(t_i3!=-1){
				String t_dst=t_src.Slice(t_i3+1);
				if(p_CreateDirRecursive(bb_os_ExtractDir(String(L"app/",4)+t_dst))){
					CopyFile(t_src,String(L"app/",4)+t_dst);
				}
			}
		}else{
			if(t_42==String(L"xml",3)){
				int t_i4=t_src.FindLast(String(L"/src/",5));
				if(t_i4!=-1){
					String t_dst2=t_src.Slice(t_i4+1);
					if(p_CreateDirRecursive(bb_os_ExtractDir(String(L"app/",4)+t_dst2))){
						String t_str2=LoadString(t_src);
						t_str2=bb_transcc_ReplaceEnv(t_str2);
						SaveString(t_str2,String(L"app/",4)+t_dst2);
					}
				}
			}
		}
	}
	if(bb_config_GetConfigVar(String(L"ANDROID_APP_ICON",16))!=String()){
		Array<String > t_iconfiles=Array<String >();
		String t_11[]={String(L"app/src/main/res/mipmap-hdpi/ic_launcher.png",44),String(L"72",2),String(L"72",2),String(L"app/src/main/res/mipmap-mdpi/ic_launcher.png",44),String(L"48",2),String(L"48",2),String(L"app/src/main/res/mipmap-xhdpi/ic_launcher.png",45),String(L"96",2),String(L"96",2),String(L"app/src/main/res/mipmap-xxhdpi/ic_launcher.png",46),String(L"144",3),String(L"144",3),String(L"app/src/main/res/mipmap-xxxhdpi/ic_launcher.png",47),String(L"192",3),String(L"192",3)};
		t_iconfiles=Array<String >(t_11,15);
		p_MakeIcons(bb_config_GetConfigVar(String(L"ANDROID_APP_ICON",16)),t_iconfiles,0);
		String t_12[]={String(L"app/src/main/res/mipmap-hdpi/ic_launcher_round.png",50),String(L"72",2),String(L"72",2),String(L"app/src/main/res/mipmap-mdpi/ic_launcher_round.png",50),String(L"48",2),String(L"48",2),String(L"app/src/main/res/mipmap-xhdpi/ic_launcher_round.png",51),String(L"96",2),String(L"96",2),String(L"app/src/main/res/mipmap-xxhdpi/ic_launcher_round.png",52),String(L"144",3),String(L"144",3),String(L"app/src/main/res/mipmap-xxxhdpi/ic_launcher_round.png",53),String(L"192",3),String(L"192",3)};
		t_iconfiles=Array<String >(t_12,15);
		if(bb_config_GetConfigVar(String(L"ANDROID_APP_ROUND_ICON",22))==String()){
			p_MakeIcons(bb_config_GetConfigVar(String(L"ANDROID_APP_ICON",16)),t_iconfiles,1);
		}else{
			p_MakeIcons(bb_config_GetConfigVar(String(L"ANDROID_APP_ROUND_ICON",22)),t_iconfiles,0);
		}
	}
	if(bb_config_GetConfigVar(String(L"ANDROID_NATIVE_GL_ENABLED",25))==String(L"1",1)){
		bb_os_CopyDir(String(L"nativegl/libs",13),String(L"libs",4),true,false);
		CreateDir(String(L"src/com",7));
		CreateDir(String(L"src/com/cerberus",16));
		CopyFile(String(L"nativegl/NativeGL.java",22),String(L"src/com/cerberus/NativeGL.java",30));
	}
	if(m_tcc->m_opt_build){
		String t_gradlecfg=String(L"assembleDebug installDebug",26);
		if(m_tcc->m_opt_config==String(L"release",7)){
			t_gradlecfg=String(L"assembleRelease",15);
		}
		String t_gradle=String();
		if(HostOS()==String(L"winnt",5)){
			t_gradle=String(L"gradlew",7);
		}else{
			t_gradle=String(L"./gradlew",9);
		}
		if(!p_Execute(t_gradle+String(L" clean ",7)+t_gradlecfg,false)){
			bb_transcc_Die(String(L"Android build failed.",21));
		}else{
			if(m_tcc->m_opt_config==String(L"release",7)){
				String t_adb=String(L"adb",3);
				if((m_tcc->m_ANDROID_PATH).Length()!=0){
					t_adb=String(L"\"",1)+m_tcc->m_ANDROID_PATH+String(L"/platform-tools/adb\"",20);
				}
				String t__file=CurrentDir();
				t__file=t__file+String(L"/app/build/outputs/apk/release/app-release.apk",46);
				bbPrint(String(L"installing ",11)+t__file+String(L" ...",4));
				p_Execute(t_adb+String(L" install -r ",12)+t__file,false);
			}
		}
		if(m_tcc->m_opt_run){
			String t_adb2=String(L"adb",3);
			if((m_tcc->m_ANDROID_PATH).Length()!=0){
				t_adb2=String(L"\"",1)+m_tcc->m_ANDROID_PATH+String(L"/platform-tools/adb\"",20);
			}
			p_Execute(t_adb2+String(L" logcat -c",10),false);
			p_Execute(t_adb2+String(L" shell am start -n ",19)+t_app_package+String(L"/",1)+t_app_package+String(L".CerberusGame",13),false);
			p_Execute(t_adb2+String(L" logcat [Cerberus]:I *:E",24),false);
		}
	}
}
void c_AndroidBuilder::mark(){
	c_Builder::mark();
}
c_Node3::c_Node3(){
	m_key=String();
	m_right=0;
	m_left=0;
	m_value=0;
	m_color=0;
	m_parent=0;
}
c_Node3* c_Node3::m_new(String t_key,c_Builder* t_value,int t_color,c_Node3* t_parent){
	this->m_key=t_key;
	this->m_value=t_value;
	this->m_color=t_color;
	this->m_parent=t_parent;
	return this;
}
c_Node3* c_Node3::m_new2(){
	return this;
}
c_Node3* c_Node3::p_NextNode(){
	c_Node3* t_node=0;
	if((m_right)!=0){
		t_node=m_right;
		while((t_node->m_left)!=0){
			t_node=t_node->m_left;
		}
		return t_node;
	}
	t_node=this;
	c_Node3* t_parent=this->m_parent;
	while(((t_parent)!=0) && t_node==t_parent->m_right){
		t_node=t_parent;
		t_parent=t_parent->m_parent;
	}
	return t_parent;
}
c_Builder* c_Node3::p_Value(){
	return m_value;
}
String c_Node3::p_Key(){
	return m_key;
}
void c_Node3::mark(){
	Object::mark();
}
c_AndroidNdkBuilder::c_AndroidNdkBuilder(){
}
c_AndroidNdkBuilder* c_AndroidNdkBuilder::m_new(c_TransCC* t_tcc){
	c_Builder::m_new(t_tcc);
	return this;
}
c_AndroidNdkBuilder* c_AndroidNdkBuilder::m_new2(){
	c_Builder::m_new2();
	return this;
}
bool c_AndroidNdkBuilder::p_IsValid(){
	return m_tcc->m_ANDROID_PATH!=String() && m_tcc->m_ANDROID_NDK_PATH!=String();
}
void c_AndroidNdkBuilder::p_Begin(){
	bb_config_ENV_LANG=String(L"cpp",3);
	bb_translator__trans=((new c_CppTranslator)->m_new());
}
String c_AndroidNdkBuilder::p_Config(){
	c_StringStack* t_config=(new c_StringStack)->m_new2();
	c_NodeEnumerator3* t_=bb_config_GetConfigVars()->p_ObjectEnumerator();
	while(t_->p_HasNext()){
		c_Node2* t_kv=t_->p_NextObject();
		t_config->p_Push(String(L"#define CFG_",12)+t_kv->p_Key()+String(L" ",1)+t_kv->p_Value());
	}
	return t_config->p_Join(String(L"\n",1));
}
bool c_AndroidNdkBuilder::p_CreateDirRecursive(String t_path){
	int t_i=0;
	do{
		t_i=t_path.Find(String(L"/",1),t_i);
		if(t_i==-1){
			CreateDir(t_path);
			return FileType(t_path)==2;
		}
		String t_t=t_path.Slice(0,t_i);
		CreateDir(t_t);
		if(FileType(t_t)!=2){
			return false;
		}
		t_i+=1;
	}while(!(false));
}
void c_AndroidNdkBuilder::p_MakeTarget(){
	bb_config_SetConfigVar2(String(L"ANDROID_SDK_DIR",15),m_tcc->m_ANDROID_PATH.Replace(String(L"\\",1),String(L"\\\\",2)));
	bb_config_SetConfigVar2(String(L"ANDROID_MANIFEST_MAIN",21),bb_config_GetConfigVar(String(L"ANDROID_MANIFEST_MAIN",21)).Replace(String(L";",1),String(L"\n",1))+String(L"\n",1));
	bb_config_SetConfigVar2(String(L"ANDROID_MANIFEST_APPLICATION",28),bb_config_GetConfigVar(String(L"ANDROID_MANIFEST_APPLICATION",28)).Replace(String(L";",1),String(L"\n",1))+String(L"\n",1));
	bb_config_SetConfigVar2(String(L"ANDROID_MANIFEST_ACTIVITY",25),bb_config_GetConfigVar(String(L"ANDROID_MAINFEST_ACTIVITY",25)).Replace(String(L";",1),String(L"\n",1))+String(L"\n",1));
	p_CreateDataDir(String(L"assets/cerberus",15));
	String t_app_label=bb_config_GetConfigVar(String(L"ANDROID_APP_LABEL",17));
	String t_app_package=bb_config_GetConfigVar(String(L"ANDROID_APP_PACKAGE",19));
	String t_main=LoadString(String(L"jni/main.cpp",12));
	t_main=bb_transcc_ReplaceBlock(t_main,String(L"TRANSCODE",9),m_transCode,String(L"\n//",3));
	t_main=bb_transcc_ReplaceBlock(t_main,String(L"CONFIG",6),p_Config(),String(L"\n//",3));
	SaveString(t_main,String(L"jni/main.cpp",12));
	bb_os_DeleteDir(String(L"src",3),true);
	String t_jmain=LoadString(String(L"CerberusGame.java",17));
	t_jmain=bb_transcc_ReplaceBlock(t_jmain,String(L"PACKAGE",7),String(L"package ",8)+t_app_package+String(L";",1),String(L"\n//",3));
	String t_dir=String(L"src/",4)+t_app_package.Replace(String(L".",1),String(L"/",1));
	if(!p_CreateDirRecursive(t_dir)){
		bbError(String(L"Failed to create dir:",21)+t_dir);
	}
	SaveString(t_jmain,t_dir+String(L"/CerberusGame.java",18));
	Array<String > t_=bb_config_GetConfigVar(String(L"LIBS",4)).Split(String(L";",1));
	int t_2=0;
	while(t_2<t_.Length()){
		String t_lib=t_[t_2];
		t_2=t_2+1;
		String t_1=bb_os_ExtractExt(t_lib);
		if(t_1==String(L"jar",3) || t_1==String(L"so",2)){
			String t_tdir=String();
			if(t_lib.Contains(String(L"/",1))){
				t_tdir=bb_os_ExtractDir(t_lib);
				if(t_tdir.Contains(String(L"/",1))){
					t_tdir=bb_os_StripDir(t_tdir);
				}
				String t_22=t_tdir;
				if(t_22==String(L"x86",3) || t_22==String(L"mips",4) || t_22==String(L"armeabi",7) || t_22==String(L"armeabi-v7a",11)){
					CreateDir(String(L"libs/",5)+t_tdir);
					t_tdir=t_tdir+String(L"/",1);
				}else{
					t_tdir=String();
				}
			}
			CopyFile(t_lib,String(L"libs/",5)+t_tdir+bb_os_StripDir(t_lib));
		}
	}
	Array<String > t_3=bb_config_GetConfigVar(String(L"SRCS",4)).Split(String(L";",1));
	int t_4=0;
	while(t_4<t_3.Length()){
		String t_src=t_3[t_4];
		t_4=t_4+1;
		String t_32=bb_os_ExtractExt(t_src);
		if(t_32==String(L"java",4) || t_32==String(L"aidl",4)){
			int t_i=t_src.FindLast(String(L"/src/",5));
			if(t_i!=-1){
				String t_dst=t_src.Slice(t_i+1);
				if(!p_CreateDirRecursive(bb_os_ExtractDir(t_dst))){
					bbError(String(L"Failed to create dir:",21)+bb_os_ExtractDir(t_dst));
				}
				CopyFile(t_src,t_dst);
			}
		}
	}
	Array<String > t_5=bb_os_LoadDir(String(L"templates",9),true,false);
	int t_6=0;
	while(t_6<t_5.Length()){
		String t_file=t_5[t_6];
		t_6=t_6+1;
		int t_i2=0;
		do{
			t_i2=t_file.Find(String(L"/",1),t_i2);
			if(t_i2==-1){
				break;
			}
			CreateDir(t_file.Slice(0,t_i2));
			if(FileType(t_file.Slice(0,t_i2))!=2){
				t_file=String();
				break;
			}
			t_i2+=1;
		}while(!(false));
		if(!((t_file).Length()!=0)){
			continue;
		}
		String t_42=bb_os_ExtractExt(t_file).ToLower();
		if(t_42==String(L"xml",3) || t_42==String(L"properties",10) || t_42==String(L"java",4)){
			String t_str=LoadString(String(L"templates/",10)+t_file);
			t_str=bb_transcc_ReplaceEnv(t_str);
			SaveString(t_str,t_file);
		}else{
			CopyFile(String(L"templates/",10)+t_file,t_file);
		}
	}
	if(m_tcc->m_opt_build){
		if(!p_Execute(m_tcc->m_ANDROID_NDK_PATH+String(L"/ndk-build",10),true)){
			bb_transcc_Die(String(L"Failed to build native code",27));
		}
		bool t_r=p_Execute(String(L"ant clean",9),false) && p_Execute(String(L"ant debug install",17),false);
		if(!t_r){
			bb_transcc_Die(String(L"Android build failed.",21));
		}else{
			if(m_tcc->m_opt_run){
				p_Execute(String(L"adb logcat -c",13),false);
				p_Execute(String(L"adb shell am start -n ",22)+t_app_package+String(L"/",1)+t_app_package+String(L".CerberusGame",13),false);
				p_Execute(String(L"adb logcat [Cerberus]:I *:E",27),false);
			}
		}
	}
}
void c_AndroidNdkBuilder::mark(){
	c_Builder::mark();
}
c_GlfwBuilder::c_GlfwBuilder(){
}
c_GlfwBuilder* c_GlfwBuilder::m_new(c_TransCC* t_tcc){
	c_Builder::m_new(t_tcc);
	return this;
}
c_GlfwBuilder* c_GlfwBuilder::m_new2(){
	c_Builder::m_new2();
	return this;
}
bool c_GlfwBuilder::p_IsValid(){
	String t_2=HostOS();
	if(t_2==String(L"winnt",5)){
		if(((m_tcc->m_MINGW_PATH).Length()!=0) || ((m_tcc->m_MSBUILD_PATH).Length()!=0)){
			return true;
		}
	}else{
		return true;
	}
	return false;
}
void c_GlfwBuilder::p_Begin(){
	bb_config_ENV_LANG=String(L"cpp",3);
	bb_translator__trans=((new c_CppTranslator)->m_new());
}
String c_GlfwBuilder::p_Config(){
	c_StringStack* t_config=(new c_StringStack)->m_new2();
	c_NodeEnumerator3* t_=bb_config_GetConfigVars()->p_ObjectEnumerator();
	while(t_->p_HasNext()){
		c_Node2* t_kv=t_->p_NextObject();
		t_config->p_Push(String(L"#define CFG_",12)+t_kv->p_Key()+String(L" ",1)+t_kv->p_Value());
	}
	return t_config->p_Join(String(L"\n",1));
}
int c_GlfwBuilder::p_ProcessExternalLibs(String t_config,String t_arch,String t_link){
	String t_libStr=bb_config_GetConfigVar(String(L"GLFW_COPY_LIBS",14)).ToLower();
	if(t_libStr==String()){
		return 0;
	}
	Array<String > t_libcopy=t_libStr.Split(String(L";",1));
	String t_dst=t_config+t_arch;
	Array<String > t_=t_libcopy;
	int t_2=0;
	while(t_2<t_.Length()){
		String t_i=t_[t_2];
		t_2=t_2+1;
		if(HostOS()==String(L"winnt",5)){
			if(t_i!=String()){
				if(FileType(t_dst+String(L"/",1)+t_i+String(L".dll",4))==1){
					continue;
				}
				if(CopyFile(m_tcc->m__libs+String(L"Win",3)+t_arch+String(L"/",1)+t_i+String(L".dll",4),t_dst+String(L"/",1)+t_i+String(L".dll",4))==1){
					bbPrint(String(L"Copied ",7)+t_i+String(L".dll to ",8)+t_dst);
				}else{
					bbPrint(String(L"Failed to copy ",15)+t_i+String(L" to ",4)+t_dst);
				}
				if(FileType(m_tcc->m__libs+String(L"/",1)+t_i+String(L"_COPYING",8))!=0){
					if(CopyFile(m_tcc->m__libs+String(L"/",1)+t_i+String(L"_COPYING",8),t_dst+String(L"/",1)+t_i+String(L"_COPYING",8))==1){
						bbPrint(String(L"Copied ",7)+t_i+String(L"_COPYING to ",12)+t_dst);
					}else{
						bbPrint(String(L"Failed to copy ",15)+t_i+String(L"_COPYING To ",12)+t_dst);
					}
				}
				if(FileType(m_tcc->m__libs+String(L"/",1)+t_i+String(L"_LICENCE",8))!=0){
					if(CopyFile(m_tcc->m__libs+String(L"/",1)+t_i+String(L"_LICENCE",8),t_dst+String(L"/",1)+t_i+String(L"_LICENCE",8))==1){
						bbPrint(String(L"Copied ",7)+t_i+String(L"_LICENCE to ",12)+t_dst);
					}else{
						bbPrint(String(L"Failed to copy ",15)+t_i+String(L"_COPYING To ",12)+t_dst);
					}
				}
			}
		}
	}
	return 0;
}
void c_GlfwBuilder::p_MakeGcc(){
	String t_msize=bb_config_GetConfigVar(String(L"GLFW_GCC_MSIZE_",15)+HostOS().ToUpper());
	String t_tconfig=m_casedConfig+t_msize;
	String t_dst=String(L"gcc_",4)+HostOS();
	CreateDir(t_dst+String(L"/",1)+t_tconfig);
	CreateDir(t_dst+String(L"/",1)+t_tconfig+String(L"/internal",9));
	CreateDir(t_dst+String(L"/",1)+t_tconfig+String(L"/external",9));
	p_CreateDataDir(t_dst+String(L"/",1)+t_tconfig+String(L"/data",5));
	p_CopySourceFiles(String(L".",1));
	p_CopyIcon(bb_config_GetConfigVar(String(L"GLFW_APP_ICON",13)),CurrentDir()+String(L"/cerberus.ico",13));
	String t_main=LoadString(String(L"main.cpp",8));
	t_main=bb_transcc_ReplaceBlock(t_main,String(L"TRANSCODE",9),m_transCode,String(L"\n//",3));
	t_main=bb_transcc_ReplaceBlock(t_main,String(L"CONFIG",6),p_Config(),String(L"\n//",3));
	SaveString(t_main,String(L"main.cpp",8));
	if(m_tcc->m_opt_build){
		ChangeDir(t_dst);
		CreateDir(String(L"build",5));
		CreateDir(String(L"build/",6)+t_tconfig);
		String t_ccopts=String();
		String t_ldopts=String();
		String t_libopts=String();
		String t_libcopy=String();
		if((t_msize).Length()!=0){
			t_ccopts=t_ccopts+(String(L" -m",3)+t_msize);
			t_ldopts=t_ldopts+(String(L" -m",3)+t_msize);
		}
		t_ccopts=t_ccopts+(String(L" ",1)+bb_config_GetConfigVar(String(L"GLFW_GCC_CC_OPTS",16)).Replace(String(L";",1),String(L" ",1)));
		t_ldopts=t_ldopts+(String(L" ",1)+bb_config_GetConfigVar(String(L"GLFW_GCC_LD_OPTS",16)).Replace(String(L";",1),String(L" ",1)));
		t_libopts=t_libopts+(String(L" ",1)+bb_config_GetConfigVar(String(L"GLFW_GCC_LIB_OPTS",17)).Replace(String(L";",1),String(L" ",1)));
		String t_1=bb_config_ENV_CONFIG;
		if(t_1==String(L"debug",5)){
			t_ccopts=t_ccopts+String(L" -O0",4);
		}else{
			if(t_1==String(L"release",7)){
				t_ccopts=t_ccopts+String(L" -O3 -DNDEBUG",13);
				t_ldopts=t_ldopts+String(L" -s",3);
			}
		}
		p_ProcessExternalLibs(CurrentDir()+String(L"\\",1)+m_casedConfig,t_msize,t_libopts);
		if(HostOS()==String(L"winnt",5)){
			t_ldopts=t_ldopts+(String(L" -L",3)+m_tcc->m__libs+String(L"Win",3)+t_msize);
		}
		String t_cmd=String(L"make",4);
		if(HostOS()==String(L"winnt",5) && ((FileType(m_tcc->m_MINGW_PATH+String(L"/bin/mingw32-make.exe",21)))!=0)){
			t_cmd=String(L"mingw32-make",12);
		}
		p_Execute(t_cmd+String(L" CCOPTS=\"",9)+t_ccopts+String(L"\" LDOPTS=\"",10)+t_ldopts+String(L"\" LIBOPTS=\"",11)+t_libopts+String(L"\" OUT=\"",7)+t_tconfig+String(L"/CerberusGame\"",14),true);
		if(m_tcc->m_opt_run){
			ChangeDir(t_tconfig);
			if(HostOS()==String(L"winnt",5)){
				p_Execute(String(L"CerberusGame",12),true);
			}else{
				p_Execute(String(L"./CerberusGame",14),true);
			}
		}
	}
}
void c_GlfwBuilder::p_MakeVc2010(){
	CreateDir(String(L"vc2010/",7)+m_casedConfig);
	CreateDir(String(L"vc2010/",7)+m_casedConfig+String(L"/internal",9));
	CreateDir(String(L"vc2010/",7)+m_casedConfig+String(L"/external",9));
	p_CreateDataDir(String(L"vc2010/",7)+m_casedConfig+String(L"/data",5));
	String t_main=LoadString(String(L"main.cpp",8));
	t_main=bb_transcc_ReplaceBlock(t_main,String(L"TRANSCODE",9),m_transCode,String(L"\n//",3));
	t_main=bb_transcc_ReplaceBlock(t_main,String(L"CONFIG",6),p_Config(),String(L"\n//",3));
	SaveString(t_main,String(L"main.cpp",8));
	if(m_tcc->m_opt_build){
		ChangeDir(String(L"vc2010",6));
		p_Execute(String(L"\"",1)+m_tcc->m_MSBUILD_PATH+String(L"\" /p:Configuration=",19)+m_casedConfig+String(L" /p:Platform=Win32 CerberusGame.sln",35),true);
		if(m_tcc->m_opt_run){
			ChangeDir(m_casedConfig);
			p_Execute(String(L"CerberusGame",12),true);
		}
	}
}
void c_GlfwBuilder::p_MakeMsvc(){
	CreateDir(String(L"msvc/",5)+m_casedConfig);
	CreateDir(String(L"msvc/",5)+m_casedConfig+String(L"/internal",9));
	CreateDir(String(L"msvc/",5)+m_casedConfig+String(L"/external",9));
	p_CreateDataDir(String(L"msvc/",5)+m_casedConfig+String(L"/data",5));
	p_CopyIcon(bb_config_GetConfigVar(String(L"GLFW_APP_ICON",13)),CurrentDir()+String(L"\\cerberus.ico",13));
	String t_main=LoadString(String(L"main.cpp",8));
	t_main=bb_transcc_ReplaceBlock(t_main,String(L"TRANSCODE",9),m_transCode,String(L"\n//",3));
	t_main=bb_transcc_ReplaceBlock(t_main,String(L"CONFIG",6),p_Config(),String(L"\n//",3));
	SaveString(t_main,String(L"main.cpp",8));
	if(m_tcc->m_opt_build){
		ChangeDir(String(L"msvc",4));
		p_Execute(String(L"\"",1)+m_tcc->m_MSBUILD_PATH+String(L"\" /p:Configuration=",19)+m_casedConfig,true);
		if(m_tcc->m_opt_run){
			ChangeDir(m_casedConfig);
			p_Execute(String(L"CerberusGame",12),true);
		}
	}
}
void c_GlfwBuilder::p_MakeXcode(){
	p_CreateDataDir(String(L"xcode/data",10));
	String t_main=LoadString(String(L"main.cpp",8));
	t_main=bb_transcc_ReplaceBlock(t_main,String(L"TRANSCODE",9),m_transCode,String(L"\n//",3));
	t_main=bb_transcc_ReplaceBlock(t_main,String(L"CONFIG",6),p_Config(),String(L"\n//",3));
	SaveString(t_main,String(L"main.cpp",8));
	if(m_tcc->m_opt_build){
		ChangeDir(String(L"xcode",5));
		p_Execute(String(L"xcodebuild -configuration ",26)+m_casedConfig,true);
		if(m_tcc->m_opt_run){
			ChangeDir(String(L"build/",6)+m_casedConfig);
			ChangeDir(String(L"CerberusGame.app/Contents/MacOS",31));
			p_Execute(String(L"./CerberusGame",14),true);
		}
	}
}
void c_GlfwBuilder::p_MakeTarget(){
	String t_3=HostOS();
	if(t_3==String(L"winnt",5)){
		if(bb_config_GetConfigVar(String(L"GLFW_USE_MINGW",14))==String(L"1",1) && ((m_tcc->m_MINGW_PATH).Length()!=0)){
			p_MakeGcc();
		}else{
			if(FileType(String(L"vc2010",6))==2){
				p_MakeVc2010();
			}else{
				if(FileType(String(L"msvc",4))==2){
					p_MakeMsvc();
				}else{
					if((m_tcc->m_MINGW_PATH).Length()!=0){
						p_MakeGcc();
					}
				}
			}
		}
	}else{
		if(t_3==String(L"macos",5)){
			p_MakeXcode();
		}else{
			if(t_3==String(L"linux",5)){
				p_MakeGcc();
			}
		}
	}
}
void c_GlfwBuilder::mark(){
	c_Builder::mark();
}
c_Html5Builder::c_Html5Builder(){
}
c_Html5Builder* c_Html5Builder::m_new(c_TransCC* t_tcc){
	c_Builder::m_new(t_tcc);
	return this;
}
c_Html5Builder* c_Html5Builder::m_new2(){
	c_Builder::m_new2();
	return this;
}
bool c_Html5Builder::p_IsValid(){
	return true;
}
void c_Html5Builder::p_Begin(){
	bb_config_ENV_LANG=String(L"js",2);
	bb_translator__trans=((new c_JsTranslator)->m_new());
}
String c_Html5Builder::p_MetaData(){
	c_StringStack* t_meta=(new c_StringStack)->m_new2();
	c_NodeEnumerator3* t_=m_dataFiles->p_ObjectEnumerator();
	while(t_->p_HasNext()){
		c_Node2* t_kv=t_->p_NextObject();
		String t_src=t_kv->p_Key();
		String t_ext=bb_os_ExtractExt(t_src).ToLower();
		String t_3=t_ext;
		if(t_3==String(L"png",3) || t_3==String(L"jpg",3) || t_3==String(L"gif",3)){
			bb_html5_Info_Width=0;
			bb_html5_Info_Height=0;
			String t_4=t_ext;
			if(t_4==String(L"png",3)){
				bb_html5_GetInfo_PNG(t_src);
			}else{
				if(t_4==String(L"jpg",3)){
					bb_html5_GetInfo_JPG(t_src);
				}else{
					if(t_4==String(L"gif",3)){
						bb_html5_GetInfo_GIF(t_src);
					}
				}
			}
			if(bb_html5_Info_Width==0 || bb_html5_Info_Height==0){
				bb_transcc_Die(String(L"Unable to load image file '",27)+t_src+String(L"'.",2));
			}
			t_meta->p_Push(String(L"[",1)+t_kv->p_Value()+String(L"];type=image/",13)+t_ext+String(L";",1));
			t_meta->p_Push(String(L"width=",6)+String(bb_html5_Info_Width)+String(L";",1));
			t_meta->p_Push(String(L"height=",7)+String(bb_html5_Info_Height)+String(L";",1));
			t_meta->p_Push(String(L"\\n",2));
		}
	}
	return t_meta->p_Join(String());
}
String c_Html5Builder::p_Config(){
	c_StringStack* t_config=(new c_StringStack)->m_new2();
	c_NodeEnumerator3* t_=bb_config_GetConfigVars()->p_ObjectEnumerator();
	while(t_->p_HasNext()){
		c_Node2* t_kv=t_->p_NextObject();
		t_config->p_Push(String(L"CFG_",4)+t_kv->p_Key()+String(L"=",1)+bb_config_Enquote(t_kv->p_Value(),String(L"js",2))+String(L";",1));
	}
	return t_config->p_Join(String(L"\n",1));
}
void c_Html5Builder::p_MakeTarget(){
	p_CreateDataDir(String(L"data",4));
	String t_meta=String(L"var META_DATA=\"",15)+p_MetaData()+String(L"\";\n",3);
	String t_main=LoadString(String(L"main.js",7));
	t_main=bb_transcc_ReplaceBlock(t_main,String(L"TRANSCODE",9),m_transCode,String(L"\n//",3));
	t_main=bb_transcc_ReplaceBlock(t_main,String(L"METADATA",8),t_meta,String(L"\n//",3));
	t_main=bb_transcc_ReplaceBlock(t_main,String(L"CONFIG",6),p_Config(),String(L"\n//",3));
	SaveString(t_main,String(L"main.js",7));
	p_CopyIcon(bb_config_GetConfigVar(String(L"HTML5_APP_ICON",14)),CurrentDir()+String(L"\\favicon.ico",12));
	String t_game=LoadString(String(L"CerberusGame.html",17));
	t_game=t_game.Replace(String(L"%%HTML5_CONSOLE_SHOW%%",22),bb_config_GetConfigVar(String(L"HTML5_CONSOLE_SHOW",18)));
	t_game=t_game.Replace(String(L"%%HTML5_APP_TITLE%%",19),bb_config_GetConfigVar(String(L"HTML5_APP_TITLE",15)));
	t_game=t_game.Replace(String(L"%%HTML5_CANVAS_WIDTH%%",22),bb_config_GetConfigVar(String(L"HTML5_CANVAS_WIDTH",18)));
	t_game=t_game.Replace(String(L"%%HTML5_CANVAS_HEIGHT%%",23),bb_config_GetConfigVar(String(L"HTML5_CANVAS_HEIGHT",19)));
	t_game=t_game.Replace(String(L"%%HTML5_CANVAS_RESIZE_MODE%%",28),bb_config_GetConfigVar(String(L"HTML5_CANVAS_RESIZE_MODE",24)));
	SaveString(t_game,bb_config_GetConfigVar(String(L"HTML5_APP_FILENAME",18)));
	if(m_tcc->m_opt_run){
		String t_p=RealPath(bb_config_GetConfigVar(String(L"HTML5_APP_FILENAME",18)));
		String t_t=m_tcc->m_HTML_PLAYER+String(L" \"",2)+t_p+String(L"\"",1);
		p_Execute(t_t,false);
	}
}
void c_Html5Builder::mark(){
	c_Builder::mark();
}
c_IosBuilder::c_IosBuilder(){
	m__buildFiles=(new c_StringMap2)->m_new();
	m__nextFileId=0;
	m__fileRefs=(new c_StringMap2)->m_new();
}
c_IosBuilder* c_IosBuilder::m_new(c_TransCC* t_tcc){
	c_Builder::m_new(t_tcc);
	return this;
}
c_IosBuilder* c_IosBuilder::m_new2(){
	c_Builder::m_new2();
	return this;
}
bool c_IosBuilder::p_IsValid(){
	String t_1=HostOS();
	if(t_1==String(L"macos",5)){
		return true;
	}
	return false;
}
void c_IosBuilder::p_Begin(){
	bb_config_ENV_LANG=String(L"cpp",3);
	bb_translator__trans=((new c_CppTranslator)->m_new());
}
String c_IosBuilder::p_Config(){
	c_StringStack* t_config=(new c_StringStack)->m_new2();
	c_NodeEnumerator3* t_=bb_config_GetConfigVars()->p_ObjectEnumerator();
	while(t_->p_HasNext()){
		c_Node2* t_kv=t_->p_NextObject();
		t_config->p_Push(String(L"#define CFG_",12)+t_kv->p_Key()+String(L" ",1)+t_kv->p_Value());
	}
	return t_config->p_Join(String(L"\n",1));
}
String c_IosBuilder::p_FileId(String t_path,c_StringMap2* t_map){
	String t_id=t_map->p_Get(t_path);
	if((t_id).Length()!=0){
		return t_id;
	}
	m__nextFileId+=1;
	t_id=String(L"1ACECAFEBABE",12)+(String(L"0000000000000000",16)+String(m__nextFileId)).Slice(-12);
	t_map->p_Set2(t_path,t_id);
	return t_id;
}
void c_IosBuilder::p_AddBuildFile(String t_path){
	p_FileId(t_path,m__buildFiles);
}
int c_IosBuilder::p_FindEol(String t_str,String t_substr,int t_start){
	int t_i=t_str.Find(t_substr,t_start);
	if(t_i==-1){
		bbPrint(String(L"Can't find ",11)+t_substr);
		return -1;
	}
	t_i+=t_substr.Length();
	int t_eol=t_str.Find(String(L"\n",1),t_i)+1;
	if(t_eol==0){
		return t_str.Length();
	}
	return t_eol;
}
String c_IosBuilder::p_BuildFiles(){
	c_StringStack* t_buf=(new c_StringStack)->m_new2();
	c_NodeEnumerator3* t_=m__buildFiles->p_ObjectEnumerator();
	while(t_->p_HasNext()){
		c_Node2* t_it=t_->p_NextObject();
		String t_path=t_it->p_Key();
		String t_id=t_it->p_Value();
		String t_fileRef=p_FileId(t_path,m__fileRefs);
		String t_dir=bb_os_ExtractDir(t_path);
		String t_name=bb_os_StripDir(t_path);
		String t_2=bb_os_ExtractExt(t_name);
		if(t_2==String(L"a",1) || t_2==String(L"framework",9)){
			t_buf->p_Push(String(L"\t\t",2)+t_id+String(L" = {isa = PBXBuildFile; fileRef = ",34)+t_fileRef+String(L"; };",4));
		}
	}
	if((t_buf->p_Length2())!=0){
		t_buf->p_Push(String());
	}
	return t_buf->p_Join(String(L"\n",1));
}
String c_IosBuilder::p_FileRefs(){
	c_StringStack* t_buf=(new c_StringStack)->m_new2();
	c_NodeEnumerator3* t_=m__fileRefs->p_ObjectEnumerator();
	while(t_->p_HasNext()){
		c_Node2* t_it=t_->p_NextObject();
		String t_path=t_it->p_Key();
		String t_id=t_it->p_Value();
		String t_dir=bb_os_ExtractDir(t_path);
		String t_name=bb_os_StripDir(t_path);
		String t_3=bb_os_ExtractExt(t_name);
		if(t_3==String(L"a",1)){
			t_buf->p_Push(String(L"\t\t",2)+t_id+String(L" = {isa = PBXFileReference; lastKnownFileType = archive.ar; path = \"",68)+t_name+String(L"\"; sourceTree = \"<group>\"; };",29));
		}else{
			if(t_3==String(L"h",1)){
				t_buf->p_Push(String(L"\t\t",2)+t_id+String(L" = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ",89)+t_name+String(L"; sourceTree = \"<group>\"; };",28));
			}else{
				if(t_3==String(L"framework",9)){
					if((t_dir).Length()!=0){
						t_buf->p_Push(String(L"\t\t",2)+t_id+String(L" = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = ",74)+t_name+String(L"; path = ",9)+t_name+String(L"; sourceTree = \"<group>\"; };",28));
					}else{
						t_buf->p_Push(String(L"\t\t",2)+t_id+String(L" = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = ",74)+t_name+String(L"; path = System/Library/Frameworks/",35)+t_name+String(L"; sourceTree = SDKROOT; };",26));
					}
				}
			}
		}
	}
	if((t_buf->p_Length2())!=0){
		t_buf->p_Push(String());
	}
	return t_buf->p_Join(String(L"\n",1));
}
String c_IosBuilder::p_FrameworksBuildPhase(){
	c_StringStack* t_buf=(new c_StringStack)->m_new2();
	c_NodeEnumerator3* t_=m__buildFiles->p_ObjectEnumerator();
	while(t_->p_HasNext()){
		c_Node2* t_it=t_->p_NextObject();
		String t_path=t_it->p_Key();
		String t_id=t_it->p_Value();
		String t_4=bb_os_ExtractExt(t_path);
		if(t_4==String(L"a",1) || t_4==String(L"framework",9)){
			t_buf->p_Push(String(L"\t\t\t\t",4)+t_id);
		}
	}
	if((t_buf->p_Length2())!=0){
		t_buf->p_Push(String());
	}
	return t_buf->p_Join(String(L",\n",2));
}
String c_IosBuilder::p_FrameworksGroup(){
	c_StringStack* t_buf=(new c_StringStack)->m_new2();
	c_NodeEnumerator3* t_=m__fileRefs->p_ObjectEnumerator();
	while(t_->p_HasNext()){
		c_Node2* t_it=t_->p_NextObject();
		String t_path=t_it->p_Key();
		String t_id=t_it->p_Value();
		String t_5=bb_os_ExtractExt(t_path);
		if(t_5==String(L"framework",9)){
			t_buf->p_Push(String(L"\t\t\t\t",4)+t_id);
		}
	}
	if((t_buf->p_Length2())!=0){
		t_buf->p_Push(String());
	}
	return t_buf->p_Join(String(L",\n",2));
}
String c_IosBuilder::p_LibsGroup(){
	c_StringStack* t_buf=(new c_StringStack)->m_new2();
	c_NodeEnumerator3* t_=m__fileRefs->p_ObjectEnumerator();
	while(t_->p_HasNext()){
		c_Node2* t_it=t_->p_NextObject();
		String t_path=t_it->p_Key();
		String t_id=t_it->p_Value();
		String t_6=bb_os_ExtractExt(t_path);
		if(t_6==String(L"a",1) || t_6==String(L"h",1)){
			t_buf->p_Push(String(L"\t\t\t\t",4)+t_id);
		}
	}
	if((t_buf->p_Length2())!=0){
		t_buf->p_Push(String());
	}
	return t_buf->p_Join(String(L",\n",2));
}
String c_IosBuilder::p_MungProj(String t_proj){
	int t_i=-1;
	t_i=p_FindEol(t_proj,String(L"/* Begin PBXBuildFile section */",32),0);
	if(t_i==-1){
		return String();
	}
	t_proj=t_proj.Slice(0,t_i)+p_BuildFiles()+t_proj.Slice(t_i);
	t_i=p_FindEol(t_proj,String(L"/* Begin PBXFileReference section */",36),0);
	if(t_i==-1){
		return String();
	}
	t_proj=t_proj.Slice(0,t_i)+p_FileRefs()+t_proj.Slice(t_i);
	t_i=p_FindEol(t_proj,String(L"/* Begin PBXFrameworksBuildPhase section */",43),0);
	if(t_i!=-1){
		t_i=p_FindEol(t_proj,String(L"/* Frameworks */ = {",20),t_i);
	}
	if(t_i!=-1){
		t_i=p_FindEol(t_proj,String(L"files = (",9),t_i);
	}
	if(t_i==-1){
		return String();
	}
	t_proj=t_proj.Slice(0,t_i)+p_FrameworksBuildPhase()+t_proj.Slice(t_i);
	t_i=p_FindEol(t_proj,String(L"/* Begin PBXGroup section */",28),0);
	if(t_i!=-1){
		t_i=p_FindEol(t_proj,String(L"/* Frameworks */ = {",20),t_i);
	}
	if(t_i!=-1){
		t_i=p_FindEol(t_proj,String(L"children = (",12),t_i);
	}
	if(t_i==-1){
		return String();
	}
	t_proj=t_proj.Slice(0,t_i)+p_FrameworksGroup()+t_proj.Slice(t_i);
	t_i=p_FindEol(t_proj,String(L"/* Begin PBXGroup section */",28),0);
	if(t_i!=-1){
		t_i=p_FindEol(t_proj,String(L"/* libs */ = {",14),t_i);
	}
	if(t_i!=-1){
		t_i=p_FindEol(t_proj,String(L"children = (",12),t_i);
	}
	if(t_i==-1){
		return String();
	}
	t_proj=t_proj.Slice(0,t_i)+p_LibsGroup()+t_proj.Slice(t_i);
	return t_proj;
}
void c_IosBuilder::p_MungProj2(){
	String t_path=String(L"CerberusGame.xcodeproj/project.pbxproj",38);
	String t_proj=LoadString(t_path);
	c_StringStack* t_buf=(new c_StringStack)->m_new2();
	Array<String > t_=t_proj.Split(String(L"\n",1));
	int t_2=0;
	while(t_2<t_.Length()){
		String t_line=t_[t_2];
		t_2=t_2+1;
		if(!t_line.Trim().StartsWith(String(L"1ACECAFEBABE",12))){
			t_buf->p_Push(t_line);
		}
	}
	t_proj=t_buf->p_Join(String(L"\n",1));
	t_proj=p_MungProj(t_proj);
	if(!((t_proj).Length()!=0)){
		bb_transcc_Die(String(L"Failed to mung XCode project file",33));
	}
	SaveString(t_proj,t_path);
}
void c_IosBuilder::p_MakeTarget(){
	String t_sim_path=String(L"/Applications/Xcode.app/Contents/Developer/Applications/Simulator.app",69);
	if(m_tcc->m_opt_run==true){
		bbPrint(String(L"Starting iOS simulator...",25));
		p_Execute(String(L"open \"",6)+t_sim_path+String(L"\"",1),true);
	}
	p_CreateDataDir(String(L"data",4));
	CreateDir(String(L"icons",5));
	String t_[]={String(L"icons/iphone-app-1x-60px.png",28),String(L"60",2),String(L"60",2),String(L"icons/iphone-app-2x-120px.png",29),String(L"120",3),String(L"120",3),String(L"icons/iphone-app-3x-180px.png",29),String(L"180",3),String(L"180",3),String(L"icons/iphone-spotlight-1x-40px.png",34),String(L"40",2),String(L"40",2),String(L"icons/iphone-spotlight-2x-80px.png",34),String(L"80",2),String(L"80",2),String(L"icons/iphone-spotlight-3x-120px.png",35),String(L"120",3),String(L"120",3),String(L"icons/iphone-settings-3x-87px.png",33),String(L"87",2),String(L"87",2),String(L"icons/ipad-app-1x-76px.png",26),String(L"76",2),String(L"76",2),String(L"icons/ipad-app-2x-152px.png",27),String(L"152",3),String(L"152",3),String(L"icons/ipad-app-3x-167px.png",27),String(L"167",3),String(L"167",3),String(L"icons/ipad-spotlight-1x-40px.png",32),String(L"40",2),String(L"40",2),String(L"icons/ipad-spotlight-2x-80px.png",32),String(L"80",2),String(L"80",2),String(L"icons/ipad-spotlight-3x-120px.png",33),String(L"120",3),String(L"120",3),String(L"icons/ipad-settings-3x-58px.png",31),String(L"58",2),String(L"58",2)};
	Array<String > t_iconfiles=Array<String >(t_,42);
	p_MakeIcons(bb_config_GetConfigVar(String(L"IOS_APP_ICON",12)),t_iconfiles,0);
	String t_main=LoadString(String(L"main.mm",7));
	t_main=bb_transcc_ReplaceBlock(t_main,String(L"TRANSCODE",9),m_transCode,String(L"\n//",3));
	t_main=bb_transcc_ReplaceBlock(t_main,String(L"CONFIG",6),p_Config(),String(L"\n//",3));
	SaveString(t_main,String(L"main.mm",7));
	String t_libs=bb_config_GetConfigVar(String(L"LIBS",4));
	if((t_libs).Length()!=0){
		Array<String > t_2=t_libs.Split(String(L";",1));
		int t_3=0;
		while(t_3<t_2.Length()){
			String t_lib=t_2[t_3];
			t_3=t_3+1;
			if(!((t_lib).Length()!=0)){
				continue;
			}
			String t_7=bb_os_ExtractExt(t_lib);
			if(t_7==String(L"a",1) || t_7==String(L"h",1)){
				String t_path=String(L"libs/",5)+bb_os_StripDir(t_lib);
				CopyFile(t_lib,t_path);
				p_AddBuildFile(t_path);
			}else{
				if(t_7==String(L"framework",9)){
					if(FileType(t_lib)==2){
						String t_path2=String(L"libs/",5)+bb_os_StripDir(t_lib);
						bb_os_CopyDir(t_lib,t_path2,true,false);
					}
					p_AddBuildFile(t_lib);
				}else{
					bb_transcc_Die(String(L"Unrecognized lib file type:",27)+t_lib);
				}
			}
		}
	}
	p_MungProj2();
	if(!m_tcc->m_opt_build){
		return;
	}
	p_Execute(String(L"xcodebuild -configuration ",26)+m_casedConfig+String(L" -sdk iphonesimulator",21),true);
	if(!m_tcc->m_opt_run){
		return;
	}
	String t_src=String(L"build/",6)+m_casedConfig+String(L"-iphonesimulator/CerberusGame.app",33);
	if(FileType(t_sim_path)==2){
		bbPrint(String(L"Installing GerberusGame.app",27));
		p_Execute(String(L"xcrun simctl install booted \"",29)+t_src+String(L"\"",1),true);
		bbPrint(String(L"Running CerberusGame.app",24));
		p_Execute(String(L"xcrun simctl launch booted com.yourcompany.CerberusGame",55),true);
		return;
	}
}
void c_IosBuilder::mark(){
	c_Builder::mark();
}
c_FlashBuilder::c_FlashBuilder(){
}
c_FlashBuilder* c_FlashBuilder::m_new(c_TransCC* t_tcc){
	c_Builder::m_new(t_tcc);
	return this;
}
c_FlashBuilder* c_FlashBuilder::m_new2(){
	c_Builder::m_new2();
	return this;
}
bool c_FlashBuilder::p_IsValid(){
	return m_tcc->m_FLEX_PATH!=String();
}
void c_FlashBuilder::p_Begin(){
	bb_config_ENV_LANG=String(L"as",2);
	bb_translator__trans=((new c_AsTranslator)->m_new());
}
String c_FlashBuilder::p_Assets(){
	c_StringStack* t_assets=(new c_StringStack)->m_new2();
	c_NodeEnumerator3* t_=m_dataFiles->p_ObjectEnumerator();
	while(t_->p_HasNext()){
		c_Node2* t_kv=t_->p_NextObject();
		String t_ext=bb_os_ExtractExt(t_kv->p_Value());
		String t_munged=String(L"_",1);
		Array<String > t_2=bb_os_StripExt(t_kv->p_Value()).Split(String(L"/",1));
		int t_3=0;
		while(t_3<t_2.Length()){
			String t_q=t_2[t_3];
			t_3=t_3+1;
			for(int t_i=0;t_i<t_q.Length();t_i=t_i+1){
				if(((bb_config_IsAlpha((int)t_q[t_i]))!=0) || ((bb_config_IsDigit((int)t_q[t_i]))!=0) || (int)t_q[t_i]==95){
					continue;
				}
				bb_transcc_Die(String(L"Invalid character in flash filename: ",37)+t_kv->p_Value()+String(L".",1));
			}
			t_munged=t_munged+(String(t_q.Length())+t_q);
		}
		t_munged=t_munged+(String(t_ext.Length())+t_ext);
		String t_1=t_ext.ToLower();
		if(t_1==String(L"png",3) || t_1==String(L"jpg",3) || t_1==String(L"mp3",3)){
			t_assets->p_Push(String(L"[Embed(source=\"data/",20)+t_kv->p_Value()+String(L"\")]",3));
			t_assets->p_Push(String(L"public static var ",18)+t_munged+String(L":Class;",7));
		}else{
			t_assets->p_Push(String(L"[Embed(source=\"data/",20)+t_kv->p_Value()+String(L"\",mimeType=\"application/octet-stream\")]",39));
			t_assets->p_Push(String(L"public static var ",18)+t_munged+String(L":Class;",7));
		}
	}
	return t_assets->p_Join(String(L"\n",1));
}
String c_FlashBuilder::p_Config(){
	c_StringStack* t_config=(new c_StringStack)->m_new2();
	c_NodeEnumerator3* t_=bb_config_GetConfigVars()->p_ObjectEnumerator();
	while(t_->p_HasNext()){
		c_Node2* t_kv=t_->p_NextObject();
		t_config->p_Push(String(L"internal static var ",20)+t_kv->p_Key()+String(L":String=",8)+bb_config_Enquote(t_kv->p_Value(),String(L"as",2)));
	}
	return t_config->p_Join(String(L"\n",1));
}
void c_FlashBuilder::p_MakeTarget(){
	p_CreateDataDir(String(L"data",4));
	String t_main=LoadString(String(L"CerberusGame.as",15));
	t_main=bb_transcc_ReplaceBlock(t_main,String(L"TRANSCODE",9),m_transCode,String(L"\n//",3));
	t_main=bb_transcc_ReplaceBlock(t_main,String(L"ASSETS",6),p_Assets(),String(L"\n//",3));
	t_main=bb_transcc_ReplaceBlock(t_main,String(L"CONFIG",6),p_Config(),String(L"\n//",3));
	SaveString(t_main,String(L"CerberusGame.as",15));
	if(m_tcc->m_opt_build){
		String t_cc_opts=String(L" -static-link-runtime-shared-libraries=true",43);
		if(bb_config_ENV_CONFIG==String(L"debug",5)){
			t_cc_opts=t_cc_opts+String(L" -debug=true",12);
		}
		DeleteFile(String(L"main.swf",8));
		p_CopyIcon(bb_config_GetConfigVar(String(L"FLASH_APP_ICON",14)),CurrentDir()+String(L"\\favicon.ico",12));
		p_Execute(String(L"mxmlc",5)+t_cc_opts+String(L" CerberusGame.as",16),true);
		if(m_tcc->m_opt_run){
			if((m_tcc->m_FLASH_PLAYER).Length()!=0){
				p_Execute(m_tcc->m_FLASH_PLAYER+String(L" \"",2)+RealPath(String(L"CerberusGame.swf",16))+String(L"\"",1),false);
			}else{
				if((m_tcc->m_HTML_PLAYER).Length()!=0){
					p_Execute(m_tcc->m_HTML_PLAYER+String(L" \"",2)+RealPath(String(L"CerberusGame.html",17))+String(L"\"",1),false);
				}
			}
		}
	}
}
void c_FlashBuilder::mark(){
	c_Builder::mark();
}
c_PsmBuilder::c_PsmBuilder(){
}
c_PsmBuilder* c_PsmBuilder::m_new(c_TransCC* t_tcc){
	c_Builder::m_new(t_tcc);
	return this;
}
c_PsmBuilder* c_PsmBuilder::m_new2(){
	c_Builder::m_new2();
	return this;
}
bool c_PsmBuilder::p_IsValid(){
	String t_4=HostOS();
	if(t_4==String(L"winnt",5)){
		if(((m_tcc->m_PSM_PATH).Length()!=0) && FileType(m_tcc->m_PSM_PATH+String(L"/tools/PsmStudio/bin/mdtool.exe",31))==1){
			return true;
		}
	}
	return false;
}
void c_PsmBuilder::p_Begin(){
	bb_config_ENV_LANG=String(L"cs",2);
	bb_translator__trans=((new c_CsTranslator)->m_new());
}
String c_PsmBuilder::p_Content(){
	c_StringStack* t_cont=(new c_StringStack)->m_new2();
	c_NodeEnumerator3* t_=m_dataFiles->p_ObjectEnumerator();
	while(t_->p_HasNext()){
		c_Node2* t_kv=t_->p_NextObject();
		String t_p=t_kv->p_Key();
		String t_r=t_kv->p_Value();
		String t_f=bb_os_StripDir(t_r);
		String t_t=(String(L"data/",5)+t_r).Replace(String(L"/",1),String(L"\\",1));
		String t_ext=bb_os_ExtractExt(t_r).ToLower();
		if(bb_transcc_MatchPath(t_r,m_TEXT_FILES)){
			t_cont->p_Push(String(L"    <Content Include=\"",22)+t_t+String(L"\">",2));
			t_cont->p_Push(String(L"      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>",67));
			t_cont->p_Push(String(L"    </Content>",14));
		}else{
			if(bb_transcc_MatchPath(t_r,m_IMAGE_FILES)){
				String t_1=t_ext;
				if(t_1==String(L"png",3) || t_1==String(L"jpg",3) || t_1==String(L"bmp",3) || t_1==String(L"gif",3)){
					t_cont->p_Push(String(L"    <Content Include=\"",22)+t_t+String(L"\">",2));
					t_cont->p_Push(String(L"      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>",67));
					t_cont->p_Push(String(L"    </Content>",14));
				}else{
					bb_transcc_Die(String(L"Invalid image file type",23));
				}
			}else{
				if(bb_transcc_MatchPath(t_r,m_SOUND_FILES)){
					String t_2=t_ext;
					if(t_2==String(L"wav",3)){
						t_cont->p_Push(String(L"    <Content Include=\"",22)+t_t+String(L"\">",2));
						t_cont->p_Push(String(L"      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>",67));
						t_cont->p_Push(String(L"    </Content>",14));
					}else{
						bb_transcc_Die(String(L"Invalid sound file type",23));
					}
				}else{
					if(bb_transcc_MatchPath(t_r,m_MUSIC_FILES)){
						String t_3=t_ext;
						if(t_3==String(L"mp3",3)){
							t_cont->p_Push(String(L"    <Content Include=\"",22)+t_t+String(L"\">",2));
							t_cont->p_Push(String(L"      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>",67));
							t_cont->p_Push(String(L"    </Content>",14));
						}else{
							bb_transcc_Die(String(L"Invalid music file type",23));
						}
					}else{
						if(bb_transcc_MatchPath(t_r,m_BINARY_FILES)){
							t_cont->p_Push(String(L"    <Content Include=\"",22)+t_t+String(L"\">",2));
							t_cont->p_Push(String(L"      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>",67));
							t_cont->p_Push(String(L"    </Content>",14));
						}
					}
				}
			}
		}
	}
	return t_cont->p_Join(String(L"\n",1));
}
String c_PsmBuilder::p_Config(){
	c_StringStack* t_config=(new c_StringStack)->m_new2();
	c_NodeEnumerator3* t_=bb_config_GetConfigVars()->p_ObjectEnumerator();
	while(t_->p_HasNext()){
		c_Node2* t_kv=t_->p_NextObject();
		t_config->p_Push(String(L"public const String ",20)+t_kv->p_Key()+String(L"=",1)+bb_config_Enquote(t_kv->p_Value(),String(L"cs",2))+String(L";",1));
	}
	return t_config->p_Join(String(L"\n",1));
}
void c_PsmBuilder::p_MakeTarget(){
	p_CreateDataDir(String(L"data",4));
	String t_proj=LoadString(String(L"CerberusGame.csproj",19));
	t_proj=bb_transcc_ReplaceBlock(t_proj,String(L"CONTENT",7),p_Content(),String(L"\n<!-- ",6));
	SaveString(t_proj,String(L"CerberusGame.csproj",19));
	String t_main=LoadString(String(L"CerberusGame.cs",15));
	t_main=bb_transcc_ReplaceBlock(t_main,String(L"TRANSCODE",9),m_transCode,String(L"\n//",3));
	t_main=bb_transcc_ReplaceBlock(t_main,String(L"CONFIG",6),p_Config(),String(L"\n//",3));
	SaveString(t_main,String(L"CerberusGame.cs",15));
	if(m_tcc->m_opt_build){
		if(m_tcc->m_opt_run){
			p_Execute(String(L"\"",1)+m_tcc->m_PSM_PATH+String(L"/tools/PsmStudio/bin/mdtool\" psm windows run-project CerberusGame.sln",69),true);
		}
	}
}
void c_PsmBuilder::mark(){
	c_Builder::mark();
}
c_StdcppBuilder::c_StdcppBuilder(){
}
c_StdcppBuilder* c_StdcppBuilder::m_new(c_TransCC* t_tcc){
	c_Builder::m_new(t_tcc);
	return this;
}
c_StdcppBuilder* c_StdcppBuilder::m_new2(){
	c_Builder::m_new2();
	return this;
}
bool c_StdcppBuilder::p_IsValid(){
	String t_1=HostOS();
	if(t_1==String(L"winnt",5)){
		if((m_tcc->m_MINGW_PATH).Length()!=0){
			return true;
		}
	}else{
		return true;
	}
	return false;
}
void c_StdcppBuilder::p_Begin(){
	bb_config_ENV_LANG=String(L"cpp",3);
	bb_translator__trans=((new c_CppTranslator)->m_new());
}
String c_StdcppBuilder::p_Config(){
	c_StringStack* t_config=(new c_StringStack)->m_new2();
	c_NodeEnumerator3* t_=bb_config_GetConfigVars()->p_ObjectEnumerator();
	while(t_->p_HasNext()){
		c_Node2* t_kv=t_->p_NextObject();
		t_config->p_Push(String(L"#define CFG_",12)+t_kv->p_Key()+String(L" ",1)+t_kv->p_Value());
	}
	return t_config->p_Join(String(L"\n",1));
}
void c_StdcppBuilder::p_MakeTarget(){
	String t_2=bb_config_ENV_CONFIG;
	if(t_2==String(L"debug",5)){
		bb_config_SetConfigVar2(String(L"DEBUG",5),String(L"1",1));
	}else{
		if(t_2==String(L"release",7)){
			bb_config_SetConfigVar2(String(L"RELEASE",7),String(L"1",1));
		}else{
			if(t_2==String(L"profile",7)){
				bb_config_SetConfigVar2(String(L"PROFILE",7),String(L"1",1));
			}
		}
	}
	p_CopySourceFiles(String(L".",1));
	String t_main=LoadString(String(L"main.cpp",8));
	t_main=bb_transcc_ReplaceBlock(t_main,String(L"TRANSCODE",9),m_transCode,String(L"\n//",3));
	t_main=bb_transcc_ReplaceBlock(t_main,String(L"CONFIG",6),p_Config(),String(L"\n//",3));
	SaveString(t_main,String(L"main.cpp",8));
	if(m_tcc->m_opt_build){
		String t_out=String(L"main_",5)+HostOS();
		DeleteFile(t_out);
		String t_OPTS=String();
		String t_LIBS=String();
		String t_3=bb_config_ENV_HOST;
		if(t_3==String(L"winnt",5)){
			t_OPTS=t_OPTS+String(L" -Wno-free-nonheap-object",25);
			t_LIBS=t_LIBS+String(L" -lwinmm -lws2_32",17);
		}else{
			if(t_3==String(L"macos",5)){
				t_OPTS=t_OPTS+String(L" -Wno-parentheses -Wno-dangling-else",36);
				t_OPTS=t_OPTS+String(L" -mmacosx-version-min=10.9 -std=gnu++0x -stdlib=libc++",54);
			}else{
				if(t_3==String(L"linux",5)){
					t_OPTS=t_OPTS+String(L" -Wno-unused-result",19);
					t_LIBS=t_LIBS+String(L" -lpthread",10);
				}
			}
		}
		String t_4=bb_config_ENV_CONFIG;
		if(t_4==String(L"debug",5)){
			t_OPTS=t_OPTS+String(L" -O0",4);
		}else{
			if(t_4==String(L"release",7)){
				t_OPTS=t_OPTS+String(L" -O3 -DNDEBUG",13);
			}
		}
		String t_cc_opts=bb_config_GetConfigVar(String(L"CC_OPTS",7));
		if((t_cc_opts).Length()!=0){
			t_OPTS=t_OPTS+(String(L" ",1)+t_cc_opts.Replace(String(L";",1),String(L" ",1)));
		}
		String t_cc_libs=bb_config_GetConfigVar(String(L"CC_LIBS",7));
		if((t_cc_libs).Length()!=0){
			t_LIBS=t_LIBS+(String(L" ",1)+t_cc_libs.Replace(String(L";",1),String(L" ",1)));
		}
		if(HostOS()==String(L"macos",5)){
			p_Execute(String(L"clang++",7)+t_OPTS+String(L" -o ",4)+t_out+String(L" main.cpp",9)+t_LIBS,true);
		}else{
			p_Execute(String(L"g++",3)+t_OPTS+String(L" -o ",4)+t_out+String(L" main.cpp",9)+t_LIBS,true);
		}
		if(m_tcc->m_opt_run){
			p_Execute(String(L"\"",1)+RealPath(t_out)+String(L"\"",1),true);
		}
	}
}
void c_StdcppBuilder::mark(){
	c_Builder::mark();
}
c_WinrtBuilder::c_WinrtBuilder(){
}
c_WinrtBuilder* c_WinrtBuilder::m_new(c_TransCC* t_tcc){
	c_Builder::m_new(t_tcc);
	return this;
}
c_WinrtBuilder* c_WinrtBuilder::m_new2(){
	c_Builder::m_new2();
	return this;
}
bool c_WinrtBuilder::p_IsValid(){
	String t_1=HostOS();
	if(t_1==String(L"winnt",5)){
		if((m_tcc->m_MSBUILD_PATH).Length()!=0){
			return true;
		}
	}
	return false;
}
void c_WinrtBuilder::p_Begin(){
	bb_config_ENV_LANG=String(L"cpp",3);
	bb_translator__trans=((new c_CppTranslator)->m_new());
}
String c_WinrtBuilder::p_Content2(bool t_csharp){
	c_StringStack* t_cont=(new c_StringStack)->m_new2();
	c_NodeEnumerator3* t_=m_dataFiles->p_ObjectEnumerator();
	while(t_->p_HasNext()){
		c_Node2* t_kv=t_->p_NextObject();
		if(t_csharp){
			t_cont->p_Push(String(L"    <Content Include=\"Assets\\cerberus\\",38)+t_kv->p_Value().Replace(String(L"/",1),String(L"\\",1))+String(L"\">",2));
			t_cont->p_Push(String(L"      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>",67));
			t_cont->p_Push(String(L"    </Content>",14));
		}else{
			t_cont->p_Push(String(L"    <None Include=\"Assets\\cerberus\\",35)+t_kv->p_Value().Replace(String(L"/",1),String(L"\\",1))+String(L"\">",2));
			t_cont->p_Push(String(L"      <DeploymentContent>true</DeploymentContent>",49));
			t_cont->p_Push(String(L"    </None>",11));
		}
	}
	return t_cont->p_Join(String(L"\n",1));
}
String c_WinrtBuilder::p_Config(){
	c_StringStack* t_config=(new c_StringStack)->m_new2();
	c_NodeEnumerator3* t_=bb_config_GetConfigVars()->p_ObjectEnumerator();
	while(t_->p_HasNext()){
		c_Node2* t_kv=t_->p_NextObject();
		t_config->p_Push(String(L"#define CFG_",12)+t_kv->p_Key()+String(L" ",1)+t_kv->p_Value());
	}
	return t_config->p_Join(String(L"\n",1));
}
void c_WinrtBuilder::p_MakeTarget(){
	p_CreateDataDir(String(L"Assets/cerberus",15));
	String t_proj=LoadString(String(L"CerberusGame.vcxproj",20));
	if((t_proj).Length()!=0){
		t_proj=bb_transcc_ReplaceBlock(t_proj,String(L"CONTENT",7),p_Content2(false),String(L"\n    <!-- ",10));
		SaveString(t_proj,String(L"CerberusGame.vcxproj",20));
	}else{
		String t_proj2=LoadString(String(L"CerberusGame.csproj",19));
		t_proj2=bb_transcc_ReplaceBlock(t_proj2,String(L"CONTENT",7),p_Content2(true),String(L"\n    <!-- ",10));
		SaveString(t_proj2,String(L"CerberusGame.csproj",19));
	}
	String t_main=LoadString(String(L"CerberusGame.cpp",16));
	t_main=bb_transcc_ReplaceBlock(t_main,String(L"TRANSCODE",9),m_transCode,String(L"\n//",3));
	t_main=bb_transcc_ReplaceBlock(t_main,String(L"CONFIG",6),p_Config(),String(L"\n//",3));
	SaveString(t_main,String(L"CerberusGame.cpp",16));
	if(m_tcc->m_opt_build){
		p_Execute(String(L"\"",1)+m_tcc->m_MSBUILD_PATH+String(L"\" /p:Configuration=",19)+m_casedConfig+String(L" /p:Platform=Win32 CerberusGame.sln",35),true);
		if(m_tcc->m_opt_run){
		}
	}
}
void c_WinrtBuilder::mark(){
	c_Builder::mark();
}
c_XnaBuilder::c_XnaBuilder(){
}
c_XnaBuilder* c_XnaBuilder::m_new(c_TransCC* t_tcc){
	c_Builder::m_new(t_tcc);
	return this;
}
c_XnaBuilder* c_XnaBuilder::m_new2(){
	c_Builder::m_new2();
	return this;
}
bool c_XnaBuilder::p_IsValid(){
	String t_4=HostOS();
	if(t_4==String(L"winnt",5)){
		if((m_tcc->m_MSBUILD_PATH).Length()!=0){
			return true;
		}
	}
	return false;
}
void c_XnaBuilder::p_Begin(){
	bb_config_ENV_LANG=String(L"cs",2);
	bb_translator__trans=((new c_CsTranslator)->m_new());
}
String c_XnaBuilder::p_Content(){
	c_StringStack* t_cont=(new c_StringStack)->m_new2();
	c_NodeEnumerator3* t_=m_dataFiles->p_ObjectEnumerator();
	while(t_->p_HasNext()){
		c_Node2* t_kv=t_->p_NextObject();
		String t_p=t_kv->p_Key();
		String t_r=t_kv->p_Value();
		String t_f=bb_os_StripDir(t_r);
		String t_t=(String(L"cerberus/",9)+t_r).Replace(String(L"/",1),String(L"\\",1));
		String t_ext=bb_os_ExtractExt(t_r).ToLower();
		if(bb_transcc_MatchPath(t_r,m_TEXT_FILES)){
			t_cont->p_Push(String(L"  <ItemGroup>",13));
			t_cont->p_Push(String(L"    <Content Include=\"",22)+t_t+String(L"\">",2));
			t_cont->p_Push(String(L"      <Name>",12)+t_f+String(L"</Name>",7));
			t_cont->p_Push(String(L"      <CopyToOutputDirectory>Always</CopyToOutputDirectory>",59));
			t_cont->p_Push(String(L"    </Content>",14));
			t_cont->p_Push(String(L"  </ItemGroup>",14));
		}else{
			if(bb_transcc_MatchPath(t_r,m_IMAGE_FILES)){
				String t_1=t_ext;
				if(t_1==String(L"bmp",3) || t_1==String(L"dds",3) || t_1==String(L"dib",3) || t_1==String(L"hdr",3) || t_1==String(L"jpg",3) || t_1==String(L"pfm",3) || t_1==String(L"png",3) || t_1==String(L"ppm",3) || t_1==String(L"tga",3)){
					t_cont->p_Push(String(L"  <ItemGroup>",13));
					t_cont->p_Push(String(L"    <Compile Include=\"",22)+t_t+String(L"\">",2));
					t_cont->p_Push(String(L"      <Name>",12)+t_f+String(L"</Name>",7));
					t_cont->p_Push(String(L"      <Importer>TextureImporter</Importer>",42));
					t_cont->p_Push(String(L"      <Processor>TextureProcessor</Processor>",45));
					t_cont->p_Push(String(L"      <ProcessorParameters_ColorKeyEnabled>False</ProcessorParameters_ColorKeyEnabled>",86));
					t_cont->p_Push(String(L"      <ProcessorParameters_PremultiplyAlpha>False</ProcessorParameters_PremultiplyAlpha>",88));
					t_cont->p_Push(String(L"\t   </Compile>",14));
					t_cont->p_Push(String(L"  </ItemGroup>",14));
				}else{
					bb_transcc_Die(String(L"Invalid image file type",23));
				}
			}else{
				if(bb_transcc_MatchPath(t_r,m_SOUND_FILES)){
					String t_2=t_ext;
					if(t_2==String(L"wav",3) || t_2==String(L"mp3",3) || t_2==String(L"wma",3)){
						String t_imp=t_ext.Slice(0,1).ToUpper()+t_ext.Slice(1)+String(L"Importer",8);
						t_cont->p_Push(String(L"  <ItemGroup>",13));
						t_cont->p_Push(String(L"    <Compile Include=\"",22)+t_t+String(L"\">",2));
						t_cont->p_Push(String(L"      <Name>",12)+t_f+String(L"</Name>",7));
						t_cont->p_Push(String(L"      <Importer>",16)+t_imp+String(L"</Importer>",11));
						t_cont->p_Push(String(L"      <Processor>SoundEffectProcessor</Processor>",49));
						t_cont->p_Push(String(L"\t   </Compile>",14));
						t_cont->p_Push(String(L"  </ItemGroup>",14));
					}else{
						bb_transcc_Die(String(L"Invalid sound file type",23));
					}
				}else{
					if(bb_transcc_MatchPath(t_r,m_MUSIC_FILES)){
						String t_3=t_ext;
						if(t_3==String(L"wav",3) || t_3==String(L"mp3",3) || t_3==String(L"wma",3)){
							String t_imp2=t_ext.Slice(0,1).ToUpper()+t_ext.Slice(1)+String(L"Importer",8);
							t_cont->p_Push(String(L"  <ItemGroup>",13));
							t_cont->p_Push(String(L"    <Compile Include=\"",22)+t_t+String(L"\">",2));
							t_cont->p_Push(String(L"      <Name>",12)+t_f+String(L"</Name>",7));
							t_cont->p_Push(String(L"      <Importer>",16)+t_imp2+String(L"</Importer>",11));
							t_cont->p_Push(String(L"      <Processor>SongProcessor</Processor>",42));
							t_cont->p_Push(String(L"\t   </Compile>",14));
							t_cont->p_Push(String(L"  </ItemGroup>",14));
						}else{
							bb_transcc_Die(String(L"Invalid music file type",23));
						}
					}else{
						if(bb_transcc_MatchPath(t_r,m_BINARY_FILES)){
							t_cont->p_Push(String(L"  <ItemGroup>",13));
							t_cont->p_Push(String(L"    <Content Include=\"",22)+t_t+String(L"\">",2));
							t_cont->p_Push(String(L"      <Name>",12)+t_f+String(L"</Name>",7));
							t_cont->p_Push(String(L"      <CopyToOutputDirectory>Always</CopyToOutputDirectory>",59));
							t_cont->p_Push(String(L"    </Content>",14));
							t_cont->p_Push(String(L"  </ItemGroup>",14));
						}
					}
				}
			}
		}
	}
	return t_cont->p_Join(String(L"\n",1));
}
String c_XnaBuilder::p_Config(){
	c_StringStack* t_config=(new c_StringStack)->m_new2();
	c_NodeEnumerator3* t_=bb_config_GetConfigVars()->p_ObjectEnumerator();
	while(t_->p_HasNext()){
		c_Node2* t_kv=t_->p_NextObject();
		t_config->p_Push(String(L"public const String ",20)+t_kv->p_Key()+String(L"=",1)+bb_config_Enquote(t_kv->p_Value(),String(L"cs",2))+String(L";",1));
	}
	return t_config->p_Join(String(L"\n",1));
}
void c_XnaBuilder::p_MakeTarget(){
	p_CreateDataDir(String(L"CerberusGame/CerberusGameContent/cerberus",41));
	String t_contproj=LoadString(String(L"CerberusGame/CerberusGameContent/CerberusGameContent.contentproj",64));
	t_contproj=bb_transcc_ReplaceBlock(t_contproj,String(L"CONTENT",7),p_Content(),String(L"\n<!-- ",6));
	SaveString(t_contproj,String(L"CerberusGame/CerberusGameContent/CerberusGameContent.contentproj",64));
	String t_main=LoadString(String(L"CerberusGame/CerberusGame/Program.cs",36));
	t_main=bb_transcc_ReplaceBlock(t_main,String(L"TRANSCODE",9),m_transCode,String(L"\n//",3));
	t_main=bb_transcc_ReplaceBlock(t_main,String(L"CONFIG",6),p_Config(),String(L"\n//",3));
	SaveString(t_main,String(L"CerberusGame/CerberusGame/Program.cs",36));
	if(m_tcc->m_opt_build){
		p_Execute(String(L"\"",1)+m_tcc->m_MSBUILD_PATH+String(L"\" /t:CerberusGame /p:Configuration=",35)+m_casedConfig+String(L" CerberusGame.sln",17),true);
		if(m_tcc->m_opt_run){
			ChangeDir(String(L"CerberusGame/CerberusGame/bin/x86/",34)+m_casedConfig);
			p_Execute(String(L"CerberusGame",12),false);
		}
	}
}
void c_XnaBuilder::mark(){
	c_Builder::mark();
}
c_AGKBuilder::c_AGKBuilder(){
}
c_AGKBuilder* c_AGKBuilder::m_new(c_TransCC* t_tcc){
	c_Builder::m_new(t_tcc);
	return this;
}
c_AGKBuilder* c_AGKBuilder::m_new2(){
	c_Builder::m_new2();
	return this;
}
bool c_AGKBuilder::p_IsValid(){
	String t_1=HostOS();
	if(t_1==String(L"winnt",5)){
		if(FileType(m_tcc->m_AGK_PATH+String(L"/Tier 1/Compiler/AGKBroadcaster.exe",35))==1 && ((m_tcc->m_MSBUILD_PATH).Length()!=0)){
			return true;
		}
	}else{
		if(t_1==String(L"macos",5)){
			if(FileType(m_tcc->m_AGK_PATH+String(L"/AppGameKit.app",15))==2){
				return true;
			}
		}else{
			return true;
		}
	}
	return false;
}
void c_AGKBuilder::p_Begin(){
	bb_config_ENV_LANG=String(L"cpp",3);
	bb_translator__trans=((new c_CppTranslator)->m_new());
}
String c_AGKBuilder::p_Config(){
	c_StringStack* t_config=(new c_StringStack)->m_new2();
	int t_l=0;
	c_NodeEnumerator3* t_=bb_config_GetConfigVars()->p_ObjectEnumerator();
	while(t_->p_HasNext()){
		c_Node2* t_kv=t_->p_NextObject();
		if(t_kv->p_Key().StartsWith(String(L"AGK_",4))){
			t_l=t_kv->p_Key().Length();
			t_config->p_Push(String(L"#define ",8)+t_kv->p_Key().Slice(4,t_l)+String(L" ",1)+t_kv->p_Value());
		}else{
			t_config->p_Push(String(L"#define CFG_",12)+t_kv->p_Key()+String(L" ",1)+t_kv->p_Value());
		}
	}
	t_config->p_Push(String(L"#define WINDOW_TITLE \"CerberusGame\"",35));
	return t_config->p_Join(String(L"\n",1));
}
void c_AGKBuilder::p_CreateMediaDir(String t_dir){
	t_dir=RealPath(t_dir);
	if(!m_syncData){
		bb_os_DeleteDir(t_dir,true);
	}
	CreateDir(t_dir);
	if(FileType(t_dir)!=2){
		bb_transcc_Die(String(L"Failed to create target project data dir: ",42)+t_dir);
	}
	String t_dataPath=bb_os_ExtractDir(bb_os_StripExt(m_tcc->m_opt_srcpath))+String(L"/media",6);
	if(FileType(t_dataPath)!=2){
		t_dataPath=String();
	}
	c_StringSet* t_udata=(new c_StringSet)->m_new();
	if((t_dataPath).Length()!=0){
		c_StringStack* t_srcs=(new c_StringStack)->m_new2();
		t_srcs->p_Push(t_dataPath);
		while(!t_srcs->p_IsEmpty()){
			String t_src=t_srcs->p_Pop();
			Array<String > t_=LoadDir(t_src);
			int t_2=0;
			while(t_2<t_.Length()){
				String t_f=t_[t_2];
				t_2=t_2+1;
				if(t_f.StartsWith(String(L".",1))){
					continue;
				}
				String t_p=t_src+String(L"/",1)+t_f;
				String t_r=t_p.Slice(t_dataPath.Length()+1);
				String t_t=t_dir+String(L"/",1)+t_r;
				int t_3=FileType(t_p);
				if(t_3==1){
					if(bb_transcc_MatchPath(t_r,m_DATA_FILES)){
						p_CCopyFile(t_p,t_t);
						t_udata->p_Insert(t_t);
						m_dataFiles->p_Set2(t_p,t_r);
					}
				}else{
					if(t_3==2){
						CreateDir(t_t);
						t_srcs->p_Push(t_p);
					}
				}
			}
		}
	}
	c_Enumerator* t_4=m_app->m_fileImports->p_ObjectEnumerator();
	while(t_4->p_HasNext()){
		String t_p2=t_4->p_NextObject();
		String t_r2=bb_os_StripDir(t_p2);
		String t_t2=t_dir+String(L"/",1)+t_r2;
		if(bb_transcc_MatchPath(t_r2,m_DATA_FILES)){
			p_CCopyFile(t_p2,t_t2);
			t_udata->p_Insert(t_t2);
			m_dataFiles->p_Set2(t_p2,t_r2);
		}
	}
	if((t_dataPath).Length()!=0){
		c_StringStack* t_dsts=(new c_StringStack)->m_new2();
		t_dsts->p_Push(t_dir);
		while(!t_dsts->p_IsEmpty()){
			String t_dst=t_dsts->p_Pop();
			Array<String > t_5=LoadDir(t_dst);
			int t_6=0;
			while(t_6<t_5.Length()){
				String t_f2=t_5[t_6];
				t_6=t_6+1;
				if(t_f2.StartsWith(String(L".",1))){
					continue;
				}
				String t_p3=t_dst+String(L"/",1)+t_f2;
				String t_r3=t_p3.Slice(t_dir.Length()+1);
				String t_t3=t_dataPath+String(L"/",1)+t_r3;
				int t_42=FileType(t_p3);
				if(t_42==1){
					if(!t_udata->p_Contains(t_p3)){
						DeleteFile(t_p3);
					}
				}else{
					if(t_42==2){
						if(FileType(t_t3)==2){
							t_dsts->p_Push(t_p3);
						}else{
							bb_os_DeleteDir(t_p3,true);
						}
					}
				}
			}
		}
	}
}
void c_AGKBuilder::p_MakeVc2017(){
	String t_buildpath=String();
	t_buildpath=CurrentDir()+String(L"\\AGKTemplate\\apps\\template_windows_vs2017_64",44);
	String t_template=LoadString(t_buildpath+String(L"\\template.cpp",13));
	String t_templateh=LoadString(t_buildpath+String(L"\\template.h",11));
	t_template=bb_transcc_ReplaceBlock(t_template,String(L"TRANSCODE",9),m_transCode,String(L"\n//",3));
	t_templateh=bb_transcc_ReplaceBlock(t_templateh,String(L"CONFIG",6),p_Config(),String(L"\n//",3));
	SaveString(t_template,t_buildpath+String(L"\\template.cpp",13));
	SaveString(t_templateh,t_buildpath+String(L"\\template.h",11));
	p_CreateMediaDir(t_buildpath+String(L"\\Final\\media",12));
	if(m_tcc->m_opt_build){
		p_Execute(String(L"\"",1)+m_tcc->m_MSBUILD_PATH+String(L"\" /p:Configuration=",19)+m_casedConfig+String(L" ",1)+t_buildpath+String(L"\\Template.sln",13),true);
		if(m_tcc->m_opt_run){
			ChangeDir(t_buildpath+String(L"\\Final",6));
			p_Execute(String(L"Template64",10),true);
		}
	}
}
void c_AGKBuilder::p_MakeXcode(){
	String t_buildpath=String();
	t_buildpath=CurrentDir()+String(L"/AGKTemplate/apps/template_mac",30);
	String t_template=LoadString(t_buildpath+String(L"/template.cpp",13));
	String t_templateh=LoadString(t_buildpath+String(L"/template.h",11));
	t_template=bb_transcc_ReplaceBlock(t_template,String(L"TRANSCODE",9),m_transCode,String(L"\n//",3));
	t_templateh=bb_transcc_ReplaceBlock(t_templateh,String(L"CONFIG",6),p_Config(),String(L"\n//",3));
	SaveString(t_template,t_buildpath+String(L"/template.cpp",13));
	SaveString(t_templateh,t_buildpath+String(L"/template.h",11));
	p_CreateMediaDir(t_buildpath+String(L"/media",6));
	if(m_tcc->m_opt_build){
		ChangeDir(t_buildpath);
		p_Execute(String(L"xcodebuild -configuration ",26)+m_casedConfig+String(L" PRODUCT_NAME=CerberusGame",26),true);
		if(m_tcc->m_opt_run){
			ChangeDir(t_buildpath+String(L"/build/",7)+m_casedConfig);
			ChangeDir(String(L"CerberusGame.app/Contents/MacOS",31));
			p_Execute(String(L"./CerberusGame",14),true);
		}
	}
}
void c_AGKBuilder::p_MakeTarget(){
	String t_2=HostOS();
	if(t_2==String(L"winnt",5)){
		p_MakeVc2017();
	}else{
		if(t_2==String(L"macos",5)){
			p_MakeXcode();
		}
	}
}
void c_AGKBuilder::mark(){
	c_Builder::mark();
}
c_AGKBuilder_ios::c_AGKBuilder_ios(){
}
c_AGKBuilder_ios* c_AGKBuilder_ios::m_new(c_TransCC* t_tcc){
	c_Builder::m_new(t_tcc);
	return this;
}
c_AGKBuilder_ios* c_AGKBuilder_ios::m_new2(){
	c_Builder::m_new2();
	return this;
}
bool c_AGKBuilder_ios::p_IsValid(){
	String t_1=HostOS();
	if(t_1==String(L"macos",5)){
		if(FileType(m_tcc->m_AGK_PATH+String(L"/AppGameKit.app",15))==2){
			return true;
		}
	}
	return false;
}
void c_AGKBuilder_ios::p_Begin(){
	bb_config_ENV_LANG=String(L"cpp",3);
	bb_translator__trans=((new c_CppTranslator)->m_new());
}
String c_AGKBuilder_ios::p_Config(){
	c_StringStack* t_config=(new c_StringStack)->m_new2();
	int t_l=0;
	c_NodeEnumerator3* t_=bb_config_GetConfigVars()->p_ObjectEnumerator();
	while(t_->p_HasNext()){
		c_Node2* t_kv=t_->p_NextObject();
		if(t_kv->p_Key().StartsWith(String(L"AGK_",4))){
			t_config->p_Push(String(L"#define ",8)+t_kv->p_Key()+String(L" ",1)+t_kv->p_Value());
		}else{
			t_config->p_Push(String(L"#define CFG_",12)+t_kv->p_Key()+String(L" ",1)+t_kv->p_Value());
		}
	}
	return t_config->p_Join(String(L"\n",1));
}
void c_AGKBuilder_ios::p_CreateMediaDir(String t_dir){
	t_dir=RealPath(t_dir);
	if(!m_syncData){
		bb_os_DeleteDir(t_dir,true);
	}
	CreateDir(t_dir);
	if(FileType(t_dir)!=2){
		bb_transcc_Die(String(L"Failed to create target project data dir: ",42)+t_dir);
	}
	String t_dataPath=bb_os_ExtractDir(bb_os_StripExt(m_tcc->m_opt_srcpath))+String(L"/media",6);
	if(FileType(t_dataPath)!=2){
		t_dataPath=String();
	}
	c_StringSet* t_udata=(new c_StringSet)->m_new();
	if((t_dataPath).Length()!=0){
		c_StringStack* t_srcs=(new c_StringStack)->m_new2();
		t_srcs->p_Push(t_dataPath);
		while(!t_srcs->p_IsEmpty()){
			String t_src=t_srcs->p_Pop();
			Array<String > t_=LoadDir(t_src);
			int t_2=0;
			while(t_2<t_.Length()){
				String t_f=t_[t_2];
				t_2=t_2+1;
				if(t_f.StartsWith(String(L".",1))){
					continue;
				}
				String t_p=t_src+String(L"/",1)+t_f;
				String t_r=t_p.Slice(t_dataPath.Length()+1);
				String t_t=t_dir+String(L"/",1)+t_r;
				int t_3=FileType(t_p);
				if(t_3==1){
					if(bb_transcc_MatchPath(t_r,m_DATA_FILES)){
						p_CCopyFile(t_p,t_t);
						t_udata->p_Insert(t_t);
						m_dataFiles->p_Set2(t_p,t_r);
					}
				}else{
					if(t_3==2){
						CreateDir(t_t);
						t_srcs->p_Push(t_p);
					}
				}
			}
		}
	}
	c_Enumerator* t_4=m_app->m_fileImports->p_ObjectEnumerator();
	while(t_4->p_HasNext()){
		String t_p2=t_4->p_NextObject();
		String t_r2=bb_os_StripDir(t_p2);
		String t_t2=t_dir+String(L"/",1)+t_r2;
		if(bb_transcc_MatchPath(t_r2,m_DATA_FILES)){
			p_CCopyFile(t_p2,t_t2);
			t_udata->p_Insert(t_t2);
			m_dataFiles->p_Set2(t_p2,t_r2);
		}
	}
	if((t_dataPath).Length()!=0){
		c_StringStack* t_dsts=(new c_StringStack)->m_new2();
		t_dsts->p_Push(t_dir);
		while(!t_dsts->p_IsEmpty()){
			String t_dst=t_dsts->p_Pop();
			Array<String > t_5=LoadDir(t_dst);
			int t_6=0;
			while(t_6<t_5.Length()){
				String t_f2=t_5[t_6];
				t_6=t_6+1;
				if(t_f2.StartsWith(String(L".",1))){
					continue;
				}
				String t_p3=t_dst+String(L"/",1)+t_f2;
				String t_r3=t_p3.Slice(t_dir.Length()+1);
				String t_t3=t_dataPath+String(L"/",1)+t_r3;
				int t_42=FileType(t_p3);
				if(t_42==1){
					if(!t_udata->p_Contains(t_p3)){
						DeleteFile(t_p3);
					}
				}else{
					if(t_42==2){
						if(FileType(t_t3)==2){
							t_dsts->p_Push(t_p3);
						}else{
							bb_os_DeleteDir(t_p3,true);
						}
					}
				}
			}
		}
	}
}
void c_AGKBuilder_ios::p_MakeXcode(){
	String t_sim_path=String(L"/Applications/Xcode.app/Contents/Developer/Applications/Simulator.app",69);
	if(m_tcc->m_opt_run==true){
		bbPrint(String(L"Starting iOS simulator...",25));
		p_Execute(String(L"open \"",6)+t_sim_path+String(L"\"",1),true);
	}
	String t_buildpath=String();
	t_buildpath=CurrentDir()+String(L"/AGKTemplate/apps/template_ios",30);
	bbPrint(String(L"buildpath= ",11)+t_buildpath);
	String t_template=LoadString(t_buildpath+String(L"/Classes/template.cpp",21));
	String t_templateh=LoadString(t_buildpath+String(L"/Classes/template.h",19));
	t_template=bb_transcc_ReplaceBlock(t_template,String(L"TRANSCODE",9),m_transCode,String(L"\n//",3));
	t_templateh=bb_transcc_ReplaceBlock(t_templateh,String(L"CONFIG",6),p_Config(),String(L"\n//",3));
	SaveString(t_template,t_buildpath+String(L"/Classes/template.cpp",21));
	SaveString(t_templateh,t_buildpath+String(L"/Classes/template.h",19));
	p_CreateMediaDir(t_buildpath+String(L"/media",6));
	if(m_tcc->m_opt_build){
		String t_src=t_buildpath+String(L"/build/",7)+m_casedConfig+String(L"/CerberusGame.app",17);
		ChangeDir(t_buildpath);
		p_Execute(String(L"xcodebuild -scheme agk_interpreter -configuration ",50)+m_casedConfig+String(L" -sdk iphonesimulator",21)+String(L" PRODUCT_NAME=CerberusGame",26)+String(L" BUILD_DIR=",11)+t_buildpath+String(L"/build",6),true);
		if(m_tcc->m_opt_run){
			bbPrint(String(L"Installing GerberusGame.app",27));
			p_Execute(String(L"xcrun simctl install booted \"",29)+t_src+String(L"\"",1),true);
			bbPrint(String(L"Running CerberusGame.app",24));
			p_Execute(String(L"xcrun simctl launch booted com.thegamecreators.AGKTemplate",58),true);
		}
	}
}
void c_AGKBuilder_ios::p_MakeTarget(){
	String t_2=HostOS();
	if(t_2==String(L"macos",5)){
		p_MakeXcode();
	}
}
void c_AGKBuilder_ios::mark(){
	c_Builder::mark();
}
c_StringMap3* bb_builders_Builders(c_TransCC* t_tcc){
	c_StringMap3* t_builders=(new c_StringMap3)->m_new();
	t_builders->p_Set3(String(L"android",7),((new c_AndroidBuilder)->m_new(t_tcc)));
	t_builders->p_Set3(String(L"android_ndk",11),((new c_AndroidNdkBuilder)->m_new(t_tcc)));
	t_builders->p_Set3(String(L"glfw",4),((new c_GlfwBuilder)->m_new(t_tcc)));
	t_builders->p_Set3(String(L"html5",5),((new c_Html5Builder)->m_new(t_tcc)));
	t_builders->p_Set3(String(L"ios",3),((new c_IosBuilder)->m_new(t_tcc)));
	t_builders->p_Set3(String(L"flash",5),((new c_FlashBuilder)->m_new(t_tcc)));
	t_builders->p_Set3(String(L"psm",3),((new c_PsmBuilder)->m_new(t_tcc)));
	t_builders->p_Set3(String(L"stdcpp",6),((new c_StdcppBuilder)->m_new(t_tcc)));
	t_builders->p_Set3(String(L"winrt",5),((new c_WinrtBuilder)->m_new(t_tcc)));
	t_builders->p_Set3(String(L"xna",3),((new c_XnaBuilder)->m_new(t_tcc)));
	t_builders->p_Set3(String(L"agk",3),((new c_AGKBuilder)->m_new(t_tcc)));
	t_builders->p_Set3(String(L"agk_ios",7),((new c_AGKBuilder_ios)->m_new(t_tcc)));
	return t_builders;
}
c_NodeEnumerator::c_NodeEnumerator(){
	m_node=0;
}
c_NodeEnumerator* c_NodeEnumerator::m_new(c_Node3* t_node){
	this->m_node=t_node;
	return this;
}
c_NodeEnumerator* c_NodeEnumerator::m_new2(){
	return this;
}
bool c_NodeEnumerator::p_HasNext(){
	return m_node!=0;
}
c_Node3* c_NodeEnumerator::p_NextObject(){
	c_Node3* t_t=m_node;
	m_node=m_node->p_NextNode();
	return t_t;
}
void c_NodeEnumerator::mark(){
	Object::mark();
}
c_List::c_List(){
	m__head=((new c_HeadNode)->m_new());
}
c_List* c_List::m_new(){
	return this;
}
c_Node4* c_List::p_AddLast(String t_data){
	return (new c_Node4)->m_new(m__head,m__head->m__pred,t_data);
}
c_List* c_List::m_new2(Array<String > t_data){
	Array<String > t_=t_data;
	int t_2=0;
	while(t_2<t_.Length()){
		String t_t=t_[t_2];
		t_2=t_2+1;
		p_AddLast(t_t);
	}
	return this;
}
bool c_List::p_IsEmpty(){
	return m__head->m__succ==m__head;
}
String c_List::p_RemoveFirst(){
	String t_data=m__head->m__succ->m__data;
	m__head->m__succ->p_Remove();
	return t_data;
}
bool c_List::p_Equals(String t_lhs,String t_rhs){
	return t_lhs==t_rhs;
}
c_Node4* c_List::p_Find(String t_value,c_Node4* t_start){
	while(t_start!=m__head){
		if(p_Equals(t_value,t_start->m__data)){
			return t_start;
		}
		t_start=t_start->m__succ;
	}
	return 0;
}
c_Node4* c_List::p_Find2(String t_value){
	return p_Find(t_value,m__head->m__succ);
}
void c_List::p_RemoveFirst2(String t_value){
	c_Node4* t_node=p_Find2(t_value);
	if((t_node)!=0){
		t_node->p_Remove();
	}
}
int c_List::p_Count(){
	int t_n=0;
	c_Node4* t_node=m__head->m__succ;
	while(t_node!=m__head){
		t_node=t_node->m__succ;
		t_n+=1;
	}
	return t_n;
}
c_Enumerator* c_List::p_ObjectEnumerator(){
	return (new c_Enumerator)->m_new(this);
}
Array<String > c_List::p_ToArray(){
	Array<String > t_arr=Array<String >(p_Count());
	int t_i=0;
	c_Enumerator* t_=this->p_ObjectEnumerator();
	while(t_->p_HasNext()){
		String t_t=t_->p_NextObject();
		t_arr[t_i]=t_t;
		t_i+=1;
	}
	return t_arr;
}
String c_List::p_RemoveLast(){
	String t_data=m__head->m__pred->m__data;
	m__head->m__pred->p_Remove();
	return t_data;
}
c_Node4* c_List::p_FindLast(String t_value,c_Node4* t_start){
	while(t_start!=m__head){
		if(p_Equals(t_value,t_start->m__data)){
			return t_start;
		}
		t_start=t_start->m__pred;
	}
	return 0;
}
c_Node4* c_List::p_FindLast2(String t_value){
	return p_FindLast(t_value,m__head->m__pred);
}
void c_List::p_RemoveLast2(String t_value){
	c_Node4* t_node=p_FindLast2(t_value);
	if((t_node)!=0){
		t_node->p_Remove();
	}
}
void c_List::mark(){
	Object::mark();
}
c_StringList::c_StringList(){
}
c_StringList* c_StringList::m_new(Array<String > t_data){
	c_List::m_new2(t_data);
	return this;
}
c_StringList* c_StringList::m_new2(){
	c_List::m_new();
	return this;
}
bool c_StringList::p_Equals(String t_lhs,String t_rhs){
	return t_lhs==t_rhs;
}
void c_StringList::mark(){
	c_List::mark();
}
c_Node4::c_Node4(){
	m__succ=0;
	m__pred=0;
	m__data=String();
}
c_Node4* c_Node4::m_new(c_Node4* t_succ,c_Node4* t_pred,String t_data){
	m__succ=t_succ;
	m__pred=t_pred;
	m__succ->m__pred=this;
	m__pred->m__succ=this;
	m__data=t_data;
	return this;
}
c_Node4* c_Node4::m_new2(){
	return this;
}
int c_Node4::p_Remove(){
	m__succ->m__pred=m__pred;
	m__pred->m__succ=m__succ;
	return 0;
}
void c_Node4::mark(){
	Object::mark();
}
c_HeadNode::c_HeadNode(){
}
c_HeadNode* c_HeadNode::m_new(){
	c_Node4::m_new2();
	m__succ=(this);
	m__pred=(this);
	return this;
}
void c_HeadNode::mark(){
	c_Node4::mark();
}
c_Enumerator::c_Enumerator(){
	m__list=0;
	m__curr=0;
}
c_Enumerator* c_Enumerator::m_new(c_List* t_list){
	m__list=t_list;
	m__curr=t_list->m__head->m__succ;
	return this;
}
c_Enumerator* c_Enumerator::m_new2(){
	return this;
}
bool c_Enumerator::p_HasNext(){
	while(m__curr->m__succ->m__pred!=m__curr){
		m__curr=m__curr->m__succ;
	}
	return m__curr!=m__list->m__head;
}
String c_Enumerator::p_NextObject(){
	String t_data=m__curr->m__data;
	m__curr=m__curr->m__succ;
	return t_data;
}
void c_Enumerator::mark(){
	Object::mark();
}
Array<String > bb_os_LoadDir(String t_path,bool t_recursive,bool t_hidden){
	c_StringList* t_dirs=(new c_StringList)->m_new2();
	c_StringList* t_files=(new c_StringList)->m_new2();
	t_dirs->p_AddLast(String());
	while(!t_dirs->p_IsEmpty()){
		String t_dir=t_dirs->p_RemoveFirst();
		Array<String > t_=LoadDir(t_path+String(L"/",1)+t_dir);
		int t_2=0;
		while(t_2<t_.Length()){
			String t_f=t_[t_2];
			t_2=t_2+1;
			if(!t_hidden && t_f.StartsWith(String(L".",1))){
				continue;
			}
			if((t_dir).Length()!=0){
				t_f=t_dir+String(L"/",1)+t_f;
			}
			int t_1=FileType(t_path+String(L"/",1)+t_f);
			if(t_1==1){
				t_files->p_AddLast(t_f);
			}else{
				if(t_1==2){
					if(t_recursive){
						t_dirs->p_AddLast(t_f);
					}else{
						t_files->p_AddLast(t_f);
					}
				}
			}
		}
	}
	return t_files->p_ToArray();
}
c_Stack2::c_Stack2(){
	m_data=Array<c_ConfigScope* >();
	m_length=0;
}
c_Stack2* c_Stack2::m_new(){
	return this;
}
c_Stack2* c_Stack2::m_new2(Array<c_ConfigScope* > t_data){
	this->m_data=t_data.Slice(0);
	this->m_length=t_data.Length();
	return this;
}
void c_Stack2::p_Push4(c_ConfigScope* t_value){
	if(m_length==m_data.Length()){
		m_data=m_data.Resize(m_length*2+10);
	}
	m_data[m_length]=t_value;
	m_length+=1;
}
void c_Stack2::p_Push5(Array<c_ConfigScope* > t_values,int t_offset,int t_count){
	for(int t_i=0;t_i<t_count;t_i=t_i+1){
		p_Push4(t_values[t_offset+t_i]);
	}
}
void c_Stack2::p_Push6(Array<c_ConfigScope* > t_values,int t_offset){
	p_Push5(t_values,t_offset,t_values.Length()-t_offset);
}
c_ConfigScope* c_Stack2::m_NIL;
c_ConfigScope* c_Stack2::p_Pop(){
	m_length-=1;
	c_ConfigScope* t_v=m_data[m_length];
	m_data[m_length]=m_NIL;
	return t_v;
}
void c_Stack2::mark(){
	Object::mark();
}
c_Stack2* bb_config__cfgScopeStack;
void bb_config_PushConfigScope(){
	bb_config__cfgScopeStack->p_Push4(bb_config__cfgScope);
	bb_config__cfgScope=(new c_ConfigScope)->m_new();
}
c_ModuleDecl::c_ModuleDecl(){
	m_rmodpath=String();
	m_filepath=String();
	m_modpath=String();
	m_imported=(new c_StringMap5)->m_new();
	m_friends=(new c_StringSet)->m_new();
	m_pubImported=(new c_StringMap5)->m_new();
}
c_ModuleDecl* c_ModuleDecl::m_new(String t_ident,int t_attrs,String t_munged,String t_modpath,String t_filepath,c_AppDecl* t_app){
	c_ScopeDecl::m_new();
	this->m_ident=t_ident;
	this->m_attrs=t_attrs;
	this->m_munged=t_munged;
	this->m_modpath=t_modpath;
	this->m_rmodpath=t_modpath;
	this->m_filepath=t_filepath;
	if(t_modpath.Contains(String(L".",1))){
		Array<String > t_bits=t_modpath.Split(String(L".",1));
		int t_n=t_bits.Length();
		if(t_n>1 && t_bits[t_n-2]==t_bits[t_n-1]){
			this->m_rmodpath=bb_os_StripExt(t_modpath);
		}
	}
	m_imported->p_Set5(t_filepath,this);
	t_app->p_InsertModule(this);
	return this;
}
c_ModuleDecl* c_ModuleDecl::m_new2(){
	c_ScopeDecl::m_new();
	return this;
}
int c_ModuleDecl::p_IsStrict(){
	return (((m_attrs&1)!=0)?1:0);
}
int c_ModuleDecl::p_ImportModule(String t_modpath,int t_attrs){
	String t_cdir=bb_os_ExtractDir(this->m_filepath);
	String t_dir=String();
	String t_filepath=String();
	String t_mpath=t_modpath.Replace(String(L".",1),String(L"/",1));
	Array<String > t_=bb_config_ENV_MODPATH.Split(String(L";",1));
	int t_2=0;
	while(t_2<t_.Length()){
		t_dir=t_[t_2];
		t_2=t_2+1;
		if(!((t_dir).Length()!=0)){
			continue;
		}
		if(t_dir==String(L".",1)){
			t_filepath=t_cdir+String(L"/",1)+t_mpath;
		}else{
			t_filepath=RealPath(t_dir)+String(L"/",1)+t_mpath;
		}
		String t_filepath2=bb_os_StripExt(t_filepath)+String(L"/",1)+bb_os_StripDir(t_filepath);
		String t_usedExtension=String();
		if(FileType(t_filepath+bb_parser_FILE_EXT)==1 || FileType(t_filepath2+bb_parser_FILE_EXT)==1){
			t_usedExtension=bb_parser_FILE_EXT;
		}else{
			if(FileType(t_filepath+bb_parser_FILE_EXT_OLD)==1 || FileType(t_filepath2+bb_parser_FILE_EXT_OLD)==1){
				t_usedExtension=bb_parser_FILE_EXT_OLD;
			}
		}
		t_filepath=t_filepath+t_usedExtension;
		t_filepath2=t_filepath2+t_usedExtension;
		if(FileType(t_filepath)==1){
			if(FileType(t_filepath2)!=1){
				break;
			}
			bb_config_Err(String(L"Duplicate module file: '",24)+t_filepath+String(L"' and '",7)+t_filepath2+String(L"'.",2));
		}else{
			if(FileType(t_filepath)==1){
				if(FileType(t_filepath2)!=1){
					break;
				}
				bb_config_Err(String(L"Duplicate module file: '",24)+t_filepath+String(L"' and '",7)+t_filepath2+String(L"'.",2));
			}
		}
		t_filepath=t_filepath2;
		if(FileType(t_filepath)==1){
			if(t_modpath.Contains(String(L".",1))){
				t_modpath=t_modpath+(String(L".",1)+bb_os_ExtractExt(t_modpath));
			}else{
				t_modpath=t_modpath+(String(L".",1)+t_modpath);
			}
			break;
		}
		t_filepath=String();
	}
	if(t_dir==String(L".",1) && this->m_modpath.Contains(String(L".",1))){
		t_modpath=bb_os_StripExt(this->m_modpath)+String(L".",1)+t_modpath;
	}
	c_AppDecl* t_app=dynamic_cast<c_AppDecl*>(m_scope);
	c_ModuleDecl* t_mdecl=t_app->m_imported->p_Get(t_filepath);
	if(((t_mdecl)!=0) && t_mdecl->m_modpath!=t_modpath){
		bbPrint(String(L"Modpath error - import=",23)+t_modpath+String(L", existing=",11)+t_mdecl->m_modpath);
	}
	if(this->m_imported->p_Contains(t_filepath)){
		return 0;
	}
	if(!((t_mdecl)!=0)){
		t_mdecl=bb_parser_ParseModule(t_modpath,t_filepath,t_app);
	}
	this->m_imported->p_Insert3(t_mdecl->m_filepath,t_mdecl);
	if(!((t_attrs&512)!=0)){
		this->m_pubImported->p_Insert3(t_mdecl->m_filepath,t_mdecl);
	}
	this->p_InsertDecl((new c_AliasDecl)->m_new(t_mdecl->m_ident,t_attrs,(t_mdecl)));
	return 0;
}
int c_ModuleDecl::p_SemantAll(){
	c_Enumerator3* t_=p_Decls()->p_ObjectEnumerator();
	while(t_->p_HasNext()){
		c_Decl* t_decl=t_->p_NextObject();
		if((dynamic_cast<c_AliasDecl*>(t_decl))!=0){
			continue;
		}
		c_ClassDecl* t_cdecl=dynamic_cast<c_ClassDecl*>(t_decl);
		if((t_cdecl)!=0){
			if((t_cdecl->m_args).Length()!=0){
				c_Enumerator5* t_2=t_cdecl->m_instances->p_ObjectEnumerator();
				while(t_2->p_HasNext()){
					c_ClassDecl* t_inst=t_2->p_NextObject();
					c_Enumerator3* t_3=t_inst->p_Decls()->p_ObjectEnumerator();
					while(t_3->p_HasNext()){
						c_Decl* t_decl2=t_3->p_NextObject();
						if((dynamic_cast<c_AliasDecl*>(t_decl2))!=0){
							continue;
						}
						t_decl2->p_Semant();
					}
				}
			}else{
				t_decl->p_Semant();
				c_Enumerator3* t_4=t_cdecl->p_Decls()->p_ObjectEnumerator();
				while(t_4->p_HasNext()){
					c_Decl* t_decl3=t_4->p_NextObject();
					if((dynamic_cast<c_AliasDecl*>(t_decl3))!=0){
						continue;
					}
					t_decl3->p_Semant();
				}
			}
		}else{
			t_decl->p_Semant();
		}
	}
	m_attrs|=2;
	return 0;
}
String c_ModuleDecl::p_ToString(){
	return String(L"Module ",7)+m_modpath;
}
Object* c_ModuleDecl::p_GetDecl2(String t_ident){
	return c_ScopeDecl::p_GetDecl(t_ident);
}
Object* c_ModuleDecl::p_GetDecl(String t_ident){
	c_List11* t_todo=(new c_List11)->m_new();
	c_StringMap5* t_done=(new c_StringMap5)->m_new();
	t_todo->p_AddLast11(this);
	t_done->p_Insert3(m_filepath,this);
	Object* t_decl=0;
	String t_declmod=String();
	while(!t_todo->p_IsEmpty()){
		c_ModuleDecl* t_mdecl=t_todo->p_RemoveLast();
		Object* t_tdecl=t_mdecl->p_GetDecl2(t_ident);
		if(((t_tdecl)!=0) && ((bb_decl__env)!=0)){
			c_Decl* t_ddecl=dynamic_cast<c_Decl*>(t_tdecl);
			if(((t_ddecl)!=0) && !((t_ddecl->p_CheckAccess())!=0)){
				t_tdecl=0;
			}
			c_FuncDeclList* t_flist=dynamic_cast<c_FuncDeclList*>(t_tdecl);
			if((t_flist)!=0){
				bool t_pub=false;
				c_Enumerator4* t_=t_flist->p_ObjectEnumerator();
				while(t_->p_HasNext()){
					c_FuncDecl* t_fdecl=t_->p_NextObject();
					if(!((t_fdecl->p_CheckAccess())!=0)){
						continue;
					}
					t_pub=true;
					break;
				}
				if(!t_pub){
					t_tdecl=0;
				}
			}
		}
		if(((t_tdecl)!=0) && t_tdecl!=t_decl){
			if(t_mdecl==this){
				return t_tdecl;
			}
			if((t_decl)!=0){
				bb_config_Err(String(L"Duplicate identifier '",22)+t_ident+String(L"' found in module '",19)+t_declmod+String(L"' and module '",14)+t_mdecl->m_ident+String(L"'.",2));
			}
			t_decl=t_tdecl;
			t_declmod=t_mdecl->m_ident;
		}
		if(!((bb_decl__env)!=0)){
			break;
		}
		c_StringMap5* t_imps=t_mdecl->m_imported;
		if(t_mdecl!=bb_decl__env->p_ModuleScope()){
			t_imps=t_mdecl->m_pubImported;
		}
		c_ValueEnumerator* t_2=t_imps->p_Values()->p_ObjectEnumerator();
		while(t_2->p_HasNext()){
			c_ModuleDecl* t_mdecl2=t_2->p_NextObject();
			if(!t_done->p_Contains(t_mdecl2->m_filepath)){
				t_todo->p_AddLast11(t_mdecl2);
				t_done->p_Insert3(t_mdecl2->m_filepath,t_mdecl2);
			}
		}
	}
	return t_decl;
}
int c_ModuleDecl::p_OnSemant(){
	return 0;
}
void c_ModuleDecl::mark(){
	c_ScopeDecl::mark();
}
c_Stack3::c_Stack3(){
	m_data=Array<int >();
	m_length=0;
}
c_Stack3* c_Stack3::m_new(){
	return this;
}
c_Stack3* c_Stack3::m_new2(Array<int > t_data){
	this->m_data=t_data.Slice(0);
	this->m_length=t_data.Length();
	return this;
}
void c_Stack3::p_Push7(int t_value){
	if(m_length==m_data.Length()){
		m_data=m_data.Resize(m_length*2+10);
	}
	m_data[m_length]=t_value;
	m_length+=1;
}
void c_Stack3::p_Push8(Array<int > t_values,int t_offset,int t_count){
	for(int t_i=0;t_i<t_count;t_i=t_i+1){
		p_Push7(t_values[t_offset+t_i]);
	}
}
void c_Stack3::p_Push9(Array<int > t_values,int t_offset){
	p_Push8(t_values,t_offset,t_values.Length()-t_offset);
}
bool c_Stack3::p_IsEmpty(){
	return m_length==0;
}
int c_Stack3::m_NIL;
int c_Stack3::p_Pop(){
	m_length-=1;
	int t_v=m_data[m_length];
	m_data[m_length]=m_NIL;
	return t_v;
}
void c_Stack3::p_Length(int t_newlength){
	if(t_newlength<m_length){
		for(int t_i=t_newlength;t_i<m_length;t_i=t_i+1){
			m_data[t_i]=m_NIL;
		}
	}else{
		if(t_newlength>m_data.Length()){
			m_data=m_data.Resize(bb_math_Max(m_length*2+10,t_newlength));
		}
	}
	m_length=t_newlength;
}
int c_Stack3::p_Length2(){
	return m_length;
}
int c_Stack3::p_Get2(int t_index){
	return m_data[t_index];
}
void c_Stack3::p_Clear(){
	for(int t_i=0;t_i<m_length;t_i=t_i+1){
		m_data[t_i]=m_NIL;
	}
	m_length=0;
}
void c_Stack3::mark(){
	Object::mark();
}
c_IntStack::c_IntStack(){
}
c_IntStack* c_IntStack::m_new(Array<int > t_data){
	c_Stack3::m_new2(t_data);
	return this;
}
c_IntStack* c_IntStack::m_new2(){
	c_Stack3::m_new();
	return this;
}
void c_IntStack::mark(){
	c_Stack3::mark();
}
c_ScopeDecl* bb_config_GetConfigScope(){
	return (bb_config__cfgScope);
}
c_ScopeDecl* bb_decl__env;
c_List2::c_List2(){
	m__head=((new c_HeadNode2)->m_new());
}
c_List2* c_List2::m_new(){
	return this;
}
c_Node5* c_List2::p_AddLast2(c_ScopeDecl* t_data){
	return (new c_Node5)->m_new(m__head,m__head->m__pred,t_data);
}
c_List2* c_List2::m_new2(Array<c_ScopeDecl* > t_data){
	Array<c_ScopeDecl* > t_=t_data;
	int t_2=0;
	while(t_2<t_.Length()){
		c_ScopeDecl* t_t=t_[t_2];
		t_2=t_2+1;
		p_AddLast2(t_t);
	}
	return this;
}
bool c_List2::p_IsEmpty(){
	return m__head->m__succ==m__head;
}
c_ScopeDecl* c_List2::p_RemoveLast(){
	c_ScopeDecl* t_data=m__head->m__pred->m__data;
	m__head->m__pred->p_Remove();
	return t_data;
}
bool c_List2::p_Equals2(c_ScopeDecl* t_lhs,c_ScopeDecl* t_rhs){
	return t_lhs==t_rhs;
}
c_Node5* c_List2::p_FindLast3(c_ScopeDecl* t_value,c_Node5* t_start){
	while(t_start!=m__head){
		if(p_Equals2(t_value,t_start->m__data)){
			return t_start;
		}
		t_start=t_start->m__pred;
	}
	return 0;
}
c_Node5* c_List2::p_FindLast4(c_ScopeDecl* t_value){
	return p_FindLast3(t_value,m__head->m__pred);
}
void c_List2::p_RemoveLast3(c_ScopeDecl* t_value){
	c_Node5* t_node=p_FindLast4(t_value);
	if((t_node)!=0){
		t_node->p_Remove();
	}
}
void c_List2::mark(){
	Object::mark();
}
c_Node5::c_Node5(){
	m__succ=0;
	m__pred=0;
	m__data=0;
}
c_Node5* c_Node5::m_new(c_Node5* t_succ,c_Node5* t_pred,c_ScopeDecl* t_data){
	m__succ=t_succ;
	m__pred=t_pred;
	m__succ->m__pred=this;
	m__pred->m__succ=this;
	m__data=t_data;
	return this;
}
c_Node5* c_Node5::m_new2(){
	return this;
}
int c_Node5::p_Remove(){
	m__succ->m__pred=m__pred;
	m__pred->m__succ=m__succ;
	return 0;
}
void c_Node5::mark(){
	Object::mark();
}
c_HeadNode2::c_HeadNode2(){
}
c_HeadNode2* c_HeadNode2::m_new(){
	c_Node5::m_new2();
	m__succ=(this);
	m__pred=(this);
	return this;
}
void c_HeadNode2::mark(){
	c_Node5::mark();
}
c_List2* bb_decl__envStack;
int bb_decl_PushEnv(c_ScopeDecl* t_env){
	bb_decl__envStack->p_AddLast2(bb_decl__env);
	bb_decl__env=t_env;
	return 0;
}
c_Toker::c_Toker(){
	m__path=String();
	m__line=0;
	m__source=String();
	m__length=0;
	m__toke=String();
	m__tokeType=0;
	m__tokePos=0;
}
c_StringSet* c_Toker::m__keywords;
c_StringSet* c_Toker::m__symbols;
int c_Toker::p__init(){
	if((m__keywords)!=0){
		return 0;
	}
	m__keywords=(new c_StringSet)->m_new();
	Array<String > t_=String(L"void strict public private protected friend property bool int float string array object mod continue exit include includedir import module extern new self super eachin true false null not extends abstract final select case default const local global field method function class and or shl shr end if then else elseif endif while wend repeat until forever for to step next return interface implements inline alias try catch throw throwable enumerate",448).Split(String(L" ",1));
	int t_2=0;
	while(t_2<t_.Length()){
		String t_t=t_[t_2];
		t_2=t_2+1;
		m__keywords->p_Insert(t_t);
	}
	m__symbols=(new c_StringSet)->m_new();
	m__symbols->p_Insert(String(L"..",2));
	m__symbols->p_Insert(String(L":=",2));
	m__symbols->p_Insert(String(L"*=",2));
	m__symbols->p_Insert(String(L"/=",2));
	m__symbols->p_Insert(String(L"+=",2));
	m__symbols->p_Insert(String(L"-=",2));
	m__symbols->p_Insert(String(L"|=",2));
	m__symbols->p_Insert(String(L"&=",2));
	m__symbols->p_Insert(String(L"~=",2));
	return 0;
}
c_Toker* c_Toker::m_new(String t_path,String t_source){
	p__init();
	m__path=t_path;
	m__line=1;
	m__source=t_source;
	m__length=m__source.Length();
	m__toke=String();
	m__tokeType=0;
	m__tokePos=0;
	return this;
}
c_Toker* c_Toker::m_new2(c_Toker* t_toker){
	p__init();
	m__path=t_toker->m__path;
	m__line=t_toker->m__line;
	m__source=t_toker->m__source;
	m__length=m__source.Length();
	m__toke=t_toker->m__toke;
	m__tokeType=t_toker->m__tokeType;
	m__tokePos=t_toker->m__tokePos;
	return this;
}
c_Toker* c_Toker::m_new3(){
	return this;
}
int c_Toker::p_TCHR(int t_i){
	t_i+=m__tokePos;
	if(t_i<m__length){
		return (int)m__source[t_i];
	}
	return 0;
}
String c_Toker::p_TSTR(int t_i){
	t_i+=m__tokePos;
	if(t_i<m__length){
		return m__source.Slice(t_i,t_i+1);
	}
	return String();
}
int c_Toker::m__tokenFlags;
bool c_Toker::m_Remarks(){
	return ((m__tokenFlags&1)!=0);
}
String c_Toker::p_NextToke(){
	m__toke=String();
	if(m__tokePos==m__length){
		m__tokeType=0;
		return m__toke;
	}
	int t_chr=p_TCHR(0);
	String t_str=p_TSTR(0);
	int t_start=m__tokePos;
	m__tokePos+=1;
	if(t_str==String(L"\n",1)){
		m__tokeType=8;
		m__line+=1;
	}else{
		if((bb_config_IsSpace(t_chr))!=0){
			m__tokeType=1;
			while(m__tokePos<m__length && ((bb_config_IsSpace(p_TCHR(0)))!=0) && p_TSTR(0)!=String(L"\n",1)){
				m__tokePos+=1;
			}
		}else{
			if(t_str==String(L"'",1)){
				m__tokeType=9;
				while(m__tokePos<m__length && p_TSTR(0)!=String(L"\n",1)){
					m__tokePos+=1;
				}
				if(m__tokePos<m__length){
					m__tokePos+=1;
					m__line+=1;
				}
			}else{
				if(t_str==String(L"_",1) || ((bb_config_IsAlpha(t_chr))!=0)){
					m__tokeType=2;
					while(m__tokePos<m__length){
						int t_chr2=(int)m__source[m__tokePos];
						if(t_chr2!=95 && !((bb_config_IsAlpha(t_chr2))!=0) && !((bb_config_IsDigit(t_chr2))!=0)){
							break;
						}
						m__tokePos+=1;
					}
					m__toke=m__source.Slice(t_start,m__tokePos);
					if(m__keywords->p_Contains(m__toke.ToLower())){
						m__tokeType=3;
					}
				}else{
					if(((bb_config_IsDigit(t_chr))!=0) || t_str==String(L".",1) && ((bb_config_IsDigit(p_TCHR(0)))!=0)){
						m__tokeType=4;
						if(t_str==String(L".",1)){
							m__tokeType=5;
						}
						while((bb_config_IsDigit(p_TCHR(0)))!=0){
							m__tokePos+=1;
						}
						if(m__tokeType==4 && p_TSTR(0)==String(L".",1) && ((bb_config_IsDigit(p_TCHR(1)))!=0)){
							m__tokeType=5;
							m__tokePos+=2;
							while((bb_config_IsDigit(p_TCHR(0)))!=0){
								m__tokePos+=1;
							}
						}
						if(p_TSTR(0).ToLower()==String(L"e",1)){
							m__tokeType=5;
							m__tokePos+=1;
							if(p_TSTR(0)==String(L"+",1) || p_TSTR(0)==String(L"-",1)){
								m__tokePos+=1;
							}
							while((bb_config_IsDigit(p_TCHR(0)))!=0){
								m__tokePos+=1;
							}
						}
					}else{
						if(t_str==String(L"%",1) && ((bb_config_IsBinDigit(p_TCHR(0)))!=0)){
							m__tokeType=4;
							m__tokePos+=1;
							while((bb_config_IsBinDigit(p_TCHR(0)))!=0){
								m__tokePos+=1;
							}
						}else{
							if(t_str==String(L"$",1) && ((bb_config_IsHexDigit(p_TCHR(0)))!=0)){
								m__tokeType=4;
								m__tokePos+=1;
								while((bb_config_IsHexDigit(p_TCHR(0)))!=0){
									m__tokePos+=1;
								}
							}else{
								if(t_str==String(L"\"",1)){
									m__tokeType=6;
									while(m__tokePos<m__length){
										if(m_Remarks()){
											m__tokeType=9;
											if(p_TSTR(0)==String(L"\n",1)){
												m__line+=1;
												break;
											}
										}else{
											if(p_TSTR(0)==String(L"\"",1)){
												break;
											}
										}
										m__tokePos+=1;
									}
									if(m__tokePos<m__length){
										m__tokePos+=1;
									}else{
										if(!m_Remarks()){
											m__tokeType=7;
										}
									}
								}else{
									if(t_str==String(L"`",1)){
										m__tokeType=4;
										while(m__tokePos<m__length){
											if(m_Remarks()){
												m__tokeType=9;
												if(p_TSTR(0)==String(L"\n",1)){
													m__line+=1;
													break;
												}
											}else{
												if(p_TSTR(0)==String(L"`",1)){
													break;
												}
											}
											m__tokePos+=1;
										}
										if(m__tokePos<m__length){
											m__tokePos+=1;
										}else{
											if(!m_Remarks()){
												m__tokeType=10;
											}
										}
									}else{
										if(t_str==String(L"[",1)){
											m__tokeType=8;
											int t_i=0;
											while(m__tokePos+t_i<m__length){
												if(p_TSTR(t_i)==String(L"]",1)){
													m__tokePos+=t_i+1;
													break;
												}
												if(p_TSTR(t_i)==String(L"\n",1) || !((bb_config_IsSpace(p_TCHR(t_i)))!=0)){
													break;
												}
												t_i+=1;
											}
										}else{
											m__tokeType=8;
											if(m__symbols->p_Contains(m__source.Slice(m__tokePos-1,m__tokePos+1))){
												m__tokePos+=1;
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
	if(!((m__toke).Length()!=0)){
		m__toke=m__source.Slice(t_start,m__tokePos);
	}
	return m__toke;
}
String c_Toker::p_Toke(){
	return m__toke;
}
int c_Toker::p_TokeType(){
	return m__tokeType;
}
String c_Toker::p_Path(){
	return m__path;
}
int c_Toker::p_Line(){
	return m__line;
}
int c_Toker::p_SkipSpace(){
	while(m__tokeType==1){
		p_NextToke();
	}
	return 0;
}
int c_Toker::m_RemarksOn(){
	m__tokenFlags|=1;
	return 0;
}
int c_Toker::m_RemarksOff(){
	m__tokenFlags&=-2;
	return 0;
}
void c_Toker::mark(){
	Object::mark();
}
c_Set::c_Set(){
	m_map=0;
}
c_Set* c_Set::m_new(c_Map4* t_map){
	this->m_map=t_map;
	return this;
}
c_Set* c_Set::m_new2(){
	return this;
}
int c_Set::p_Insert(String t_value){
	m_map->p_Insert2(t_value,0);
	return 0;
}
bool c_Set::p_Contains(String t_value){
	return m_map->p_Contains(t_value);
}
void c_Set::mark(){
	Object::mark();
}
c_StringSet::c_StringSet(){
}
c_StringSet* c_StringSet::m_new(){
	c_Set::m_new((new c_StringMap4)->m_new());
	return this;
}
void c_StringSet::mark(){
	c_Set::mark();
}
c_Map4::c_Map4(){
	m_root=0;
}
c_Map4* c_Map4::m_new(){
	return this;
}
int c_Map4::p_RotateLeft4(c_Node6* t_node){
	c_Node6* t_child=t_node->m_right;
	t_node->m_right=t_child->m_left;
	if((t_child->m_left)!=0){
		t_child->m_left->m_parent=t_node;
	}
	t_child->m_parent=t_node->m_parent;
	if((t_node->m_parent)!=0){
		if(t_node==t_node->m_parent->m_left){
			t_node->m_parent->m_left=t_child;
		}else{
			t_node->m_parent->m_right=t_child;
		}
	}else{
		m_root=t_child;
	}
	t_child->m_left=t_node;
	t_node->m_parent=t_child;
	return 0;
}
int c_Map4::p_RotateRight4(c_Node6* t_node){
	c_Node6* t_child=t_node->m_left;
	t_node->m_left=t_child->m_right;
	if((t_child->m_right)!=0){
		t_child->m_right->m_parent=t_node;
	}
	t_child->m_parent=t_node->m_parent;
	if((t_node->m_parent)!=0){
		if(t_node==t_node->m_parent->m_right){
			t_node->m_parent->m_right=t_child;
		}else{
			t_node->m_parent->m_left=t_child;
		}
	}else{
		m_root=t_child;
	}
	t_child->m_right=t_node;
	t_node->m_parent=t_child;
	return 0;
}
int c_Map4::p_InsertFixup4(c_Node6* t_node){
	while(((t_node->m_parent)!=0) && t_node->m_parent->m_color==-1 && ((t_node->m_parent->m_parent)!=0)){
		if(t_node->m_parent==t_node->m_parent->m_parent->m_left){
			c_Node6* t_uncle=t_node->m_parent->m_parent->m_right;
			if(((t_uncle)!=0) && t_uncle->m_color==-1){
				t_node->m_parent->m_color=1;
				t_uncle->m_color=1;
				t_uncle->m_parent->m_color=-1;
				t_node=t_uncle->m_parent;
			}else{
				if(t_node==t_node->m_parent->m_right){
					t_node=t_node->m_parent;
					p_RotateLeft4(t_node);
				}
				t_node->m_parent->m_color=1;
				t_node->m_parent->m_parent->m_color=-1;
				p_RotateRight4(t_node->m_parent->m_parent);
			}
		}else{
			c_Node6* t_uncle2=t_node->m_parent->m_parent->m_left;
			if(((t_uncle2)!=0) && t_uncle2->m_color==-1){
				t_node->m_parent->m_color=1;
				t_uncle2->m_color=1;
				t_uncle2->m_parent->m_color=-1;
				t_node=t_uncle2->m_parent;
			}else{
				if(t_node==t_node->m_parent->m_left){
					t_node=t_node->m_parent;
					p_RotateRight4(t_node);
				}
				t_node->m_parent->m_color=1;
				t_node->m_parent->m_parent->m_color=-1;
				p_RotateLeft4(t_node->m_parent->m_parent);
			}
		}
	}
	m_root->m_color=1;
	return 0;
}
bool c_Map4::p_Set4(String t_key,Object* t_value){
	c_Node6* t_node=m_root;
	c_Node6* t_parent=0;
	int t_cmp=0;
	while((t_node)!=0){
		t_parent=t_node;
		t_cmp=p_Compare(t_key,t_node->m_key);
		if(t_cmp>0){
			t_node=t_node->m_right;
		}else{
			if(t_cmp<0){
				t_node=t_node->m_left;
			}else{
				t_node->m_value=t_value;
				return false;
			}
		}
	}
	t_node=(new c_Node6)->m_new(t_key,t_value,-1,t_parent);
	if((t_parent)!=0){
		if(t_cmp>0){
			t_parent->m_right=t_node;
		}else{
			t_parent->m_left=t_node;
		}
		p_InsertFixup4(t_node);
	}else{
		m_root=t_node;
	}
	return true;
}
bool c_Map4::p_Insert2(String t_key,Object* t_value){
	return p_Set4(t_key,t_value);
}
c_Node6* c_Map4::p_FindNode(String t_key){
	c_Node6* t_node=m_root;
	while((t_node)!=0){
		int t_cmp=p_Compare(t_key,t_node->m_key);
		if(t_cmp>0){
			t_node=t_node->m_right;
		}else{
			if(t_cmp<0){
				t_node=t_node->m_left;
			}else{
				return t_node;
			}
		}
	}
	return t_node;
}
bool c_Map4::p_Contains(String t_key){
	return p_FindNode(t_key)!=0;
}
Object* c_Map4::p_Get(String t_key){
	c_Node6* t_node=p_FindNode(t_key);
	if((t_node)!=0){
		return t_node->m_value;
	}
	return 0;
}
void c_Map4::mark(){
	Object::mark();
}
c_StringMap4::c_StringMap4(){
}
c_StringMap4* c_StringMap4::m_new(){
	c_Map4::m_new();
	return this;
}
int c_StringMap4::p_Compare(String t_lhs,String t_rhs){
	return t_lhs.Compare(t_rhs);
}
void c_StringMap4::mark(){
	c_Map4::mark();
}
c_Node6::c_Node6(){
	m_key=String();
	m_right=0;
	m_left=0;
	m_value=0;
	m_color=0;
	m_parent=0;
}
c_Node6* c_Node6::m_new(String t_key,Object* t_value,int t_color,c_Node6* t_parent){
	this->m_key=t_key;
	this->m_value=t_value;
	this->m_color=t_color;
	this->m_parent=t_parent;
	return this;
}
c_Node6* c_Node6::m_new2(){
	return this;
}
void c_Node6::mark(){
	Object::mark();
}
int bb_config_IsSpace(int t_ch){
	return ((t_ch<=32)?1:0);
}
int bb_config_IsAlpha(int t_ch){
	return ((t_ch>=65 && t_ch<=90 || t_ch>=97 && t_ch<=122)?1:0);
}
int bb_config_IsDigit(int t_ch){
	return ((t_ch>=48 && t_ch<=57)?1:0);
}
int bb_config_IsBinDigit(int t_ch){
	return ((t_ch==48 || t_ch==49)?1:0);
}
int bb_config_IsHexDigit(int t_ch){
	return ((t_ch>=48 && t_ch<=57 || t_ch>=65 && t_ch<=70 || t_ch>=97 && t_ch<=102)?1:0);
}
String bb_config_ENV_MODPATH;
String bb_os_StripExt(String t_path){
	int t_i=t_path.FindLast(String(L".",1));
	if(t_i!=-1 && t_path.Find(String(L"/",1),t_i+1)==-1 && t_path.Find(String(L"\\",1),t_i+1)==-1){
		return t_path.Slice(0,t_i);
	}
	return t_path;
}
String bb_os_StripDir(String t_path){
	int t_i=t_path.FindLast(String(L"/",1));
	if(t_i==-1){
		t_i=t_path.FindLast(String(L"\\",1));
	}
	if(t_i!=-1){
		return t_path.Slice(t_i+1);
	}
	return t_path;
}
String bb_parser_FILE_EXT;
String bb_parser_FILE_EXT_OLD;
int bb_config_Err(String t_err){
	bbPrint(bb_config__errInfo+String(L" : Error : ",11)+t_err);
	ExitApp(-1);
	return 0;
}
String bb_os_ExtractExt(String t_path){
	int t_i=t_path.FindLast(String(L".",1));
	if(t_i!=-1 && t_path.Find(String(L"/",1),t_i+1)==-1 && t_path.Find(String(L"\\",1),t_i+1)==-1){
		return t_path.Slice(t_i+1);
	}
	return String();
}
c_AppDecl::c_AppDecl(){
	m_imported=(new c_StringMap5)->m_new();
	m_mainModule=0;
	m_fileImports=(new c_StringList)->m_new2();
	m_fileIncludes=(new c_StringList)->m_new2();
	m_dirIncludes=(new c_StringList)->m_new2();
	m_allSemantedDecls=(new c_List5)->m_new();
	m_semantedGlobals=(new c_List10)->m_new();
	m_semantedClasses=(new c_List8)->m_new();
	m_mainFunc=0;
}
int c_AppDecl::p_InsertModule(c_ModuleDecl* t_mdecl){
	t_mdecl->m_scope=(this);
	m_imported->p_Insert3(t_mdecl->m_filepath,t_mdecl);
	if(!((m_mainModule)!=0)){
		m_mainModule=t_mdecl;
	}
	return 0;
}
c_AppDecl* c_AppDecl::m_new(){
	c_ScopeDecl::m_new();
	return this;
}
int c_AppDecl::p_FinalizeClasses(){
	bb_decl__env=0;
	do{
		int t_more=0;
		c_Enumerator5* t_=m_semantedClasses->p_ObjectEnumerator();
		while(t_->p_HasNext()){
			c_ClassDecl* t_cdecl=t_->p_NextObject();
			t_more+=t_cdecl->p_UpdateLiveMethods();
		}
		if(!((t_more)!=0)){
			break;
		}
	}while(!(false));
	c_Enumerator5* t_2=m_semantedClasses->p_ObjectEnumerator();
	while(t_2->p_HasNext()){
		c_ClassDecl* t_cdecl2=t_2->p_NextObject();
		t_cdecl2->p_FinalizeClass();
	}
	return 0;
}
int c_AppDecl::p_OnSemant(){
	bb_decl__env=0;
	m_mainFunc=m_mainModule->p_FindFuncDecl(String(L"Main",4),Array<c_Expr* >(),0);
	if(!((m_mainFunc)!=0)){
		bb_config_Err(String(L"Function 'Main' not found.",26));
	}
	if(!((dynamic_cast<c_IntType*>(m_mainFunc->m_retType))!=0) || ((m_mainFunc->m_argDecls.Length())!=0)){
		bb_config_Err(String(L"Main function must be of type Main:Int()",40));
	}
	p_FinalizeClasses();
	return 0;
}
void c_AppDecl::mark(){
	c_ScopeDecl::mark();
}
c_Map5::c_Map5(){
	m_root=0;
}
c_Map5* c_Map5::m_new(){
	return this;
}
c_Node7* c_Map5::p_FindNode(String t_key){
	c_Node7* t_node=m_root;
	while((t_node)!=0){
		int t_cmp=p_Compare(t_key,t_node->m_key);
		if(t_cmp>0){
			t_node=t_node->m_right;
		}else{
			if(t_cmp<0){
				t_node=t_node->m_left;
			}else{
				return t_node;
			}
		}
	}
	return t_node;
}
c_ModuleDecl* c_Map5::p_Get(String t_key){
	c_Node7* t_node=p_FindNode(t_key);
	if((t_node)!=0){
		return t_node->m_value;
	}
	return 0;
}
bool c_Map5::p_Contains(String t_key){
	return p_FindNode(t_key)!=0;
}
int c_Map5::p_RotateLeft5(c_Node7* t_node){
	c_Node7* t_child=t_node->m_right;
	t_node->m_right=t_child->m_left;
	if((t_child->m_left)!=0){
		t_child->m_left->m_parent=t_node;
	}
	t_child->m_parent=t_node->m_parent;
	if((t_node->m_parent)!=0){
		if(t_node==t_node->m_parent->m_left){
			t_node->m_parent->m_left=t_child;
		}else{
			t_node->m_parent->m_right=t_child;
		}
	}else{
		m_root=t_child;
	}
	t_child->m_left=t_node;
	t_node->m_parent=t_child;
	return 0;
}
int c_Map5::p_RotateRight5(c_Node7* t_node){
	c_Node7* t_child=t_node->m_left;
	t_node->m_left=t_child->m_right;
	if((t_child->m_right)!=0){
		t_child->m_right->m_parent=t_node;
	}
	t_child->m_parent=t_node->m_parent;
	if((t_node->m_parent)!=0){
		if(t_node==t_node->m_parent->m_right){
			t_node->m_parent->m_right=t_child;
		}else{
			t_node->m_parent->m_left=t_child;
		}
	}else{
		m_root=t_child;
	}
	t_child->m_right=t_node;
	t_node->m_parent=t_child;
	return 0;
}
int c_Map5::p_InsertFixup5(c_Node7* t_node){
	while(((t_node->m_parent)!=0) && t_node->m_parent->m_color==-1 && ((t_node->m_parent->m_parent)!=0)){
		if(t_node->m_parent==t_node->m_parent->m_parent->m_left){
			c_Node7* t_uncle=t_node->m_parent->m_parent->m_right;
			if(((t_uncle)!=0) && t_uncle->m_color==-1){
				t_node->m_parent->m_color=1;
				t_uncle->m_color=1;
				t_uncle->m_parent->m_color=-1;
				t_node=t_uncle->m_parent;
			}else{
				if(t_node==t_node->m_parent->m_right){
					t_node=t_node->m_parent;
					p_RotateLeft5(t_node);
				}
				t_node->m_parent->m_color=1;
				t_node->m_parent->m_parent->m_color=-1;
				p_RotateRight5(t_node->m_parent->m_parent);
			}
		}else{
			c_Node7* t_uncle2=t_node->m_parent->m_parent->m_left;
			if(((t_uncle2)!=0) && t_uncle2->m_color==-1){
				t_node->m_parent->m_color=1;
				t_uncle2->m_color=1;
				t_uncle2->m_parent->m_color=-1;
				t_node=t_uncle2->m_parent;
			}else{
				if(t_node==t_node->m_parent->m_left){
					t_node=t_node->m_parent;
					p_RotateRight5(t_node);
				}
				t_node->m_parent->m_color=1;
				t_node->m_parent->m_parent->m_color=-1;
				p_RotateLeft5(t_node->m_parent->m_parent);
			}
		}
	}
	m_root->m_color=1;
	return 0;
}
bool c_Map5::p_Set5(String t_key,c_ModuleDecl* t_value){
	c_Node7* t_node=m_root;
	c_Node7* t_parent=0;
	int t_cmp=0;
	while((t_node)!=0){
		t_parent=t_node;
		t_cmp=p_Compare(t_key,t_node->m_key);
		if(t_cmp>0){
			t_node=t_node->m_right;
		}else{
			if(t_cmp<0){
				t_node=t_node->m_left;
			}else{
				t_node->m_value=t_value;
				return false;
			}
		}
	}
	t_node=(new c_Node7)->m_new(t_key,t_value,-1,t_parent);
	if((t_parent)!=0){
		if(t_cmp>0){
			t_parent->m_right=t_node;
		}else{
			t_parent->m_left=t_node;
		}
		p_InsertFixup5(t_node);
	}else{
		m_root=t_node;
	}
	return true;
}
bool c_Map5::p_Insert3(String t_key,c_ModuleDecl* t_value){
	return p_Set5(t_key,t_value);
}
c_MapValues* c_Map5::p_Values(){
	return (new c_MapValues)->m_new(this);
}
c_Node7* c_Map5::p_FirstNode(){
	if(!((m_root)!=0)){
		return 0;
	}
	c_Node7* t_node=m_root;
	while((t_node->m_left)!=0){
		t_node=t_node->m_left;
	}
	return t_node;
}
void c_Map5::mark(){
	Object::mark();
}
c_StringMap5::c_StringMap5(){
}
c_StringMap5* c_StringMap5::m_new(){
	c_Map5::m_new();
	return this;
}
int c_StringMap5::p_Compare(String t_lhs,String t_rhs){
	return t_lhs.Compare(t_rhs);
}
void c_StringMap5::mark(){
	c_Map5::mark();
}
c_Node7::c_Node7(){
	m_key=String();
	m_right=0;
	m_left=0;
	m_value=0;
	m_color=0;
	m_parent=0;
}
c_Node7* c_Node7::m_new(String t_key,c_ModuleDecl* t_value,int t_color,c_Node7* t_parent){
	this->m_key=t_key;
	this->m_value=t_value;
	this->m_color=t_color;
	this->m_parent=t_parent;
	return this;
}
c_Node7* c_Node7::m_new2(){
	return this;
}
c_Node7* c_Node7::p_NextNode(){
	c_Node7* t_node=0;
	if((m_right)!=0){
		t_node=m_right;
		while((t_node->m_left)!=0){
			t_node=t_node->m_left;
		}
		return t_node;
	}
	t_node=this;
	c_Node7* t_parent=this->m_parent;
	while(((t_parent)!=0) && t_node==t_parent->m_right){
		t_node=t_parent;
		t_parent=t_parent->m_parent;
	}
	return t_parent;
}
void c_Node7::mark(){
	Object::mark();
}
c_Parser::c_Parser(){
	m__toke=String();
	m__toker=0;
	m__app=0;
	m__module=0;
	m__defattrs=0;
	m__tokeType=0;
	m__block=0;
	m__blockStack=(new c_List9)->m_new();
	m__errStack=(new c_StringList)->m_new2();
	m__selTmpId=0;
}
int c_Parser::p_SetErr(int t_line){
	if(t_line==-1){
		t_line=m__toker->p_Line();
	}
	if((m__toker->p_Path()).Length()!=0){
		bb_config__errInfo=m__toker->p_Path()+String(L"<",1)+String(t_line)+String(L">",1);
	}
	return 0;
}
int c_Parser::p_CParse(String t_toke){
	if(m__toke!=t_toke){
		return 0;
	}
	p_NextToke();
	return 1;
}
int c_Parser::p_SkipEols(){
	while((p_CParse(String(L"\n",1)))!=0){
	}
	p_SetErr(-1);
	return 0;
}
String c_Parser::p_NextToke(){
	String t_toke=m__toke;
	do{
		m__toke=m__toker->p_NextToke();
		m__tokeType=m__toker->p_TokeType();
	}while(!(m__tokeType!=1));
	int t_2=m__tokeType;
	if(t_2==3){
		m__toke=m__toke.ToLower();
	}else{
		if(t_2==8){
			if((int)m__toke[0]==91 && (int)m__toke[m__toke.Length()-1]==93){
				m__toke=String(L"[]",2);
			}
		}
	}
	if(t_toke==String(L",",1)){
		p_SkipEols();
	}
	return m__toke;
}
c_Parser* c_Parser::m_new(c_Toker* t_toker,c_AppDecl* t_app,c_ModuleDecl* t_mdecl,int t_defattrs){
	m__toke=String(L"\n",1);
	m__toker=t_toker;
	m__app=t_app;
	m__module=t_mdecl;
	m__defattrs=t_defattrs;
	p_SetErr(-1);
	p_NextToke();
	return this;
}
c_Parser* c_Parser::m_new2(){
	return this;
}
String c_Parser::p_ParseStringLit(){
	if(m__tokeType!=6){
		bb_config_Err(String(L"Expecting string literal.",25));
	}
	String t_str=bb_config_Dequote(m__toke,String(L"cerberus",8));
	p_NextToke();
	return t_str;
}
String c_Parser::p_RealPath(String t_path){
	String t_popDir=CurrentDir();
	ChangeDir(bb_os_ExtractDir(m__toker->p_Path()));
	t_path=RealPath(t_path);
	ChangeDir(t_popDir);
	return t_path;
}
int c_Parser::p_ImportFile(String t_filepath){
	if((bb_config_ENV_SAFEMODE)!=0){
		if(m__app->m_mainModule==m__module){
			bb_config_Err(String(L"Import of external files not permitted in safe mode.",52));
		}
	}
	t_filepath=p_RealPath(t_filepath);
	if(FileType(t_filepath)!=1){
		bb_config_Err(String(L"File '",6)+t_filepath+String(L"' not found.",12));
	}
	m__app->m_fileImports->p_AddLast(t_filepath);
	return 0;
}
String c_Parser::p_ParseIdent(){
	String t_3=m__toke;
	if(t_3==String(L"@",1)){
		p_NextToke();
	}else{
		if(t_3==String(L"object",6) || t_3==String(L"throwable",9)){
		}else{
			if(m__tokeType!=2){
				bb_config_Err(String(L"Syntax error - Expecting identifier.",36));
			}
		}
	}
	String t_id=m__toke;
	p_NextToke();
	return t_id;
}
String c_Parser::p_ParseModPath(){
	String t_path=p_ParseIdent();
	while((p_CParse(String(L".",1)))!=0){
		t_path=t_path+(String(L".",1)+p_ParseIdent());
	}
	return t_path;
}
int c_Parser::p_ImportModule(String t_modpath,int t_attrs){
	return 0;
}
int c_Parser::p_IncludeFiles(String t_filepath){
	t_filepath=p_RealPath(t_filepath);
	bbPrint(String(L"IncludeFiles=",13)+t_filepath);
	if(FileType(t_filepath)!=1){
		bb_config_Err(String(L"Source File '",13)+t_filepath+String(L"' not found.",12));
	}
	m__app->m_fileIncludes->p_AddLast(t_filepath);
	return 0;
}
int c_Parser::p_IncludeDirs(String t_filepath){
	t_filepath=p_RealPath(t_filepath);
	bbPrint(String(L"IncludeDirs=",12)+t_filepath);
	if(FileType(t_filepath)!=2){
		bb_config_Err(String(L"Source directory '",18)+t_filepath+String(L"' not found.",12));
	}
	m__app->m_dirIncludes->p_AddLast(t_filepath);
	return 0;
}
int c_Parser::p_Parse(String t_toke){
	if(!((p_CParse(t_toke))!=0)){
		bb_config_Err(String(L"Syntax error - Expecting '",26)+t_toke+String(L"'.",2));
	}
	return 0;
}
c_Type* c_Parser::p_CParsePrimitiveType(){
	if((p_CParse(String(L"void",4)))!=0){
		return (c_Type::m_voidType);
	}
	if((p_CParse(String(L"bool",4)))!=0){
		return (c_Type::m_boolType);
	}
	if((p_CParse(String(L"int",3)))!=0){
		return (c_Type::m_intType);
	}
	if((p_CParse(String(L"float",5)))!=0){
		return (c_Type::m_floatType);
	}
	if((p_CParse(String(L"string",6)))!=0){
		return (c_Type::m_stringType);
	}
	if((p_CParse(String(L"object",6)))!=0){
		return (c_Type::m_objectType);
	}
	if((p_CParse(String(L"throwable",9)))!=0){
		return (c_Type::m_throwableType);
	}
	return 0;
}
c_IdentType* c_Parser::p_ParseIdentType(){
	String t_id=p_ParseIdent();
	if((p_CParse(String(L".",1)))!=0){
		t_id=t_id+(String(L".",1)+p_ParseIdent());
	}
	c_Stack4* t_args=(new c_Stack4)->m_new();
	if((p_CParse(String(L"<",1)))!=0){
		do{
			c_Type* t_arg=p_ParseType();
			while((p_CParse(String(L"[]",2)))!=0){
				t_arg=(t_arg->p_ArrayOf());
			}
			t_args->p_Push10(t_arg);
		}while(!(!((p_CParse(String(L",",1)))!=0)));
		p_Parse(String(L">",1));
	}
	return (new c_IdentType)->m_new(t_id,t_args->p_ToArray());
}
c_Type* c_Parser::p_ParseType(){
	c_Type* t_ty=p_CParsePrimitiveType();
	if((t_ty)!=0){
		return t_ty;
	}
	return (p_ParseIdentType());
}
c_Type* c_Parser::p_ParseDeclType(){
	c_Type* t_ty=0;
	String t_4=m__toke;
	if(t_4==String(L"?",1)){
		p_NextToke();
		t_ty=(c_Type::m_boolType);
	}else{
		if(t_4==String(L"%",1)){
			p_NextToke();
			t_ty=(c_Type::m_intType);
		}else{
			if(t_4==String(L"#",1)){
				p_NextToke();
				t_ty=(c_Type::m_floatType);
			}else{
				if(t_4==String(L"$",1)){
					p_NextToke();
					t_ty=(c_Type::m_stringType);
				}else{
					if(t_4==String(L":",1)){
						p_NextToke();
						t_ty=p_ParseType();
					}else{
						if((m__module->p_IsStrict())!=0){
							bb_config_Err(String(L"Illegal type expression.",24));
						}
						t_ty=(c_Type::m_intType);
					}
				}
			}
		}
	}
	while((p_CParse(String(L"[]",2)))!=0){
		t_ty=(t_ty->p_ArrayOf());
	}
	return t_ty;
}
c_ArrayExpr* c_Parser::p_ParseArrayExpr(){
	p_Parse(String(L"[",1));
	c_Stack5* t_args=(new c_Stack5)->m_new();
	do{
		t_args->p_Push13(p_ParseExpr());
	}while(!(!((p_CParse(String(L",",1)))!=0)));
	p_Parse(String(L"]",1));
	return (new c_ArrayExpr)->m_new(t_args->p_ToArray());
}
int c_Parser::p_AtEos(){
	return ((m__toke==String() || m__toke==String(L";",1) || m__toke==String(L"\n",1) || m__toke==String(L"else",4))?1:0);
}
Array<c_Expr* > c_Parser::p_ParseArgs2(int t_stmt){
	Array<c_Expr* > t_args=Array<c_Expr* >();
	if((t_stmt)!=0){
		if((p_AtEos())!=0){
			return t_args;
		}
	}else{
		if(m__toke!=String(L"(",1)){
			return t_args;
		}
	}
	int t_nargs=0;
	int t_eat=0;
	if(m__toke==String(L"(",1)){
		if((t_stmt)!=0){
			c_Toker* t_toker=(new c_Toker)->m_new2(m__toker);
			int t_bra=1;
			do{
				t_toker->p_NextToke();
				t_toker->p_SkipSpace();
				String t_5=t_toker->p_Toke().ToLower();
				if(t_5==String() || t_5==String(L"else",4)){
					bb_config_Err(String(L"Parenthesis mismatch error.",27));
				}else{
					if(t_5==String(L"(",1) || t_5==String(L"[",1)){
						t_bra+=1;
					}else{
						if(t_5==String(L"]",1) || t_5==String(L")",1)){
							t_bra-=1;
							if((t_bra)!=0){
								continue;
							}
							t_toker->p_NextToke();
							t_toker->p_SkipSpace();
							String t_6=t_toker->p_Toke().ToLower();
							if(t_6==String(L".",1) || t_6==String(L"(",1) || t_6==String(L"[",1) || t_6==String() || t_6==String(L";",1) || t_6==String(L"\n",1) || t_6==String(L"else",4)){
								t_eat=1;
							}
							break;
						}else{
							if(t_5==String(L",",1)){
								if(t_bra!=1){
									continue;
								}
								t_eat=1;
								break;
							}
						}
					}
				}
			}while(!(false));
		}else{
			t_eat=1;
		}
		if(((t_eat)!=0) && p_NextToke()==String(L")",1)){
			p_NextToke();
			return t_args;
		}
	}
	do{
		c_Expr* t_arg=0;
		if(((m__toke).Length()!=0) && m__toke!=String(L",",1)){
			t_arg=p_ParseExpr();
		}
		if(t_args.Length()==t_nargs){
			t_args=t_args.Resize(t_nargs+10);
		}
		t_args[t_nargs]=t_arg;
		t_nargs+=1;
	}while(!(!((p_CParse(String(L",",1)))!=0)));
	t_args=t_args.Slice(0,t_nargs);
	if((t_eat)!=0){
		p_Parse(String(L")",1));
	}
	return t_args;
}
c_IdentType* c_Parser::p_CParseIdentType(bool t_inner){
	if(m__tokeType!=2){
		return 0;
	}
	String t_id=p_ParseIdent();
	if((p_CParse(String(L".",1)))!=0){
		if(m__tokeType!=2){
			return 0;
		}
		t_id=t_id+(String(L".",1)+p_ParseIdent());
	}
	if(!((p_CParse(String(L"<",1)))!=0)){
		if(t_inner){
			return (new c_IdentType)->m_new(t_id,Array<c_Type* >());
		}
		return 0;
	}
	c_Stack4* t_args=(new c_Stack4)->m_new();
	do{
		c_Type* t_arg=p_CParsePrimitiveType();
		if(!((t_arg)!=0)){
			t_arg=(p_CParseIdentType(true));
			if(!((t_arg)!=0)){
				return 0;
			}
		}
		while((p_CParse(String(L"[]",2)))!=0){
			t_arg=(t_arg->p_ArrayOf());
		}
		t_args->p_Push10(t_arg);
	}while(!(!((p_CParse(String(L",",1)))!=0)));
	if(!((p_CParse(String(L">",1)))!=0)){
		return 0;
	}
	return (new c_IdentType)->m_new(t_id,t_args->p_ToArray());
}
c_TraceRecord* c_Parser::p_BackTrace(int t_tokeID){
	int t_blk=c_BlockTrace::m_TraceLog(t_tokeID);
	c_TraceRecord* t_record=c_BlockTrace::m_Pop();
	if(t_record!=0){
		p_SetErr(t_record->p_Line());
	}
	return t_record;
}
c_Expr* c_Parser::p_ParsePrimaryExpr(int t_stmt){
	c_Expr* t_expr=0;
	String t_7=m__toke;
	if(t_7==String(L"(",1)){
		p_NextToke();
		t_expr=p_ParseExpr();
		p_Parse(String(L")",1));
	}else{
		if(t_7==String(L"[",1)){
			t_expr=(p_ParseArrayExpr());
		}else{
			if(t_7==String(L"[]",2)){
				p_NextToke();
				t_expr=((new c_ConstExpr)->m_new((c_Type::m_emptyArrayType),String()));
			}else{
				if(t_7==String(L".",1)){
					t_expr=((new c_ScopeExpr)->m_new(m__module));
				}else{
					if(t_7==String(L"new",3)){
						p_NextToke();
						c_Type* t_ty=p_ParseType();
						if((p_CParse(String(L"[",1)))!=0){
							c_Expr* t_len=p_ParseExpr();
							p_Parse(String(L"]",1));
							while((p_CParse(String(L"[]",2)))!=0){
								t_ty=(t_ty->p_ArrayOf());
							}
							t_expr=((new c_NewArrayExpr)->m_new(t_ty,t_len));
						}else{
							t_expr=((new c_NewObjectExpr)->m_new(t_ty,p_ParseArgs2(t_stmt)));
						}
					}else{
						if(t_7==String(L"null",4)){
							p_NextToke();
							t_expr=((new c_ConstExpr)->m_new((c_Type::m_nullObjectType),String()));
						}else{
							if(t_7==String(L"true",4)){
								p_NextToke();
								t_expr=((new c_ConstExpr)->m_new((c_Type::m_boolType),String(L"1",1)));
							}else{
								if(t_7==String(L"false",5)){
									p_NextToke();
									t_expr=((new c_ConstExpr)->m_new((c_Type::m_boolType),String()));
								}else{
									if(t_7==String(L"bool",4) || t_7==String(L"int",3) || t_7==String(L"float",5) || t_7==String(L"string",6) || t_7==String(L"object",6) || t_7==String(L"throwable",9)){
										String t_id=m__toke;
										c_Type* t_ty2=p_ParseType();
										if(((p_CParse(String(L"(",1)))!=0)){
											t_expr=p_ParseExpr();
											p_Parse(String(L")",1));
											t_expr=((new c_CastExpr)->m_new(t_ty2,t_expr,1));
										}else{
											t_expr=((new c_IdentExpr)->m_new(t_id,0));
										}
									}else{
										if(t_7==String(L"self",4)){
											p_NextToke();
											t_expr=((new c_SelfExpr)->m_new());
										}else{
											if(t_7==String(L"super",5)){
												p_NextToke();
												p_Parse(String(L".",1));
												p_SkipEols();
												if(m__toke==String(L"new",3)){
													p_NextToke();
													c_FuncDecl* t_func=dynamic_cast<c_FuncDecl*>(m__block);
													if(!((t_func)!=0) || !((t_stmt)!=0) || !t_func->p_IsCtor() || !t_func->m_stmts->p_IsEmpty()){
														bb_config_Err(String(L"Call to Super.new must be first statement in a constructor.",59));
													}
													t_expr=((new c_InvokeSuperExpr)->m_new(String(L"new",3),p_ParseArgs2(t_stmt)));
													t_func->m_attrs|=8;
												}else{
													String t_id2=p_ParseIdent();
													t_expr=((new c_InvokeSuperExpr)->m_new(t_id2,p_ParseArgs2(t_stmt)));
												}
											}else{
												int t_8=m__tokeType;
												if(t_8==2){
													c_Toker* t_toker=(new c_Toker)->m_new2(m__toker);
													c_IdentType* t_ty3=p_CParseIdentType(false);
													if((t_ty3)!=0){
														t_expr=((new c_IdentTypeExpr)->m_new(t_ty3));
													}else{
														m__toker=t_toker;
														m__toke=m__toker->p_Toke();
														m__tokeType=m__toker->p_TokeType();
														t_expr=((new c_IdentExpr)->m_new(p_ParseIdent(),0));
													}
												}else{
													if(t_8==4){
														t_expr=((new c_ConstExpr)->m_new((c_Type::m_intType),m__toke));
														p_NextToke();
													}else{
														if(t_8==5){
															t_expr=((new c_ConstExpr)->m_new((c_Type::m_floatType),m__toke));
															p_NextToke();
														}else{
															if(t_8==6){
																t_expr=((new c_ConstExpr)->m_new((c_Type::m_stringType),bb_config_Dequote(m__toke,String(L"cerberus",8))));
																p_NextToke();
															}else{
																if(t_8==0){
																	c_TraceRecord* t_record=p_BackTrace(0);
																	bb_config_Err(String(L"End-Of-File. ",13)+c_BlockTrace::m_Code2Str(t_record->p_Toke())+String(L" block incorrectly terminated.",30));
																}else{
																	c_TraceRecord* t_record2=p_BackTrace(0);
																	if(t_record2!=0){
																		p_SetErr(m__toker->p_Line());
																	}else{
																		p_SetErr(-1);
																	}
																	bb_config_Err(String(L"Syntax error - Unexpected token '",33)+m__toke+String(L"'.",2));
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
	do{
		String t_9=m__toke;
		if(t_9==String(L".",1)){
			p_NextToke();
			p_SkipEols();
			String t_id3=p_ParseIdent();
			t_expr=((new c_IdentExpr)->m_new(t_id3,t_expr));
		}else{
			if(t_9==String(L"(",1)){
				t_expr=((new c_FuncCallExpr)->m_new(t_expr,p_ParseArgs2(t_stmt)));
			}else{
				if(t_9==String(L"[",1)){
					p_NextToke();
					if((p_CParse(String(L"..",2)))!=0){
						if(m__toke==String(L"]",1)){
							t_expr=((new c_SliceExpr)->m_new(t_expr,0,0));
						}else{
							t_expr=((new c_SliceExpr)->m_new(t_expr,0,p_ParseExpr()));
						}
					}else{
						c_Expr* t_from=p_ParseExpr();
						if((p_CParse(String(L"..",2)))!=0){
							if(m__toke==String(L"]",1)){
								t_expr=((new c_SliceExpr)->m_new(t_expr,t_from,0));
							}else{
								t_expr=((new c_SliceExpr)->m_new(t_expr,t_from,p_ParseExpr()));
							}
						}else{
							t_expr=((new c_IndexExpr)->m_new(t_expr,t_from));
						}
					}
					p_Parse(String(L"]",1));
				}else{
					return t_expr;
				}
			}
		}
	}while(!(false));
}
c_Expr* c_Parser::p_ParseUnaryExpr(){
	p_SkipEols();
	String t_op=m__toke;
	String t_10=t_op;
	if(t_10==String(L"+",1) || t_10==String(L"-",1) || t_10==String(L"~",1) || t_10==String(L"not",3)){
		p_NextToke();
		c_Expr* t_expr=p_ParseUnaryExpr();
		return ((new c_UnaryExpr)->m_new(t_op,t_expr));
	}
	return p_ParsePrimaryExpr(0);
}
c_Expr* c_Parser::p_ParseMulDivExpr(){
	c_Expr* t_expr=p_ParseUnaryExpr();
	do{
		String t_op=m__toke;
		String t_11=t_op;
		if(t_11==String(L"*",1) || t_11==String(L"/",1) || t_11==String(L"mod",3) || t_11==String(L"shl",3) || t_11==String(L"shr",3)){
			p_NextToke();
			c_Expr* t_rhs=p_ParseUnaryExpr();
			t_expr=((new c_BinaryMathExpr)->m_new(t_op,t_expr,t_rhs));
		}else{
			return t_expr;
		}
	}while(!(false));
}
c_Expr* c_Parser::p_ParseAddSubExpr(){
	c_Expr* t_expr=p_ParseMulDivExpr();
	do{
		String t_op=m__toke;
		String t_12=t_op;
		if(t_12==String(L"+",1) || t_12==String(L"-",1)){
			p_NextToke();
			c_Expr* t_rhs=p_ParseMulDivExpr();
			t_expr=((new c_BinaryMathExpr)->m_new(t_op,t_expr,t_rhs));
		}else{
			return t_expr;
		}
	}while(!(false));
}
c_Expr* c_Parser::p_ParseBitandExpr(){
	c_Expr* t_expr=p_ParseAddSubExpr();
	do{
		String t_op=m__toke;
		String t_13=t_op;
		if(t_13==String(L"&",1) || t_13==String(L"~",1)){
			p_NextToke();
			c_Expr* t_rhs=p_ParseAddSubExpr();
			t_expr=((new c_BinaryMathExpr)->m_new(t_op,t_expr,t_rhs));
		}else{
			return t_expr;
		}
	}while(!(false));
}
c_Expr* c_Parser::p_ParseBitorExpr(){
	c_Expr* t_expr=p_ParseBitandExpr();
	do{
		String t_op=m__toke;
		String t_14=t_op;
		if(t_14==String(L"|",1)){
			p_NextToke();
			c_Expr* t_rhs=p_ParseBitandExpr();
			t_expr=((new c_BinaryMathExpr)->m_new(t_op,t_expr,t_rhs));
		}else{
			return t_expr;
		}
	}while(!(false));
}
c_Expr* c_Parser::p_ParseCompareExpr(){
	c_Expr* t_expr=p_ParseBitorExpr();
	do{
		String t_op=m__toke;
		String t_15=t_op;
		if(t_15==String(L"=",1) || t_15==String(L"<",1) || t_15==String(L">",1) || t_15==String(L"<=",2) || t_15==String(L">=",2) || t_15==String(L"<>",2)){
			p_NextToke();
			if(t_op==String(L">",1) && m__toke==String(L"=",1)){
				t_op=t_op+m__toke;
				p_NextToke();
			}else{
				if(t_op==String(L"<",1) && (m__toke==String(L"=",1) || m__toke==String(L">",1))){
					t_op=t_op+m__toke;
					p_NextToke();
				}
			}
			c_Expr* t_rhs=p_ParseBitorExpr();
			t_expr=((new c_BinaryCompareExpr)->m_new(t_op,t_expr,t_rhs));
		}else{
			return t_expr;
		}
	}while(!(false));
}
c_Expr* c_Parser::p_ParseAndExpr(){
	c_Expr* t_expr=p_ParseCompareExpr();
	do{
		String t_op=m__toke;
		if(t_op==String(L"and",3)){
			p_NextToke();
			c_Expr* t_rhs=p_ParseCompareExpr();
			t_expr=((new c_BinaryLogicExpr)->m_new(t_op,t_expr,t_rhs));
		}else{
			return t_expr;
		}
	}while(!(false));
}
c_Expr* c_Parser::p_ParseOrExpr(){
	c_Expr* t_expr=p_ParseAndExpr();
	do{
		String t_op=m__toke;
		if(t_op==String(L"or",2)){
			p_NextToke();
			c_Expr* t_rhs=p_ParseAndExpr();
			t_expr=((new c_BinaryLogicExpr)->m_new(t_op,t_expr,t_rhs));
		}else{
			return t_expr;
		}
	}while(!(false));
}
c_Expr* c_Parser::p_ParseExpr(){
	return p_ParseOrExpr();
}
c_Decl* c_Parser::p_ParseDecl(String t_toke,int t_attrs){
	p_SetErr(-1);
	String t_id=p_ParseIdent();
	c_Type* t_ty=0;
	c_Expr* t_init=0;
	if((t_attrs&256)!=0){
		t_ty=p_ParseDeclType();
	}else{
		if((p_CParse(String(L":=",2)))!=0){
			t_init=p_ParseExpr();
		}else{
			t_ty=p_ParseDeclType();
			if((p_CParse(String(L"=",1)))!=0){
				t_init=p_ParseExpr();
			}else{
				if((p_CParse(String(L"[",1)))!=0){
					c_Expr* t_len=p_ParseExpr();
					p_Parse(String(L"]",1));
					while((p_CParse(String(L"[]",2)))!=0){
						t_ty=(t_ty->p_ArrayOf());
					}
					t_init=((new c_NewArrayExpr)->m_new(t_ty,t_len));
					t_ty=(t_ty->p_ArrayOf());
				}else{
					if(t_toke!=String(L"const",5)){
						t_init=((new c_ConstExpr)->m_new(t_ty,String()));
					}else{
						bb_config_Err(String(L"Constants must be initialized.",30));
					}
				}
			}
		}
	}
	c_ValDecl* t_decl=0;
	String t_21=t_toke;
	if(t_21==String(L"global",6)){
		t_decl=((new c_GlobalDecl)->m_new(t_id,t_attrs,t_ty,t_init));
	}else{
		if(t_21==String(L"field",5)){
			t_decl=((new c_FieldDecl)->m_new(t_id,t_attrs,t_ty,t_init));
		}else{
			if(t_21==String(L"const",5)){
				t_decl=((new c_ConstDecl)->m_new(t_id,t_attrs,t_ty,t_init));
			}else{
				if(t_21==String(L"local",5)){
					t_decl=((new c_LocalDecl)->m_new(t_id,t_attrs,t_ty,t_init));
				}
			}
		}
	}
	if(((t_decl->p_IsExtern())!=0) || ((p_CParse(String(L"extern",6)))!=0)){
		t_decl->m_munged=t_decl->m_ident;
		if((p_CParse(String(L"=",1)))!=0){
			t_decl->m_munged=p_ParseStringLit();
		}
	}
	return (t_decl);
}
c_List5* c_Parser::p_ParseDecls(String t_toke,int t_attrs){
	if((t_toke).Length()!=0){
		p_Parse(t_toke);
	}
	c_List5* t_decls=(new c_List5)->m_new();
	do{
		c_Decl* t_decl=p_ParseDecl(t_toke,t_attrs);
		t_decls->p_AddLast5(t_decl);
		if(!((p_CParse(String(L",",1)))!=0)){
			return t_decls;
		}
	}while(!(false));
}
c_List5* c_Parser::p_ParseEnumStmt(int t_attrs,bool t_createDeclList){
	if((t_attrs&256)!=0){
		bb_config_Err(String(L"Enumerations cannot be extern.",30));
	}
	c_List5* t_declList=0;
	if(t_createDeclList){
		t_declList=(new c_List5)->m_new();
	}
	String t_toke=m__toke;
	p_NextToke();
	int t_i=0;
	bool t_isFirst=true;
	c_Expr* t_lastInit=0;
	p_SkipEols();
	do{
		String t_id=p_ParseIdent();
		c_Expr* t_init=0;
		c_Decl* t_decl=0;
		if(m__toke!=String(L"=",1)){
			if(t_lastInit==0){
				t_init=((new c_ConstExpr)->m_new((c_Type::m_intType),String(t_i)));
			}else{
				t_init=((new c_BinaryMathExpr)->m_new(String(L"+",1),t_lastInit->p_Copy(),((new c_ConstExpr)->m_new((c_Type::m_intType),String(t_i)))));
			}
			t_decl=((new c_ConstDecl)->m_new(t_id,t_attrs,(c_Type::m_intType),t_init));
		}else{
			p_Parse(String(L"=",1));
			t_init=p_ParseExpr();
			t_lastInit=t_init;
			t_i=0;
			t_decl=((new c_ConstDecl)->m_new(t_id,t_attrs,(c_Type::m_intType),t_init));
		}
		t_i+=1;
		if(t_createDeclList){
			t_declList->p_AddLast5(t_decl);
		}else{
			m__block->p_AddStmt((new c_DeclStmt)->m_new(t_decl));
		}
	}while(!(!((p_CParse(String(L",",1)))!=0)));
	return t_declList;
}
c_List5* c_Parser::p_ParseEnum(String t_toke,int t_attrs){
	return p_ParseEnumStmt(t_attrs,true);
}
int c_Parser::p_PushBlock(c_BlockDecl* t_block){
	m__blockStack->p_AddLast9(m__block);
	m__errStack->p_AddLast(bb_config__errInfo);
	m__block=t_block;
	return 0;
}
int c_Parser::p_ParseDeclStmts(){
	String t_toke=m__toke;
	p_NextToke();
	do{
		c_Decl* t_decl=p_ParseDecl(t_toke,0);
		m__block->p_AddStmt((new c_DeclStmt)->m_new(t_decl));
	}while(!(!((p_CParse(String(L",",1)))!=0)));
	return 0;
}
int c_Parser::p_ParseReturnStmt(){
	p_Parse(String(L"return",6));
	c_Expr* t_expr=0;
	if(!((p_AtEos())!=0)){
		t_expr=p_ParseExpr();
	}
	m__block->p_AddStmt((new c_ReturnStmt)->m_new(t_expr));
	return 0;
}
int c_Parser::p_ParseExitStmt(){
	p_Parse(String(L"exit",4));
	m__block->p_AddStmt((new c_BreakStmt)->m_new());
	return 0;
}
int c_Parser::p_ParseContinueStmt(){
	p_Parse(String(L"continue",8));
	m__block->p_AddStmt((new c_ContinueStmt)->m_new());
	return 0;
}
int c_Parser::p_AtEOF(int t_tokeID,String t_msg){
	p_SetErr(c_BlockTrace::m_TraceLog(t_tokeID));
	bb_config_Err(String(L"End-Of-File Reached. ",21)+t_msg+String(L" block not terminated correctly.",32));
	return 0;
}
int c_Parser::p_AtEOF2(String t_tokeID,String t_msg){
	p_SetErr(c_BlockTrace::m_TraceLog2(t_tokeID));
	bb_config_Err(String(L"End-Of-File Reached. ",21)+t_msg+String(L" block not terminated correctly.",32));
	return 0;
}
int c_Parser::p_PopBlock(){
	m__block=m__blockStack->p_RemoveLast();
	bb_config__errInfo=m__errStack->p_RemoveLast();
	return 0;
}
int c_Parser::p_AtEos2(){
	return ((m__toke==String() || m__toke==String(L";",1) || m__toke==String(L"\n",1))?1:0);
}
int c_Parser::p_ParseBlockEnd(String t_toke,String t_msg,int t_log){
	p_SetErr(-1);
	if(!((p_CParse(t_toke))!=0) && p_AtEos2()==0 && m__tokeType!=9){
		if(t_msg!=String()){
			if((t_log)!=0){
				c_BlockTrace::m_TraceLog2(t_toke);
			}
			bb_config_Err(t_msg);
		}
		return 1;
	}
	return 0;
}
int c_Parser::p_ParseIfStmt(String t_term){
	int t_lineStart=m__toker->p_Line();
	int t_tokeID=4;
	p_CParse(String(L"if",2));
	c_Expr* t_expr=p_ParseExpr();
	p_CParse(String(L"then",4));
	c_BlockDecl* t_thenBlock=(new c_BlockDecl)->m_new(m__block);
	c_BlockDecl* t_elseBlock=(new c_BlockDecl)->m_new(m__block);
	int t_eatTerm=0;
	if(!((t_term).Length()!=0)){
		if(m__toke==String(L"\n",1)){
			t_term=String(L"end",3);
		}else{
			t_term=String(L"\n",1);
		}
		t_eatTerm=1;
	}
	c_BlockTrace::m_Push(t_tokeID,t_lineStart);
	p_PushBlock(t_thenBlock);
	while(m__toke!=t_term){
		if(m__tokeType==0){
			p_AtEOF(t_tokeID,String(L"Conditional",11));
		}
		String t_16=m__toke;
		if(t_16==String(L"endif",5)){
			if(t_term==String(L"end",3)){
				break;
			}
			p_SetErr(c_BlockTrace::m_TraceLog(t_tokeID));
			bb_config_Err(String(L"Syntax error - Expecting conditional blocks to terminate with 'End', 'End If' or 'Endif'.",89));
		}else{
			if(t_16==String(L"else",4) || t_16==String(L"elseif",6)){
				int t_elif=((m__toke==String(L"elseif",6))?1:0);
				p_NextToke();
				if(m__block==t_elseBlock){
					bb_config_Err(String(L"If statement can only have one 'else' block.",44));
				}
				p_PopBlock();
				p_PushBlock(t_elseBlock);
				if(((t_elif)!=0) || m__toke==String(L"if",2)){
					p_ParseIfStmt(t_term);
				}
			}else{
				p_ParseStmt();
			}
		}
	}
	p_PopBlock();
	c_TraceRecord* t_blkTrace=c_BlockTrace::m_Pop();
	if((t_eatTerm)!=0){
		p_NextToke();
		if(t_term==String(L"end",3)){
			p_ParseBlockEnd(String(L"if",2),String(L"Syntax error - Expecting conditional blocks to terminate with 'End', 'Endif' Or 'End If'.",89),1);
		}
	}
	c_IfStmt* t_stmt=(new c_IfStmt)->m_new(t_expr,t_thenBlock,t_elseBlock);
	m__block->p_AddStmt(t_stmt);
	return 0;
}
int c_Parser::p_ParseWhileStmt(){
	int t_lineStart=m__toker->p_Line();
	int t_tokeID=6;
	p_SetErr(-1);
	String t_errLine=bb_config__errInfo;
	p_Parse(String(L"while",5));
	c_Expr* t_expr=p_ParseExpr();
	c_BlockDecl* t_block=(new c_BlockDecl)->m_new(m__block);
	c_BlockTrace::m_Push(t_tokeID,t_lineStart);
	p_PushBlock(t_block);
	while(true){
		if(m__tokeType==0){
			p_AtEOF(t_tokeID,String(L"While/Wend/End While iterator",29));
		}
		if(!((p_CParse(String(L"wend",4)))!=0)){
			if((p_CParse(String(L"end",3)))!=0){
				if(!((p_ParseBlockEnd(String(L"while",5),String(L"Syntax error - Expecting 'while' block to terminate with 'End' or 'End While'.",78),0))!=0)){
					break;
				}
				break;
			}
		}else{
			if(!((p_AtEos2())!=0)){
				p_SetErr(-1);
				bb_config_Err(String(L"Syntax error - Wend does not except a variable or expression.",61));
			}
			break;
		}
		p_ParseStmt();
	}
	p_PopBlock();
	c_TraceRecord* t_blkTrace=c_BlockTrace::m_Pop();
	c_WhileStmt* t_stmt=(new c_WhileStmt)->m_new(t_expr,t_block);
	m__block->p_AddStmt(t_stmt);
	return 0;
}
int c_Parser::p_PushErr(){
	m__errStack->p_AddLast(bb_config__errInfo);
	return 0;
}
int c_Parser::p_PopErr(){
	bb_config__errInfo=m__errStack->p_RemoveLast();
	return 0;
}
int c_Parser::p_ParseRepeatStmt(){
	int t_lineStart=m__toker->p_Line();
	int t_tokeID=5;
	p_Parse(String(L"repeat",6));
	c_BlockDecl* t_block=(new c_BlockDecl)->m_new(m__block);
	c_BlockTrace::m_Push(t_tokeID,t_lineStart);
	p_PushBlock(t_block);
	while(m__toke!=String(L"until",5) && m__toke!=String(L"forever",7) && m__tokeType!=0){
		p_ParseStmt();
	}
	p_PopBlock();
	if(m__tokeType==0){
		p_AtEOF(t_tokeID,String(L"Repeat/Until/Forever",20));
	}
	c_TraceRecord* t_blkTrace=c_BlockTrace::m_Pop();
	c_Expr* t_expr=0;
	if((p_CParse(String(L"until",5)))!=0){
		p_PushErr();
		t_expr=p_ParseExpr();
		p_PopErr();
	}else{
		p_Parse(String(L"forever",7));
		t_expr=((new c_ConstExpr)->m_new((c_Type::m_boolType),String()));
	}
	c_RepeatStmt* t_stmt=(new c_RepeatStmt)->m_new(t_block,t_expr);
	m__block->p_AddStmt(t_stmt);
	return 0;
}
int c_Parser::p_ParseForStmt(){
	int t_lineStart=m__toker->p_Line();
	int t_tokeID=1;
	p_Parse(String(L"for",3));
	String t_varid=String();
	c_Type* t_varty=0;
	int t_varlocal=0;
	if((p_CParse(String(L"local",5)))!=0){
		t_varlocal=1;
		t_varid=p_ParseIdent();
		if(!((p_CParse(String(L":=",2)))!=0)){
			t_varty=p_ParseDeclType();
			p_Parse(String(L"=",1));
		}
	}else{
		t_varlocal=0;
		t_varid=p_ParseIdent();
		p_Parse(String(L"=",1));
	}
	if((p_CParse(String(L"eachin",6)))!=0){
		c_Expr* t_expr=p_ParseExpr();
		c_BlockDecl* t_block=(new c_BlockDecl)->m_new(m__block);
		c_BlockTrace::m_Push(t_tokeID,t_lineStart);
		p_PushBlock(t_block);
		while(true){
			if(m__tokeType==0){
				p_AtEOF(t_tokeID,String(L"For/Next/End For",16));
			}
			if((p_CParse(String(L"next",4)))!=0){
				if(m__tokeType==2 && p_ParseIdent()!=t_varid){
					bb_config_Err(String(L"Syntax error - Next variable name does not match For variable name",66));
				}
				if(!((p_AtEos2())!=0)){
					c_BlockTrace::m_TraceLog(t_tokeID);
					bb_config_Err(String(L"Syntax error - Expecting 'For' iterator to terminate with 'Next', 'End' or 'End For'.",85));
				}
				break;
			}else{
				if((p_CParse(String(L"end",3)))!=0){
					if(m__toke!=String(L"for",3)){
						if(m__tokeType==2 && p_ParseIdent()!=t_varid){
							bb_config_Err(String(L"Syntax error - Next variable name does not match For variable name",66));
						}
						if(!((p_AtEos2())!=0)){
							c_BlockTrace::m_TraceLog(t_tokeID);
							bb_config_Err(String(L"Syntax error - Expecting 'For' iterator to terminate with 'Next', 'End' or 'End For'.",85));
						}
					}else{
						p_NextToke();
						if(m__tokeType==2 && p_ParseIdent()!=t_varid){
							bb_config_Err(String(L"Syntax error - Next variable name does not match For variable name",66));
						}
						if(!((p_AtEos2())!=0)){
							c_BlockTrace::m_TraceLog(t_tokeID);
							bb_config_Err(String(L"Syntax error - Expecting 'For' iterator to terminate with 'Next', 'End' or 'End For'.",85));
						}
					}
					break;
				}
			}
			p_ParseStmt();
		}
		p_PopBlock();
		c_TraceRecord* t_blkTrace=c_BlockTrace::m_Pop();
		c_ForEachinStmt* t_stmt=(new c_ForEachinStmt)->m_new(t_varid,t_varty,t_varlocal,t_expr,t_block);
		m__block->p_AddStmt(t_stmt);
		return 0;
	}
	c_Expr* t_from=p_ParseExpr();
	String t_op=String();
	if((p_CParse(String(L"to",2)))!=0){
		t_op=String(L"<=",2);
	}else{
		if((p_CParse(String(L"until",5)))!=0){
			t_op=String(L"<",1);
		}else{
			bb_config_Err(String(L"Expecting 'To' or 'Until'.",26));
		}
	}
	c_Expr* t_term=p_ParseExpr();
	c_Expr* t_stp=0;
	if((p_CParse(String(L"step",4)))!=0){
		t_stp=p_ParseExpr();
	}else{
		t_stp=((new c_ConstExpr)->m_new((c_Type::m_intType),String(L"1",1)));
	}
	c_Stmt* t_init=0;
	c_Expr* t_expr2=0;
	c_Stmt* t_incr=0;
	if((t_varlocal)!=0){
		c_LocalDecl* t_indexVar=(new c_LocalDecl)->m_new(t_varid,0,t_varty,t_from);
		t_init=((new c_DeclStmt)->m_new(t_indexVar));
	}else{
		t_init=((new c_AssignStmt)->m_new(String(L"=",1),((new c_IdentExpr)->m_new(t_varid,0)),t_from));
	}
	t_expr2=((new c_BinaryCompareExpr)->m_new(t_op,((new c_IdentExpr)->m_new(t_varid,0)),t_term));
	t_incr=((new c_AssignStmt)->m_new(String(L"=",1),((new c_IdentExpr)->m_new(t_varid,0)),((new c_BinaryMathExpr)->m_new(String(L"+",1),((new c_IdentExpr)->m_new(t_varid,0)),t_stp))));
	c_BlockDecl* t_block2=(new c_BlockDecl)->m_new(m__block);
	c_BlockTrace::m_Push(t_tokeID,t_lineStart);
	p_PushBlock(t_block2);
	while(true){
		if(m__tokeType==0){
			p_AtEOF(t_tokeID,String(L"For/Next/End For",16));
		}
		if((p_CParse(String(L"next",4)))!=0){
			if(m__tokeType==2 && p_ParseIdent()!=t_varid){
				bb_config_Err(String(L"Syntax error - Next variable name does not match For variable name",66));
			}
			if(!((p_AtEos2())!=0)){
				c_BlockTrace::m_TraceLog(t_tokeID);
				bb_config_Err(String(L"Syntax error - Expecting 'For' iterator to terminate with 'Next', 'End' or 'End For'.",85));
			}
			break;
		}else{
			if((p_CParse(String(L"end",3)))!=0){
				if(m__toke!=String(L"for",3)){
					if(m__tokeType==2 && p_ParseIdent()!=t_varid){
						bb_config_Err(String(L"Syntax error - Next variable name does not match For variable name",66));
					}
					if(!((p_AtEos2())!=0)){
						c_BlockTrace::m_TraceLog(t_tokeID);
						bb_config_Err(String(L"Syntax error - Expecting 'For' iterator to terminate with 'Next', 'End' or 'End For'.",85));
					}
				}else{
					p_NextToke();
					if(m__tokeType==2 && p_ParseIdent()!=t_varid){
						bb_config_Err(String(L"Syntax error - Next variable name does not match For variable name",66));
					}
					if(!((p_AtEos2())!=0)){
						c_BlockTrace::m_TraceLog(t_tokeID);
						bb_config_Err(String(L"Syntax error - Expecting 'For' iterator to terminate with 'Next', 'End' or 'End For'.",85));
					}
				}
				break;
			}
		}
		p_ParseStmt();
	}
	p_PopBlock();
	c_TraceRecord* t_blkTrace2=c_BlockTrace::m_Pop();
	c_ForStmt* t_stmt2=(new c_ForStmt)->m_new(t_init,t_expr2,t_incr,t_block2);
	m__block->p_AddStmt(t_stmt2);
	return 0;
}
int c_Parser::p_ParseSelectStmt(){
	p_Parse(String(L"select",6));
	int t_lineStart=m__toker->p_Line();
	int t_tokeID=9;
	c_Expr* t_expr=p_ParseExpr();
	c_BlockDecl* t_block=m__block;
	c_BlockTrace::m_Push(t_tokeID,t_lineStart);
	m__selTmpId+=1;
	String t_tmpId=String(m__selTmpId);
	t_block->p_AddStmt((new c_DeclStmt)->m_new2(t_tmpId,0,t_expr));
	c_IdentExpr* t_tmpExpr=(new c_IdentExpr)->m_new(t_tmpId,0);
	while(m__toke!=String(L"end",3) && m__toke!=String(L"default",7)){
		p_SetErr(-1);
		if(m__tokeType==0){
			break;
		}
		String t_17=m__toke;
		if(t_17==String(L"\n",1)){
			p_NextToke();
		}else{
			if(t_17==String(L"case",4)){
				p_NextToke();
				c_Expr* t_comp=0;
				do{
					c_Expr* t_expr2=((new c_IdentExpr)->m_new(t_tmpId,0));
					t_expr2=((new c_BinaryCompareExpr)->m_new(String(L"=",1),t_expr2,p_ParseExpr()));
					if((t_comp)!=0){
						t_comp=((new c_BinaryLogicExpr)->m_new(String(L"or",2),t_comp,t_expr2));
					}else{
						t_comp=t_expr2;
					}
				}while(!(!((p_CParse(String(L",",1)))!=0)));
				c_BlockDecl* t_thenBlock=(new c_BlockDecl)->m_new(m__block);
				c_BlockDecl* t_elseBlock=(new c_BlockDecl)->m_new(m__block);
				c_IfStmt* t_ifstmt=(new c_IfStmt)->m_new(t_comp,t_thenBlock,t_elseBlock);
				t_block->p_AddStmt(t_ifstmt);
				t_block=t_ifstmt->m_thenBlock;
				p_PushBlock(t_block);
				while(m__toke!=String(L"case",4) && m__toke!=String(L"default",7) && m__toke!=String(L"end",3)){
					p_ParseStmt();
				}
				p_PopBlock();
				t_block=t_elseBlock;
			}else{
				bb_config_Err(String(L"Syntax error - Expecting 'Case', 'Default' or 'End'.",52));
			}
		}
	}
	if(m__toke==String(L"default",7)){
		p_NextToke();
		p_PushBlock(t_block);
		while(m__toke!=String(L"end",3)){
			if(m__tokeType==0){
				break;
			}
			p_SetErr(-1);
			String t_18=m__toke;
			if(t_18==String(L"case",4)){
				bb_config_Err(String(L"Case can not appear after default.",34));
			}else{
				if(t_18==String(L"default",7)){
					bb_config_Err(String(L"Select statement can have only one default block.",49));
				}
			}
			p_ParseStmt();
		}
		p_PopBlock();
	}
	if(m__tokeType==0){
		p_AtEOF(t_tokeID,String(L"Selec/Case",10));
	}
	p_SetErr(-1);
	p_Parse(String(L"end",3));
	p_ParseBlockEnd(String(L"select",6),String(L"Syntax error -Expecting 'Select' block to terminate with 'End' or 'End Select'.",79),0);
	c_BlockTrace::m_Pop();
	return 0;
}
int c_Parser::p_ParseTryStmt(){
	int t_lineStart=m__toker->p_Line();
	int t_tokeID=6;
	p_Parse(String(L"try",3));
	c_BlockDecl* t_block=(new c_BlockDecl)->m_new(m__block);
	c_Stack8* t_catches=(new c_Stack8)->m_new();
	c_BlockTrace::m_Push(t_tokeID,t_lineStart);
	p_PushBlock(t_block);
	while(m__toke!=String(L"end",3)){
		if(m__tokeType==0){
			p_AtEOF(t_tokeID,String(L"Try/End Try",11));
		}
		if((p_CParse(String(L"catch",5)))!=0){
			String t_id=p_ParseIdent();
			p_Parse(String(L":",1));
			c_Type* t_ty=p_ParseType();
			c_LocalDecl* t_init=(new c_LocalDecl)->m_new(t_id,0,t_ty,0);
			c_BlockDecl* t_block2=(new c_BlockDecl)->m_new(m__block);
			t_catches->p_Push22((new c_CatchStmt)->m_new(t_init,t_block2));
			p_PopBlock();
			p_PushBlock(t_block2);
		}else{
			p_ParseStmt();
		}
	}
	if(!((t_catches->p_Length2())!=0)){
		bb_config_Err(String(L"Try block must have at least one catch block",44));
	}
	p_PopBlock();
	c_TraceRecord* t_record=c_BlockTrace::m_Pop();
	p_NextToke();
	p_ParseBlockEnd(String(L"try",3),String(L"Expecting 'Try' block must terminate with 'End' or 'End Try'.",61),0);
	m__block->p_AddStmt((new c_TryStmt)->m_new(t_block,t_catches->p_ToArray()));
	return 0;
}
int c_Parser::p_ParseThrowStmt(){
	p_Parse(String(L"throw",5));
	m__block->p_AddStmt((new c_ThrowStmt)->m_new(p_ParseExpr()));
	return 0;
}
int c_Parser::p_ParseStmt(){
	p_SetErr(-1);
	String t_19=m__toke;
	if(t_19==String(L";",1) || t_19==String(L"\n",1)){
		p_NextToke();
	}else{
		if(t_19==String(L"const",5) || t_19==String(L"local",5)){
			p_ParseDeclStmts();
		}else{
			if(t_19==String(L"enumerate",9)){
				p_ParseEnumStmt(0,false);
			}else{
				if(t_19==String(L"return",6)){
					p_ParseReturnStmt();
				}else{
					if(t_19==String(L"exit",4)){
						p_ParseExitStmt();
					}else{
						if(t_19==String(L"continue",8)){
							p_ParseContinueStmt();
						}else{
							if(t_19==String(L"if",2)){
								p_ParseIfStmt(String());
							}else{
								if(t_19==String(L"while",5)){
									p_ParseWhileStmt();
								}else{
									if(t_19==String(L"repeat",6)){
										p_ParseRepeatStmt();
									}else{
										if(t_19==String(L"for",3)){
											p_ParseForStmt();
										}else{
											if(t_19==String(L"select",6)){
												p_ParseSelectStmt();
											}else{
												if(t_19==String(L"try",3)){
													p_ParseTryStmt();
												}else{
													if(t_19==String(L"throw",5)){
														p_ParseThrowStmt();
													}else{
														c_Expr* t_expr=p_ParsePrimaryExpr(1);
														String t_20=m__toke;
														if(t_20==String(L"=",1) || t_20==String(L"*=",2) || t_20==String(L"/=",2) || t_20==String(L"+=",2) || t_20==String(L"-=",2) || t_20==String(L"&=",2) || t_20==String(L"|=",2) || t_20==String(L"~=",2) || t_20==String(L"mod",3) || t_20==String(L"shl",3) || t_20==String(L"shr",3)){
															if(((dynamic_cast<c_IdentExpr*>(t_expr))!=0) || ((dynamic_cast<c_IndexExpr*>(t_expr))!=0)){
																String t_op=m__toke;
																p_NextToke();
																if(!t_op.EndsWith(String(L"=",1))){
																	p_Parse(String(L"=",1));
																	t_op=t_op+String(L"=",1);
																}
																m__block->p_AddStmt((new c_AssignStmt)->m_new(t_op,t_expr,p_ParseExpr()));
															}else{
																bb_config_Err(String(L"Assignment operator '",21)+m__toke+String(L"' cannot be used this way.",26));
															}
															return 0;
														}
														if((dynamic_cast<c_IdentExpr*>(t_expr))!=0){
															t_expr=((new c_FuncCallExpr)->m_new(t_expr,p_ParseArgs2(1)));
														}else{
															if(((dynamic_cast<c_FuncCallExpr*>(t_expr))!=0) || ((dynamic_cast<c_InvokeSuperExpr*>(t_expr))!=0) || ((dynamic_cast<c_NewObjectExpr*>(t_expr))!=0)){
															}else{
																bb_config_Err(String(L"Expression cannot be used as a statement.",41));
															}
														}
														m__block->p_AddStmt((new c_ExprStmt)->m_new(t_expr));
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
	return 0;
}
c_FuncDecl* c_Parser::p_ParseFuncDecl(int t_attrs){
	int t_lineStart=m__toker->p_Line();
	int t_tokeID=2;
	p_SetErr(-1);
	if((p_CParse(String(L"method",6)))!=0){
		t_attrs|=1;
		t_tokeID=3;
	}else{
		if(!((p_CParse(String(L"function",8)))!=0)){
			bb_config_InternalErr(String(L"Internal error",14));
		}
	}
	t_attrs|=m__defattrs;
	String t_id=String();
	c_Type* t_ty=0;
	if((t_attrs&1)!=0){
		if(m__toke==String(L"new",3)){
			if((t_attrs&256)!=0){
				bb_config_Err(String(L"Extern classes cannot have constructors.",40));
			}
			t_id=m__toke;
			p_NextToke();
			t_attrs|=2;
			t_attrs&=-2;
		}else{
			t_id=p_ParseIdent();
			t_ty=p_ParseDeclType();
		}
	}else{
		t_id=p_ParseIdent();
		t_ty=p_ParseDeclType();
	}
	c_Stack7* t_args=(new c_Stack7)->m_new();
	p_Parse(String(L"(",1));
	p_SkipEols();
	if(m__toke!=String(L")",1)){
		do{
			String t_id2=p_ParseIdent();
			c_Type* t_ty2=p_ParseDeclType();
			c_Expr* t_init=0;
			if((p_CParse(String(L"=",1)))!=0){
				t_init=p_ParseExpr();
			}
			t_args->p_Push19((new c_ArgDecl)->m_new(t_id2,0,t_ty2,t_init));
			if(m__toke==String(L")",1)){
				break;
			}
			p_Parse(String(L",",1));
		}while(!(false));
	}
	p_Parse(String(L")",1));
	do{
		if((p_CParse(String(L"final",5)))!=0){
			if(!((t_attrs&1)!=0)){
				bb_config_Err(String(L"Functions cannot be final.",26));
			}
			if((t_attrs&2048)!=0){
				bb_config_Err(String(L"Duplicate method attribute.",27));
			}
			if((t_attrs&1024)!=0){
				bb_config_Err(String(L"Methods cannot be both final and abstract.",42));
			}
			t_attrs|=2048;
		}else{
			if((p_CParse(String(L"abstract",8)))!=0){
				if(!((t_attrs&1)!=0)){
					bb_config_Err(String(L"Functions cannot be abstract.",29));
				}
				if((t_attrs&1024)!=0){
					bb_config_Err(String(L"Duplicate method attribute.",27));
				}
				if((t_attrs&2048)!=0){
					bb_config_Err(String(L"Methods cannot be both final and abstract.",42));
				}
				t_attrs|=1024;
			}else{
				if((p_CParse(String(L"property",8)))!=0){
					if(!((t_attrs&1)!=0)){
						bb_config_Err(String(L"Functions cannot be properties.",31));
					}
					if((t_attrs&4)!=0){
						bb_config_Err(String(L"Duplicate method attribute.",27));
					}
					t_attrs|=4;
				}else{
					break;
				}
			}
		}
	}while(!(false));
	c_FuncDecl* t_funcDecl=(new c_FuncDecl)->m_new(t_id,t_attrs,t_ty,t_args->p_ToArray());
	if(((t_funcDecl->p_IsExtern())!=0) || ((p_CParse(String(L"extern",6)))!=0)){
		t_funcDecl->m_munged=t_funcDecl->m_ident;
		if((p_CParse(String(L"=",1)))!=0){
			t_funcDecl->m_munged=p_ParseStringLit();
			if(t_funcDecl->m_munged==String(L"$resize",7)){
				t_funcDecl->m_retType=(c_Type::m_emptyArrayType);
			}
		}
	}
	if(((t_funcDecl->p_IsExtern())!=0) || ((t_funcDecl->p_IsAbstract())!=0)){
		return t_funcDecl;
	}
	c_BlockTrace::m_Push(t_tokeID,t_lineStart);
	p_PushBlock(t_funcDecl);
	while(m__toke!=String(L"end",3)){
		p_ParseStmt();
	}
	p_PopBlock();
	c_TraceRecord* t_blkTrace=c_BlockTrace::m_Pop();
	if(m__toke==String(L"end",3)){
		p_NextToke();
		String t_blkend=String(L"function",8);
		String t_msg=String(L"Syntax error - Expecting Function block to terminate with 'End' or 'End Function'.",82);
		if((t_attrs&3)!=0){
			t_blkend=String(L"method",6);
			t_msg=String(L"Syntax error - Expecting Method block to terminate with 'End' Or 'End Method'.",78);
		}
		p_SetErr(-1);
		p_ParseBlockEnd(t_blkend,t_msg,0);
	}else{
		p_NextToke();
	}
	return t_funcDecl;
}
c_ClassDecl* c_Parser::p_ParseClassDecl(int t_attrs){
	p_SetErr(-1);
	String t_toke=m__toke;
	int t_lineStart=m__toker->p_Line();
	int t_tokeID=7;
	if((p_CParse(String(L"interface",9)))!=0){
		if((t_attrs&256)!=0){
			bb_config_Err(String(L"Interfaces cannot be extern.",28));
		}
		t_attrs|=5120;
		t_tokeID=8;
	}else{
		if(!((p_CParse(String(L"class",5)))!=0)){
			bb_config_InternalErr(String(L"Internal error",14));
		}
	}
	c_BlockTrace::m_Push(t_tokeID,t_lineStart);
	String t_id=p_ParseIdent();
	c_StringStack* t_args=(new c_StringStack)->m_new2();
	c_IdentType* t_superTy=c_Type::m_objectType;
	c_Stack6* t_imps=(new c_Stack6)->m_new();
	if((p_CParse(String(L"<",1)))!=0){
		if((t_attrs&256)!=0){
			bb_config_Err(String(L"Extern classes cannot be generic.",33));
		}
		do{
			t_args->p_Push(p_ParseIdent());
		}while(!(!((p_CParse(String(L",",1)))!=0)));
		p_Parse(String(L">",1));
	}
	if((p_CParse(String(L"extends",7)))!=0){
		if((p_CParse(String(L"null",4)))!=0){
			if((t_attrs&4096)!=0){
				bb_config_Err(String(L"Interfaces cannot extend null",29));
			}
			if(!((t_attrs&256)!=0)){
				bb_config_Err(String(L"Only extern objects can extend null.",36));
			}
			t_superTy=0;
		}else{
			if((t_attrs&4096)!=0){
				do{
					t_imps->p_Push16(p_ParseIdentType());
				}while(!(!((p_CParse(String(L",",1)))!=0)));
				t_superTy=c_Type::m_objectType;
			}else{
				t_superTy=p_ParseIdentType();
			}
		}
	}
	if((p_CParse(String(L"implements",10)))!=0){
		if((t_attrs&256)!=0){
			bb_config_Err(String(L"Implements cannot be used with external classes.",48));
		}
		if((t_attrs&4096)!=0){
			bb_config_Err(String(L"Implements cannot be used with interfaces.",42));
		}
		do{
			t_imps->p_Push16(p_ParseIdentType());
		}while(!(!((p_CParse(String(L",",1)))!=0)));
	}
	do{
		if((p_CParse(String(L"final",5)))!=0){
			if((t_attrs&4096)!=0){
				bb_config_Err(String(L"Interfaces cannot be final.",27));
			}
			if((t_attrs&2048)!=0){
				bb_config_Err(String(L"Duplicate class attribute.",26));
			}
			if((t_attrs&1024)!=0){
				bb_config_Err(String(L"Classes cannot be both final and abstract.",42));
			}
			t_attrs|=2048;
		}else{
			if((p_CParse(String(L"abstract",8)))!=0){
				if((t_attrs&4096)!=0){
					bb_config_Err(String(L"Interfaces cannot be abstract.",30));
				}
				if((t_attrs&1024)!=0){
					bb_config_Err(String(L"Duplicate class attribute.",26));
				}
				if((t_attrs&2048)!=0){
					bb_config_Err(String(L"Classes cannot be both final and abstract.",42));
				}
				t_attrs|=1024;
			}else{
				break;
			}
		}
	}while(!(false));
	c_ClassDecl* t_classDecl=(new c_ClassDecl)->m_new(t_id,t_attrs,t_args->p_ToArray(),t_superTy,t_imps->p_ToArray());
	if(((t_classDecl->p_IsExtern())!=0) || ((p_CParse(String(L"extern",6)))!=0)){
		t_classDecl->m_munged=t_classDecl->m_ident;
		if((p_CParse(String(L"=",1)))!=0){
			t_classDecl->m_munged=p_ParseStringLit();
		}
	}
	int t_decl_attrs=t_attrs&256;
	int t_func_attrs=0;
	if((t_attrs&4096)!=0){
		t_func_attrs|=1024;
	}
	do{
		p_SkipEols();
		String t_22=m__toke;
		if(t_22==String(L"end",3)){
			p_NextToke();
			break;
		}else{
			if(t_22==String(L"public",6)){
				p_NextToke();
				t_decl_attrs&=-16897;
			}else{
				if(t_22==String(L"private",7)){
					p_NextToke();
					t_decl_attrs&=-16897;
					t_decl_attrs|=512;
				}else{
					if(t_22==String(L"protected",9)){
						p_NextToke();
						t_decl_attrs&=-16897;
						t_decl_attrs|=16384;
					}else{
						if(t_22==String(L"const",5) || t_22==String(L"global",6) || t_22==String(L"field",5)){
							if(((t_attrs&4096)!=0) && m__toke!=String(L"const",5)){
								bb_config_Err(String(L"Interfaces can only contain constants and methods.",50));
							}
							t_classDecl->p_InsertDecls(p_ParseDecls(m__toke,t_decl_attrs));
						}else{
							if(t_22==String(L"enumerate",9)){
								t_classDecl->p_InsertDecls(p_ParseEnum(m__toke,t_decl_attrs));
							}else{
								if(t_22==String(L"method",6)){
									t_classDecl->p_InsertDecl(p_ParseFuncDecl(t_decl_attrs|t_func_attrs));
								}else{
									if(t_22==String(L"function",8)){
										if((t_attrs&4096)!=0){
											bb_config_Err(String(L"Interfaces can only contain constants and methods.",50));
										}
										t_classDecl->p_InsertDecl(p_ParseFuncDecl(t_decl_attrs|t_func_attrs));
									}else{
										if(m__tokeType==0){
											p_AtEOF(0,String(L"Code",4));
										}
										bb_config_Err(String(L"Syntax error - Expecting class member declaration.",50));
									}
								}
							}
						}
					}
				}
			}
		}
	}while(!(false));
	if((t_toke).Length()!=0){
		String t_msg=String();
		if(t_toke==String(L"class",5)){
			t_msg=String(L"Syntax error - Expecting 'Class' to terminate with 'End' or 'End Class'.",72);
		}else{
			if(t_toke==String(L"interface",9)){
				t_msg=String(L"Syntax error - Expecting 'Interface' to terminate with 'End' or 'End Interface'.",80);
			}
		}
		if(t_msg!=String()){
			p_SetErr(-1);
			p_ParseBlockEnd(t_toke,t_msg,1);
		}
	}
	c_TraceRecord* t_recor=c_BlockTrace::m_Pop();
	return t_classDecl;
}
int c_Parser::p_ParseMain(){
	p_SkipEols();
	if((p_CParse(String(L"strict",6)))!=0){
		m__module->m_attrs|=1;
	}
	int t_attrs=0;
	c_BlockTrace::m_Clear();
	while((m__toke).Length()!=0){
		p_SetErr(-1);
		String t_23=m__toke;
		if(t_23==String(L"\n",1)){
			p_NextToke();
		}else{
			if(t_23==String(L"public",6)){
				p_NextToke();
				t_attrs=0;
			}else{
				if(t_23==String(L"private",7)){
					p_NextToke();
					t_attrs=512;
				}else{
					if(t_23==String(L"protected",9)){
						bb_config_Err(String(L"Protected may only be used within classes.",42));
					}else{
						if(t_23==String(L"import",6)){
							p_NextToke();
							if(m__tokeType==6){
								p_ImportFile(bb_config_EvalConfigTags(p_ParseStringLit()));
							}else{
								p_ImportModule(p_ParseModPath(),t_attrs);
							}
						}else{
							if(t_23==String(L"include",7)){
								p_NextToke();
								p_IncludeFiles(p_ParseStringLit());
							}else{
								if(t_23==String(L"includedir",10)){
									p_NextToke();
									p_IncludeDirs(p_ParseStringLit());
								}else{
									if(t_23==String(L"friend",6)){
										p_NextToke();
										String t_modpath=p_ParseModPath();
										m__module->m_friends->p_Insert(t_modpath);
									}else{
										if(t_23==String(L"alias",5)){
											p_NextToke();
											do{
												String t_ident=p_ParseIdent();
												p_Parse(String(L"=",1));
												Object* t_decl=0;
												String t_24=m__toke;
												if(t_24==String(L"int",3)){
													t_decl=(c_Type::m_intType);
												}else{
													if(t_24==String(L"float",5)){
														t_decl=(c_Type::m_floatType);
													}else{
														if(t_24==String(L"string",6)){
															t_decl=(c_Type::m_stringType);
														}
													}
												}
												if((t_decl)!=0){
													m__module->p_InsertDecl((new c_AliasDecl)->m_new(t_ident,t_attrs,t_decl));
													p_NextToke();
													continue;
												}
												c_ScopeDecl* t_scope=(m__module);
												bb_decl_PushEnv(m__module);
												do{
													String t_id=p_ParseIdent();
													t_decl=t_scope->p_FindDecl(t_id);
													if(!((t_decl)!=0)){
														bb_config_Err(String(L"Identifier '",12)+t_id+String(L"' not found.",12));
													}
													if(!((p_CParse(String(L".",1)))!=0)){
														break;
													}
													t_scope=dynamic_cast<c_ScopeDecl*>(t_decl);
													if(!((t_scope)!=0) || ((dynamic_cast<c_FuncDecl*>(t_scope))!=0)){
														bb_config_Err(String(L"Invalid scope '",15)+t_id+String(L"'.",2));
													}
												}while(!(false));
												bb_decl_PopEnv();
												m__module->p_InsertDecl((new c_AliasDecl)->m_new(t_ident,t_attrs,t_decl));
											}while(!(!((p_CParse(String(L",",1)))!=0)));
										}else{
											break;
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
	while((m__toke).Length()!=0){
		p_SetErr(-1);
		String t_25=m__toke;
		if(t_25==String(L"\n",1)){
			p_NextToke();
		}else{
			if(t_25==String(L"public",6)){
				p_NextToke();
				t_attrs=0;
			}else{
				if(t_25==String(L"private",7)){
					p_NextToke();
					t_attrs=512;
				}else{
					if(t_25==String(L"extern",6)){
						if((bb_config_ENV_SAFEMODE)!=0){
							if(m__app->m_mainModule==m__module){
								bb_config_Err(String(L"Extern not permitted in safe mode.",34));
							}
						}
						p_NextToke();
						t_attrs=256;
						if((p_CParse(String(L"private",7)))!=0){
							t_attrs|=512;
						}
					}else{
						if(t_25==String(L"const",5) || t_25==String(L"global",6)){
							m__module->p_InsertDecls(p_ParseDecls(m__toke,t_attrs));
						}else{
							if(t_25==String(L"enumerate",9)){
								m__module->p_InsertDecls(p_ParseEnum(m__toke,t_attrs));
							}else{
								if(t_25==String(L"class",5)){
									m__module->p_InsertDecl(p_ParseClassDecl(t_attrs));
								}else{
									if(t_25==String(L"interface",9)){
										m__module->p_InsertDecl(p_ParseClassDecl(t_attrs));
									}else{
										if(t_25==String(L"function",8)){
											m__module->p_InsertDecl(p_ParseFuncDecl(t_attrs));
										}else{
											bb_config_Err(String(L"Syntax error - Expecting declaration.",37));
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
	bb_config__errInfo=String();
	return 0;
}
void c_Parser::mark(){
	Object::mark();
}
c_BlockTrace::c_BlockTrace(){
	m__map=(new c_IntMap)->m_new();
	m__record=(new c_List4)->m_new();
}
c_BlockTrace* c_BlockTrace::m_new(){
	return this;
}
c_BlockTrace* c_BlockTrace::m__Blocks;
int c_BlockTrace::m_Clear(){
	m__Blocks->m__map->p_Clear();
	m__Blocks->m__record->p_Clear();
	return 0;
}
c_TraceRecord* c_BlockTrace::p_LastBlockItem(){
	if(m__record->p_IsEmpty()){
		return 0;
	}
	return m__record->p_Last();
}
c_IntList* c_BlockTrace::p_BlockLineList(int t_token){
	c_IntList* t_blklines=(new c_IntList)->m_new2();
	int t_lastblkline=0;
	if(p_LastBlockItem()!=0){
		t_lastblkline=p_LastBlockItem()->p_Line();
	}
	if(t_token>0){
		c_IntList* t_tokelines=m__map->p_Get2(t_token);
		if(t_lastblkline>0){
			t_blklines->p_AddLast3(t_lastblkline);
		}
		c_Enumerator2* t_=t_tokelines->p_ObjectEnumerator();
		while(t_->p_HasNext()){
			int t_i=t_->p_NextObject();
			if(t_i>t_lastblkline){
				t_blklines->p_AddLast3(t_i);
			}
		}
	}else{
		if(t_lastblkline>0){
			t_blklines->p_AddLast3(t_lastblkline);
		}
		c_KeyEnumerator* t_2=m__map->p_Keys()->p_ObjectEnumerator();
		while(t_2->p_HasNext()){
			int t_i2=t_2->p_NextObject();
			c_Enumerator2* t_3=m__map->p_Get2(t_i2)->p_ObjectEnumerator();
			while(t_3->p_HasNext()){
				int t_j=t_3->p_NextObject();
				if(t_j>t_lastblkline){
					t_blklines->p_AddLast3(t_j);
				}
			}
		}
		t_blklines->p_Sort(1);
	}
	return t_blklines;
}
int c_BlockTrace::p_Unwind(int t_token){
	Array<int > t_blklines=m__Blocks->p_BlockLineList(t_token)->p_ToArray();
	String t_path=bb_config__errInfo.Slice(0,bb_config__errInfo.FindLast(String(L"<",1)));
	bbPrint(String(L"\n\t------------ BLOCK TRACE ------------",39));
	bbPrint(String(L"FILE: ",6)+t_path);
	int t_i=0;
	while(t_i<t_blklines.Length()){
		String t_str=String();
		int t_col=0;
		while(t_col<10){
			if(t_i>=t_blklines.Length()){
				break;
			}
			t_str=t_str+(String(t_blklines[t_i])+String(L", ",2));
			t_i+=1;
			t_col+=1;
		}
		bbPrint(String(L"Statement Blocks at lines: ",27)+t_str.Slice(0,t_str.Length()-2));
	}
	bbPrint(String());
	if(t_blklines.Length()>0){
		return t_blklines[0];
	}else{
		return 0;
	}
}
int c_BlockTrace::m_TraceLog(int t_token){
	return m__Blocks->p_Unwind(t_token);
}
int c_BlockTrace::m_Str2Code(String t_toke){
	String t_2=t_toke.ToLower();
	if(t_2==String(L"for",3)){
		return 1;
	}else{
		if(t_2==String(L"function",8)){
			return 2;
		}else{
			if(t_2==String(L"method",6)){
				return 3;
			}else{
				if(t_2==String(L"if",2)){
					return 4;
				}else{
					if(t_2==String(L"repeat",6)){
						return 5;
					}else{
						if(t_2==String(L"while",5)){
							return 6;
						}else{
							if(t_2==String(L"try",3)){
								return 6;
							}else{
								if(t_2==String(L"class",5)){
									return 7;
								}else{
									if(t_2==String(L"interface",9)){
										return 8;
									}else{
										if(t_2==String(L"select",6)){
											return 9;
										}else{
											return 0;
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
}
int c_BlockTrace::m_TraceLog2(String t_token){
	return m__Blocks->p_Unwind(m_Str2Code(t_token));
}
c_TraceRecord* c_BlockTrace::p_RemoveRecord(){
	if(m__record->p_IsEmpty()){
		return 0;
	}
	return m__record->p_RemoveLast();
}
c_TraceRecord* c_BlockTrace::m_Pop(){
	return m__Blocks->p_RemoveRecord();
}
String c_BlockTrace::m_Code2Str(int t_code){
	int t_1=t_code;
	if(t_1==1){
		return String(L"For",3);
	}else{
		if(t_1==2){
			return String(L"Function",8);
		}else{
			if(t_1==3){
				return String(L"Method",6);
			}else{
				if(t_1==4){
					return String(L"If",2);
				}else{
					if(t_1==5){
						return String(L"Repeat",6);
					}else{
						if(t_1==6){
							return String(L"While",5);
						}else{
							if(t_1==6){
								return String(L"Try",3);
							}else{
								if(t_1==7){
									return String(L"Class",5);
								}else{
									if(t_1==8){
										return String(L"Try",3);
									}else{
										if(t_1==9){
											return String(L"Select",6);
										}else{
											return String();
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
}
int c_BlockTrace::p_AddRecord(c_TraceRecord* t_record){
	int t_token=t_record->p_Toke();
	if(!m__map->p_Contains2(t_token)){
		c_IntList* t_newlist=(new c_IntList)->m_new2();
		t_newlist->p_AddLast3(t_record->p_Line());
		m__map->p_Add(t_token,t_newlist);
	}else{
		m__map->p_Get2(t_token)->p_AddLast3(t_record->p_Line());
	}
	m__record->p_AddLast4(t_record);
	return 0;
}
int c_BlockTrace::m_Push(int t_toke,int t_line){
	m__Blocks->p_AddRecord((new c_TraceRecord)->m_new(t_toke,t_line));
	return 0;
}
int c_BlockTrace::m_Push2(String t_toke,int t_line){
	m__Blocks->p_AddRecord((new c_TraceRecord)->m_new(m_Str2Code(t_toke),t_line));
	return 0;
}
void c_BlockTrace::mark(){
	Object::mark();
}
c_List3::c_List3(){
	m__head=((new c_HeadNode7)->m_new());
}
c_List3* c_List3::m_new(){
	return this;
}
c_Node13* c_List3::p_AddLast3(int t_data){
	return (new c_Node13)->m_new(m__head,m__head->m__pred,t_data);
}
c_List3* c_List3::m_new2(Array<int > t_data){
	Array<int > t_=t_data;
	int t_2=0;
	while(t_2<t_.Length()){
		int t_t=t_[t_2];
		t_2=t_2+1;
		p_AddLast3(t_t);
	}
	return this;
}
c_Enumerator2* c_List3::p_ObjectEnumerator(){
	return (new c_Enumerator2)->m_new(this);
}
int c_List3::p_Compare2(int t_lhs,int t_rhs){
	bbError(String(L"Unable to compare items",23));
	return 0;
}
int c_List3::p_Sort(int t_ascending){
	int t_ccsgn=-1;
	if((t_ascending)!=0){
		t_ccsgn=1;
	}
	int t_insize=1;
	do{
		int t_merges=0;
		c_Node13* t_tail=m__head;
		c_Node13* t_p=m__head->m__succ;
		while(t_p!=m__head){
			t_merges+=1;
			c_Node13* t_q=t_p->m__succ;
			int t_qsize=t_insize;
			int t_psize=1;
			while(t_psize<t_insize && t_q!=m__head){
				t_psize+=1;
				t_q=t_q->m__succ;
			}
			do{
				c_Node13* t_t=0;
				if(((t_psize)!=0) && ((t_qsize)!=0) && t_q!=m__head){
					int t_cc=p_Compare2(t_p->m__data,t_q->m__data)*t_ccsgn;
					if(t_cc<=0){
						t_t=t_p;
						t_p=t_p->m__succ;
						t_psize-=1;
					}else{
						t_t=t_q;
						t_q=t_q->m__succ;
						t_qsize-=1;
					}
				}else{
					if((t_psize)!=0){
						t_t=t_p;
						t_p=t_p->m__succ;
						t_psize-=1;
					}else{
						if(((t_qsize)!=0) && t_q!=m__head){
							t_t=t_q;
							t_q=t_q->m__succ;
							t_qsize-=1;
						}else{
							break;
						}
					}
				}
				t_t->m__pred=t_tail;
				t_tail->m__succ=t_t;
				t_tail=t_t;
			}while(!(false));
			t_p=t_q;
		}
		t_tail->m__succ=m__head;
		m__head->m__pred=t_tail;
		if(t_merges<=1){
			return 0;
		}
		t_insize*=2;
	}while(!(false));
}
int c_List3::p_Count(){
	int t_n=0;
	c_Node13* t_node=m__head->m__succ;
	while(t_node!=m__head){
		t_node=t_node->m__succ;
		t_n+=1;
	}
	return t_n;
}
Array<int > c_List3::p_ToArray(){
	Array<int > t_arr=Array<int >(p_Count());
	int t_i=0;
	c_Enumerator2* t_=this->p_ObjectEnumerator();
	while(t_->p_HasNext()){
		int t_t=t_->p_NextObject();
		t_arr[t_i]=t_t;
		t_i+=1;
	}
	return t_arr;
}
void c_List3::mark(){
	Object::mark();
}
c_IntList::c_IntList(){
}
c_IntList* c_IntList::m_new(Array<int > t_data){
	c_List3::m_new2(t_data);
	return this;
}
c_IntList* c_IntList::m_new2(){
	c_List3::m_new();
	return this;
}
int c_IntList::p_Compare2(int t_lhs,int t_rhs){
	return t_lhs-t_rhs;
}
void c_IntList::mark(){
	c_List3::mark();
}
c_Map6::c_Map6(){
	m_root=0;
}
c_Map6* c_Map6::m_new(){
	return this;
}
int c_Map6::p_Clear(){
	m_root=0;
	return 0;
}
c_Node8* c_Map6::p_FindNode2(int t_key){
	c_Node8* t_node=m_root;
	while((t_node)!=0){
		int t_cmp=p_Compare2(t_key,t_node->m_key);
		if(t_cmp>0){
			t_node=t_node->m_right;
		}else{
			if(t_cmp<0){
				t_node=t_node->m_left;
			}else{
				return t_node;
			}
		}
	}
	return t_node;
}
c_IntList* c_Map6::p_Get2(int t_key){
	c_Node8* t_node=p_FindNode2(t_key);
	if((t_node)!=0){
		return t_node->m_value;
	}
	return 0;
}
c_MapKeys* c_Map6::p_Keys(){
	return (new c_MapKeys)->m_new(this);
}
c_Node8* c_Map6::p_FirstNode(){
	if(!((m_root)!=0)){
		return 0;
	}
	c_Node8* t_node=m_root;
	while((t_node->m_left)!=0){
		t_node=t_node->m_left;
	}
	return t_node;
}
bool c_Map6::p_Contains2(int t_key){
	return p_FindNode2(t_key)!=0;
}
int c_Map6::p_RotateLeft6(c_Node8* t_node){
	c_Node8* t_child=t_node->m_right;
	t_node->m_right=t_child->m_left;
	if((t_child->m_left)!=0){
		t_child->m_left->m_parent=t_node;
	}
	t_child->m_parent=t_node->m_parent;
	if((t_node->m_parent)!=0){
		if(t_node==t_node->m_parent->m_left){
			t_node->m_parent->m_left=t_child;
		}else{
			t_node->m_parent->m_right=t_child;
		}
	}else{
		m_root=t_child;
	}
	t_child->m_left=t_node;
	t_node->m_parent=t_child;
	return 0;
}
int c_Map6::p_RotateRight6(c_Node8* t_node){
	c_Node8* t_child=t_node->m_left;
	t_node->m_left=t_child->m_right;
	if((t_child->m_right)!=0){
		t_child->m_right->m_parent=t_node;
	}
	t_child->m_parent=t_node->m_parent;
	if((t_node->m_parent)!=0){
		if(t_node==t_node->m_parent->m_right){
			t_node->m_parent->m_right=t_child;
		}else{
			t_node->m_parent->m_left=t_child;
		}
	}else{
		m_root=t_child;
	}
	t_child->m_right=t_node;
	t_node->m_parent=t_child;
	return 0;
}
int c_Map6::p_InsertFixup6(c_Node8* t_node){
	while(((t_node->m_parent)!=0) && t_node->m_parent->m_color==-1 && ((t_node->m_parent->m_parent)!=0)){
		if(t_node->m_parent==t_node->m_parent->m_parent->m_left){
			c_Node8* t_uncle=t_node->m_parent->m_parent->m_right;
			if(((t_uncle)!=0) && t_uncle->m_color==-1){
				t_node->m_parent->m_color=1;
				t_uncle->m_color=1;
				t_uncle->m_parent->m_color=-1;
				t_node=t_uncle->m_parent;
			}else{
				if(t_node==t_node->m_parent->m_right){
					t_node=t_node->m_parent;
					p_RotateLeft6(t_node);
				}
				t_node->m_parent->m_color=1;
				t_node->m_parent->m_parent->m_color=-1;
				p_RotateRight6(t_node->m_parent->m_parent);
			}
		}else{
			c_Node8* t_uncle2=t_node->m_parent->m_parent->m_left;
			if(((t_uncle2)!=0) && t_uncle2->m_color==-1){
				t_node->m_parent->m_color=1;
				t_uncle2->m_color=1;
				t_uncle2->m_parent->m_color=-1;
				t_node=t_uncle2->m_parent;
			}else{
				if(t_node==t_node->m_parent->m_left){
					t_node=t_node->m_parent;
					p_RotateRight6(t_node);
				}
				t_node->m_parent->m_color=1;
				t_node->m_parent->m_parent->m_color=-1;
				p_RotateLeft6(t_node->m_parent->m_parent);
			}
		}
	}
	m_root->m_color=1;
	return 0;
}
bool c_Map6::p_Add(int t_key,c_IntList* t_value){
	c_Node8* t_node=m_root;
	c_Node8* t_parent=0;
	int t_cmp=0;
	while((t_node)!=0){
		t_parent=t_node;
		t_cmp=p_Compare2(t_key,t_node->m_key);
		if(t_cmp>0){
			t_node=t_node->m_right;
		}else{
			if(t_cmp<0){
				t_node=t_node->m_left;
			}else{
				return false;
			}
		}
	}
	t_node=(new c_Node8)->m_new(t_key,t_value,-1,t_parent);
	if((t_parent)!=0){
		if(t_cmp>0){
			t_parent->m_right=t_node;
		}else{
			t_parent->m_left=t_node;
		}
		p_InsertFixup6(t_node);
	}else{
		m_root=t_node;
	}
	return true;
}
void c_Map6::mark(){
	Object::mark();
}
c_IntMap::c_IntMap(){
}
c_IntMap* c_IntMap::m_new(){
	c_Map6::m_new();
	return this;
}
int c_IntMap::p_Compare2(int t_lhs,int t_rhs){
	return t_lhs-t_rhs;
}
void c_IntMap::mark(){
	c_Map6::mark();
}
c_Node8::c_Node8(){
	m_key=0;
	m_right=0;
	m_left=0;
	m_value=0;
	m_parent=0;
	m_color=0;
}
c_Node8* c_Node8::p_NextNode(){
	c_Node8* t_node=0;
	if((m_right)!=0){
		t_node=m_right;
		while((t_node->m_left)!=0){
			t_node=t_node->m_left;
		}
		return t_node;
	}
	t_node=this;
	c_Node8* t_parent=this->m_parent;
	while(((t_parent)!=0) && t_node==t_parent->m_right){
		t_node=t_parent;
		t_parent=t_parent->m_parent;
	}
	return t_parent;
}
c_Node8* c_Node8::m_new(int t_key,c_IntList* t_value,int t_color,c_Node8* t_parent){
	this->m_key=t_key;
	this->m_value=t_value;
	this->m_color=t_color;
	this->m_parent=t_parent;
	return this;
}
c_Node8* c_Node8::m_new2(){
	return this;
}
void c_Node8::mark(){
	Object::mark();
}
c_TraceRecord::c_TraceRecord(){
	m__line=0;
	m__toke=0;
}
int c_TraceRecord::p_Line(){
	return m__line;
}
int c_TraceRecord::p_Toke(){
	return m__toke;
}
c_TraceRecord* c_TraceRecord::m_new(int t_toke,int t_line){
	m__toke=t_toke;
	m__line=t_line;
	return this;
}
c_TraceRecord* c_TraceRecord::m_new2(){
	return this;
}
void c_TraceRecord::mark(){
	Object::mark();
}
c_List4::c_List4(){
	m__head=((new c_HeadNode3)->m_new());
}
c_List4* c_List4::m_new(){
	return this;
}
c_Node9* c_List4::p_AddLast4(c_TraceRecord* t_data){
	return (new c_Node9)->m_new(m__head,m__head->m__pred,t_data);
}
c_List4* c_List4::m_new2(Array<c_TraceRecord* > t_data){
	Array<c_TraceRecord* > t_=t_data;
	int t_2=0;
	while(t_2<t_.Length()){
		c_TraceRecord* t_t=t_[t_2];
		t_2=t_2+1;
		p_AddLast4(t_t);
	}
	return this;
}
int c_List4::p_Clear(){
	m__head->m__succ=m__head;
	m__head->m__pred=m__head;
	return 0;
}
bool c_List4::p_IsEmpty(){
	return m__head->m__succ==m__head;
}
c_TraceRecord* c_List4::p_Last(){
	return m__head->m__pred->m__data;
}
c_TraceRecord* c_List4::p_RemoveLast(){
	c_TraceRecord* t_data=m__head->m__pred->m__data;
	m__head->m__pred->p_Remove();
	return t_data;
}
bool c_List4::p_Equals3(c_TraceRecord* t_lhs,c_TraceRecord* t_rhs){
	return t_lhs==t_rhs;
}
c_Node9* c_List4::p_FindLast5(c_TraceRecord* t_value,c_Node9* t_start){
	while(t_start!=m__head){
		if(p_Equals3(t_value,t_start->m__data)){
			return t_start;
		}
		t_start=t_start->m__pred;
	}
	return 0;
}
c_Node9* c_List4::p_FindLast6(c_TraceRecord* t_value){
	return p_FindLast5(t_value,m__head->m__pred);
}
void c_List4::p_RemoveLast4(c_TraceRecord* t_value){
	c_Node9* t_node=p_FindLast6(t_value);
	if((t_node)!=0){
		t_node->p_Remove();
	}
}
void c_List4::mark(){
	Object::mark();
}
c_Node9::c_Node9(){
	m__succ=0;
	m__pred=0;
	m__data=0;
}
c_Node9* c_Node9::m_new(c_Node9* t_succ,c_Node9* t_pred,c_TraceRecord* t_data){
	m__succ=t_succ;
	m__pred=t_pred;
	m__succ->m__pred=this;
	m__pred->m__succ=this;
	m__data=t_data;
	return this;
}
c_Node9* c_Node9::m_new2(){
	return this;
}
int c_Node9::p_Remove(){
	m__succ->m__pred=m__pred;
	m__pred->m__succ=m__succ;
	return 0;
}
void c_Node9::mark(){
	Object::mark();
}
c_HeadNode3::c_HeadNode3(){
}
c_HeadNode3* c_HeadNode3::m_new(){
	c_Node9::m_new2();
	m__succ=(this);
	m__pred=(this);
	return this;
}
void c_HeadNode3::mark(){
	c_Node9::mark();
}
int bb_config_InternalErr(String t_err){
	bbPrint(bb_config__errInfo+String(L" : ",3)+t_err);
	bbError(bb_config__errInfo+String(L" : ",3)+t_err);
	return 0;
}
int bb_config_StringToInt(String t_str,int t_base){
	int t_i=0;
	int t_l=t_str.Length();
	while(t_i<t_l && (int)t_str[t_i]<=32){
		t_i+=1;
	}
	bool t_neg=false;
	if(t_i<t_l && ((int)t_str[t_i]==43 || (int)t_str[t_i]==45)){
		t_neg=(int)t_str[t_i]==45;
		t_i+=1;
	}
	int t_n=0;
	while(t_i<t_l){
		int t_c=(int)t_str[t_i];
		int t_t=0;
		if(t_c>=48 && t_c<58){
			t_t=t_c-48;
		}else{
			if(t_c>=65 && t_c<=90){
				t_t=t_c-55;
			}else{
				if(t_c>=97 && t_c<=122){
					t_t=t_c-87;
				}else{
					break;
				}
			}
		}
		if(t_t>=t_base){
			break;
		}
		t_n=t_n*t_base+t_t;
		t_i+=1;
	}
	if(t_neg){
		t_n=-t_n;
	}
	return t_n;
}
String bb_config_Dequote(String t_str,String t_lang){
	String t_4=t_lang;
	if(t_4==String(L"cerberus",8)){
		if(t_str.Length()<2 || !(t_str.StartsWith(String(L"\"",1)) && t_str.EndsWith(String(L"\"",1))) && !(t_str.StartsWith(String(L"`",1)) && t_str.EndsWith(String(L"`",1)))){
			bb_config_InternalErr(String(L"Internal error",14));
		}
		bool t_isChar=t_str.StartsWith(String(L"`",1));
		t_str=t_str.Slice(1,-1);
		int t_i=0;
		do{
			t_i=t_str.Find(String(L"~",1),t_i);
			if(t_i==-1){
				break;
			}
			if(t_i+1>=t_str.Length()){
				bb_config_Err(String(L"Invalid escape sequence in string",33));
			}
			String t_ch=t_str.Slice(t_i+1,t_i+2);
			String t_5=t_ch;
			if(t_5==String(L"~",1)){
				t_ch=String(L"~",1);
			}else{
				if(t_5==String(L"q",1)){
					t_ch=String(L"\"",1);
				}else{
					if(t_5==String(L"n",1)){
						t_ch=String(L"\n",1);
					}else{
						if(t_5==String(L"r",1)){
							t_ch=String(L"\r",1);
						}else{
							if(t_5==String(L"t",1)){
								t_ch=String(L"\t",1);
							}else{
								if(t_5==String(L"g",1)){
									t_ch=String(L"`",1);
								}else{
									if(t_5==String(L"u",1)){
										String t_t=t_str.Slice(t_i+2,t_i+6);
										if(t_t.Length()!=4){
											bb_config_Err(String(L"Invalid unicode hex value in string",35));
										}
										for(int t_j=0;t_j<4;t_j=t_j+1){
											if(!((bb_config_IsHexDigit((int)t_t[t_j]))!=0)){
												bb_config_Err(String(L"Invalid unicode hex digit in string",35));
											}
										}
										t_str=t_str.Slice(0,t_i)+String((Char)(bb_config_StringToInt(t_t,16)),1)+t_str.Slice(t_i+6);
										t_i+=1;
										continue;
									}else{
										if(t_5==String(L"0",1)){
											t_ch=String((Char)(0),1);
										}else{
											bb_config_Err(String(L"Invalid escape character in string: '",37)+t_ch+String(L"'",1));
										}
									}
								}
							}
						}
					}
				}
			}
			t_str=t_str.Slice(0,t_i)+t_ch+t_str.Slice(t_i+2);
			t_i+=t_ch.Length();
		}while(!(false));
		if(t_isChar && t_str.Length()>1){
			bb_config_InternalErr(String(L"Internal error",14));
		}
		return t_str;
	}else{
		if(t_4==String(L"monkey",6)){
			if(t_str.Length()<2 || !(t_str.StartsWith(String(L"\"",1)) && t_str.EndsWith(String(L"\"",1))) && !(t_str.StartsWith(String(L"`",1)) && t_str.EndsWith(String(L"`",1)))){
				bb_config_InternalErr(String(L"Internal error",14));
			}
			bool t_isChar2=t_str.StartsWith(String(L"`",1));
			t_str=t_str.Slice(1,-1);
			int t_i2=0;
			do{
				t_i2=t_str.Find(String(L"~",1),t_i2);
				if(t_i2==-1){
					break;
				}
				if(t_i2+1>=t_str.Length()){
					bb_config_Err(String(L"Invalid escape sequence in string",33));
				}
				String t_ch2=t_str.Slice(t_i2+1,t_i2+2);
				String t_6=t_ch2;
				if(t_6==String(L"~",1)){
					t_ch2=String(L"~",1);
				}else{
					if(t_6==String(L"q",1)){
						t_ch2=String(L"\"",1);
					}else{
						if(t_6==String(L"n",1)){
							t_ch2=String(L"\n",1);
						}else{
							if(t_6==String(L"r",1)){
								t_ch2=String(L"\r",1);
							}else{
								if(t_6==String(L"t",1)){
									t_ch2=String(L"\t",1);
								}else{
									if(t_6==String(L"g",1)){
										t_ch2=String(L"`",1);
									}else{
										if(t_6==String(L"u",1)){
											String t_t2=t_str.Slice(t_i2+2,t_i2+6);
											if(t_t2.Length()!=4){
												bb_config_Err(String(L"Invalid unicode hex value in string",35));
											}
											for(int t_j2=0;t_j2<4;t_j2=t_j2+1){
												if(!((bb_config_IsHexDigit((int)t_t2[t_j2]))!=0)){
													bb_config_Err(String(L"Invalid unicode hex digit in string",35));
												}
											}
											t_str=t_str.Slice(0,t_i2)+String((Char)(bb_config_StringToInt(t_t2,16)),1)+t_str.Slice(t_i2+6);
											t_i2+=1;
											continue;
										}else{
											if(t_6==String(L"0",1)){
												t_ch2=String((Char)(0),1);
											}else{
												bb_config_Err(String(L"Invalid escape character in string: '",37)+t_ch2+String(L"'",1));
											}
										}
									}
								}
							}
						}
					}
				}
				t_str=t_str.Slice(0,t_i2)+t_ch2+t_str.Slice(t_i2+2);
				t_i2+=t_ch2.Length();
			}while(!(false));
			if(t_isChar2 && t_str.Length()>1){
				bb_config_InternalErr(String(L"Internal error",14));
			}
			return t_str;
		}
	}
	bb_config_InternalErr(String(L"Internal error",14));
	return String();
}
String bb_config_EvalConfigTags(String t_cfg){
	int t_i=0;
	do{
		t_i=t_cfg.Find(String(L"${",2),0);
		if(t_i==-1){
			return t_cfg;
		}
		int t_e=t_cfg.Find(String(L"}",1),t_i+2);
		if(t_e==-1){
			return t_cfg;
		}
		String t_key=t_cfg.Slice(t_i+2,t_e);
		String t_val=bb_config__cfgScope->m_vars->p_Get(t_key);
		t_cfg=t_cfg.Slice(0,t_i)+t_val+t_cfg.Slice(t_e+1);
		t_i+=t_val.Length();
	}while(!(false));
}
int bb_config_ENV_SAFEMODE;
c_NumericType::c_NumericType(){
}
c_NumericType* c_NumericType::m_new(){
	c_Type::m_new();
	return this;
}
void c_NumericType::mark(){
	c_Type::mark();
}
c_IntType::c_IntType(){
}
c_IntType* c_IntType::m_new(){
	c_NumericType::m_new();
	return this;
}
int c_IntType::p_EqualsType(c_Type* t_ty){
	return ((dynamic_cast<c_IntType*>(t_ty)!=0)?1:0);
}
int c_IntType::p_ExtendsType(c_Type* t_ty){
	if((dynamic_cast<c_ObjectType*>(t_ty))!=0){
		c_Expr* t_expr=((new c_ConstExpr)->m_new((this),String()))->p_Semant();
		c_Expr* t_[]={t_expr};
		c_FuncDecl* t_ctor=t_ty->p_GetClass()->p_FindFuncDecl(String(L"new",3),Array<c_Expr* >(t_,1),1);
		return ((((t_ctor)!=0) && t_ctor->p_IsCtor())?1:0);
	}
	return ((dynamic_cast<c_NumericType*>(t_ty)!=0 || dynamic_cast<c_StringType*>(t_ty)!=0)?1:0);
}
c_ClassDecl* c_IntType::p_GetClass(){
	return dynamic_cast<c_ClassDecl*>(bb_decl__env->p_FindDecl(String(L"int",3)));
}
String c_IntType::p_ToString(){
	return String(L"Int",3);
}
void c_IntType::mark(){
	c_NumericType::mark();
}
c_FloatType::c_FloatType(){
}
c_FloatType* c_FloatType::m_new(){
	c_NumericType::m_new();
	return this;
}
int c_FloatType::p_EqualsType(c_Type* t_ty){
	return ((dynamic_cast<c_FloatType*>(t_ty)!=0)?1:0);
}
int c_FloatType::p_ExtendsType(c_Type* t_ty){
	if((dynamic_cast<c_ObjectType*>(t_ty))!=0){
		c_Expr* t_expr=((new c_ConstExpr)->m_new((this),String()))->p_Semant();
		c_Expr* t_[]={t_expr};
		c_FuncDecl* t_ctor=t_ty->p_GetClass()->p_FindFuncDecl(String(L"new",3),Array<c_Expr* >(t_,1),1);
		return ((((t_ctor)!=0) && t_ctor->p_IsCtor())?1:0);
	}
	return ((dynamic_cast<c_NumericType*>(t_ty)!=0 || dynamic_cast<c_StringType*>(t_ty)!=0)?1:0);
}
c_ClassDecl* c_FloatType::p_GetClass(){
	return dynamic_cast<c_ClassDecl*>(bb_decl__env->p_FindDecl(String(L"float",5)));
}
String c_FloatType::p_ToString(){
	return String(L"Float",5);
}
void c_FloatType::mark(){
	c_NumericType::mark();
}
c_AliasDecl::c_AliasDecl(){
	m_decl=0;
}
c_AliasDecl* c_AliasDecl::m_new(String t_ident,int t_attrs,Object* t_decl){
	c_Decl::m_new();
	this->m_ident=t_ident;
	this->m_attrs=t_attrs;
	this->m_decl=t_decl;
	return this;
}
c_AliasDecl* c_AliasDecl::m_new2(){
	c_Decl::m_new();
	return this;
}
c_Decl* c_AliasDecl::p_OnCopy(){
	return ((new c_AliasDecl)->m_new(m_ident,m_attrs,m_decl));
}
int c_AliasDecl::p_OnSemant(){
	return 0;
}
void c_AliasDecl::mark(){
	c_Decl::mark();
}
c_List5::c_List5(){
	m__head=((new c_HeadNode4)->m_new());
}
c_List5* c_List5::m_new(){
	return this;
}
c_Node10* c_List5::p_AddLast5(c_Decl* t_data){
	return (new c_Node10)->m_new(m__head,m__head->m__pred,t_data);
}
c_List5* c_List5::m_new2(Array<c_Decl* > t_data){
	Array<c_Decl* > t_=t_data;
	int t_2=0;
	while(t_2<t_.Length()){
		c_Decl* t_t=t_[t_2];
		t_2=t_2+1;
		p_AddLast5(t_t);
	}
	return this;
}
c_Enumerator3* c_List5::p_ObjectEnumerator(){
	return (new c_Enumerator3)->m_new(this);
}
int c_List5::p_Count(){
	int t_n=0;
	c_Node10* t_node=m__head->m__succ;
	while(t_node!=m__head){
		t_node=t_node->m__succ;
		t_n+=1;
	}
	return t_n;
}
void c_List5::mark(){
	Object::mark();
}
c_Node10::c_Node10(){
	m__succ=0;
	m__pred=0;
	m__data=0;
}
c_Node10* c_Node10::m_new(c_Node10* t_succ,c_Node10* t_pred,c_Decl* t_data){
	m__succ=t_succ;
	m__pred=t_pred;
	m__succ->m__pred=this;
	m__pred->m__succ=this;
	m__data=t_data;
	return this;
}
c_Node10* c_Node10::m_new2(){
	return this;
}
void c_Node10::mark(){
	Object::mark();
}
c_HeadNode4::c_HeadNode4(){
}
c_HeadNode4* c_HeadNode4::m_new(){
	c_Node10::m_new2();
	m__succ=(this);
	m__pred=(this);
	return this;
}
void c_HeadNode4::mark(){
	c_Node10::mark();
}
c_BlockDecl::c_BlockDecl(){
	m_stmts=(new c_List7)->m_new();
}
int c_BlockDecl::p_AddStmt(c_Stmt* t_stmt){
	m_stmts->p_AddLast7(t_stmt);
	return 0;
}
c_BlockDecl* c_BlockDecl::m_new(c_ScopeDecl* t_scope){
	c_ScopeDecl::m_new();
	this->m_scope=t_scope;
	return this;
}
c_BlockDecl* c_BlockDecl::m_new2(){
	c_ScopeDecl::m_new();
	return this;
}
c_Decl* c_BlockDecl::p_OnCopy(){
	c_BlockDecl* t_t=(new c_BlockDecl)->m_new2();
	c_Enumerator6* t_=m_stmts->p_ObjectEnumerator();
	while(t_->p_HasNext()){
		c_Stmt* t_stmt=t_->p_NextObject();
		t_t->p_AddStmt(t_stmt->p_Copy2(t_t));
	}
	return (t_t);
}
int c_BlockDecl::p_OnSemant(){
	bb_decl_PushEnv(this);
	c_Enumerator6* t_=m_stmts->p_ObjectEnumerator();
	while(t_->p_HasNext()){
		c_Stmt* t_stmt=t_->p_NextObject();
		t_stmt->p_Semant();
	}
	bb_decl_PopEnv();
	return 0;
}
c_BlockDecl* c_BlockDecl::p_CopyBlock(c_ScopeDecl* t_scope){
	c_BlockDecl* t_t=dynamic_cast<c_BlockDecl*>(p_Copy());
	t_t->m_scope=t_scope;
	return t_t;
}
void c_BlockDecl::mark(){
	c_ScopeDecl::mark();
}
c_FuncDecl::c_FuncDecl(){
	m_retType=0;
	m_argDecls=Array<c_ArgDecl* >();
	m_overrides=0;
}
bool c_FuncDecl::p_IsCtor(){
	return (m_attrs&2)!=0;
}
c_FuncDecl* c_FuncDecl::m_new(String t_ident,int t_attrs,c_Type* t_retType,Array<c_ArgDecl* > t_argDecls){
	c_BlockDecl::m_new2();
	this->m_ident=t_ident;
	this->m_attrs=t_attrs;
	this->m_retType=t_retType;
	this->m_argDecls=t_argDecls;
	return this;
}
c_FuncDecl* c_FuncDecl::m_new2(){
	c_BlockDecl::m_new2();
	return this;
}
bool c_FuncDecl::p_IsMethod(){
	return (m_attrs&1)!=0;
}
String c_FuncDecl::p_ToString(){
	String t_t=String();
	Array<c_ArgDecl* > t_=m_argDecls;
	int t_2=0;
	while(t_2<t_.Length()){
		c_ArgDecl* t_decl=t_[t_2];
		t_2=t_2+1;
		if((t_t).Length()!=0){
			t_t=t_t+String(L",",1);
		}
		t_t=t_t+t_decl->p_ToString();
	}
	String t_q=String();
	if(p_IsCtor()){
		t_q=String(L"Method ",7)+c_Decl::p_ToString();
	}else{
		if(p_IsMethod()){
			t_q=String(L"Method ",7);
		}else{
			t_q=String(L"Function ",9);
		}
		t_q=t_q+(c_Decl::p_ToString()+String(L":",1));
		t_q=t_q+m_retType->p_ToString();
	}
	return t_q+String(L"(",1)+t_t+String(L")",1);
}
bool c_FuncDecl::p_EqualsArgs(c_FuncDecl* t_decl){
	if(m_argDecls.Length()!=t_decl->m_argDecls.Length()){
		return false;
	}
	for(int t_i=0;t_i<m_argDecls.Length();t_i=t_i+1){
		if(!((m_argDecls[t_i]->m_type->p_EqualsType(t_decl->m_argDecls[t_i]->m_type))!=0)){
			return false;
		}
	}
	return true;
}
bool c_FuncDecl::p_EqualsFunc(c_FuncDecl* t_decl){
	return ((m_retType->p_EqualsType(t_decl->m_retType))!=0) && p_EqualsArgs(t_decl);
}
c_Decl* c_FuncDecl::p_OnCopy(){
	Array<c_ArgDecl* > t_args=m_argDecls.Slice(0);
	for(int t_i=0;t_i<t_args.Length();t_i=t_i+1){
		t_args[t_i]=dynamic_cast<c_ArgDecl*>(t_args[t_i]->p_Copy());
	}
	c_FuncDecl* t_t=(new c_FuncDecl)->m_new(m_ident,m_attrs,m_retType,t_args);
	c_Enumerator6* t_=m_stmts->p_ObjectEnumerator();
	while(t_->p_HasNext()){
		c_Stmt* t_stmt=t_->p_NextObject();
		t_t->p_AddStmt(t_stmt->p_Copy2(t_t));
	}
	return (t_t);
}
int c_FuncDecl::p_OnSemant(){
	c_ClassDecl* t_cdecl=p_ClassScope();
	c_ClassDecl* t_sclass=0;
	if((t_cdecl)!=0){
		t_sclass=t_cdecl->m_superClass;
	}
	if(p_IsCtor()){
		m_retType=(t_cdecl->m_objectType);
	}else{
		m_retType=m_retType->p_Semant();
	}
	Array<c_ArgDecl* > t_=m_argDecls;
	int t_2=0;
	while(t_2<t_.Length()){
		c_ArgDecl* t_arg=t_[t_2];
		t_2=t_2+1;
		p_InsertDecl(t_arg);
		t_arg->p_Semant();
	}
	c_Enumerator4* t_3=m_scope->p_SemantedFuncs(m_ident)->p_ObjectEnumerator();
	while(t_3->p_HasNext()){
		c_FuncDecl* t_decl=t_3->p_NextObject();
		if(t_decl!=this && p_EqualsArgs(t_decl)){
			bb_config_Err(String(L"Duplicate declaration ",22)+p_ToString());
		}
	}
	if(p_IsCtor() && !((m_attrs&8)!=0)){
		if((t_sclass->p_FindFuncDecl(String(L"new",3),Array<c_Expr* >(),0))!=0){
			c_InvokeSuperExpr* t_expr=(new c_InvokeSuperExpr)->m_new(String(L"new",3),Array<c_Expr* >());
			m_stmts->p_AddFirst((new c_ExprStmt)->m_new(t_expr));
		}
	}
	if(((t_sclass)!=0) && p_IsMethod()){
		while((t_sclass)!=0){
			int t_found=0;
			c_Enumerator4* t_4=t_sclass->p_MethodDecls(m_ident)->p_ObjectEnumerator();
			while(t_4->p_HasNext()){
				c_FuncDecl* t_decl2=t_4->p_NextObject();
				t_found=1;
				t_decl2->p_Semant();
				if(p_EqualsFunc(t_decl2)){
					m_overrides=t_decl2;
					t_decl2->m_attrs|=16;
					break;
				}
			}
			if((t_found)!=0){
				if(!((m_overrides)!=0)){
					bb_config_Err(String(L"Overriding method does not match any overridden method.",55));
				}
				if((m_overrides->p_IsFinal())!=0){
					bb_config_Err(String(L"Cannot override final method.",29));
				}
				if((m_overrides->m_munged).Length()!=0){
					if(((m_munged).Length()!=0) && m_munged!=m_overrides->m_munged){
						bb_config_InternalErr(String(L"Internal error",14));
					}
					m_munged=m_overrides->m_munged;
				}
				break;
			}
			t_sclass=t_sclass->m_superClass;
		}
	}
	m_attrs|=1048576;
	c_BlockDecl::p_OnSemant();
	return 0;
}
bool c_FuncDecl::p_IsStatic(){
	return (m_attrs&3)==0;
}
bool c_FuncDecl::p_IsProperty(){
	return (m_attrs&4)!=0;
}
bool c_FuncDecl::p_IsVirtual(){
	return (m_attrs&1040)!=0;
}
void c_FuncDecl::mark(){
	c_BlockDecl::mark();
}
c_List6::c_List6(){
	m__head=((new c_HeadNode5)->m_new());
}
c_List6* c_List6::m_new(){
	return this;
}
c_Node11* c_List6::p_AddLast6(c_FuncDecl* t_data){
	return (new c_Node11)->m_new(m__head,m__head->m__pred,t_data);
}
c_List6* c_List6::m_new2(Array<c_FuncDecl* > t_data){
	Array<c_FuncDecl* > t_=t_data;
	int t_2=0;
	while(t_2<t_.Length()){
		c_FuncDecl* t_t=t_[t_2];
		t_2=t_2+1;
		p_AddLast6(t_t);
	}
	return this;
}
c_Enumerator4* c_List6::p_ObjectEnumerator(){
	return (new c_Enumerator4)->m_new(this);
}
void c_List6::mark(){
	Object::mark();
}
c_FuncDeclList::c_FuncDeclList(){
}
c_FuncDeclList* c_FuncDeclList::m_new(){
	c_List6::m_new();
	return this;
}
void c_FuncDeclList::mark(){
	c_List6::mark();
}
c_Node11::c_Node11(){
	m__succ=0;
	m__pred=0;
	m__data=0;
}
c_Node11* c_Node11::m_new(c_Node11* t_succ,c_Node11* t_pred,c_FuncDecl* t_data){
	m__succ=t_succ;
	m__pred=t_pred;
	m__succ->m__pred=this;
	m__pred->m__succ=this;
	m__data=t_data;
	return this;
}
c_Node11* c_Node11::m_new2(){
	return this;
}
void c_Node11::mark(){
	Object::mark();
}
c_HeadNode5::c_HeadNode5(){
}
c_HeadNode5* c_HeadNode5::m_new(){
	c_Node11::m_new2();
	m__succ=(this);
	m__pred=(this);
	return this;
}
void c_HeadNode5::mark(){
	c_Node11::mark();
}
c_ClassDecl::c_ClassDecl(){
	m_superClass=0;
	m_args=Array<String >();
	m_superTy=0;
	m_impltys=Array<c_IdentType* >();
	m_objectType=0;
	m_instances=0;
	m_instanceof=0;
	m_instArgs=Array<c_Type* >();
	m_implmentsAll=Array<c_ClassDecl* >();
	m_implments=Array<c_ClassDecl* >();
}
c_ClassDecl* c_ClassDecl::m_new(String t_ident,int t_attrs,Array<String > t_args,c_IdentType* t_superTy,Array<c_IdentType* > t_impls){
	c_ScopeDecl::m_new();
	this->m_ident=t_ident;
	this->m_attrs=t_attrs;
	this->m_args=t_args;
	this->m_superTy=t_superTy;
	this->m_impltys=t_impls;
	this->m_objectType=(new c_ObjectType)->m_new(this);
	if((t_args).Length()!=0){
		m_instances=(new c_List8)->m_new();
	}
	return this;
}
c_ClassDecl* c_ClassDecl::m_new2(){
	c_ScopeDecl::m_new();
	return this;
}
int c_ClassDecl::p_IsInterface(){
	return (((m_attrs&4096)!=0)?1:0);
}
String c_ClassDecl::p_ToString(){
	String t_t=String();
	if((m_args).Length()!=0){
		t_t=String(L",",1).Join(m_args);
	}else{
		if((m_instArgs).Length()!=0){
			Array<c_Type* > t_=m_instArgs;
			int t_2=0;
			while(t_2<t_.Length()){
				c_Type* t_arg=t_[t_2];
				t_2=t_2+1;
				if((t_t).Length()!=0){
					t_t=t_t+String(L",",1);
				}
				t_t=t_t+t_arg->p_ToString();
			}
		}
	}
	if((t_t).Length()!=0){
		t_t=String(L"<",1)+t_t+String(L">",1);
	}
	return m_ident+t_t;
}
c_FuncDecl* c_ClassDecl::p_FindFuncDecl2(String t_ident,Array<c_Expr* > t_args,int t_explicit){
	return c_ScopeDecl::p_FindFuncDecl(t_ident,t_args,t_explicit);
}
c_FuncDecl* c_ClassDecl::p_FindFuncDecl(String t_ident,Array<c_Expr* > t_args,int t_explicit){
	if(!((p_IsInterface())!=0)){
		return p_FindFuncDecl2(t_ident,t_args,t_explicit);
	}
	c_FuncDecl* t_fdecl=p_FindFuncDecl2(t_ident,t_args,1);
	Array<c_ClassDecl* > t_=m_implmentsAll;
	int t_2=0;
	while(t_2<t_.Length()){
		c_ClassDecl* t_iface=t_[t_2];
		t_2=t_2+1;
		c_FuncDecl* t_decl=t_iface->p_FindFuncDecl2(t_ident,t_args,1);
		if(!((t_decl)!=0)){
			continue;
		}
		if((t_fdecl)!=0){
			if(t_fdecl->p_EqualsFunc(t_decl)){
				continue;
			}
			bb_config_Err(String(L"Unable to determine overload to use: ",37)+t_fdecl->p_ToString()+String(L" or ",4)+t_decl->p_ToString()+String(L".",1));
		}
		t_fdecl=t_decl;
	}
	if(((t_fdecl)!=0) || ((t_explicit)!=0)){
		return t_fdecl;
	}
	t_fdecl=p_FindFuncDecl2(t_ident,t_args,0);
	Array<c_ClassDecl* > t_3=m_implmentsAll;
	int t_4=0;
	while(t_4<t_3.Length()){
		c_ClassDecl* t_iface2=t_3[t_4];
		t_4=t_4+1;
		c_FuncDecl* t_decl2=t_iface2->p_FindFuncDecl2(t_ident,t_args,0);
		if(!((t_decl2)!=0)){
			continue;
		}
		if((t_fdecl)!=0){
			if(t_fdecl->p_EqualsFunc(t_decl2)){
				continue;
			}
			bb_config_Err(String(L"Unable to determine overload to use: ",37)+t_fdecl->p_ToString()+String(L" or ",4)+t_decl2->p_ToString()+String(L".",1));
		}
		t_fdecl=t_decl2;
	}
	return t_fdecl;
}
int c_ClassDecl::p_ExtendsObject(){
	return (((m_attrs&2)!=0)?1:0);
}
c_ClassDecl* c_ClassDecl::p_GenClassInstance(Array<c_Type* > t_instArgs){
	if((m_instanceof)!=0){
		bb_config_InternalErr(String(L"Internal error",14));
	}
	if(!((t_instArgs).Length()!=0)){
		if(!((m_args).Length()!=0)){
			return this;
		}
		c_Enumerator5* t_=m_instances->p_ObjectEnumerator();
		while(t_->p_HasNext()){
			c_ClassDecl* t_inst=t_->p_NextObject();
			if(bb_decl__env->p_ClassScope()==t_inst){
				return t_inst;
			}
		}
	}
	if(m_args.Length()!=t_instArgs.Length()){
		bb_config_Err(String(L"Wrong number of type arguments for class ",41)+p_ToString());
	}
	c_Enumerator5* t_2=m_instances->p_ObjectEnumerator();
	while(t_2->p_HasNext()){
		c_ClassDecl* t_inst2=t_2->p_NextObject();
		int t_equal=1;
		for(int t_i=0;t_i<m_args.Length();t_i=t_i+1){
			if(!((t_inst2->m_instArgs[t_i]->p_EqualsType(t_instArgs[t_i]))!=0)){
				t_equal=0;
				break;
			}
		}
		if((t_equal)!=0){
			return t_inst2;
		}
	}
	c_ClassDecl* t_inst3=(new c_ClassDecl)->m_new(m_ident,m_attrs,Array<String >(),m_superTy,m_impltys);
	t_inst3->m_attrs&=-1048577;
	t_inst3->m_munged=m_munged;
	t_inst3->m_errInfo=m_errInfo;
	t_inst3->m_scope=m_scope;
	t_inst3->m_instanceof=this;
	t_inst3->m_instArgs=t_instArgs;
	m_instances->p_AddLast8(t_inst3);
	for(int t_i2=0;t_i2<m_args.Length();t_i2=t_i2+1){
		t_inst3->p_InsertDecl((new c_AliasDecl)->m_new(m_args[t_i2],0,(t_instArgs[t_i2])));
	}
	c_Enumerator3* t_3=m_decls->p_ObjectEnumerator();
	while(t_3->p_HasNext()){
		c_Decl* t_decl=t_3->p_NextObject();
		t_inst3->p_InsertDecl(t_decl->p_Copy());
	}
	return t_inst3;
}
int c_ClassDecl::p_IsFinalized(){
	return (((m_attrs&4)!=0)?1:0);
}
int c_ClassDecl::p_UpdateLiveMethods(){
	if((p_IsFinalized())!=0){
		return 0;
	}
	if((p_IsInterface())!=0){
		return 0;
	}
	if(!((m_superClass)!=0)){
		return 0;
	}
	int t_n=0;
	c_Enumerator4* t_=p_MethodDecls(String())->p_ObjectEnumerator();
	while(t_->p_HasNext()){
		c_FuncDecl* t_decl=t_->p_NextObject();
		if((t_decl->p_IsSemanted())!=0){
			continue;
		}
		int t_live=0;
		c_List6* t_unsem=(new c_List6)->m_new();
		t_unsem->p_AddLast6(t_decl);
		c_ClassDecl* t_sclass=m_superClass;
		while((t_sclass)!=0){
			c_Enumerator4* t_2=t_sclass->p_MethodDecls(t_decl->m_ident)->p_ObjectEnumerator();
			while(t_2->p_HasNext()){
				c_FuncDecl* t_decl2=t_2->p_NextObject();
				if((t_decl2->p_IsSemanted())!=0){
					t_live=1;
				}else{
					t_unsem->p_AddLast6(t_decl2);
					if((t_decl2->p_IsExtern())!=0){
						t_live=1;
					}
					if((t_decl2->p_IsSemanted())!=0){
						t_live=1;
					}
				}
			}
			t_sclass=t_sclass->m_superClass;
		}
		if(!((t_live)!=0)){
			c_ClassDecl* t_cdecl=this;
			while((t_cdecl)!=0){
				Array<c_ClassDecl* > t_3=t_cdecl->m_implmentsAll;
				int t_4=0;
				while(t_4<t_3.Length()){
					c_ClassDecl* t_iface=t_3[t_4];
					t_4=t_4+1;
					c_Enumerator4* t_5=t_iface->p_MethodDecls(t_decl->m_ident)->p_ObjectEnumerator();
					while(t_5->p_HasNext()){
						c_FuncDecl* t_decl22=t_5->p_NextObject();
						if((t_decl22->p_IsSemanted())!=0){
							t_live=1;
						}else{
							t_unsem->p_AddLast6(t_decl22);
							if((t_decl22->p_IsExtern())!=0){
								t_live=1;
							}
							if((t_decl22->p_IsSemanted())!=0){
								t_live=1;
							}
						}
					}
				}
				t_cdecl=t_cdecl->m_superClass;
			}
		}
		if(!((t_live)!=0)){
			continue;
		}
		c_Enumerator4* t_6=t_unsem->p_ObjectEnumerator();
		while(t_6->p_HasNext()){
			c_FuncDecl* t_decl3=t_6->p_NextObject();
			t_decl3->p_Semant();
			t_n+=1;
		}
	}
	return t_n;
}
int c_ClassDecl::p_IsInstanced(){
	return (((m_attrs&1)!=0)?1:0);
}
int c_ClassDecl::p_FinalizeClass(){
	if((p_IsFinalized())!=0){
		return 0;
	}
	m_attrs|=4;
	if((p_IsInterface())!=0){
		return 0;
	}
	bb_config_PushErr(m_errInfo);
	c_Enumerator3* t_=p_Semanted()->p_ObjectEnumerator();
	while(t_->p_HasNext()){
		c_Decl* t_decl=t_->p_NextObject();
		c_FieldDecl* t_fdecl=dynamic_cast<c_FieldDecl*>(t_decl);
		if(!((t_fdecl)!=0)){
			continue;
		}
		c_ClassDecl* t_cdecl=m_superClass;
		while((t_cdecl)!=0){
			c_Enumerator3* t_2=t_cdecl->p_Semanted()->p_ObjectEnumerator();
			while(t_2->p_HasNext()){
				c_Decl* t_decl2=t_2->p_NextObject();
				if(t_decl2->m_ident==t_fdecl->m_ident){
					bb_config__errInfo=t_fdecl->m_errInfo;
					bb_config_Err(String(L"Field '",7)+t_fdecl->m_ident+String(L"' in class ",11)+p_ToString()+String(L" overrides existing declaration in class ",41)+t_cdecl->p_ToString());
				}
			}
			t_cdecl=t_cdecl->m_superClass;
		}
	}
	if((p_IsAbstract())!=0){
		if((p_IsInstanced())!=0){
			bb_config_Err(String(L"Can't create instance of abstract class ",40)+p_ToString()+String(L".",1));
		}
	}else{
		c_ClassDecl* t_cdecl2=this;
		c_List6* t_impls=(new c_List6)->m_new();
		while(((t_cdecl2)!=0) && !((p_IsAbstract())!=0)){
			c_Enumerator4* t_3=t_cdecl2->p_SemantedMethods(String())->p_ObjectEnumerator();
			while(t_3->p_HasNext()){
				c_FuncDecl* t_decl3=t_3->p_NextObject();
				if((t_decl3->p_IsAbstract())!=0){
					int t_found=0;
					c_Enumerator4* t_4=t_impls->p_ObjectEnumerator();
					while(t_4->p_HasNext()){
						c_FuncDecl* t_decl22=t_4->p_NextObject();
						if(t_decl3->m_ident==t_decl22->m_ident && t_decl3->p_EqualsFunc(t_decl22)){
							t_found=1;
							break;
						}
					}
					if(!((t_found)!=0)){
						if((p_IsInstanced())!=0){
							bb_config_Err(String(L"Can't create instance of class ",31)+p_ToString()+String(L" due to abstract method ",24)+t_decl3->p_ToString()+String(L".",1));
						}
						m_attrs|=1024;
						break;
					}
				}else{
					t_impls->p_AddLast6(t_decl3);
				}
			}
			t_cdecl2=t_cdecl2->m_superClass;
		}
	}
	Array<c_ClassDecl* > t_5=m_implmentsAll;
	int t_6=0;
	while(t_6<t_5.Length()){
		c_ClassDecl* t_iface=t_5[t_6];
		t_6=t_6+1;
		c_ClassDecl* t_cdecl3=m_superClass;
		bool t_found2=false;
		while((t_cdecl3)!=0){
			Array<c_ClassDecl* > t_7=t_cdecl3->m_implmentsAll;
			int t_8=0;
			while(t_8<t_7.Length()){
				c_ClassDecl* t_iface2=t_7[t_8];
				t_8=t_8+1;
				if(t_iface!=t_iface2){
					continue;
				}
				t_found2=true;
				break;
			}
			if(t_found2){
				break;
			}
			t_cdecl3=t_cdecl3->m_superClass;
		}
		if(t_found2){
			continue;
		}
		c_Enumerator4* t_9=t_iface->p_SemantedMethods(String())->p_ObjectEnumerator();
		while(t_9->p_HasNext()){
			c_FuncDecl* t_decl4=t_9->p_NextObject();
			bool t_found3=false;
			c_Enumerator4* t_10=p_SemantedMethods(t_decl4->m_ident)->p_ObjectEnumerator();
			while(t_10->p_HasNext()){
				c_FuncDecl* t_decl23=t_10->p_NextObject();
				if(t_decl4->p_EqualsFunc(t_decl23)){
					if((t_decl23->m_munged).Length()!=0){
						bb_config_Err(String(L"Extern methods cannot be used to implement interface methods.",61));
					}
					t_found3=true;
				}
			}
			if(!t_found3){
				bb_config_Err(t_decl4->p_ToString()+String(L" must be implemented by class ",30)+p_ToString());
			}
		}
	}
	bb_config_PopErr();
	return 0;
}
c_Decl* c_ClassDecl::p_OnCopy(){
	bb_config_InternalErr(String(L"Internal error",14));
	return 0;
}
Object* c_ClassDecl::p_GetDecl2(String t_ident){
	return c_ScopeDecl::p_GetDecl(t_ident);
}
Object* c_ClassDecl::p_GetDecl(String t_ident){
	c_ClassDecl* t_cdecl=this;
	while((t_cdecl)!=0){
		Object* t_decl=t_cdecl->p_GetDecl2(t_ident);
		if((t_decl)!=0){
			return t_decl;
		}
		t_cdecl=t_cdecl->m_superClass;
	}
	return 0;
}
c_ClassDecl* c_ClassDecl::m_nullObjectClass;
int c_ClassDecl::p_IsThrowable(){
	return (((m_attrs&8192)!=0)?1:0);
}
int c_ClassDecl::p_OnSemant(){
	if((m_args).Length()!=0){
		return 0;
	}
	bb_decl_PushEnv(this);
	if((m_superTy)!=0){
		m_superClass=m_superTy->p_SemantClass();
		if((m_superClass->p_IsFinal())!=0){
			bb_config_Err(String(L"Cannot extend final class.",26));
		}
		if((m_superClass->p_IsInterface())!=0){
			bb_config_Err(String(L"Cannot extend an interface.",27));
		}
		if(m_munged==String(L"ThrowableObject",15) || ((m_superClass->p_IsThrowable())!=0)){
			m_attrs|=8192;
		}
		if((m_superClass->p_ExtendsObject())!=0){
			m_attrs|=2;
		}
	}else{
		if(m_munged==String(L"Object",6)){
			m_attrs|=2;
		}
	}
	Array<c_ClassDecl* > t_impls=Array<c_ClassDecl* >(m_impltys.Length());
	c_Stack9* t_implsall=(new c_Stack9)->m_new();
	for(int t_i=0;t_i<m_impltys.Length();t_i=t_i+1){
		c_ClassDecl* t_cdecl=m_impltys[t_i]->p_SemantClass();
		if(!((t_cdecl->p_IsInterface())!=0)){
			bb_config_Err(t_cdecl->p_ToString()+String(L" is a class, not an interface.",30));
		}
		for(int t_j=0;t_j<t_i;t_j=t_j+1){
			if(t_impls[t_j]==t_cdecl){
				bb_config_Err(String(L"Duplicate interface ",20)+t_cdecl->p_ToString()+String(L".",1));
			}
		}
		t_impls[t_i]=t_cdecl;
		t_implsall->p_Push25(t_cdecl);
		Array<c_ClassDecl* > t_=t_cdecl->m_implmentsAll;
		int t_2=0;
		while(t_2<t_.Length()){
			c_ClassDecl* t_tdecl=t_[t_2];
			t_2=t_2+1;
			t_implsall->p_Push25(t_tdecl);
		}
	}
	m_implmentsAll=Array<c_ClassDecl* >(t_implsall->p_Length2());
	for(int t_i2=0;t_i2<t_implsall->p_Length2();t_i2=t_i2+1){
		m_implmentsAll[t_i2]=t_implsall->p_Get2(t_i2);
	}
	m_implments=t_impls;
	bb_decl_PopEnv();
	if(!((p_IsAbstract())!=0)){
		c_Enumerator3* t_3=m_decls->p_ObjectEnumerator();
		while(t_3->p_HasNext()){
			c_Decl* t_decl=t_3->p_NextObject();
			c_FuncDecl* t_fdecl=dynamic_cast<c_FuncDecl*>(t_decl);
			if(((t_fdecl)!=0) && ((t_fdecl->p_IsAbstract())!=0)){
				m_attrs|=1024;
				break;
			}
		}
	}
	if(!((p_IsExtern())!=0) && !((p_IsInterface())!=0)){
		c_FuncDecl* t_fdecl2=0;
		c_Enumerator4* t_4=p_FuncDecls(String())->p_ObjectEnumerator();
		while(t_4->p_HasNext()){
			c_FuncDecl* t_decl2=t_4->p_NextObject();
			if(!t_decl2->p_IsCtor()){
				continue;
			}
			int t_nargs=0;
			Array<c_ArgDecl* > t_5=t_decl2->m_argDecls;
			int t_6=0;
			while(t_6<t_5.Length()){
				c_ArgDecl* t_arg=t_5[t_6];
				t_6=t_6+1;
				if(!((t_arg->m_init)!=0)){
					t_nargs+=1;
				}
			}
			if((t_nargs)!=0){
				continue;
			}
			t_fdecl2=t_decl2;
			break;
		}
		if(!((t_fdecl2)!=0)){
			t_fdecl2=(new c_FuncDecl)->m_new(String(L"new",3),2,(m_objectType),Array<c_ArgDecl* >());
			t_fdecl2->p_AddStmt((new c_ReturnStmt)->m_new(0));
			p_InsertDecl(t_fdecl2);
		}
	}
	p_AppScope()->m_semantedClasses->p_AddLast8(this);
	return 0;
}
int c_ClassDecl::p_ExtendsClass(c_ClassDecl* t_cdecl){
	if(this==m_nullObjectClass){
		return 1;
	}
	c_ClassDecl* t_tdecl=this;
	while((t_tdecl)!=0){
		if(t_tdecl==t_cdecl){
			return 1;
		}
		if((t_cdecl->p_IsInterface())!=0){
			Array<c_ClassDecl* > t_=t_tdecl->m_implmentsAll;
			int t_2=0;
			while(t_2<t_.Length()){
				c_ClassDecl* t_iface=t_[t_2];
				t_2=t_2+1;
				if(t_iface==t_cdecl){
					return 1;
				}
			}
		}
		t_tdecl=t_tdecl->m_superClass;
	}
	return 0;
}
void c_ClassDecl::mark(){
	c_ScopeDecl::mark();
}
int bb_decl_PopEnv(){
	if(bb_decl__envStack->p_IsEmpty()){
		bb_config_InternalErr(String(L"Internal error",14));
	}
	bb_decl__env=bb_decl__envStack->p_RemoveLast();
	return 0;
}
c_VoidType::c_VoidType(){
}
c_VoidType* c_VoidType::m_new(){
	c_Type::m_new();
	return this;
}
int c_VoidType::p_EqualsType(c_Type* t_ty){
	return ((dynamic_cast<c_VoidType*>(t_ty)!=0)?1:0);
}
String c_VoidType::p_ToString(){
	return String(L"Void",4);
}
void c_VoidType::mark(){
	c_Type::mark();
}
c_IdentType::c_IdentType(){
	m_ident=String();
	m_args=Array<c_Type* >();
}
c_IdentType* c_IdentType::m_new(String t_ident,Array<c_Type* > t_args){
	c_Type::m_new();
	this->m_ident=t_ident;
	this->m_args=t_args;
	return this;
}
c_IdentType* c_IdentType::m_new2(){
	c_Type::m_new();
	return this;
}
c_Type* c_IdentType::p_Semant(){
	if(!((m_ident).Length()!=0)){
		return (c_ClassDecl::m_nullObjectClass->m_objectType);
	}
	Array<c_Type* > t_targs=Array<c_Type* >(m_args.Length());
	for(int t_i=0;t_i<m_args.Length();t_i=t_i+1){
		t_targs[t_i]=m_args[t_i]->p_Semant();
	}
	String t_tyid=String();
	c_Type* t_type=0;
	int t_i2=m_ident.Find(String(L".",1),0);
	if(t_i2==-1){
		t_tyid=m_ident;
		t_type=bb_decl__env->p_FindType(t_tyid,t_targs);
	}else{
		String t_modid=m_ident.Slice(0,t_i2);
		c_ModuleDecl* t_mdecl=bb_decl__env->p_FindModuleDecl(t_modid);
		if(!((t_mdecl)!=0)){
			bb_config_Err(String(L"Module '",8)+t_modid+String(L"' not found",11));
		}
		t_tyid=m_ident.Slice(t_i2+1);
		t_type=t_mdecl->p_FindType(t_tyid,t_targs);
	}
	if(!((t_type)!=0)){
		bb_config_Err(String(L"Type '",6)+t_tyid+String(L"' not found",11));
	}
	return t_type;
}
c_ClassDecl* c_IdentType::p_SemantClass(){
	c_ObjectType* t_type=dynamic_cast<c_ObjectType*>(p_Semant());
	if(!((t_type)!=0)){
		bb_config_Err(String(L"Type is not a class",19));
	}
	return t_type->m_classDecl;
}
int c_IdentType::p_EqualsType(c_Type* t_ty){
	bb_config_InternalErr(String(L"Internal error",14));
	return 0;
}
int c_IdentType::p_ExtendsType(c_Type* t_ty){
	bb_config_InternalErr(String(L"Internal error",14));
	return 0;
}
String c_IdentType::p_ToString(){
	String t_t=String();
	Array<c_Type* > t_=m_args;
	int t_2=0;
	while(t_2<t_.Length()){
		c_Type* t_arg=t_[t_2];
		t_2=t_2+1;
		if((t_t).Length()!=0){
			t_t=t_t+String(L",",1);
		}
		t_t=t_t+t_arg->p_ToString();
	}
	if((t_t).Length()!=0){
		return String(L"$",1)+m_ident+String(L"<",1)+t_t.Replace(String(L"$",1),String())+String(L">",1);
	}
	return String(L"$",1)+m_ident;
}
void c_IdentType::mark(){
	c_Type::mark();
}
c_Stack4::c_Stack4(){
	m_data=Array<c_Type* >();
	m_length=0;
}
c_Stack4* c_Stack4::m_new(){
	return this;
}
c_Stack4* c_Stack4::m_new2(Array<c_Type* > t_data){
	this->m_data=t_data.Slice(0);
	this->m_length=t_data.Length();
	return this;
}
void c_Stack4::p_Push10(c_Type* t_value){
	if(m_length==m_data.Length()){
		m_data=m_data.Resize(m_length*2+10);
	}
	m_data[m_length]=t_value;
	m_length+=1;
}
void c_Stack4::p_Push11(Array<c_Type* > t_values,int t_offset,int t_count){
	for(int t_i=0;t_i<t_count;t_i=t_i+1){
		p_Push10(t_values[t_offset+t_i]);
	}
}
void c_Stack4::p_Push12(Array<c_Type* > t_values,int t_offset){
	p_Push11(t_values,t_offset,t_values.Length()-t_offset);
}
Array<c_Type* > c_Stack4::p_ToArray(){
	Array<c_Type* > t_t=Array<c_Type* >(m_length);
	for(int t_i=0;t_i<m_length;t_i=t_i+1){
		t_t[t_i]=m_data[t_i];
	}
	return t_t;
}
void c_Stack4::mark(){
	Object::mark();
}
c_ArrayType::c_ArrayType(){
	m_elemType=0;
}
c_ArrayType* c_ArrayType::m_new(c_Type* t_elemType){
	c_Type::m_new();
	this->m_elemType=t_elemType;
	return this;
}
c_ArrayType* c_ArrayType::m_new2(){
	c_Type::m_new();
	return this;
}
int c_ArrayType::p_EqualsType(c_Type* t_ty){
	c_ArrayType* t_arrayType=dynamic_cast<c_ArrayType*>(t_ty);
	return ((((t_arrayType)!=0) && ((m_elemType->p_EqualsType(t_arrayType->m_elemType))!=0))?1:0);
}
int c_ArrayType::p_ExtendsType(c_Type* t_ty){
	c_ArrayType* t_arrayType=dynamic_cast<c_ArrayType*>(t_ty);
	return ((((t_arrayType)!=0) && (((dynamic_cast<c_VoidType*>(m_elemType))!=0) || ((m_elemType->p_EqualsType(t_arrayType->m_elemType))!=0)))?1:0);
}
c_Type* c_ArrayType::p_Semant(){
	c_Type* t_ty=m_elemType->p_Semant();
	if(t_ty!=m_elemType){
		return ((new c_ArrayType)->m_new(t_ty));
	}
	return (this);
}
c_ClassDecl* c_ArrayType::p_GetClass(){
	return dynamic_cast<c_ClassDecl*>(bb_decl__env->p_FindDecl(String(L"array",5)));
}
String c_ArrayType::p_ToString(){
	return m_elemType->p_ToString()+String(L"[]",2);
}
void c_ArrayType::mark(){
	c_Type::mark();
}
c_UnaryExpr::c_UnaryExpr(){
	m_op=String();
	m_expr=0;
}
c_UnaryExpr* c_UnaryExpr::m_new(String t_op,c_Expr* t_expr){
	c_Expr::m_new();
	this->m_op=t_op;
	this->m_expr=t_expr;
	return this;
}
c_UnaryExpr* c_UnaryExpr::m_new2(){
	c_Expr::m_new();
	return this;
}
c_Expr* c_UnaryExpr::p_Copy(){
	return ((new c_UnaryExpr)->m_new(m_op,p_CopyExpr(m_expr)));
}
c_Expr* c_UnaryExpr::p_Semant(){
	if((m_exprType)!=0){
		return (this);
	}
	String t_1=m_op;
	if(t_1==String(L"+",1) || t_1==String(L"-",1)){
		m_expr=m_expr->p_Semant();
		if(!((dynamic_cast<c_NumericType*>(m_expr->m_exprType))!=0)){
			bb_config_Err(m_expr->p_ToString()+String(L" must be numeric for use with unary operator '",46)+m_op+String(L"'",1));
		}
		m_exprType=m_expr->m_exprType;
	}else{
		if(t_1==String(L"~",1)){
			m_expr=m_expr->p_Semant2((c_Type::m_intType),0);
			m_exprType=(c_Type::m_intType);
		}else{
			if(t_1==String(L"not",3)){
				m_expr=m_expr->p_Semant2((c_Type::m_boolType),1);
				m_exprType=(c_Type::m_boolType);
			}else{
				bb_config_InternalErr(String(L"Internal error",14));
			}
		}
	}
	if((dynamic_cast<c_ConstExpr*>(m_expr))!=0){
		return p_EvalConst();
	}
	return (this);
}
String c_UnaryExpr::p_Eval(){
	String t_val=m_expr->p_Eval();
	String t_2=m_op;
	if(t_2==String(L"~",1)){
		return String(~(t_val).ToInt());
	}else{
		if(t_2==String(L"+",1)){
			return t_val;
		}else{
			if(t_2==String(L"-",1)){
				if(t_val.StartsWith(String(L"-",1))){
					return t_val.Slice(1);
				}
				return String(L"-",1)+t_val;
			}else{
				if(t_2==String(L"not",3)){
					if((t_val).Length()!=0){
						return String();
					}
					return String(L"1",1);
				}
			}
		}
	}
	bb_config_InternalErr(String(L"Internal error",14));
	return String();
}
String c_UnaryExpr::p_Trans(){
	return bb_translator__trans->p_TransUnaryExpr(this);
}
void c_UnaryExpr::mark(){
	c_Expr::mark();
}
c_ArrayExpr::c_ArrayExpr(){
	m_exprs=Array<c_Expr* >();
}
c_ArrayExpr* c_ArrayExpr::m_new(Array<c_Expr* > t_exprs){
	c_Expr::m_new();
	this->m_exprs=t_exprs;
	return this;
}
c_ArrayExpr* c_ArrayExpr::m_new2(){
	c_Expr::m_new();
	return this;
}
c_Expr* c_ArrayExpr::p_Copy(){
	return ((new c_ArrayExpr)->m_new(p_CopyArgs(m_exprs)));
}
c_Expr* c_ArrayExpr::p_Semant(){
	if((m_exprType)!=0){
		return (this);
	}
	m_exprs[0]=m_exprs[0]->p_Semant();
	c_Type* t_ty=m_exprs[0]->m_exprType;
	for(int t_i=1;t_i<m_exprs.Length();t_i=t_i+1){
		m_exprs[t_i]=m_exprs[t_i]->p_Semant();
		t_ty=p_BalanceTypes(t_ty,m_exprs[t_i]->m_exprType);
	}
	for(int t_i2=0;t_i2<m_exprs.Length();t_i2=t_i2+1){
		m_exprs[t_i2]=m_exprs[t_i2]->p_Cast(t_ty,0);
	}
	m_exprType=(t_ty->p_ArrayOf());
	return (this);
}
String c_ArrayExpr::p_Trans(){
	return bb_translator__trans->p_TransArrayExpr(this);
}
void c_ArrayExpr::mark(){
	c_Expr::mark();
}
c_Stack5::c_Stack5(){
	m_data=Array<c_Expr* >();
	m_length=0;
}
c_Stack5* c_Stack5::m_new(){
	return this;
}
c_Stack5* c_Stack5::m_new2(Array<c_Expr* > t_data){
	this->m_data=t_data.Slice(0);
	this->m_length=t_data.Length();
	return this;
}
void c_Stack5::p_Push13(c_Expr* t_value){
	if(m_length==m_data.Length()){
		m_data=m_data.Resize(m_length*2+10);
	}
	m_data[m_length]=t_value;
	m_length+=1;
}
void c_Stack5::p_Push14(Array<c_Expr* > t_values,int t_offset,int t_count){
	for(int t_i=0;t_i<t_count;t_i=t_i+1){
		p_Push13(t_values[t_offset+t_i]);
	}
}
void c_Stack5::p_Push15(Array<c_Expr* > t_values,int t_offset){
	p_Push14(t_values,t_offset,t_values.Length()-t_offset);
}
Array<c_Expr* > c_Stack5::p_ToArray(){
	Array<c_Expr* > t_t=Array<c_Expr* >(m_length);
	for(int t_i=0;t_i<m_length;t_i=t_i+1){
		t_t[t_i]=m_data[t_i];
	}
	return t_t;
}
void c_Stack5::mark(){
	Object::mark();
}
c_ConstExpr::c_ConstExpr(){
	m_ty=0;
	m_value=String();
}
c_ConstExpr* c_ConstExpr::m_new(c_Type* t_ty,String t_value){
	c_Expr::m_new();
	if((dynamic_cast<c_IntType*>(t_ty))!=0){
		if(t_value.StartsWith(String(L"%",1))){
			t_value=String(bb_config_StringToInt(t_value.Slice(1),2));
		}else{
			if(t_value.StartsWith(String(L"$",1))){
				t_value=String(bb_config_StringToInt(t_value.Slice(1),16));
			}else{
				if(t_value.StartsWith(String(L"`",1)) && t_value.EndsWith(String(L"`",1))){
					t_value=bb_config_Dequote(t_value,String(L"cerberus",8));
					if(t_value.Length()<1){
						t_value=String(L"0",1);
					}else{
						t_value=String((int)t_value[0]);
					}
				}else{
					while(t_value.Length()>1 && t_value.StartsWith(String(L"0",1))){
						t_value=t_value.Slice(1);
					}
				}
			}
		}
	}else{
		if((dynamic_cast<c_FloatType*>(t_ty))!=0){
			if(!(t_value.Contains(String(L"e",1)) || t_value.Contains(String(L"E",1)) || t_value.Contains(String(L".",1)))){
				t_value=t_value+String(L".0",2);
			}
		}
	}
	this->m_ty=t_ty;
	this->m_value=t_value;
	return this;
}
c_ConstExpr* c_ConstExpr::m_new2(){
	c_Expr::m_new();
	return this;
}
c_Expr* c_ConstExpr::p_Semant(){
	if((m_exprType)!=0){
		return (this);
	}
	m_exprType=m_ty->p_Semant();
	return (this);
}
c_Expr* c_ConstExpr::p_Copy(){
	return ((new c_ConstExpr)->m_new(m_ty,m_value));
}
String c_ConstExpr::p_ToString(){
	return String(L"ConstExpr(\"",11)+m_value+String(L"\")",2);
}
String c_ConstExpr::p_Eval(){
	return m_value;
}
c_Expr* c_ConstExpr::p_EvalConst(){
	return (this);
}
bool c_ConstExpr::p_SideEffects(){
	return false;
}
String c_ConstExpr::p_Trans(){
	return bb_translator__trans->p_TransConstExpr(this);
}
void c_ConstExpr::mark(){
	c_Expr::mark();
}
c_ScopeExpr::c_ScopeExpr(){
	m_scope=0;
}
c_ScopeExpr* c_ScopeExpr::m_new(c_ScopeDecl* t_scope){
	c_Expr::m_new();
	this->m_scope=t_scope;
	return this;
}
c_ScopeExpr* c_ScopeExpr::m_new2(){
	c_Expr::m_new();
	return this;
}
c_Expr* c_ScopeExpr::p_Copy(){
	return (this);
}
String c_ScopeExpr::p_ToString(){
	bbPrint(String(L"ScopeExpr(",10)+m_scope->p_ToString()+String(L")",1));
	return String();
}
c_Expr* c_ScopeExpr::p_Semant(){
	bb_config_InternalErr(String(L"Internal error",14));
	return 0;
}
c_ScopeDecl* c_ScopeExpr::p_SemantScope(){
	return m_scope;
}
void c_ScopeExpr::mark(){
	c_Expr::mark();
}
c_NewArrayExpr::c_NewArrayExpr(){
	m_ty=0;
	m_expr=0;
}
c_NewArrayExpr* c_NewArrayExpr::m_new(c_Type* t_ty,c_Expr* t_expr){
	c_Expr::m_new();
	this->m_ty=t_ty;
	this->m_expr=t_expr;
	return this;
}
c_NewArrayExpr* c_NewArrayExpr::m_new2(){
	c_Expr::m_new();
	return this;
}
c_Expr* c_NewArrayExpr::p_Copy(){
	if((m_exprType)!=0){
		bb_config_InternalErr(String(L"Internal error",14));
	}
	return ((new c_NewArrayExpr)->m_new(m_ty,p_CopyExpr(m_expr)));
}
c_Expr* c_NewArrayExpr::p_Semant(){
	if((m_exprType)!=0){
		return (this);
	}
	m_ty=m_ty->p_Semant();
	m_exprType=(m_ty->p_ArrayOf());
	m_expr=m_expr->p_Semant2((c_Type::m_intType),0);
	return (this);
}
String c_NewArrayExpr::p_Trans(){
	return bb_translator__trans->p_TransNewArrayExpr(this);
}
void c_NewArrayExpr::mark(){
	c_Expr::mark();
}
c_NewObjectExpr::c_NewObjectExpr(){
	m_ty=0;
	m_args=Array<c_Expr* >();
	m_classDecl=0;
	m_ctor=0;
}
c_NewObjectExpr* c_NewObjectExpr::m_new(c_Type* t_ty,Array<c_Expr* > t_args){
	c_Expr::m_new();
	this->m_ty=t_ty;
	this->m_args=t_args;
	return this;
}
c_NewObjectExpr* c_NewObjectExpr::m_new2(){
	c_Expr::m_new();
	return this;
}
c_Expr* c_NewObjectExpr::p_Semant(){
	if((m_exprType)!=0){
		return (this);
	}
	m_ty=m_ty->p_Semant();
	m_args=p_SemantArgs(m_args);
	c_ObjectType* t_objTy=dynamic_cast<c_ObjectType*>(m_ty);
	if(!((t_objTy)!=0)){
		bb_config_Err(String(L"Expression is not a class.",26));
	}
	m_classDecl=t_objTy->m_classDecl;
	if((m_classDecl->p_IsInterface())!=0){
		bb_config_Err(String(L"Cannot create instance of an interface.",39));
	}
	if((m_classDecl->p_IsAbstract())!=0){
		bb_config_Err(String(L"Cannot create instance of an abstract class.",44));
	}
	if(((m_classDecl->m_args).Length()!=0) && !((m_classDecl->m_instanceof)!=0)){
		bb_config_Err(String(L"Cannot create instance of a generic class.",42));
	}
	if((m_classDecl->p_IsExtern())!=0){
		if((m_args).Length()!=0){
			bb_config_Err(String(L"No suitable constructor found for class ",40)+m_classDecl->p_ToString()+String(L".",1));
		}
	}else{
		m_ctor=m_classDecl->p_FindFuncDecl(String(L"new",3),m_args,0);
		if(!((m_ctor)!=0)){
			bb_config_Err(String(L"No suitable constructor found for class ",40)+m_classDecl->p_ToString()+String(L".",1));
		}
		m_args=p_CastArgs(m_args,m_ctor);
	}
	m_classDecl->m_attrs|=1;
	m_exprType=m_ty;
	return (this);
}
c_Expr* c_NewObjectExpr::p_Copy(){
	return ((new c_NewObjectExpr)->m_new(m_ty,p_CopyArgs(m_args)));
}
String c_NewObjectExpr::p_Trans(){
	return bb_translator__trans->p_TransNewObjectExpr(this);
}
void c_NewObjectExpr::mark(){
	c_Expr::mark();
}
c_CastExpr::c_CastExpr(){
	m_ty=0;
	m_expr=0;
	m_flags=0;
}
c_CastExpr* c_CastExpr::m_new(c_Type* t_ty,c_Expr* t_expr,int t_flags){
	c_Expr::m_new();
	this->m_ty=t_ty;
	this->m_expr=t_expr;
	this->m_flags=t_flags;
	return this;
}
c_CastExpr* c_CastExpr::m_new2(){
	c_Expr::m_new();
	return this;
}
c_Expr* c_CastExpr::p_Semant(){
	if((m_exprType)!=0){
		return (this);
	}
	m_ty=m_ty->p_Semant();
	m_expr=m_expr->p_Semant();
	c_Type* t_src=m_expr->m_exprType;
	if((t_src->p_EqualsType(m_ty))!=0){
		return m_expr;
	}
	if((t_src->p_ExtendsType(m_ty))!=0){
		if(((dynamic_cast<c_ArrayType*>(t_src))!=0) && ((dynamic_cast<c_VoidType*>(dynamic_cast<c_ArrayType*>(t_src)->m_elemType))!=0)){
			return ((new c_ConstExpr)->m_new(m_ty,String()))->p_Semant();
		}
		if(((dynamic_cast<c_ObjectType*>(m_ty))!=0) && !((dynamic_cast<c_ObjectType*>(t_src))!=0)){
			c_Expr* t_[]={m_expr};
			m_expr=((new c_NewObjectExpr)->m_new(m_ty,Array<c_Expr* >(t_,1)))->p_Semant();
		}else{
			if(((dynamic_cast<c_ObjectType*>(t_src))!=0) && !((dynamic_cast<c_ObjectType*>(m_ty))!=0)){
				String t_op=String();
				if((dynamic_cast<c_BoolType*>(m_ty))!=0){
					t_op=String(L"ToBool",6);
				}else{
					if((dynamic_cast<c_IntType*>(m_ty))!=0){
						t_op=String(L"ToInt",5);
					}else{
						if((dynamic_cast<c_FloatType*>(m_ty))!=0){
							t_op=String(L"ToFloat",7);
						}else{
							if((dynamic_cast<c_StringType*>(m_ty))!=0){
								t_op=String(L"ToString",8);
							}else{
								bb_config_InternalErr(String(L"Internal error",14));
							}
						}
					}
				}
				c_FuncDecl* t_fdecl=t_src->p_GetClass()->p_FindFuncDecl(t_op,Array<c_Expr* >(),0);
				m_expr=((new c_InvokeMemberExpr)->m_new(m_expr,t_fdecl,Array<c_Expr* >()))->p_Semant();
			}
		}
		m_exprType=m_ty;
	}else{
		if((dynamic_cast<c_BoolType*>(m_ty))!=0){
			if((dynamic_cast<c_VoidType*>(t_src))!=0){
				bb_config_Err(String(L"Cannot convert from Void to Bool.",33));
			}
			if((m_flags&1)!=0){
				m_exprType=m_ty;
			}
		}else{
			if((m_ty->p_ExtendsType(t_src))!=0){
				if((m_flags&1)!=0){
					if(dynamic_cast<c_ObjectType*>(m_ty)!=0==(dynamic_cast<c_ObjectType*>(t_src)!=0)){
						m_exprType=m_ty;
					}
				}
			}else{
				if(((dynamic_cast<c_ObjectType*>(m_ty))!=0) && ((dynamic_cast<c_ObjectType*>(t_src))!=0)){
					if((m_flags&1)!=0){
						if(((t_src->p_GetClass()->p_IsInterface())!=0) || ((m_ty->p_GetClass()->p_IsInterface())!=0)){
							m_exprType=m_ty;
						}
					}
				}
			}
		}
	}
	if(!((m_exprType)!=0)){
		bb_config_Err(String(L"Cannot convert from ",20)+t_src->p_ToString()+String(L" to ",4)+m_ty->p_ToString()+String(L".",1));
	}
	if((dynamic_cast<c_ConstExpr*>(m_expr))!=0){
		return p_EvalConst();
	}
	return (this);
}
c_Expr* c_CastExpr::p_Copy(){
	return ((new c_CastExpr)->m_new(m_ty,p_CopyExpr(m_expr),m_flags));
}
String c_CastExpr::p_Eval(){
	String t_val=m_expr->p_Eval();
	if((dynamic_cast<c_BoolType*>(m_exprType))!=0){
		if((dynamic_cast<c_IntType*>(m_expr->m_exprType))!=0){
			if(((t_val).ToInt())!=0){
				return String(L"1",1);
			}
			return String();
		}else{
			if((dynamic_cast<c_FloatType*>(m_expr->m_exprType))!=0){
				if(((t_val).ToFloat())!=0){
					return String(L"1",1);
				}
				return String();
			}else{
				if((dynamic_cast<c_StringType*>(m_expr->m_exprType))!=0){
					if((t_val).Length()!=0){
						return String(L"1",1);
					}
					return String();
				}
			}
		}
	}else{
		if((dynamic_cast<c_IntType*>(m_exprType))!=0){
			if((dynamic_cast<c_BoolType*>(m_expr->m_exprType))!=0){
				if((t_val).Length()!=0){
					return String(L"1",1);
				}
				return String(L"0",1);
			}
			return String((t_val).ToInt());
		}else{
			if((dynamic_cast<c_FloatType*>(m_exprType))!=0){
				return String((t_val).ToFloat());
			}else{
				if((dynamic_cast<c_StringType*>(m_exprType))!=0){
					return t_val;
				}
			}
		}
	}
	if(!((t_val).Length()!=0)){
		return t_val;
	}
	return c_Expr::p_Eval();
}
String c_CastExpr::p_Trans(){
	return bb_translator__trans->p_TransCastExpr(this);
}
void c_CastExpr::mark(){
	c_Expr::mark();
}
c_IdentExpr::c_IdentExpr(){
	m_ident=String();
	m_expr=0;
	m_scope=0;
	m_static=false;
}
c_IdentExpr* c_IdentExpr::m_new(String t_ident,c_Expr* t_expr){
	c_Expr::m_new();
	this->m_ident=t_ident;
	this->m_expr=t_expr;
	return this;
}
c_IdentExpr* c_IdentExpr::m_new2(){
	c_Expr::m_new();
	return this;
}
c_Expr* c_IdentExpr::p_Copy(){
	return ((new c_IdentExpr)->m_new(m_ident,p_CopyExpr(m_expr)));
}
String c_IdentExpr::p_ToString(){
	String t_t=String(L"IdentExpr(\"",11)+m_ident+String(L"\"",1);
	if((m_expr)!=0){
		t_t=t_t+(String(L",",1)+m_expr->p_ToString());
	}
	return t_t+String(L")",1);
}
int c_IdentExpr::p__Semant(){
	if((m_scope)!=0){
		return 0;
	}
	if((m_expr)!=0){
		m_scope=m_expr->p_SemantScope();
		if((m_scope)!=0){
			m_static=true;
		}else{
			m_expr=m_expr->p_Semant();
			m_scope=(m_expr->m_exprType->p_GetClass());
			if(!((m_scope)!=0)){
				bb_config_Err(String(L"Expression has no scope",23));
			}
		}
	}else{
		m_scope=bb_decl__env;
		m_static=bb_decl__env->p_FuncScope()==0 || bb_decl__env->p_FuncScope()->p_IsStatic();
	}
	return 0;
}
int c_IdentExpr::p_IdentErr(){
	String t_close=String();
	c_Enumerator3* t_=m_scope->p_Decls()->p_ObjectEnumerator();
	while(t_->p_HasNext()){
		c_Decl* t_decl=t_->p_NextObject();
		if(m_ident.ToLower()==t_decl->m_ident.ToLower()){
			t_close=t_decl->m_ident;
		}
	}
	if(((t_close).Length()!=0) && m_ident!=t_close){
		bb_config_Err(String(L"Identifier '",12)+m_ident+String(L"' not found - perhaps you meant '",33)+t_close+String(L"'?",2));
	}
	bb_config_Err(String(L"Identifier '",12)+m_ident+String(L"' not found.",12));
	return 0;
}
c_Expr* c_IdentExpr::p_SemantSet(String t_op,c_Expr* t_rhs){
	p__Semant();
	c_ValDecl* t_vdecl=m_scope->p_FindValDecl(m_ident);
	if((t_vdecl)!=0){
		if((dynamic_cast<c_ConstDecl*>(t_vdecl))!=0){
			if((t_rhs)!=0){
				bb_config_Err(String(L"Constant '",10)+m_ident+String(L"' cannot be modified.",21));
			}
			c_ConstExpr* t_cexpr=(new c_ConstExpr)->m_new(t_vdecl->m_type,dynamic_cast<c_ConstDecl*>(t_vdecl)->m_value);
			if(!m_static && (((dynamic_cast<c_InvokeExpr*>(m_expr))!=0) || ((dynamic_cast<c_InvokeMemberExpr*>(m_expr))!=0))){
				return ((new c_StmtExpr)->m_new(((new c_ExprStmt)->m_new(m_expr)),(t_cexpr)))->p_Semant();
			}
			return t_cexpr->p_Semant();
		}else{
			if((dynamic_cast<c_FieldDecl*>(t_vdecl))!=0){
				if(m_static){
					bb_config_Err(String(L"Field '",7)+m_ident+String(L"' cannot be accessed from here.",31));
				}
				if((m_expr)!=0){
					return ((new c_MemberVarExpr)->m_new(m_expr,dynamic_cast<c_VarDecl*>(t_vdecl)))->p_Semant();
				}
			}
		}
		return ((new c_VarExpr)->m_new(dynamic_cast<c_VarDecl*>(t_vdecl)))->p_Semant();
	}
	if(((t_op).Length()!=0) && t_op!=String(L"=",1)){
		c_FuncDecl* t_fdecl=m_scope->p_FindFuncDecl(m_ident,Array<c_Expr* >(),0);
		if(!((t_fdecl)!=0)){
			p_IdentErr();
		}
		if(((bb_decl__env->p_ModuleScope()->p_IsStrict())!=0) && !t_fdecl->p_IsProperty()){
			bb_config_Err(String(L"Identifier '",12)+m_ident+String(L"' cannot be used in this way.",29));
		}
		c_Expr* t_lhs=0;
		if(t_fdecl->p_IsStatic() || m_scope==bb_decl__env && !bb_decl__env->p_FuncScope()->p_IsStatic()){
			t_lhs=((new c_InvokeExpr)->m_new(t_fdecl,Array<c_Expr* >()));
		}else{
			if((m_expr)!=0){
				c_LocalDecl* t_tmp=(new c_LocalDecl)->m_new(String(),0,0,m_expr);
				t_lhs=((new c_InvokeMemberExpr)->m_new(((new c_VarExpr)->m_new(t_tmp)),t_fdecl,Array<c_Expr* >()));
				t_lhs=((new c_StmtExpr)->m_new(((new c_DeclStmt)->m_new(t_tmp)),t_lhs));
			}else{
				return 0;
			}
		}
		String t_bop=t_op.Slice(0,1);
		String t_1=t_bop;
		if(t_1==String(L"*",1) || t_1==String(L"/",1) || t_1==String(L"shl",3) || t_1==String(L"shr",3) || t_1==String(L"+",1) || t_1==String(L"-",1) || t_1==String(L"&",1) || t_1==String(L"|",1) || t_1==String(L"~",1)){
			t_rhs=((new c_BinaryMathExpr)->m_new(t_bop,t_lhs,t_rhs));
		}else{
			bb_config_InternalErr(String(L"Internal error",14));
		}
		t_rhs=t_rhs->p_Semant();
	}
	Array<c_Expr* > t_args=Array<c_Expr* >();
	if((t_rhs)!=0){
		c_Expr* t_[]={t_rhs};
		t_args=Array<c_Expr* >(t_,1);
	}
	c_FuncDecl* t_fdecl2=m_scope->p_FindFuncDecl(m_ident,t_args,0);
	if((t_fdecl2)!=0){
		if(((bb_decl__env->p_ModuleScope()->p_IsStrict())!=0) && !t_fdecl2->p_IsProperty()){
			bb_config_Err(String(L"Identifier '",12)+m_ident+String(L"' cannot be used in this way.",29));
		}
		if(!t_fdecl2->p_IsStatic()){
			if(m_static){
				bb_config_Err(String(L"Method '",8)+m_ident+String(L"' cannot be accessed from here.",31));
			}
			if((m_expr)!=0){
				return ((new c_InvokeMemberExpr)->m_new(m_expr,t_fdecl2,t_args))->p_Semant();
			}
		}
		return ((new c_InvokeExpr)->m_new(t_fdecl2,t_args))->p_Semant();
	}
	p_IdentErr();
	return 0;
}
c_Expr* c_IdentExpr::p_Semant(){
	return p_SemantSet(String(),0);
}
c_ScopeDecl* c_IdentExpr::p_SemantScope(){
	p__Semant();
	return m_scope->p_FindScopeDecl(m_ident);
}
c_Expr* c_IdentExpr::p_SemantFunc(Array<c_Expr* > t_args){
	p__Semant();
	c_FuncDecl* t_fdecl=m_scope->p_FindFuncDecl(m_ident,t_args,0);
	if((t_fdecl)!=0){
		if(!t_fdecl->p_IsStatic()){
			if(m_static){
				bb_config_Err(String(L"Method '",8)+m_ident+String(L"' cannot be accessed from here.",31));
			}
			if((m_expr)!=0){
				return ((new c_InvokeMemberExpr)->m_new(m_expr,t_fdecl,t_args))->p_Semant();
			}
		}
		return ((new c_InvokeExpr)->m_new(t_fdecl,t_args))->p_Semant();
	}
	c_Type* t_type=m_scope->p_FindType(m_ident,Array<c_Type* >());
	if((t_type)!=0){
		if(t_args.Length()==1 && ((t_args[0])!=0)){
			return t_args[0]->p_Cast(t_type,1);
		}
		bb_config_Err(String(L"Illegal number of arguments for type conversion",47));
	}
	p_IdentErr();
	return 0;
}
void c_IdentExpr::mark(){
	c_Expr::mark();
}
c_SelfExpr::c_SelfExpr(){
}
c_SelfExpr* c_SelfExpr::m_new(){
	c_Expr::m_new();
	return this;
}
c_Expr* c_SelfExpr::p_Copy(){
	return ((new c_SelfExpr)->m_new());
}
c_Expr* c_SelfExpr::p_Semant(){
	if((m_exprType)!=0){
		return (this);
	}
	if((bb_decl__env->p_FuncScope())!=0){
		if(bb_decl__env->p_FuncScope()->p_IsStatic()){
			bb_config_Err(String(L"Illegal use of Self within static scope.",40));
		}
	}else{
		bb_config_Err(String(L"Self cannot be used here.",25));
	}
	m_exprType=(bb_decl__env->p_ClassScope()->m_objectType);
	return (this);
}
bool c_SelfExpr::p_SideEffects(){
	return false;
}
String c_SelfExpr::p_Trans(){
	return bb_translator__trans->p_TransSelfExpr(this);
}
void c_SelfExpr::mark(){
	c_Expr::mark();
}
c_Stmt::c_Stmt(){
	m_errInfo=String();
}
c_Stmt* c_Stmt::m_new(){
	m_errInfo=bb_config__errInfo;
	return this;
}
c_Stmt* c_Stmt::p_Copy2(c_ScopeDecl* t_scope){
	c_Stmt* t_t=p_OnCopy2(t_scope);
	t_t->m_errInfo=m_errInfo;
	return t_t;
}
int c_Stmt::p_Semant(){
	bb_config_PushErr(m_errInfo);
	p_OnSemant();
	bb_config_PopErr();
	return 0;
}
void c_Stmt::mark(){
	Object::mark();
}
c_List7::c_List7(){
	m__head=((new c_HeadNode6)->m_new());
}
c_List7* c_List7::m_new(){
	return this;
}
c_Node12* c_List7::p_AddLast7(c_Stmt* t_data){
	return (new c_Node12)->m_new(m__head,m__head->m__pred,t_data);
}
c_List7* c_List7::m_new2(Array<c_Stmt* > t_data){
	Array<c_Stmt* > t_=t_data;
	int t_2=0;
	while(t_2<t_.Length()){
		c_Stmt* t_t=t_[t_2];
		t_2=t_2+1;
		p_AddLast7(t_t);
	}
	return this;
}
bool c_List7::p_IsEmpty(){
	return m__head->m__succ==m__head;
}
c_Enumerator6* c_List7::p_ObjectEnumerator(){
	return (new c_Enumerator6)->m_new(this);
}
c_Node12* c_List7::p_AddFirst(c_Stmt* t_data){
	return (new c_Node12)->m_new(m__head->m__succ,m__head,t_data);
}
void c_List7::mark(){
	Object::mark();
}
c_Node12::c_Node12(){
	m__succ=0;
	m__pred=0;
	m__data=0;
}
c_Node12* c_Node12::m_new(c_Node12* t_succ,c_Node12* t_pred,c_Stmt* t_data){
	m__succ=t_succ;
	m__pred=t_pred;
	m__succ->m__pred=this;
	m__pred->m__succ=this;
	m__data=t_data;
	return this;
}
c_Node12* c_Node12::m_new2(){
	return this;
}
void c_Node12::mark(){
	Object::mark();
}
c_HeadNode6::c_HeadNode6(){
}
c_HeadNode6* c_HeadNode6::m_new(){
	c_Node12::m_new2();
	m__succ=(this);
	m__pred=(this);
	return this;
}
void c_HeadNode6::mark(){
	c_Node12::mark();
}
c_InvokeSuperExpr::c_InvokeSuperExpr(){
	m_ident=String();
	m_args=Array<c_Expr* >();
	m_funcDecl=0;
}
c_InvokeSuperExpr* c_InvokeSuperExpr::m_new(String t_ident,Array<c_Expr* > t_args){
	c_Expr::m_new();
	this->m_ident=t_ident;
	this->m_args=t_args;
	return this;
}
c_InvokeSuperExpr* c_InvokeSuperExpr::m_new2(){
	c_Expr::m_new();
	return this;
}
c_Expr* c_InvokeSuperExpr::p_Copy(){
	return ((new c_InvokeSuperExpr)->m_new(m_ident,p_CopyArgs(m_args)));
}
c_Expr* c_InvokeSuperExpr::p_Semant(){
	if((m_exprType)!=0){
		return (this);
	}
	if(bb_decl__env->p_FuncScope()->p_IsStatic()){
		bb_config_Err(String(L"Illegal use of Super.",21));
	}
	c_ClassDecl* t_classScope=bb_decl__env->p_ClassScope();
	c_ClassDecl* t_superClass=t_classScope->m_superClass;
	if(!((t_superClass)!=0)){
		bb_config_Err(String(L"Class has no super class.",25));
	}
	m_args=p_SemantArgs(m_args);
	m_funcDecl=t_superClass->p_FindFuncDecl(m_ident,m_args,0);
	if(!((m_funcDecl)!=0)){
		bb_config_Err(String(L"Can't find superclass method '",30)+m_ident+String(L"'.",2));
	}
	if((m_funcDecl->p_IsAbstract())!=0){
		bb_config_Err(String(L"Can't invoke abstract superclass method '",41)+m_ident+String(L"'.",2));
	}
	m_args=p_CastArgs(m_args,m_funcDecl);
	m_exprType=m_funcDecl->m_retType;
	return (this);
}
String c_InvokeSuperExpr::p_Trans(){
	return bb_translator__trans->p_TransInvokeSuperExpr(this);
}
void c_InvokeSuperExpr::mark(){
	c_Expr::mark();
}
c_IdentTypeExpr::c_IdentTypeExpr(){
	m_cdecl=0;
}
c_IdentTypeExpr* c_IdentTypeExpr::m_new(c_Type* t_type){
	c_Expr::m_new();
	this->m_exprType=t_type;
	return this;
}
c_IdentTypeExpr* c_IdentTypeExpr::m_new2(){
	c_Expr::m_new();
	return this;
}
c_Expr* c_IdentTypeExpr::p_Copy(){
	return ((new c_IdentTypeExpr)->m_new(m_exprType));
}
int c_IdentTypeExpr::p__Semant(){
	if((m_cdecl)!=0){
		return 0;
	}
	m_exprType=m_exprType->p_Semant();
	m_cdecl=m_exprType->p_GetClass();
	if(!((m_cdecl)!=0)){
		bb_config_InternalErr(String(L"Internal error",14));
	}
	return 0;
}
c_Expr* c_IdentTypeExpr::p_Semant(){
	p__Semant();
	bb_config_Err(String(L"Expression can't be used in this way",36));
	return 0;
}
c_ScopeDecl* c_IdentTypeExpr::p_SemantScope(){
	p__Semant();
	return (m_cdecl);
}
c_Expr* c_IdentTypeExpr::p_SemantFunc(Array<c_Expr* > t_args){
	p__Semant();
	if(t_args.Length()==1 && ((t_args[0])!=0)){
		return t_args[0]->p_Cast((m_cdecl->m_objectType),1);
	}
	bb_config_Err(String(L"Illegal number of arguments for type conversion",47));
	return 0;
}
void c_IdentTypeExpr::mark(){
	c_Expr::mark();
}
c_Node13::c_Node13(){
	m__succ=0;
	m__pred=0;
	m__data=0;
}
c_Node13* c_Node13::m_new(c_Node13* t_succ,c_Node13* t_pred,int t_data){
	m__succ=t_succ;
	m__pred=t_pred;
	m__succ->m__pred=this;
	m__pred->m__succ=this;
	m__data=t_data;
	return this;
}
c_Node13* c_Node13::m_new2(){
	return this;
}
void c_Node13::mark(){
	Object::mark();
}
c_HeadNode7::c_HeadNode7(){
}
c_HeadNode7* c_HeadNode7::m_new(){
	c_Node13::m_new2();
	m__succ=(this);
	m__pred=(this);
	return this;
}
void c_HeadNode7::mark(){
	c_Node13::mark();
}
c_Enumerator2::c_Enumerator2(){
	m__list=0;
	m__curr=0;
}
c_Enumerator2* c_Enumerator2::m_new(c_List3* t_list){
	m__list=t_list;
	m__curr=t_list->m__head->m__succ;
	return this;
}
c_Enumerator2* c_Enumerator2::m_new2(){
	return this;
}
bool c_Enumerator2::p_HasNext(){
	while(m__curr->m__succ->m__pred!=m__curr){
		m__curr=m__curr->m__succ;
	}
	return m__curr!=m__list->m__head;
}
int c_Enumerator2::p_NextObject(){
	int t_data=m__curr->m__data;
	m__curr=m__curr->m__succ;
	return t_data;
}
void c_Enumerator2::mark(){
	Object::mark();
}
c_MapKeys::c_MapKeys(){
	m_map=0;
}
c_MapKeys* c_MapKeys::m_new(c_Map6* t_map){
	this->m_map=t_map;
	return this;
}
c_MapKeys* c_MapKeys::m_new2(){
	return this;
}
c_KeyEnumerator* c_MapKeys::p_ObjectEnumerator(){
	return (new c_KeyEnumerator)->m_new(m_map->p_FirstNode());
}
void c_MapKeys::mark(){
	Object::mark();
}
c_KeyEnumerator::c_KeyEnumerator(){
	m_node=0;
}
c_KeyEnumerator* c_KeyEnumerator::m_new(c_Node8* t_node){
	this->m_node=t_node;
	return this;
}
c_KeyEnumerator* c_KeyEnumerator::m_new2(){
	return this;
}
bool c_KeyEnumerator::p_HasNext(){
	return m_node!=0;
}
int c_KeyEnumerator::p_NextObject(){
	c_Node8* t_t=m_node;
	m_node=m_node->p_NextNode();
	return t_t->m_key;
}
void c_KeyEnumerator::mark(){
	Object::mark();
}
c_FuncCallExpr::c_FuncCallExpr(){
	m_expr=0;
	m_args=Array<c_Expr* >();
}
c_FuncCallExpr* c_FuncCallExpr::m_new(c_Expr* t_expr,Array<c_Expr* > t_args){
	c_Expr::m_new();
	this->m_expr=t_expr;
	this->m_args=t_args;
	return this;
}
c_FuncCallExpr* c_FuncCallExpr::m_new2(){
	c_Expr::m_new();
	return this;
}
c_Expr* c_FuncCallExpr::p_Copy(){
	return ((new c_FuncCallExpr)->m_new(p_CopyExpr(m_expr),p_CopyArgs(m_args)));
}
String c_FuncCallExpr::p_ToString(){
	String t_t=String(L"FuncCallExpr(",13)+m_expr->p_ToString();
	Array<c_Expr* > t_=m_args;
	int t_2=0;
	while(t_2<t_.Length()){
		c_Expr* t_arg=t_[t_2];
		t_2=t_2+1;
		t_t=t_t+(String(L",",1)+t_arg->p_ToString());
	}
	return t_t+String(L")",1);
}
c_Expr* c_FuncCallExpr::p_Semant(){
	m_args=p_SemantArgs(m_args);
	return m_expr->p_SemantFunc(m_args);
}
void c_FuncCallExpr::mark(){
	c_Expr::mark();
}
c_SliceExpr::c_SliceExpr(){
	m_expr=0;
	m_from=0;
	m_term=0;
}
c_SliceExpr* c_SliceExpr::m_new(c_Expr* t_expr,c_Expr* t_from,c_Expr* t_term){
	c_Expr::m_new();
	this->m_expr=t_expr;
	this->m_from=t_from;
	this->m_term=t_term;
	return this;
}
c_SliceExpr* c_SliceExpr::m_new2(){
	c_Expr::m_new();
	return this;
}
c_Expr* c_SliceExpr::p_Copy(){
	return ((new c_SliceExpr)->m_new(p_CopyExpr(m_expr),p_CopyExpr(m_from),p_CopyExpr(m_term)));
}
c_Expr* c_SliceExpr::p_Semant(){
	if((m_exprType)!=0){
		return (this);
	}
	m_expr=m_expr->p_Semant();
	if(((dynamic_cast<c_ArrayType*>(m_expr->m_exprType))!=0) || ((dynamic_cast<c_StringType*>(m_expr->m_exprType))!=0)){
		if((m_from)!=0){
			m_from=m_from->p_Semant2((c_Type::m_intType),0);
		}
		if((m_term)!=0){
			m_term=m_term->p_Semant2((c_Type::m_intType),0);
		}
		m_exprType=m_expr->m_exprType;
	}else{
		bb_config_Err(String(L"Slices can only be used on strings or arrays.",45));
	}
	return (this);
}
String c_SliceExpr::p_Eval(){
	int t_from=(this->m_from->p_Eval()).ToInt();
	int t_term=(this->m_term->p_Eval()).ToInt();
	if((dynamic_cast<c_StringType*>(m_expr->m_exprType))!=0){
		return m_expr->p_Eval().Slice(t_from,t_term);
	}else{
		if((dynamic_cast<c_ArrayType*>(m_expr->m_exprType))!=0){
			bb_config_Err(String(L"TODO!",5));
		}
	}
	return String();
}
String c_SliceExpr::p_Trans(){
	return bb_translator__trans->p_TransSliceExpr(this);
}
void c_SliceExpr::mark(){
	c_Expr::mark();
}
c_IndexExpr::c_IndexExpr(){
	m_expr=0;
	m_index=0;
}
c_IndexExpr* c_IndexExpr::m_new(c_Expr* t_expr,c_Expr* t_index){
	c_Expr::m_new();
	this->m_expr=t_expr;
	this->m_index=t_index;
	return this;
}
c_IndexExpr* c_IndexExpr::m_new2(){
	c_Expr::m_new();
	return this;
}
c_Expr* c_IndexExpr::p_Copy(){
	return ((new c_IndexExpr)->m_new(p_CopyExpr(m_expr),p_CopyExpr(m_index)));
}
c_Expr* c_IndexExpr::p_Semant(){
	if((m_exprType)!=0){
		return (this);
	}
	m_expr=m_expr->p_Semant();
	m_index=m_index->p_Semant2((c_Type::m_intType),0);
	if((dynamic_cast<c_StringType*>(m_expr->m_exprType))!=0){
		m_exprType=(c_Type::m_intType);
	}else{
		if((dynamic_cast<c_ArrayType*>(m_expr->m_exprType))!=0){
			m_exprType=dynamic_cast<c_ArrayType*>(m_expr->m_exprType)->m_elemType;
		}else{
			bb_config_Err(String(L"Only strings and arrays may be indexed.",39));
		}
	}
	if(((dynamic_cast<c_StringType*>(m_expr->m_exprType))!=0) && ((dynamic_cast<c_ConstExpr*>(m_expr))!=0) && ((dynamic_cast<c_ConstExpr*>(m_index))!=0)){
		return p_EvalConst();
	}
	return (this);
}
String c_IndexExpr::p_Eval(){
	if((dynamic_cast<c_StringType*>(m_expr->m_exprType))!=0){
		String t_str=m_expr->p_Eval();
		int t_idx=(m_index->p_Eval()).ToInt();
		if(t_idx<0 || t_idx>=t_str.Length()){
			bb_config_Err(String(L"String index out of range.",26));
		}
		return String((int)t_str[t_idx]);
	}
	bb_config_InternalErr(String(L"Internal error",14));
	return String();
}
c_Expr* c_IndexExpr::p_SemantSet(String t_op,c_Expr* t_rhs){
	p_Semant();
	if((dynamic_cast<c_StringType*>(m_expr->m_exprType))!=0){
		bb_config_Err(String(L"Strings are read only.",22));
	}
	return (this);
}
bool c_IndexExpr::p_SideEffects(){
	return m_expr->p_SideEffects() || m_index->p_SideEffects();
}
String c_IndexExpr::p_Trans(){
	return bb_translator__trans->p_TransIndexExpr(this);
}
String c_IndexExpr::p_TransVar(){
	return bb_translator__trans->p_TransIndexExpr(this);
}
void c_IndexExpr::mark(){
	c_Expr::mark();
}
c_BinaryExpr::c_BinaryExpr(){
	m_op=String();
	m_lhs=0;
	m_rhs=0;
}
c_BinaryExpr* c_BinaryExpr::m_new(String t_op,c_Expr* t_lhs,c_Expr* t_rhs){
	c_Expr::m_new();
	this->m_op=t_op;
	this->m_lhs=t_lhs;
	this->m_rhs=t_rhs;
	return this;
}
c_BinaryExpr* c_BinaryExpr::m_new2(){
	c_Expr::m_new();
	return this;
}
String c_BinaryExpr::p_Trans(){
	return bb_translator__trans->p_TransBinaryExpr(this);
}
void c_BinaryExpr::mark(){
	c_Expr::mark();
}
c_BinaryMathExpr::c_BinaryMathExpr(){
}
c_BinaryMathExpr* c_BinaryMathExpr::m_new(String t_op,c_Expr* t_lhs,c_Expr* t_rhs){
	c_BinaryExpr::m_new2();
	this->m_op=t_op;
	this->m_lhs=t_lhs;
	this->m_rhs=t_rhs;
	return this;
}
c_BinaryMathExpr* c_BinaryMathExpr::m_new2(){
	c_BinaryExpr::m_new2();
	return this;
}
c_Expr* c_BinaryMathExpr::p_Copy(){
	return ((new c_BinaryMathExpr)->m_new(m_op,p_CopyExpr(m_lhs),p_CopyExpr(m_rhs)));
}
c_Expr* c_BinaryMathExpr::p_Semant(){
	if((m_exprType)!=0){
		return (this);
	}
	m_lhs=m_lhs->p_Semant();
	m_rhs=m_rhs->p_Semant();
	String t_3=m_op;
	if(t_3==String(L"&",1) || t_3==String(L"~",1) || t_3==String(L"|",1) || t_3==String(L"shl",3) || t_3==String(L"shr",3)){
		m_exprType=(c_Type::m_intType);
	}else{
		m_exprType=p_BalanceTypes(m_lhs->m_exprType,m_rhs->m_exprType);
		if((dynamic_cast<c_StringType*>(m_exprType))!=0){
			if(m_op!=String(L"+",1)){
				bb_config_Err(String(L"Illegal string operator.",24));
			}
		}else{
			if(!((dynamic_cast<c_NumericType*>(m_exprType))!=0)){
				bb_config_Err(String(L"Illegal expression type.",24));
			}
		}
	}
	m_lhs=m_lhs->p_Cast(m_exprType,0);
	m_rhs=m_rhs->p_Cast(m_exprType,0);
	if(((dynamic_cast<c_ConstExpr*>(m_lhs))!=0) && ((dynamic_cast<c_ConstExpr*>(m_rhs))!=0)){
		return p_EvalConst();
	}
	return (this);
}
String c_BinaryMathExpr::p_Eval(){
	String t_lhs=this->m_lhs->p_Eval();
	String t_rhs=this->m_rhs->p_Eval();
	if((dynamic_cast<c_IntType*>(m_exprType))!=0){
		int t_x=(t_lhs).ToInt();
		int t_y=(t_rhs).ToInt();
		String t_4=m_op;
		if(t_4==String(L"/",1)){
			if(!((t_y)!=0)){
				bb_config_Err(String(L"Divide by zero error.",21));
			}
			return String(t_x/t_y);
		}else{
			if(t_4==String(L"*",1)){
				return String(t_x*t_y);
			}else{
				if(t_4==String(L"mod",3)){
					if(!((t_y)!=0)){
						bb_config_Err(String(L"Divide by zero error.",21));
					}
					return String(t_x % t_y);
				}else{
					if(t_4==String(L"shl",3)){
						return String(t_x<<t_y);
					}else{
						if(t_4==String(L"shr",3)){
							return String(t_x>>t_y);
						}else{
							if(t_4==String(L"+",1)){
								return String(t_x+t_y);
							}else{
								if(t_4==String(L"-",1)){
									return String(t_x-t_y);
								}else{
									if(t_4==String(L"&",1)){
										return String(t_x&t_y);
									}else{
										if(t_4==String(L"~",1)){
											return String(t_x^t_y);
										}else{
											if(t_4==String(L"|",1)){
												return String(t_x|t_y);
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}else{
		if((dynamic_cast<c_FloatType*>(m_exprType))!=0){
			Float t_x2=(t_lhs).ToFloat();
			Float t_y2=(t_rhs).ToFloat();
			String t_5=m_op;
			if(t_5==String(L"/",1)){
				if(!((t_y2)!=0)){
					bb_config_Err(String(L"Divide by zero error.",21));
				}
				return String(t_x2/t_y2);
			}else{
				if(t_5==String(L"*",1)){
					return String(t_x2*t_y2);
				}else{
					if(t_5==String(L"mod",3)){
						if(!((t_y2)!=0)){
							bb_config_Err(String(L"Divide by zero error.",21));
						}
						return String((Float)fmod(t_x2,t_y2));
					}else{
						if(t_5==String(L"+",1)){
							return String(t_x2+t_y2);
						}else{
							if(t_5==String(L"-",1)){
								return String(t_x2-t_y2);
							}
						}
					}
				}
			}
		}else{
			if((dynamic_cast<c_StringType*>(m_exprType))!=0){
				String t_6=m_op;
				if(t_6==String(L"+",1)){
					return t_lhs+t_rhs;
				}
			}
		}
	}
	bb_config_InternalErr(String(L"Internal error",14));
	return String();
}
void c_BinaryMathExpr::mark(){
	c_BinaryExpr::mark();
}
c_BinaryCompareExpr::c_BinaryCompareExpr(){
	m_ty=0;
}
c_BinaryCompareExpr* c_BinaryCompareExpr::m_new(String t_op,c_Expr* t_lhs,c_Expr* t_rhs){
	c_BinaryExpr::m_new2();
	this->m_op=t_op;
	this->m_lhs=t_lhs;
	this->m_rhs=t_rhs;
	return this;
}
c_BinaryCompareExpr* c_BinaryCompareExpr::m_new2(){
	c_BinaryExpr::m_new2();
	return this;
}
c_Expr* c_BinaryCompareExpr::p_Copy(){
	return ((new c_BinaryCompareExpr)->m_new(m_op,p_CopyExpr(m_lhs),p_CopyExpr(m_rhs)));
}
c_Expr* c_BinaryCompareExpr::p_Semant(){
	if((m_exprType)!=0){
		return (this);
	}
	m_lhs=m_lhs->p_Semant();
	m_rhs=m_rhs->p_Semant();
	m_ty=p_BalanceTypes(m_lhs->m_exprType,m_rhs->m_exprType);
	if((dynamic_cast<c_ArrayType*>(m_ty))!=0){
		bb_config_Err(String(L"Arrays cannot be compared.",26));
	}
	if(((dynamic_cast<c_BoolType*>(m_ty))!=0) && m_op!=String(L"=",1) && m_op!=String(L"<>",2)){
		bb_config_Err(String(L"Bools can only be compared for equality.",40));
	}
	if(((dynamic_cast<c_ObjectType*>(m_ty))!=0) && m_op!=String(L"=",1) && m_op!=String(L"<>",2)){
		bb_config_Err(String(L"Objects can only be compared for equality.",42));
	}
	m_lhs=m_lhs->p_Cast(m_ty,0);
	m_rhs=m_rhs->p_Cast(m_ty,0);
	m_exprType=(c_Type::m_boolType);
	if(((dynamic_cast<c_ConstExpr*>(m_lhs))!=0) && ((dynamic_cast<c_ConstExpr*>(m_rhs))!=0)){
		return p_EvalConst();
	}
	return (this);
}
String c_BinaryCompareExpr::p_Eval(){
	int t_r=-1;
	if((dynamic_cast<c_BoolType*>(m_ty))!=0){
		String t_lhs=this->m_lhs->p_Eval();
		String t_rhs=this->m_rhs->p_Eval();
		String t_7=m_op;
		if(t_7==String(L"=",1)){
			t_r=((t_lhs==t_rhs)?1:0);
		}else{
			if(t_7==String(L"<>",2)){
				t_r=((t_lhs!=t_rhs)?1:0);
			}
		}
	}else{
		if((dynamic_cast<c_IntType*>(m_ty))!=0){
			int t_lhs2=(this->m_lhs->p_Eval()).ToInt();
			int t_rhs2=(this->m_rhs->p_Eval()).ToInt();
			String t_8=m_op;
			if(t_8==String(L"=",1)){
				t_r=((t_lhs2==t_rhs2)?1:0);
			}else{
				if(t_8==String(L"<>",2)){
					t_r=((t_lhs2!=t_rhs2)?1:0);
				}else{
					if(t_8==String(L"<",1)){
						t_r=((t_lhs2<t_rhs2)?1:0);
					}else{
						if(t_8==String(L"<=",2)){
							t_r=((t_lhs2<=t_rhs2)?1:0);
						}else{
							if(t_8==String(L">",1)){
								t_r=((t_lhs2>t_rhs2)?1:0);
							}else{
								if(t_8==String(L">=",2)){
									t_r=((t_lhs2>=t_rhs2)?1:0);
								}
							}
						}
					}
				}
			}
		}else{
			if((dynamic_cast<c_FloatType*>(m_ty))!=0){
				Float t_lhs3=(this->m_lhs->p_Eval()).ToFloat();
				Float t_rhs3=(this->m_rhs->p_Eval()).ToFloat();
				String t_9=m_op;
				if(t_9==String(L"=",1)){
					t_r=((t_lhs3==t_rhs3)?1:0);
				}else{
					if(t_9==String(L"<>",2)){
						t_r=((t_lhs3!=t_rhs3)?1:0);
					}else{
						if(t_9==String(L"<",1)){
							t_r=((t_lhs3<t_rhs3)?1:0);
						}else{
							if(t_9==String(L"<=",2)){
								t_r=((t_lhs3<=t_rhs3)?1:0);
							}else{
								if(t_9==String(L">",1)){
									t_r=((t_lhs3>t_rhs3)?1:0);
								}else{
									if(t_9==String(L">=",2)){
										t_r=((t_lhs3>=t_rhs3)?1:0);
									}
								}
							}
						}
					}
				}
			}else{
				if((dynamic_cast<c_StringType*>(m_ty))!=0){
					String t_lhs4=this->m_lhs->p_Eval();
					String t_rhs4=this->m_rhs->p_Eval();
					String t_10=m_op;
					if(t_10==String(L"=",1)){
						t_r=((t_lhs4==t_rhs4)?1:0);
					}else{
						if(t_10==String(L"<>",2)){
							t_r=((t_lhs4!=t_rhs4)?1:0);
						}else{
							if(t_10==String(L"<",1)){
								t_r=((t_lhs4<t_rhs4)?1:0);
							}else{
								if(t_10==String(L"<=",2)){
									t_r=((t_lhs4<=t_rhs4)?1:0);
								}else{
									if(t_10==String(L">",1)){
										t_r=((t_lhs4>t_rhs4)?1:0);
									}else{
										if(t_10==String(L">=",2)){
											t_r=((t_lhs4>=t_rhs4)?1:0);
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
	if(t_r==1){
		return String(L"1",1);
	}
	if(t_r==0){
		return String();
	}
	bb_config_InternalErr(String(L"Internal error",14));
	return String();
}
void c_BinaryCompareExpr::mark(){
	c_BinaryExpr::mark();
}
c_BinaryLogicExpr::c_BinaryLogicExpr(){
}
c_BinaryLogicExpr* c_BinaryLogicExpr::m_new(String t_op,c_Expr* t_lhs,c_Expr* t_rhs){
	c_BinaryExpr::m_new2();
	this->m_op=t_op;
	this->m_lhs=t_lhs;
	this->m_rhs=t_rhs;
	return this;
}
c_BinaryLogicExpr* c_BinaryLogicExpr::m_new2(){
	c_BinaryExpr::m_new2();
	return this;
}
c_Expr* c_BinaryLogicExpr::p_Copy(){
	return ((new c_BinaryLogicExpr)->m_new(m_op,p_CopyExpr(m_lhs),p_CopyExpr(m_rhs)));
}
c_Expr* c_BinaryLogicExpr::p_Semant(){
	if((m_exprType)!=0){
		return (this);
	}
	m_lhs=m_lhs->p_Semant2((c_Type::m_boolType),1);
	m_rhs=m_rhs->p_Semant2((c_Type::m_boolType),1);
	m_exprType=(c_Type::m_boolType);
	if(((dynamic_cast<c_ConstExpr*>(m_lhs))!=0) && ((dynamic_cast<c_ConstExpr*>(m_rhs))!=0)){
		return p_EvalConst();
	}
	return (this);
}
String c_BinaryLogicExpr::p_Eval(){
	String t_11=m_op;
	if(t_11==String(L"and",3)){
		if(((m_lhs->p_Eval()).Length()!=0) && ((m_rhs->p_Eval()).Length()!=0)){
			return String(L"1",1);
		}else{
			return String();
		}
	}else{
		if(t_11==String(L"or",2)){
			if(((m_lhs->p_Eval()).Length()!=0) || ((m_rhs->p_Eval()).Length()!=0)){
				return String(L"1",1);
			}else{
				return String();
			}
		}
	}
	bb_config_InternalErr(String(L"Internal error",14));
	return String();
}
void c_BinaryLogicExpr::mark(){
	c_BinaryExpr::mark();
}
c_VarDecl::c_VarDecl(){
}
c_VarDecl* c_VarDecl::m_new(){
	c_ValDecl::m_new();
	return this;
}
void c_VarDecl::mark(){
	c_ValDecl::mark();
}
c_GlobalDecl::c_GlobalDecl(){
}
c_GlobalDecl* c_GlobalDecl::m_new(String t_ident,int t_attrs,c_Type* t_type,c_Expr* t_init){
	c_VarDecl::m_new();
	this->m_ident=t_ident;
	this->m_attrs=t_attrs;
	this->m_type=t_type;
	this->m_init=t_init;
	return this;
}
c_GlobalDecl* c_GlobalDecl::m_new2(){
	c_VarDecl::m_new();
	return this;
}
String c_GlobalDecl::p_ToString(){
	return String(L"Global ",7)+c_ValDecl::p_ToString();
}
c_Decl* c_GlobalDecl::p_OnCopy(){
	return ((new c_GlobalDecl)->m_new(m_ident,m_attrs,m_type,p_CopyInit()));
}
void c_GlobalDecl::mark(){
	c_VarDecl::mark();
}
c_FieldDecl::c_FieldDecl(){
}
c_FieldDecl* c_FieldDecl::m_new(String t_ident,int t_attrs,c_Type* t_type,c_Expr* t_init){
	c_VarDecl::m_new();
	this->m_ident=t_ident;
	this->m_attrs=t_attrs;
	this->m_type=t_type;
	this->m_init=t_init;
	return this;
}
c_FieldDecl* c_FieldDecl::m_new2(){
	c_VarDecl::m_new();
	return this;
}
String c_FieldDecl::p_ToString(){
	return String(L"Field ",6)+c_ValDecl::p_ToString();
}
c_Decl* c_FieldDecl::p_OnCopy(){
	return ((new c_FieldDecl)->m_new(m_ident,m_attrs,m_type,p_CopyInit()));
}
void c_FieldDecl::mark(){
	c_VarDecl::mark();
}
c_LocalDecl::c_LocalDecl(){
}
c_LocalDecl* c_LocalDecl::m_new(String t_ident,int t_attrs,c_Type* t_type,c_Expr* t_init){
	c_VarDecl::m_new();
	this->m_ident=t_ident;
	this->m_attrs=t_attrs;
	this->m_type=t_type;
	this->m_init=t_init;
	return this;
}
c_LocalDecl* c_LocalDecl::m_new2(){
	c_VarDecl::m_new();
	return this;
}
String c_LocalDecl::p_ToString(){
	return String(L"Local ",6)+c_ValDecl::p_ToString();
}
c_Decl* c_LocalDecl::p_OnCopy(){
	return ((new c_LocalDecl)->m_new(m_ident,m_attrs,m_type,p_CopyInit()));
}
void c_LocalDecl::mark(){
	c_VarDecl::mark();
}
c_Enumerator3::c_Enumerator3(){
	m__list=0;
	m__curr=0;
}
c_Enumerator3* c_Enumerator3::m_new(c_List5* t_list){
	m__list=t_list;
	m__curr=t_list->m__head->m__succ;
	return this;
}
c_Enumerator3* c_Enumerator3::m_new2(){
	return this;
}
bool c_Enumerator3::p_HasNext(){
	while(m__curr->m__succ->m__pred!=m__curr){
		m__curr=m__curr->m__succ;
	}
	return m__curr!=m__list->m__head;
}
c_Decl* c_Enumerator3::p_NextObject(){
	c_Decl* t_data=m__curr->m__data;
	m__curr=m__curr->m__succ;
	return t_data;
}
void c_Enumerator3::mark(){
	Object::mark();
}
c_DeclStmt::c_DeclStmt(){
	m_decl=0;
}
c_DeclStmt* c_DeclStmt::m_new(c_Decl* t_decl){
	c_Stmt::m_new();
	this->m_decl=t_decl;
	return this;
}
c_DeclStmt* c_DeclStmt::m_new2(String t_id,c_Type* t_ty,c_Expr* t_init){
	c_Stmt::m_new();
	this->m_decl=((new c_LocalDecl)->m_new(t_id,0,t_ty,t_init));
	return this;
}
c_DeclStmt* c_DeclStmt::m_new3(){
	c_Stmt::m_new();
	return this;
}
c_Stmt* c_DeclStmt::p_OnCopy2(c_ScopeDecl* t_scope){
	return ((new c_DeclStmt)->m_new(m_decl->p_Copy()));
}
int c_DeclStmt::p_OnSemant(){
	m_decl->p_Semant();
	bb_decl__env->p_InsertDecl(m_decl);
	return 0;
}
String c_DeclStmt::p_Trans(){
	return bb_translator__trans->p_TransDeclStmt(this);
}
void c_DeclStmt::mark(){
	c_Stmt::mark();
}
c_Stack6::c_Stack6(){
	m_data=Array<c_IdentType* >();
	m_length=0;
}
c_Stack6* c_Stack6::m_new(){
	return this;
}
c_Stack6* c_Stack6::m_new2(Array<c_IdentType* > t_data){
	this->m_data=t_data.Slice(0);
	this->m_length=t_data.Length();
	return this;
}
void c_Stack6::p_Push16(c_IdentType* t_value){
	if(m_length==m_data.Length()){
		m_data=m_data.Resize(m_length*2+10);
	}
	m_data[m_length]=t_value;
	m_length+=1;
}
void c_Stack6::p_Push17(Array<c_IdentType* > t_values,int t_offset,int t_count){
	for(int t_i=0;t_i<t_count;t_i=t_i+1){
		p_Push16(t_values[t_offset+t_i]);
	}
}
void c_Stack6::p_Push18(Array<c_IdentType* > t_values,int t_offset){
	p_Push17(t_values,t_offset,t_values.Length()-t_offset);
}
Array<c_IdentType* > c_Stack6::p_ToArray(){
	Array<c_IdentType* > t_t=Array<c_IdentType* >(m_length);
	for(int t_i=0;t_i<m_length;t_i=t_i+1){
		t_t[t_i]=m_data[t_i];
	}
	return t_t;
}
void c_Stack6::mark(){
	Object::mark();
}
c_ObjectType::c_ObjectType(){
	m_classDecl=0;
}
c_ObjectType* c_ObjectType::m_new(c_ClassDecl* t_classDecl){
	c_Type::m_new();
	this->m_classDecl=t_classDecl;
	return this;
}
c_ObjectType* c_ObjectType::m_new2(){
	c_Type::m_new();
	return this;
}
int c_ObjectType::p_EqualsType(c_Type* t_ty){
	c_ObjectType* t_objty=dynamic_cast<c_ObjectType*>(t_ty);
	return ((((t_objty)!=0) && m_classDecl==t_objty->m_classDecl)?1:0);
}
c_ClassDecl* c_ObjectType::p_GetClass(){
	return m_classDecl;
}
int c_ObjectType::p_ExtendsType(c_Type* t_ty){
	c_ObjectType* t_objty=dynamic_cast<c_ObjectType*>(t_ty);
	if((t_objty)!=0){
		return m_classDecl->p_ExtendsClass(t_objty->m_classDecl);
	}
	String t_op=String();
	if((dynamic_cast<c_BoolType*>(t_ty))!=0){
		t_op=String(L"ToBool",6);
	}else{
		if((dynamic_cast<c_IntType*>(t_ty))!=0){
			t_op=String(L"ToInt",5);
		}else{
			if((dynamic_cast<c_FloatType*>(t_ty))!=0){
				t_op=String(L"ToFloat",7);
			}else{
				if((dynamic_cast<c_StringType*>(t_ty))!=0){
					t_op=String(L"ToString",8);
				}else{
					return 0;
				}
			}
		}
	}
	c_FuncDecl* t_fdecl=p_GetClass()->p_FindFuncDecl(t_op,Array<c_Expr* >(),1);
	return ((((t_fdecl)!=0) && t_fdecl->p_IsMethod() && ((t_fdecl->m_retType->p_EqualsType(t_ty))!=0))?1:0);
}
String c_ObjectType::p_ToString(){
	return m_classDecl->p_ToString();
}
void c_ObjectType::mark(){
	c_Type::mark();
}
c_List8::c_List8(){
	m__head=((new c_HeadNode8)->m_new());
}
c_List8* c_List8::m_new(){
	return this;
}
c_Node14* c_List8::p_AddLast8(c_ClassDecl* t_data){
	return (new c_Node14)->m_new(m__head,m__head->m__pred,t_data);
}
c_List8* c_List8::m_new2(Array<c_ClassDecl* > t_data){
	Array<c_ClassDecl* > t_=t_data;
	int t_2=0;
	while(t_2<t_.Length()){
		c_ClassDecl* t_t=t_[t_2];
		t_2=t_2+1;
		p_AddLast8(t_t);
	}
	return this;
}
c_Enumerator5* c_List8::p_ObjectEnumerator(){
	return (new c_Enumerator5)->m_new(this);
}
void c_List8::mark(){
	Object::mark();
}
c_Node14::c_Node14(){
	m__succ=0;
	m__pred=0;
	m__data=0;
}
c_Node14* c_Node14::m_new(c_Node14* t_succ,c_Node14* t_pred,c_ClassDecl* t_data){
	m__succ=t_succ;
	m__pred=t_pred;
	m__succ->m__pred=this;
	m__pred->m__succ=this;
	m__data=t_data;
	return this;
}
c_Node14* c_Node14::m_new2(){
	return this;
}
void c_Node14::mark(){
	Object::mark();
}
c_HeadNode8::c_HeadNode8(){
}
c_HeadNode8* c_HeadNode8::m_new(){
	c_Node14::m_new2();
	m__succ=(this);
	m__pred=(this);
	return this;
}
void c_HeadNode8::mark(){
	c_Node14::mark();
}
c_ArgDecl::c_ArgDecl(){
}
c_ArgDecl* c_ArgDecl::m_new(String t_ident,int t_attrs,c_Type* t_type,c_Expr* t_init){
	c_LocalDecl::m_new2();
	this->m_ident=t_ident;
	this->m_attrs=t_attrs;
	this->m_type=t_type;
	this->m_init=t_init;
	return this;
}
c_ArgDecl* c_ArgDecl::m_new2(){
	c_LocalDecl::m_new2();
	return this;
}
String c_ArgDecl::p_ToString(){
	return c_LocalDecl::p_ToString();
}
c_Decl* c_ArgDecl::p_OnCopy(){
	return ((new c_ArgDecl)->m_new(m_ident,m_attrs,m_type,p_CopyInit()));
}
void c_ArgDecl::mark(){
	c_LocalDecl::mark();
}
c_Stack7::c_Stack7(){
	m_data=Array<c_ArgDecl* >();
	m_length=0;
}
c_Stack7* c_Stack7::m_new(){
	return this;
}
c_Stack7* c_Stack7::m_new2(Array<c_ArgDecl* > t_data){
	this->m_data=t_data.Slice(0);
	this->m_length=t_data.Length();
	return this;
}
void c_Stack7::p_Push19(c_ArgDecl* t_value){
	if(m_length==m_data.Length()){
		m_data=m_data.Resize(m_length*2+10);
	}
	m_data[m_length]=t_value;
	m_length+=1;
}
void c_Stack7::p_Push20(Array<c_ArgDecl* > t_values,int t_offset,int t_count){
	for(int t_i=0;t_i<t_count;t_i=t_i+1){
		p_Push19(t_values[t_offset+t_i]);
	}
}
void c_Stack7::p_Push21(Array<c_ArgDecl* > t_values,int t_offset){
	p_Push20(t_values,t_offset,t_values.Length()-t_offset);
}
Array<c_ArgDecl* > c_Stack7::p_ToArray(){
	Array<c_ArgDecl* > t_t=Array<c_ArgDecl* >(m_length);
	for(int t_i=0;t_i<m_length;t_i=t_i+1){
		t_t[t_i]=m_data[t_i];
	}
	return t_t;
}
void c_Stack7::mark(){
	Object::mark();
}
c_List9::c_List9(){
	m__head=((new c_HeadNode9)->m_new());
}
c_List9* c_List9::m_new(){
	return this;
}
c_Node15* c_List9::p_AddLast9(c_BlockDecl* t_data){
	return (new c_Node15)->m_new(m__head,m__head->m__pred,t_data);
}
c_List9* c_List9::m_new2(Array<c_BlockDecl* > t_data){
	Array<c_BlockDecl* > t_=t_data;
	int t_2=0;
	while(t_2<t_.Length()){
		c_BlockDecl* t_t=t_[t_2];
		t_2=t_2+1;
		p_AddLast9(t_t);
	}
	return this;
}
c_BlockDecl* c_List9::p_RemoveLast(){
	c_BlockDecl* t_data=m__head->m__pred->m__data;
	m__head->m__pred->p_Remove();
	return t_data;
}
bool c_List9::p_Equals4(c_BlockDecl* t_lhs,c_BlockDecl* t_rhs){
	return t_lhs==t_rhs;
}
c_Node15* c_List9::p_FindLast7(c_BlockDecl* t_value,c_Node15* t_start){
	while(t_start!=m__head){
		if(p_Equals4(t_value,t_start->m__data)){
			return t_start;
		}
		t_start=t_start->m__pred;
	}
	return 0;
}
c_Node15* c_List9::p_FindLast8(c_BlockDecl* t_value){
	return p_FindLast7(t_value,m__head->m__pred);
}
void c_List9::p_RemoveLast5(c_BlockDecl* t_value){
	c_Node15* t_node=p_FindLast8(t_value);
	if((t_node)!=0){
		t_node->p_Remove();
	}
}
void c_List9::mark(){
	Object::mark();
}
c_Node15::c_Node15(){
	m__succ=0;
	m__pred=0;
	m__data=0;
}
c_Node15* c_Node15::m_new(c_Node15* t_succ,c_Node15* t_pred,c_BlockDecl* t_data){
	m__succ=t_succ;
	m__pred=t_pred;
	m__succ->m__pred=this;
	m__pred->m__succ=this;
	m__data=t_data;
	return this;
}
c_Node15* c_Node15::m_new2(){
	return this;
}
int c_Node15::p_Remove(){
	m__succ->m__pred=m__pred;
	m__pred->m__succ=m__succ;
	return 0;
}
void c_Node15::mark(){
	Object::mark();
}
c_HeadNode9::c_HeadNode9(){
}
c_HeadNode9* c_HeadNode9::m_new(){
	c_Node15::m_new2();
	m__succ=(this);
	m__pred=(this);
	return this;
}
void c_HeadNode9::mark(){
	c_Node15::mark();
}
c_ReturnStmt::c_ReturnStmt(){
	m_expr=0;
}
c_ReturnStmt* c_ReturnStmt::m_new(c_Expr* t_expr){
	c_Stmt::m_new();
	this->m_expr=t_expr;
	return this;
}
c_ReturnStmt* c_ReturnStmt::m_new2(){
	c_Stmt::m_new();
	return this;
}
c_Stmt* c_ReturnStmt::p_OnCopy2(c_ScopeDecl* t_scope){
	if((m_expr)!=0){
		return ((new c_ReturnStmt)->m_new(m_expr->p_Copy()));
	}
	return ((new c_ReturnStmt)->m_new(0));
}
int c_ReturnStmt::p_OnSemant(){
	c_FuncDecl* t_fdecl=bb_decl__env->p_FuncScope();
	if((m_expr)!=0){
		if(t_fdecl->p_IsCtor()){
			bb_config_Err(String(L"Constructors may not return a value.",36));
		}
		if((dynamic_cast<c_VoidType*>(t_fdecl->m_retType))!=0){
			bb_config_Err(String(L"Void functions may not return a value.",38));
		}
		m_expr=m_expr->p_Semant2(t_fdecl->m_retType,0);
	}else{
		if(t_fdecl->p_IsCtor()){
			m_expr=((new c_SelfExpr)->m_new())->p_Semant();
		}else{
			if(!((dynamic_cast<c_VoidType*>(t_fdecl->m_retType))!=0)){
				if((bb_decl__env->p_ModuleScope()->p_IsStrict())!=0){
					bb_config_Err(String(L"Missing return expression.",26));
				}
				m_expr=((new c_ConstExpr)->m_new(t_fdecl->m_retType,String()))->p_Semant();
			}
		}
	}
	return 0;
}
String c_ReturnStmt::p_Trans(){
	return bb_translator__trans->p_TransReturnStmt(this);
}
void c_ReturnStmt::mark(){
	c_Stmt::mark();
}
c_BreakStmt::c_BreakStmt(){
}
c_BreakStmt* c_BreakStmt::m_new(){
	c_Stmt::m_new();
	return this;
}
c_Stmt* c_BreakStmt::p_OnCopy2(c_ScopeDecl* t_scope){
	return ((new c_BreakStmt)->m_new());
}
int c_BreakStmt::p_OnSemant(){
	if(!((bb_decl__loopnest)!=0)){
		bb_config_Err(String(L"Exit statement must appear inside a loop.",41));
	}
	return 0;
}
String c_BreakStmt::p_Trans(){
	return bb_translator__trans->p_TransBreakStmt(this);
}
void c_BreakStmt::mark(){
	c_Stmt::mark();
}
c_ContinueStmt::c_ContinueStmt(){
}
c_ContinueStmt* c_ContinueStmt::m_new(){
	c_Stmt::m_new();
	return this;
}
c_Stmt* c_ContinueStmt::p_OnCopy2(c_ScopeDecl* t_scope){
	return ((new c_ContinueStmt)->m_new());
}
int c_ContinueStmt::p_OnSemant(){
	if(!((bb_decl__loopnest)!=0)){
		bb_config_Err(String(L"Continue statement must appear inside a loop.",45));
	}
	return 0;
}
String c_ContinueStmt::p_Trans(){
	return bb_translator__trans->p_TransContinueStmt(this);
}
void c_ContinueStmt::mark(){
	c_Stmt::mark();
}
c_IfStmt::c_IfStmt(){
	m_expr=0;
	m_thenBlock=0;
	m_elseBlock=0;
}
c_IfStmt* c_IfStmt::m_new(c_Expr* t_expr,c_BlockDecl* t_thenBlock,c_BlockDecl* t_elseBlock){
	c_Stmt::m_new();
	this->m_expr=t_expr;
	this->m_thenBlock=t_thenBlock;
	this->m_elseBlock=t_elseBlock;
	return this;
}
c_IfStmt* c_IfStmt::m_new2(){
	c_Stmt::m_new();
	return this;
}
c_Stmt* c_IfStmt::p_OnCopy2(c_ScopeDecl* t_scope){
	return ((new c_IfStmt)->m_new(m_expr->p_Copy(),m_thenBlock->p_CopyBlock(t_scope),m_elseBlock->p_CopyBlock(t_scope)));
}
int c_IfStmt::p_OnSemant(){
	m_expr=m_expr->p_Semant2((c_Type::m_boolType),1);
	m_thenBlock->p_Semant();
	m_elseBlock->p_Semant();
	return 0;
}
String c_IfStmt::p_Trans(){
	return bb_translator__trans->p_TransIfStmt(this);
}
void c_IfStmt::mark(){
	c_Stmt::mark();
}
c_WhileStmt::c_WhileStmt(){
	m_expr=0;
	m_block=0;
}
c_WhileStmt* c_WhileStmt::m_new(c_Expr* t_expr,c_BlockDecl* t_block){
	c_Stmt::m_new();
	this->m_expr=t_expr;
	this->m_block=t_block;
	return this;
}
c_WhileStmt* c_WhileStmt::m_new2(){
	c_Stmt::m_new();
	return this;
}
c_Stmt* c_WhileStmt::p_OnCopy2(c_ScopeDecl* t_scope){
	return ((new c_WhileStmt)->m_new(m_expr->p_Copy(),m_block->p_CopyBlock(t_scope)));
}
int c_WhileStmt::p_OnSemant(){
	m_expr=m_expr->p_Semant2((c_Type::m_boolType),1);
	bb_decl__loopnest+=1;
	m_block->p_Semant();
	bb_decl__loopnest-=1;
	return 0;
}
String c_WhileStmt::p_Trans(){
	return bb_translator__trans->p_TransWhileStmt(this);
}
void c_WhileStmt::mark(){
	c_Stmt::mark();
}
c_RepeatStmt::c_RepeatStmt(){
	m_block=0;
	m_expr=0;
}
c_RepeatStmt* c_RepeatStmt::m_new(c_BlockDecl* t_block,c_Expr* t_expr){
	c_Stmt::m_new();
	this->m_block=t_block;
	this->m_expr=t_expr;
	return this;
}
c_RepeatStmt* c_RepeatStmt::m_new2(){
	c_Stmt::m_new();
	return this;
}
c_Stmt* c_RepeatStmt::p_OnCopy2(c_ScopeDecl* t_scope){
	return ((new c_RepeatStmt)->m_new(m_block->p_CopyBlock(t_scope),m_expr->p_Copy()));
}
int c_RepeatStmt::p_OnSemant(){
	bb_decl__loopnest+=1;
	m_block->p_Semant();
	bb_decl__loopnest-=1;
	m_expr=m_expr->p_Semant2((c_Type::m_boolType),1);
	return 0;
}
String c_RepeatStmt::p_Trans(){
	return bb_translator__trans->p_TransRepeatStmt(this);
}
void c_RepeatStmt::mark(){
	c_Stmt::mark();
}
c_ForEachinStmt::c_ForEachinStmt(){
	m_varid=String();
	m_varty=0;
	m_varlocal=0;
	m_expr=0;
	m_block=0;
}
c_ForEachinStmt* c_ForEachinStmt::m_new(String t_varid,c_Type* t_varty,int t_varlocal,c_Expr* t_expr,c_BlockDecl* t_block){
	c_Stmt::m_new();
	this->m_varid=t_varid;
	this->m_varty=t_varty;
	this->m_varlocal=t_varlocal;
	this->m_expr=t_expr;
	this->m_block=t_block;
	return this;
}
c_ForEachinStmt* c_ForEachinStmt::m_new2(){
	c_Stmt::m_new();
	return this;
}
c_Stmt* c_ForEachinStmt::p_OnCopy2(c_ScopeDecl* t_scope){
	return ((new c_ForEachinStmt)->m_new(m_varid,m_varty,m_varlocal,m_expr->p_Copy(),m_block->p_CopyBlock(t_scope)));
}
int c_ForEachinStmt::p_OnSemant(){
	m_expr=m_expr->p_Semant();
	if(((dynamic_cast<c_ArrayType*>(m_expr->m_exprType))!=0) || ((dynamic_cast<c_StringType*>(m_expr->m_exprType))!=0)){
		c_LocalDecl* t_exprTmp=(new c_LocalDecl)->m_new(String(),0,0,m_expr);
		c_LocalDecl* t_indexTmp=(new c_LocalDecl)->m_new(String(),0,0,((new c_ConstExpr)->m_new((c_Type::m_intType),String(L"0",1))));
		c_Expr* t_lenExpr=((new c_IdentExpr)->m_new(String(L"Length",6),((new c_VarExpr)->m_new(t_exprTmp))));
		c_Expr* t_cmpExpr=((new c_BinaryCompareExpr)->m_new(String(L"<",1),((new c_VarExpr)->m_new(t_indexTmp)),t_lenExpr));
		c_Expr* t_indexExpr=((new c_IndexExpr)->m_new(((new c_VarExpr)->m_new(t_exprTmp)),((new c_VarExpr)->m_new(t_indexTmp))));
		c_Expr* t_addExpr=((new c_BinaryMathExpr)->m_new(String(L"+",1),((new c_VarExpr)->m_new(t_indexTmp)),((new c_ConstExpr)->m_new((c_Type::m_intType),String(L"1",1)))));
		m_block->m_stmts->p_AddFirst((new c_AssignStmt)->m_new(String(L"=",1),((new c_VarExpr)->m_new(t_indexTmp)),t_addExpr));
		if((m_varlocal)!=0){
			c_LocalDecl* t_varTmp=(new c_LocalDecl)->m_new(m_varid,0,m_varty,t_indexExpr);
			m_block->m_stmts->p_AddFirst((new c_DeclStmt)->m_new(t_varTmp));
		}else{
			m_block->m_stmts->p_AddFirst((new c_AssignStmt)->m_new(String(L"=",1),((new c_IdentExpr)->m_new(m_varid,0)),t_indexExpr));
		}
		c_WhileStmt* t_whileStmt=(new c_WhileStmt)->m_new(t_cmpExpr,m_block);
		m_block=(new c_BlockDecl)->m_new(m_block->m_scope);
		m_block->p_AddStmt((new c_DeclStmt)->m_new(t_exprTmp));
		m_block->p_AddStmt((new c_DeclStmt)->m_new(t_indexTmp));
		m_block->p_AddStmt(t_whileStmt);
	}else{
		if((dynamic_cast<c_ObjectType*>(m_expr->m_exprType))!=0){
			c_Expr* t_enumerInit=((new c_FuncCallExpr)->m_new(((new c_IdentExpr)->m_new(String(L"ObjectEnumerator",16),m_expr)),Array<c_Expr* >()));
			c_LocalDecl* t_enumerTmp=(new c_LocalDecl)->m_new(String(),0,0,t_enumerInit);
			c_Expr* t_hasNextExpr=((new c_FuncCallExpr)->m_new(((new c_IdentExpr)->m_new(String(L"HasNext",7),((new c_VarExpr)->m_new(t_enumerTmp)))),Array<c_Expr* >()));
			c_Expr* t_nextObjExpr=((new c_FuncCallExpr)->m_new(((new c_IdentExpr)->m_new(String(L"NextObject",10),((new c_VarExpr)->m_new(t_enumerTmp)))),Array<c_Expr* >()));
			if((m_varlocal)!=0){
				c_LocalDecl* t_varTmp2=(new c_LocalDecl)->m_new(m_varid,0,m_varty,t_nextObjExpr);
				m_block->m_stmts->p_AddFirst((new c_DeclStmt)->m_new(t_varTmp2));
			}else{
				m_block->m_stmts->p_AddFirst((new c_AssignStmt)->m_new(String(L"=",1),((new c_IdentExpr)->m_new(m_varid,0)),t_nextObjExpr));
			}
			c_WhileStmt* t_whileStmt2=(new c_WhileStmt)->m_new(t_hasNextExpr,m_block);
			m_block=(new c_BlockDecl)->m_new(m_block->m_scope);
			m_block->p_AddStmt((new c_DeclStmt)->m_new(t_enumerTmp));
			m_block->p_AddStmt(t_whileStmt2);
		}else{
			bb_config_Err(String(L"Expression cannot be used with For Each.",40));
		}
	}
	m_block->p_Semant();
	return 0;
}
String c_ForEachinStmt::p_Trans(){
	return bb_translator__trans->p_TransBlock(m_block);
}
void c_ForEachinStmt::mark(){
	c_Stmt::mark();
}
c_AssignStmt::c_AssignStmt(){
	m_op=String();
	m_lhs=0;
	m_rhs=0;
	m_tmp1=0;
	m_tmp2=0;
}
c_AssignStmt* c_AssignStmt::m_new(String t_op,c_Expr* t_lhs,c_Expr* t_rhs){
	c_Stmt::m_new();
	this->m_op=t_op;
	this->m_lhs=t_lhs;
	this->m_rhs=t_rhs;
	return this;
}
c_AssignStmt* c_AssignStmt::m_new2(){
	c_Stmt::m_new();
	return this;
}
c_Stmt* c_AssignStmt::p_OnCopy2(c_ScopeDecl* t_scope){
	return ((new c_AssignStmt)->m_new(m_op,m_lhs->p_Copy(),m_rhs->p_Copy()));
}
int c_AssignStmt::p_FixSideEffects(){
	c_MemberVarExpr* t_e1=dynamic_cast<c_MemberVarExpr*>(m_lhs);
	if((t_e1)!=0){
		if(t_e1->m_expr->p_SideEffects()){
			m_tmp1=(new c_LocalDecl)->m_new(String(),0,t_e1->m_expr->m_exprType,t_e1->m_expr);
			m_tmp1->p_Semant();
			m_lhs=((new c_MemberVarExpr)->m_new(((new c_VarExpr)->m_new(m_tmp1)),t_e1->m_decl));
		}
	}
	c_IndexExpr* t_e2=dynamic_cast<c_IndexExpr*>(m_lhs);
	if((t_e2)!=0){
		c_Expr* t_expr=t_e2->m_expr;
		c_Expr* t_index=t_e2->m_index;
		if(t_expr->p_SideEffects() || t_index->p_SideEffects()){
			if(t_expr->p_SideEffects()){
				m_tmp1=(new c_LocalDecl)->m_new(String(),0,t_expr->m_exprType,t_expr);
				m_tmp1->p_Semant();
				t_expr=((new c_VarExpr)->m_new(m_tmp1));
			}
			if(t_index->p_SideEffects()){
				m_tmp2=(new c_LocalDecl)->m_new(String(),0,t_index->m_exprType,t_index);
				m_tmp2->p_Semant();
				t_index=((new c_VarExpr)->m_new(m_tmp2));
			}
			m_lhs=((new c_IndexExpr)->m_new(t_expr,t_index))->p_Semant();
		}
	}
	return 0;
}
int c_AssignStmt::p_OnSemant(){
	m_rhs=m_rhs->p_Semant();
	m_lhs=m_lhs->p_SemantSet(m_op,m_rhs);
	if(((dynamic_cast<c_InvokeExpr*>(m_lhs))!=0) || ((dynamic_cast<c_InvokeMemberExpr*>(m_lhs))!=0)){
		m_rhs=0;
		return 0;
	}
	bool t_kludge=true;
	String t_1=m_op;
	if(t_1==String(L"=",1)){
		m_rhs=m_rhs->p_Cast(m_lhs->m_exprType,0);
		t_kludge=false;
	}else{
		if(t_1==String(L"*=",2) || t_1==String(L"/=",2) || t_1==String(L"+=",2) || t_1==String(L"-=",2)){
			if(((dynamic_cast<c_NumericType*>(m_lhs->m_exprType))!=0) && ((m_lhs->m_exprType->p_EqualsType(m_rhs->m_exprType))!=0)){
				t_kludge=false;
				if(bb_config_ENV_LANG==String(L"js",2)){
					if(m_op==String(L"/=",2) && ((dynamic_cast<c_IntType*>(m_lhs->m_exprType))!=0)){
						t_kludge=true;
					}
				}
			}
		}else{
			if(t_1==String(L"&=",2) || t_1==String(L"|=",2) || t_1==String(L"~=",2) || t_1==String(L"shl=",4) || t_1==String(L"shr=",4) || t_1==String(L"mod=",4)){
				if(((dynamic_cast<c_IntType*>(m_lhs->m_exprType))!=0) && ((m_lhs->m_exprType->p_EqualsType(m_rhs->m_exprType))!=0)){
					t_kludge=false;
				}
			}else{
				bb_config_InternalErr(String(L"Internal error",14));
			}
		}
	}
	if(bb_config_ENV_LANG==String()){
		t_kludge=true;
	}
	if(t_kludge){
		p_FixSideEffects();
		m_rhs=((new c_BinaryMathExpr)->m_new(m_op.Slice(0,-1),m_lhs,m_rhs))->p_Semant()->p_Cast(m_lhs->m_exprType,0);
		m_op=String(L"=",1);
	}
	return 0;
}
String c_AssignStmt::p_Trans(){
	bb_config__errInfo=m_errInfo;
	return bb_translator__trans->p_TransAssignStmt(this);
}
void c_AssignStmt::mark(){
	c_Stmt::mark();
}
c_ForStmt::c_ForStmt(){
	m_init=0;
	m_expr=0;
	m_incr=0;
	m_block=0;
}
c_ForStmt* c_ForStmt::m_new(c_Stmt* t_init,c_Expr* t_expr,c_Stmt* t_incr,c_BlockDecl* t_block){
	c_Stmt::m_new();
	this->m_init=t_init;
	this->m_expr=t_expr;
	this->m_incr=t_incr;
	this->m_block=t_block;
	return this;
}
c_ForStmt* c_ForStmt::m_new2(){
	c_Stmt::m_new();
	return this;
}
c_Stmt* c_ForStmt::p_OnCopy2(c_ScopeDecl* t_scope){
	return ((new c_ForStmt)->m_new(m_init->p_Copy2(t_scope),m_expr->p_Copy(),m_incr->p_Copy2(t_scope),m_block->p_CopyBlock(t_scope)));
}
int c_ForStmt::p_OnSemant(){
	bb_decl_PushEnv(m_block);
	m_init->p_Semant();
	m_expr=m_expr->p_Semant();
	bb_decl__loopnest+=1;
	m_block->p_Semant();
	bb_decl__loopnest-=1;
	m_incr->p_Semant();
	bb_decl_PopEnv();
	c_AssignStmt* t_assop=dynamic_cast<c_AssignStmt*>(m_incr);
	c_BinaryExpr* t_addop=dynamic_cast<c_BinaryExpr*>(t_assop->m_rhs);
	if(!((t_addop)!=0)){
		bb_config_Err(String(L"Invalid step expression",23));
	}
	String t_stpval=t_addop->m_rhs->p_Eval();
	if(t_stpval.StartsWith(String(L"-",1))){
		c_BinaryExpr* t_bexpr=dynamic_cast<c_BinaryExpr*>(m_expr);
		String t_2=t_bexpr->m_op;
		if(t_2==String(L"<",1)){
			t_bexpr->m_op=String(L">",1);
		}else{
			if(t_2==String(L"<=",2)){
				t_bexpr->m_op=String(L">=",2);
			}
		}
	}
	return 0;
}
String c_ForStmt::p_Trans(){
	return bb_translator__trans->p_TransForStmt(this);
}
void c_ForStmt::mark(){
	c_Stmt::mark();
}
c_CatchStmt::c_CatchStmt(){
	m_init=0;
	m_block=0;
}
c_CatchStmt* c_CatchStmt::m_new(c_LocalDecl* t_init,c_BlockDecl* t_block){
	c_Stmt::m_new();
	this->m_init=t_init;
	this->m_block=t_block;
	return this;
}
c_CatchStmt* c_CatchStmt::m_new2(){
	c_Stmt::m_new();
	return this;
}
c_Stmt* c_CatchStmt::p_OnCopy2(c_ScopeDecl* t_scope){
	return ((new c_CatchStmt)->m_new(dynamic_cast<c_LocalDecl*>(m_init->p_Copy()),m_block->p_CopyBlock(t_scope)));
}
int c_CatchStmt::p_OnSemant(){
	m_init->p_Semant();
	if(!((dynamic_cast<c_ObjectType*>(m_init->m_type))!=0)){
		bb_config_Err(String(L"Variable type must extend Throwable",35));
	}
	if(!((m_init->m_type->p_GetClass()->p_IsThrowable())!=0)){
		bb_config_Err(String(L"Variable type must extend Throwable",35));
	}
	m_block->p_InsertDecl(m_init);
	m_block->p_Semant();
	return 0;
}
String c_CatchStmt::p_Trans(){
	return String();
}
void c_CatchStmt::mark(){
	c_Stmt::mark();
}
c_Stack8::c_Stack8(){
	m_data=Array<c_CatchStmt* >();
	m_length=0;
}
c_Stack8* c_Stack8::m_new(){
	return this;
}
c_Stack8* c_Stack8::m_new2(Array<c_CatchStmt* > t_data){
	this->m_data=t_data.Slice(0);
	this->m_length=t_data.Length();
	return this;
}
void c_Stack8::p_Push22(c_CatchStmt* t_value){
	if(m_length==m_data.Length()){
		m_data=m_data.Resize(m_length*2+10);
	}
	m_data[m_length]=t_value;
	m_length+=1;
}
void c_Stack8::p_Push23(Array<c_CatchStmt* > t_values,int t_offset,int t_count){
	for(int t_i=0;t_i<t_count;t_i=t_i+1){
		p_Push22(t_values[t_offset+t_i]);
	}
}
void c_Stack8::p_Push24(Array<c_CatchStmt* > t_values,int t_offset){
	p_Push23(t_values,t_offset,t_values.Length()-t_offset);
}
c_CatchStmt* c_Stack8::m_NIL;
void c_Stack8::p_Length(int t_newlength){
	if(t_newlength<m_length){
		for(int t_i=t_newlength;t_i<m_length;t_i=t_i+1){
			m_data[t_i]=m_NIL;
		}
	}else{
		if(t_newlength>m_data.Length()){
			m_data=m_data.Resize(bb_math_Max(m_length*2+10,t_newlength));
		}
	}
	m_length=t_newlength;
}
int c_Stack8::p_Length2(){
	return m_length;
}
Array<c_CatchStmt* > c_Stack8::p_ToArray(){
	Array<c_CatchStmt* > t_t=Array<c_CatchStmt* >(m_length);
	for(int t_i=0;t_i<m_length;t_i=t_i+1){
		t_t[t_i]=m_data[t_i];
	}
	return t_t;
}
void c_Stack8::mark(){
	Object::mark();
}
int bb_math_Max(int t_x,int t_y){
	if(t_x>t_y){
		return t_x;
	}
	return t_y;
}
Float bb_math_Max2(Float t_x,Float t_y){
	if(t_x>t_y){
		return t_x;
	}
	return t_y;
}
c_TryStmt::c_TryStmt(){
	m_block=0;
	m_catches=Array<c_CatchStmt* >();
}
c_TryStmt* c_TryStmt::m_new(c_BlockDecl* t_block,Array<c_CatchStmt* > t_catches){
	c_Stmt::m_new();
	this->m_block=t_block;
	this->m_catches=t_catches;
	return this;
}
c_TryStmt* c_TryStmt::m_new2(){
	c_Stmt::m_new();
	return this;
}
c_Stmt* c_TryStmt::p_OnCopy2(c_ScopeDecl* t_scope){
	Array<c_CatchStmt* > t_tcatches=this->m_catches.Slice(0);
	for(int t_i=0;t_i<t_tcatches.Length();t_i=t_i+1){
		t_tcatches[t_i]=dynamic_cast<c_CatchStmt*>(t_tcatches[t_i]->p_Copy2(t_scope));
	}
	return ((new c_TryStmt)->m_new(m_block->p_CopyBlock(t_scope),t_tcatches));
}
int c_TryStmt::p_OnSemant(){
	m_block->p_Semant();
	for(int t_i=0;t_i<m_catches.Length();t_i=t_i+1){
		m_catches[t_i]->p_Semant();
		for(int t_j=0;t_j<t_i;t_j=t_j+1){
			if((m_catches[t_i]->m_init->m_type->p_ExtendsType(m_catches[t_j]->m_init->m_type))!=0){
				bb_config_PushErr(m_catches[t_i]->m_errInfo);
				bb_config_Err(String(L"Catch variable class extends earlier catch variable class",57));
			}
		}
	}
	return 0;
}
String c_TryStmt::p_Trans(){
	return bb_translator__trans->p_TransTryStmt(this);
}
void c_TryStmt::mark(){
	c_Stmt::mark();
}
c_ThrowStmt::c_ThrowStmt(){
	m_expr=0;
}
c_ThrowStmt* c_ThrowStmt::m_new(c_Expr* t_expr){
	c_Stmt::m_new();
	this->m_expr=t_expr;
	return this;
}
c_ThrowStmt* c_ThrowStmt::m_new2(){
	c_Stmt::m_new();
	return this;
}
c_Stmt* c_ThrowStmt::p_OnCopy2(c_ScopeDecl* t_scope){
	return ((new c_ThrowStmt)->m_new(m_expr->p_Copy()));
}
int c_ThrowStmt::p_OnSemant(){
	m_expr=m_expr->p_Semant();
	if(!((dynamic_cast<c_ObjectType*>(m_expr->m_exprType))!=0)){
		bb_config_Err(String(L"Expression type must extend Throwable",37));
	}
	if(!((m_expr->m_exprType->p_GetClass()->p_IsThrowable())!=0)){
		bb_config_Err(String(L"Expression type must extend Throwable",37));
	}
	return 0;
}
String c_ThrowStmt::p_Trans(){
	return bb_translator__trans->p_TransThrowStmt(this);
}
void c_ThrowStmt::mark(){
	c_Stmt::mark();
}
c_ExprStmt::c_ExprStmt(){
	m_expr=0;
}
c_ExprStmt* c_ExprStmt::m_new(c_Expr* t_expr){
	c_Stmt::m_new();
	this->m_expr=t_expr;
	return this;
}
c_ExprStmt* c_ExprStmt::m_new2(){
	c_Stmt::m_new();
	return this;
}
c_Stmt* c_ExprStmt::p_OnCopy2(c_ScopeDecl* t_scope){
	return ((new c_ExprStmt)->m_new(m_expr->p_Copy()));
}
int c_ExprStmt::p_OnSemant(){
	m_expr=m_expr->p_Semant();
	if(!((m_expr)!=0)){
		bb_config_InternalErr(String(L"Internal error",14));
	}
	return 0;
}
String c_ExprStmt::p_Trans(){
	return bb_translator__trans->p_TransExprStmt(this);
}
void c_ExprStmt::mark(){
	c_Stmt::mark();
}
c_ModuleDecl* bb_parser_ParseModule(String t_modpath,String t_filepath,c_AppDecl* t_app){
	String t_ident=t_modpath;
	if(t_ident.Contains(String(L".",1))){
		t_ident=bb_os_ExtractExt(t_ident);
	}
	c_ModuleDecl* t_mdecl=(new c_ModuleDecl)->m_new(t_ident,0,String(),t_modpath,t_filepath,t_app);
	t_mdecl->p_ImportModule(String(L"cerberus",8),0);
	String t_source=bb_preprocessor_PreProcess(t_filepath,t_mdecl);
	c_Toker* t_toker=(new c_Toker)->m_new(t_filepath,t_source);
	c_Parser* t_parser=(new c_Parser)->m_new(t_toker,t_app,t_mdecl,0);
	t_parser->p_ParseMain();
	return t_parser->m__module;
}
c_Enumerator4::c_Enumerator4(){
	m__list=0;
	m__curr=0;
}
c_Enumerator4* c_Enumerator4::m_new(c_List6* t_list){
	m__list=t_list;
	m__curr=t_list->m__head->m__succ;
	return this;
}
c_Enumerator4* c_Enumerator4::m_new2(){
	return this;
}
bool c_Enumerator4::p_HasNext(){
	while(m__curr->m__succ->m__pred!=m__curr){
		m__curr=m__curr->m__succ;
	}
	return m__curr!=m__list->m__head;
}
c_FuncDecl* c_Enumerator4::p_NextObject(){
	c_FuncDecl* t_data=m__curr->m__data;
	m__curr=m__curr->m__succ;
	return t_data;
}
void c_Enumerator4::mark(){
	Object::mark();
}
c_StringList* bb_config__errStack;
int bb_config_PushErr(String t_errInfo){
	bb_config__errStack->p_AddLast(bb_config__errInfo);
	bb_config__errInfo=t_errInfo;
	return 0;
}
c_List10::c_List10(){
	m__head=((new c_HeadNode10)->m_new());
}
c_List10* c_List10::m_new(){
	return this;
}
c_Node16* c_List10::p_AddLast10(c_GlobalDecl* t_data){
	return (new c_Node16)->m_new(m__head,m__head->m__pred,t_data);
}
c_List10* c_List10::m_new2(Array<c_GlobalDecl* > t_data){
	Array<c_GlobalDecl* > t_=t_data;
	int t_2=0;
	while(t_2<t_.Length()){
		c_GlobalDecl* t_t=t_[t_2];
		t_2=t_2+1;
		p_AddLast10(t_t);
	}
	return this;
}
c_Enumerator7* c_List10::p_ObjectEnumerator(){
	return (new c_Enumerator7)->m_new(this);
}
void c_List10::mark(){
	Object::mark();
}
c_Node16::c_Node16(){
	m__succ=0;
	m__pred=0;
	m__data=0;
}
c_Node16* c_Node16::m_new(c_Node16* t_succ,c_Node16* t_pred,c_GlobalDecl* t_data){
	m__succ=t_succ;
	m__pred=t_pred;
	m__succ->m__pred=this;
	m__pred->m__succ=this;
	m__data=t_data;
	return this;
}
c_Node16* c_Node16::m_new2(){
	return this;
}
void c_Node16::mark(){
	Object::mark();
}
c_HeadNode10::c_HeadNode10(){
}
c_HeadNode10* c_HeadNode10::m_new(){
	c_Node16::m_new2();
	m__succ=(this);
	m__pred=(this);
	return this;
}
void c_HeadNode10::mark(){
	c_Node16::mark();
}
int bb_config_PopErr(){
	bb_config__errInfo=bb_config__errStack->p_RemoveLast();
	return 0;
}
c_InvokeMemberExpr::c_InvokeMemberExpr(){
	m_expr=0;
	m_decl=0;
	m_args=Array<c_Expr* >();
	m_isResize=0;
}
c_InvokeMemberExpr* c_InvokeMemberExpr::m_new(c_Expr* t_expr,c_FuncDecl* t_decl,Array<c_Expr* > t_args){
	c_Expr::m_new();
	this->m_expr=t_expr;
	this->m_decl=t_decl;
	this->m_args=t_args;
	return this;
}
c_InvokeMemberExpr* c_InvokeMemberExpr::m_new2(){
	c_Expr::m_new();
	return this;
}
c_Expr* c_InvokeMemberExpr::p_Semant(){
	if((m_exprType)!=0){
		return (this);
	}
	m_exprType=m_decl->m_retType;
	m_args=p_CastArgs(m_args,m_decl);
	if(((dynamic_cast<c_ArrayType*>(m_exprType))!=0) && ((dynamic_cast<c_VoidType*>(dynamic_cast<c_ArrayType*>(m_exprType)->m_elemType))!=0)){
		m_isResize=1;
		m_exprType=m_expr->m_exprType;
	}
	return (this);
}
String c_InvokeMemberExpr::p_ToString(){
	String t_t=String(L"InvokeMemberExpr(",17)+m_expr->p_ToString()+String(L",",1)+m_decl->p_ToString();
	Array<c_Expr* > t_=m_args;
	int t_2=0;
	while(t_2<t_.Length()){
		c_Expr* t_arg=t_[t_2];
		t_2=t_2+1;
		t_t=t_t+(String(L",",1)+t_arg->p_ToString());
	}
	return t_t+String(L")",1);
}
String c_InvokeMemberExpr::p_Trans(){
	if((m_isResize)!=0){
		return bb_translator__trans->p_TransInvokeMemberExpr(this);
	}
	return bb_translator__trans->p_TransInvokeMemberExpr(this);
}
String c_InvokeMemberExpr::p_TransStmt(){
	return bb_translator__trans->p_TransInvokeMemberExpr(this);
}
void c_InvokeMemberExpr::mark(){
	c_Expr::mark();
}
c_Expr* bb_preprocessor_EvalExpr(c_Toker* t_toker){
	c_StringStack* t_buf=(new c_StringStack)->m_new2();
	while(((t_toker->p_Toke()).Length()!=0) && t_toker->p_Toke()!=String(L"\n",1) && t_toker->p_TokeType()!=9){
		t_buf->p_Push(t_toker->p_Toke());
		t_toker->p_NextToke();
	}
	String t_source=t_buf->p_Join(String());
	t_toker=(new c_Toker)->m_new(String(),t_source);
	c_Parser* t_parser=(new c_Parser)->m_new(t_toker,0,0,0);
	c_Expr* t_expr=t_parser->p_ParseExpr()->p_Semant();
	return t_expr;
}
bool bb_preprocessor_EvalBool(c_Toker* t_toker){
	if(c_Toker::m_Remarks()){
		return false;
	}
	c_Expr* t_expr=bb_preprocessor_EvalExpr(t_toker);
	if(!((dynamic_cast<c_BoolType*>(t_expr->m_exprType))!=0)){
		t_expr=t_expr->p_Cast((c_Type::m_boolType),1);
	}
	if((t_expr->p_Eval()).Length()!=0){
		return true;
	}
	return false;
}
String bb_preprocessor_EvalText(c_Toker* t_toker){
	c_Expr* t_expr=bb_preprocessor_EvalExpr(t_toker);
	String t_val=t_expr->p_Eval();
	if((dynamic_cast<c_StringType*>(t_expr->m_exprType))!=0){
		return bb_config_EvalConfigTags(t_val);
	}
	if((dynamic_cast<c_BoolType*>(t_expr->m_exprType))!=0){
		if((t_val).Length()!=0){
			return String(L"True",4);
		}
		return String(L"False",5);
	}
	return t_val;
}
c_StringMap2* bb_config_GetConfigVars(){
	return bb_config__cfgScope->m_vars;
}
c_Type* bb_config_GetConfigVarType(String t_key){
	c_ConstDecl* t_decl=bb_config__cfgScope->m_cdecls->p_Get(t_key);
	if((t_decl)!=0){
		return t_decl->m_type;
	}
	return 0;
}
String bb_preprocessor_PreProcess(String t_path,c_ModuleDecl* t_mdecl){
	int t_cnest=0;
	int t_ifnest=0;
	int t_line=0;
	c_StringStack* t_source=(new c_StringStack)->m_new2();
	c_IntStack* t_tracknesting=(new c_IntStack)->m_new2();
	c_IntStack* t_trace=(new c_IntStack)->m_new2();
	bb_decl_PushEnv(bb_config_GetConfigScope());
	String t_p_cd=bb_config_GetConfigVar(String(L"CD",2));
	String t_p_modpath=bb_config_GetConfigVar(String(L"MODPATH",7));
	bb_config_SetConfigVar2(String(L"CD",2),bb_os_ExtractDir(RealPath(t_path)));
	if((t_mdecl)!=0){
		bb_config_SetConfigVar2(String(L"MODPATH",7),t_mdecl->m_rmodpath);
	}else{
		bb_config_SetConfigVar2(String(L"MODPATH",7),String());
	}
	c_Toker* t_toker=(new c_Toker)->m_new(t_path,LoadString(t_path));
	t_toker->p_NextToke();
	int t_attrs=0;
	do{
		if((t_line)!=0){
			t_source->p_Push(String(L"\n",1));
			while(((t_toker->p_Toke()).Length()!=0) && t_toker->p_Toke()!=String(L"\n",1) && t_toker->p_TokeType()!=9){
				t_toker->p_NextToke();
			}
			if(!((t_toker->p_Toke()).Length()!=0)){
				break;
			}
			t_toker->p_NextToke();
		}
		t_line+=1;
		bb_config__errInfo=t_toker->p_Path()+String(L"<",1)+String(t_toker->p_Line())+String(L">",1);
		if(t_toker->p_TokeType()==1){
			t_toker->p_NextToke();
		}
		if(t_toker->p_Toke()!=String(L"#",1)){
			if(t_cnest==t_ifnest){
				String t_line2=String();
				while(((t_toker->p_Toke()).Length()!=0) && t_toker->p_Toke()!=String(L"\n",1) && t_toker->p_TokeType()!=9){
					String t_toke=t_toker->p_Toke();
					t_toker->p_NextToke();
					if((t_mdecl)!=0){
						String t_1=t_toke.ToLower();
						if(t_1==String(L"public",6)){
							t_attrs=0;
						}else{
							if(t_1==String(L"private",7)){
								t_attrs=512;
							}else{
								if(t_1==String(L"import",6)){
									while(t_toker->p_TokeType()==1){
										t_toke=t_toke+t_toker->p_Toke();
										t_toker->p_NextToke();
									}
									if(t_toker->p_TokeType()==2){
										String t_modpath=t_toker->p_Toke();
										while(t_toker->p_NextToke()==String(L".",1)){
											t_modpath=t_modpath+String(L".",1);
											t_toker->p_NextToke();
											if(t_toker->p_TokeType()!=2){
												break;
											}
											t_modpath=t_modpath+t_toker->p_Toke();
										}
										t_toke=t_toke+t_modpath;
										t_mdecl->p_ImportModule(t_modpath,t_attrs);
									}
								}
							}
						}
					}
					t_line2=t_line2+t_toke;
				}
				if((t_line2).Length()!=0){
					t_source->p_Push(t_line2);
				}
			}
			continue;
		}
		String t_toke2=t_toker->p_NextToke();
		if(t_toker->p_TokeType()==1){
			t_toke2=t_toker->p_NextToke();
		}
		String t_stm=t_toke2.ToLower();
		int t_ty=t_toker->p_TokeType();
		t_toker->p_NextToke();
		if(t_stm==String(L"end",3) || t_stm==String(L"else",4)){
			if(t_toker->p_TokeType()==1){
				t_toker->p_NextToke();
			}
			if(t_toker->p_Toke().ToLower()==String(L"if",2)){
				t_toker->p_NextToke();
				t_stm=t_stm+String(L"if",2);
			}
		}
		String t_2=t_stm;
		if(t_2==String(L"rem",3)){
			if(!c_Toker::m_Remarks()){
				c_Toker::m_RemarksOn();
				t_ifnest+=1;
				t_tracknesting->p_Push7(t_line);
				t_trace->p_Push7(t_line);
			}
		}else{
			if(t_2==String(L"if",2)){
				t_ifnest+=1;
				if(t_cnest==t_ifnest-1){
					if(bb_preprocessor_EvalBool(t_toker)){
						t_cnest=t_ifnest;
					}
				}
				t_tracknesting->p_Push7(t_line);
				t_trace->p_Push7(t_line);
			}else{
				if(t_2==String(L"else",4)){
					if(!((t_ifnest)!=0)){
						bb_config_Err(String(L"#Else without #If",17));
					}
					if(t_cnest==t_ifnest){
						t_cnest|=65536;
					}else{
						if(t_cnest==t_ifnest-1){
							t_cnest=t_ifnest;
						}
					}
					t_trace->p_Push7(t_line);
				}else{
					if(t_2==String(L"elseif",6)){
						if(!((t_ifnest)!=0)){
							bb_config_Err(String(L"#ElseIf without #If",19));
						}
						if(t_cnest==t_ifnest){
							t_cnest|=65536;
						}else{
							if(t_cnest==t_ifnest-1){
								if(bb_preprocessor_EvalBool(t_toker)){
									t_cnest=t_ifnest;
								}
							}
						}
						t_trace->p_Push7(t_line);
					}else{
						if(t_2==String(L"end",3) || t_2==String(L"endif",5)){
							if(!((t_ifnest)!=0)){
								bb_config_Err(String(L"#End without #If or #Rem",24));
							}
							t_ifnest-=1;
							if(t_ifnest<(t_cnest&65535)){
								t_cnest=t_ifnest;
							}
							if(!t_tracknesting->p_IsEmpty()){
								t_tracknesting->p_Pop();
							}
							if(c_Toker::m_Remarks()){
								c_Toker::m_RemarksOff();
							}
						}else{
							if(t_2==String(L"print",5)){
								if(t_cnest==t_ifnest){
									bbPrint(bb_preprocessor_EvalText(t_toker));
								}
							}else{
								if(t_2==String(L"error",5)){
									if(t_cnest==t_ifnest){
										bb_config_Err(bb_preprocessor_EvalText(t_toker));
									}
								}else{
									if(t_cnest==t_ifnest){
										if(t_ty==2){
											if(t_toker->p_TokeType()==1){
												t_toker->p_NextToke();
											}
											String t_op=t_toker->p_Toke();
											String t_3=t_op;
											if(t_3==String(L"=",1) || t_3==String(L"+=",2)){
												String t_4=t_toke2;
												if(t_4==String(L"HOST",4) || t_4==String(L"LANG",4) || t_4==String(L"CONFIG",6) || t_4==String(L"TARGET",6) || t_4==String(L"SAFEMODE",8)){
													bb_config_Err(String(L"App config var '",16)+t_toke2+String(L"' cannot be modified",20));
												}
												t_toker->p_NextToke();
												String t_5=t_op;
												if(t_5==String(L"=",1)){
													c_Expr* t_expr=bb_preprocessor_EvalExpr(t_toker);
													String t_val=t_expr->p_Eval();
													if(!bb_config_GetConfigVars()->p_Contains(t_toke2)){
														if((dynamic_cast<c_StringType*>(t_expr->m_exprType))!=0){
															t_val=bb_config_EvalConfigTags(t_val);
														}
														bb_config_SetConfigVar(t_toke2,t_val,t_expr->m_exprType);
													}
												}else{
													if(t_5==String(L"+=",2)){
														String t_val2=bb_preprocessor_EvalText(t_toker);
														String t_var=bb_config_GetConfigVar(t_toke2);
														if((dynamic_cast<c_BoolType*>(bb_config_GetConfigVarType(t_toke2)))!=0){
															if(t_var==String(L"1",1)){
																t_var=String(L"True",4);
															}else{
																t_var=String(L"False",5);
															}
														}
														if(((t_var).Length()!=0) && !t_val2.StartsWith(String(L";",1))){
															t_val2=String(L";",1)+t_val2;
														}
														bb_config_SetConfigVar2(t_toke2,t_var+t_val2);
													}
												}
											}else{
												bb_config_Err(String(L"Expecting assignment operator.",30));
											}
										}else{
											bb_config_Err(String(L"Unrecognized preprocessor directive '",37)+t_toke2+String(L"'",1));
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}while(!(false));
	if(t_toker->p_TokeType()==0){
		if(!t_tracknesting->p_IsEmpty()){
			if(!t_trace->p_IsEmpty()){
				bbPrint(String(L"\t\t-------------- Preprocessor Trace Log --------------",54));
				String t_s=String(L" : Starts here.....",19);
				for(int t_i=0;t_i<t_trace->p_Length2()-1;t_i=t_i+1){
					if(t_i>0){
						t_s=String();
					}
					bbPrint(bb_config__errInfo.Slice(0,bb_config__errInfo.FindLast(String(L"<",1))+1)+String(t_trace->p_Get2(t_i))+String(L">",1)+t_s);
				}
				bbPrint(String());
			}
			if(t_trace->p_IsEmpty()){
				bb_config__errInfo=bb_config__errInfo.Slice(0,bb_config__errInfo.FindLast(String(L"<",1)))+String(L"<",1)+String(t_tracknesting->p_Pop())+String(L">",1);
			}else{
				bb_config__errInfo=bb_config__errInfo.Slice(0,bb_config__errInfo.FindLast(String(L"<",1)))+String(L"<",1)+String(t_trace->p_Pop())+String(L">",1);
			}
			bb_config_Err(String(L"End of file reached. Preprocessor Conditional or Remark block preprocess not closed.",84));
		}
		t_trace->p_Clear();
		t_tracknesting->p_Clear();
	}
	bb_config_SetConfigVar2(String(L"MODPATH",7),t_p_modpath);
	bb_config_SetConfigVar2(String(L"CD",2),t_p_cd);
	bb_decl_PopEnv();
	return t_source->p_Join(String());
}
c_Target::c_Target(){
	m_dir=String();
	m_name=String();
	m_system=String();
	m_builder=0;
}
c_Target* c_Target::m_new(String t_dir,String t_name,String t_system,c_Builder* t_builder){
	this->m_dir=t_dir;
	this->m_name=t_name;
	this->m_system=t_system;
	this->m_builder=t_builder;
	return this;
}
c_Target* c_Target::m_new2(){
	return this;
}
void c_Target::mark(){
	Object::mark();
}
c_Map7::c_Map7(){
	m_root=0;
}
c_Map7* c_Map7::m_new(){
	return this;
}
int c_Map7::p_RotateLeft7(c_Node17* t_node){
	c_Node17* t_child=t_node->m_right;
	t_node->m_right=t_child->m_left;
	if((t_child->m_left)!=0){
		t_child->m_left->m_parent=t_node;
	}
	t_child->m_parent=t_node->m_parent;
	if((t_node->m_parent)!=0){
		if(t_node==t_node->m_parent->m_left){
			t_node->m_parent->m_left=t_child;
		}else{
			t_node->m_parent->m_right=t_child;
		}
	}else{
		m_root=t_child;
	}
	t_child->m_left=t_node;
	t_node->m_parent=t_child;
	return 0;
}
int c_Map7::p_RotateRight7(c_Node17* t_node){
	c_Node17* t_child=t_node->m_left;
	t_node->m_left=t_child->m_right;
	if((t_child->m_right)!=0){
		t_child->m_right->m_parent=t_node;
	}
	t_child->m_parent=t_node->m_parent;
	if((t_node->m_parent)!=0){
		if(t_node==t_node->m_parent->m_right){
			t_node->m_parent->m_right=t_child;
		}else{
			t_node->m_parent->m_left=t_child;
		}
	}else{
		m_root=t_child;
	}
	t_child->m_right=t_node;
	t_node->m_parent=t_child;
	return 0;
}
int c_Map7::p_InsertFixup7(c_Node17* t_node){
	while(((t_node->m_parent)!=0) && t_node->m_parent->m_color==-1 && ((t_node->m_parent->m_parent)!=0)){
		if(t_node->m_parent==t_node->m_parent->m_parent->m_left){
			c_Node17* t_uncle=t_node->m_parent->m_parent->m_right;
			if(((t_uncle)!=0) && t_uncle->m_color==-1){
				t_node->m_parent->m_color=1;
				t_uncle->m_color=1;
				t_uncle->m_parent->m_color=-1;
				t_node=t_uncle->m_parent;
			}else{
				if(t_node==t_node->m_parent->m_right){
					t_node=t_node->m_parent;
					p_RotateLeft7(t_node);
				}
				t_node->m_parent->m_color=1;
				t_node->m_parent->m_parent->m_color=-1;
				p_RotateRight7(t_node->m_parent->m_parent);
			}
		}else{
			c_Node17* t_uncle2=t_node->m_parent->m_parent->m_left;
			if(((t_uncle2)!=0) && t_uncle2->m_color==-1){
				t_node->m_parent->m_color=1;
				t_uncle2->m_color=1;
				t_uncle2->m_parent->m_color=-1;
				t_node=t_uncle2->m_parent;
			}else{
				if(t_node==t_node->m_parent->m_left){
					t_node=t_node->m_parent;
					p_RotateRight7(t_node);
				}
				t_node->m_parent->m_color=1;
				t_node->m_parent->m_parent->m_color=-1;
				p_RotateLeft7(t_node->m_parent->m_parent);
			}
		}
	}
	m_root->m_color=1;
	return 0;
}
bool c_Map7::p_Set6(String t_key,c_Target* t_value){
	c_Node17* t_node=m_root;
	c_Node17* t_parent=0;
	int t_cmp=0;
	while((t_node)!=0){
		t_parent=t_node;
		t_cmp=p_Compare(t_key,t_node->m_key);
		if(t_cmp>0){
			t_node=t_node->m_right;
		}else{
			if(t_cmp<0){
				t_node=t_node->m_left;
			}else{
				t_node->m_value=t_value;
				return false;
			}
		}
	}
	t_node=(new c_Node17)->m_new(t_key,t_value,-1,t_parent);
	if((t_parent)!=0){
		if(t_cmp>0){
			t_parent->m_right=t_node;
		}else{
			t_parent->m_left=t_node;
		}
		p_InsertFixup7(t_node);
	}else{
		m_root=t_node;
	}
	return true;
}
c_Node17* c_Map7::p_FirstNode(){
	if(!((m_root)!=0)){
		return 0;
	}
	c_Node17* t_node=m_root;
	while((t_node->m_left)!=0){
		t_node=t_node->m_left;
	}
	return t_node;
}
c_NodeEnumerator2* c_Map7::p_ObjectEnumerator(){
	return (new c_NodeEnumerator2)->m_new(p_FirstNode());
}
c_Node17* c_Map7::p_FindNode(String t_key){
	c_Node17* t_node=m_root;
	while((t_node)!=0){
		int t_cmp=p_Compare(t_key,t_node->m_key);
		if(t_cmp>0){
			t_node=t_node->m_right;
		}else{
			if(t_cmp<0){
				t_node=t_node->m_left;
			}else{
				return t_node;
			}
		}
	}
	return t_node;
}
c_Target* c_Map7::p_Get(String t_key){
	c_Node17* t_node=p_FindNode(t_key);
	if((t_node)!=0){
		return t_node->m_value;
	}
	return 0;
}
void c_Map7::mark(){
	Object::mark();
}
c_StringMap6::c_StringMap6(){
}
c_StringMap6* c_StringMap6::m_new(){
	c_Map7::m_new();
	return this;
}
int c_StringMap6::p_Compare(String t_lhs,String t_rhs){
	return t_lhs.Compare(t_rhs);
}
void c_StringMap6::mark(){
	c_Map7::mark();
}
c_Node17::c_Node17(){
	m_key=String();
	m_right=0;
	m_left=0;
	m_value=0;
	m_color=0;
	m_parent=0;
}
c_Node17* c_Node17::m_new(String t_key,c_Target* t_value,int t_color,c_Node17* t_parent){
	this->m_key=t_key;
	this->m_value=t_value;
	this->m_color=t_color;
	this->m_parent=t_parent;
	return this;
}
c_Node17* c_Node17::m_new2(){
	return this;
}
c_Node17* c_Node17::p_NextNode(){
	c_Node17* t_node=0;
	if((m_right)!=0){
		t_node=m_right;
		while((t_node->m_left)!=0){
			t_node=t_node->m_left;
		}
		return t_node;
	}
	t_node=this;
	c_Node17* t_parent=this->m_parent;
	while(((t_parent)!=0) && t_node==t_parent->m_right){
		t_node=t_parent;
		t_parent=t_parent->m_parent;
	}
	return t_parent;
}
String c_Node17::p_Key(){
	return m_key;
}
void c_Node17::mark(){
	Object::mark();
}
void bb_config_PopConfigScope(){
	bb_config__cfgScope=bb_config__cfgScopeStack->p_Pop();
}
c_NodeEnumerator2::c_NodeEnumerator2(){
	m_node=0;
}
c_NodeEnumerator2* c_NodeEnumerator2::m_new(c_Node17* t_node){
	this->m_node=t_node;
	return this;
}
c_NodeEnumerator2* c_NodeEnumerator2::m_new2(){
	return this;
}
bool c_NodeEnumerator2::p_HasNext(){
	return m_node!=0;
}
c_Node17* c_NodeEnumerator2::p_NextObject(){
	c_Node17* t_t=m_node;
	m_node=m_node->p_NextNode();
	return t_t;
}
void c_NodeEnumerator2::mark(){
	Object::mark();
}
String bb_config_ENV_HOST;
String bb_config_ENV_CONFIG;
String bb_config_ENV_TARGET;
String bb_config_ENV_LANG;
String bb_os_StripAll(String t_path){
	return bb_os_StripDir(bb_os_StripExt(t_path));
}
c_AppDecl* bb_parser_ParseApp(String t_filepath){
	bb_config__errInfo=t_filepath+String(L"<1>",3);
	c_AppDecl* t_app=(new c_AppDecl)->m_new();
	String t_modpath=bb_os_StripAll(t_filepath);
	bb_parser_ParseModule(t_modpath,t_filepath,t_app);
	return t_app;
}
c_Reflector::c_Reflector(){
	m_debug=false;
	m_refmod=0;
	m_langmod=0;
	m_boxesmod=0;
	m_munged=(new c_StringMap7)->m_new();
	m_modexprs=(new c_StringMap2)->m_new();
	m_refmods=(new c_StringSet)->m_new();
	m_classdecls=(new c_Stack9)->m_new();
	m_classids=(new c_StringMap7)->m_new();
	m_output=(new c_StringStack)->m_new2();
}
c_Reflector* c_Reflector::m_new(){
	return this;
}
bool c_Reflector::m_MatchPath(String t_text,String t_pattern){
	Array<String > t_alts=t_pattern.Split(String(L"|",1));
	Array<String > t_=t_alts;
	int t_2=0;
	while(t_2<t_.Length()){
		String t_alt=t_[t_2];
		t_2=t_2+1;
		if(!((t_alt).Length()!=0)){
			continue;
		}
		Array<String > t_bits=t_alt.Split(String(L"*",1));
		if(t_bits.Length()==1){
			if(t_bits[0]==t_text){
				return true;
			}
			continue;
		}
		if(!t_text.StartsWith(t_bits[0])){
			continue;
		}
		int t_i=t_bits[0].Length();
		for(int t_j=1;t_j<t_bits.Length()-1;t_j=t_j+1){
			String t_bit=t_bits[t_j];
			t_i=t_text.Find(t_bit,t_i);
			if(t_i==-1){
				break;
			}
			t_i+=t_bit.Length();
		}
		if(t_i!=-1 && t_text.Slice(t_i).EndsWith(t_bits[t_bits.Length()-1])){
			return true;
		}
	}
	return false;
}
String c_Reflector::p_Mung(String t_ident){
	if(m_debug){
		t_ident=String(L"R",1)+t_ident;
		t_ident=t_ident.Replace(String(L"_",1),String(L"_0",2));
		t_ident=t_ident.Replace(String(L"[",1),String(L"_1",2));
		t_ident=t_ident.Replace(String(L"]",1),String(L"_2",2));
		t_ident=t_ident.Replace(String(L"<",1),String(L"_3",2));
		t_ident=t_ident.Replace(String(L">",1),String(L"_4",2));
		t_ident=t_ident.Replace(String(L",",1),String(L"_5",2));
		t_ident=t_ident.Replace(String(L".",1),String(L"_",1));
	}else{
		t_ident=String(L"R",1);
	}
	if(m_munged->p_Contains(t_ident)){
		int t_n=m_munged->p_Get(t_ident);
		t_n+=1;
		m_munged->p_Set7(t_ident,t_n);
		t_ident=t_ident+String(t_n);
	}else{
		m_munged->p_Set7(t_ident,1);
	}
	return t_ident;
}
bool c_Reflector::p_ValidClass(c_ClassDecl* t_cdecl){
	if(t_cdecl->m_munged==String(L"Object",6)){
		return true;
	}
	if(t_cdecl->m_munged==String(L"ThrowableObject",15)){
		return true;
	}
	if(!((t_cdecl->p_ExtendsObject())!=0)){
		return false;
	}
	if(!m_refmods->p_Contains(t_cdecl->p_ModuleScope()->m_filepath)){
		return false;
	}
	Array<c_Type* > t_=t_cdecl->m_instArgs;
	int t_2=0;
	while(t_2<t_.Length()){
		c_Type* t_arg=t_[t_2];
		t_2=t_2+1;
		if(((dynamic_cast<c_ObjectType*>(t_arg))!=0) && !p_ValidClass(t_arg->p_GetClass())){
			return false;
		}
	}
	if((t_cdecl->m_superClass)!=0){
		return p_ValidClass(t_cdecl->m_superClass);
	}
	return true;
}
String c_Reflector::p_TypeExpr(c_Type* t_ty,bool t_path){
	if((dynamic_cast<c_VoidType*>(t_ty))!=0){
		return String(L"Void",4);
	}
	if((dynamic_cast<c_BoolType*>(t_ty))!=0){
		return String(L"Bool",4);
	}
	if((dynamic_cast<c_IntType*>(t_ty))!=0){
		return String(L"Int",3);
	}
	if((dynamic_cast<c_FloatType*>(t_ty))!=0){
		return String(L"Float",5);
	}
	if((dynamic_cast<c_StringType*>(t_ty))!=0){
		return String(L"String",6);
	}
	if((dynamic_cast<c_ArrayType*>(t_ty))!=0){
		return p_TypeExpr(dynamic_cast<c_ArrayType*>(t_ty)->m_elemType,t_path)+String(L"[]",2);
	}
	if((dynamic_cast<c_ObjectType*>(t_ty))!=0){
		return p_DeclExpr((t_ty->p_GetClass()),t_path);
	}
	bb_config_InternalErr(String(L"Internal error",14));
	return String();
}
String c_Reflector::p_DeclExpr(c_Decl* t_decl,bool t_path){
	if(t_path && ((dynamic_cast<c_ClassDecl*>(t_decl->m_scope))!=0)){
		return t_decl->m_ident;
	}
	c_ModuleDecl* t_mdecl=dynamic_cast<c_ModuleDecl*>(t_decl);
	if((t_mdecl)!=0){
		if(t_path){
			return t_mdecl->m_rmodpath;
		}
		String t_expr=m_modexprs->p_Get(t_mdecl->m_filepath);
		if(!((t_expr).Length()!=0)){
			bbPrint(String(L"REFLECTION ERROR",16));
			t_expr=p_Mung(t_mdecl->m_rmodpath);
			m_refmod->p_InsertDecl((new c_AliasDecl)->m_new(t_expr,0,(t_mdecl)));
			m_modexprs->p_Set2(t_mdecl->m_filepath,t_expr);
		}
		return t_expr;
	}
	c_ClassDecl* t_cdecl=dynamic_cast<c_ClassDecl*>(t_decl);
	if(((t_cdecl)!=0) && t_cdecl->m_munged==String(L"Object",6)){
		if(t_path){
			return String(L"cerberus.lang.Object",20);
		}
		return String(L"Object",6);
	}
	if(((t_cdecl)!=0) && t_cdecl->m_munged==String(L"ThrowableObject",15)){
		if(t_path){
			return String(L"cerberus.lang.Throwable",23);
		}
		return String(L"Throwable",9);
	}
	String t_ident=p_DeclExpr((t_decl->m_scope),t_path)+String(L".",1)+t_decl->m_ident;
	if(((t_cdecl)!=0) && ((t_cdecl->m_instArgs).Length()!=0)){
		String t_t=String();
		Array<c_Type* > t_=t_cdecl->m_instArgs;
		int t_2=0;
		while(t_2<t_.Length()){
			c_Type* t_arg=t_[t_2];
			t_2=t_2+1;
			if((t_t).Length()!=0){
				t_t=t_t+String(L",",1);
			}
			t_t=t_t+p_TypeExpr(t_arg,t_path);
		}
		t_ident=t_ident+(String(L"<",1)+t_t+String(L">",1));
	}
	return t_ident;
}
int c_Reflector::p_Emit(String t_t){
	m_output->p_Push(t_t);
	return 0;
}
bool c_Reflector::p_ValidType(c_Type* t_ty){
	if((dynamic_cast<c_ArrayType*>(t_ty))!=0){
		return p_ValidType(dynamic_cast<c_ArrayType*>(t_ty)->m_elemType);
	}
	if((dynamic_cast<c_ObjectType*>(t_ty))!=0){
		return p_ValidClass(t_ty->p_GetClass());
	}
	return true;
}
String c_Reflector::p_TypeInfo(c_Type* t_ty){
	if((dynamic_cast<c_VoidType*>(t_ty))!=0){
		return String(L"Null",4);
	}
	if((dynamic_cast<c_BoolType*>(t_ty))!=0){
		return String(L"_boolClass",10);
	}
	if((dynamic_cast<c_IntType*>(t_ty))!=0){
		return String(L"_intClass",9);
	}
	if((dynamic_cast<c_FloatType*>(t_ty))!=0){
		return String(L"_floatClass",11);
	}
	if((dynamic_cast<c_StringType*>(t_ty))!=0){
		return String(L"_stringClass",12);
	}
	if((dynamic_cast<c_ArrayType*>(t_ty))!=0){
		c_Type* t_elemType=dynamic_cast<c_ArrayType*>(t_ty)->m_elemType;
		String t_name=String(L"cerberus.boxes.ArrayObject<",27)+p_TypeExpr(t_elemType,true)+String(L">",1);
		if(m_classids->p_Contains(t_name)){
			return String(L"_classes[",9)+String(m_classids->p_Get(t_name))+String(L"]",1);
		}
		if(m_debug){
			bbPrint(String(L"Instantiating class: ",21)+t_name);
		}
		c_Type* t_[]={t_elemType};
		c_ClassDecl* t_cdecl=m_boxesmod->p_FindType(String(L"ArrayObject",11),Array<c_Type* >(t_,1))->p_GetClass();
		c_Enumerator3* t_2=t_cdecl->p_Decls()->p_ObjectEnumerator();
		while(t_2->p_HasNext()){
			c_Decl* t_decl=t_2->p_NextObject();
			if(!((dynamic_cast<c_AliasDecl*>(t_decl))!=0)){
				t_decl->p_Semant();
			}
		}
		int t_id=m_classdecls->p_Length2();
		m_classids->p_Set7(t_name,t_id);
		m_classdecls->p_Push25(t_cdecl);
		return String(L"_classes[",9)+String(t_id)+String(L"]",1);
	}
	if((dynamic_cast<c_ObjectType*>(t_ty))!=0){
		String t_name2=p_DeclExpr((t_ty->p_GetClass()),true);
		if(m_classids->p_Contains(t_name2)){
			return String(L"_classes[",9)+String(m_classids->p_Get(t_name2))+String(L"]",1);
		}
		return String(L"_unknownClass",13);
	}
	bb_config_InternalErr(String(L"Internal error",14));
	return String();
}
int c_Reflector::p_Attrs(c_Decl* t_decl){
	return t_decl->m_attrs>>8&255;
}
String c_Reflector::p_Box(c_Type* t_ty,String t_expr){
	if((dynamic_cast<c_VoidType*>(t_ty))!=0){
		return t_expr;
	}
	if((dynamic_cast<c_BoolType*>(t_ty))!=0){
		return String(L"New BoolObject(",15)+t_expr+String(L")",1);
	}
	if((dynamic_cast<c_IntType*>(t_ty))!=0){
		return String(L"New IntObject(",14)+t_expr+String(L")",1);
	}
	if((dynamic_cast<c_FloatType*>(t_ty))!=0){
		return String(L"New FloatObject(",16)+t_expr+String(L")",1);
	}
	if((dynamic_cast<c_StringType*>(t_ty))!=0){
		return String(L"New StringObject(",17)+t_expr+String(L")",1);
	}
	if((dynamic_cast<c_ArrayType*>(t_ty))!=0){
		return String(L"New ArrayObject<",16)+p_TypeExpr(dynamic_cast<c_ArrayType*>(t_ty)->m_elemType,false)+String(L">(",2)+t_expr+String(L")",1);
	}
	if((dynamic_cast<c_ObjectType*>(t_ty))!=0){
		return t_expr;
	}
	bb_config_InternalErr(String(L"Internal error",14));
	return String();
}
String c_Reflector::p_Emit2(c_ConstDecl* t_tdecl){
	if(!p_ValidType(t_tdecl->m_type)){
		return String();
	}
	String t_name=p_DeclExpr((t_tdecl),true);
	String t_expr=p_DeclExpr((t_tdecl),false);
	String t_type=p_TypeInfo(t_tdecl->m_type);
	return String(L"New ConstInfo(\"",15)+t_name+String(L"\",",2)+String(p_Attrs(t_tdecl))+String(L",",1)+t_type+String(L",",1)+p_Box(t_tdecl->m_type,t_expr)+String(L")",1);
}
String c_Reflector::p_Unbox(c_Type* t_ty,String t_expr){
	if((dynamic_cast<c_BoolType*>(t_ty))!=0){
		return String(L"BoolObject(",11)+t_expr+String(L").value",7);
	}
	if((dynamic_cast<c_IntType*>(t_ty))!=0){
		return String(L"IntObject(",10)+t_expr+String(L").value",7);
	}
	if((dynamic_cast<c_FloatType*>(t_ty))!=0){
		return String(L"FloatObject(",12)+t_expr+String(L").value",7);
	}
	if((dynamic_cast<c_StringType*>(t_ty))!=0){
		return String(L"StringObject(",13)+t_expr+String(L").value",7);
	}
	if((dynamic_cast<c_ArrayType*>(t_ty))!=0){
		return String(L"ArrayObject<",12)+p_TypeExpr(dynamic_cast<c_ArrayType*>(t_ty)->m_elemType,false)+String(L">(",2)+t_expr+String(L").value",7);
	}
	if((dynamic_cast<c_ObjectType*>(t_ty))!=0){
		return p_DeclExpr((t_ty->p_GetClass()),false)+String(L"(",1)+t_expr+String(L")",1);
	}
	bb_config_InternalErr(String(L"Internal error",14));
	return String();
}
String c_Reflector::p_Emit3(c_ClassDecl* t_cdecl){
	if((t_cdecl->m_args).Length()!=0){
		bb_config_InternalErr(String(L"Internal error",14));
	}
	String t_name=p_DeclExpr((t_cdecl),true);
	String t_expr=p_DeclExpr((t_cdecl),false);
	String t_ident=p_Mung(t_name);
	String t_sclass=String(L"Null",4);
	if((t_cdecl->m_superClass)!=0){
		t_sclass=p_TypeInfo(t_cdecl->m_superClass->m_objectType);
	}
	String t_ifaces=String();
	Array<c_ClassDecl* > t_=t_cdecl->m_implments;
	int t_2=0;
	while(t_2<t_.Length()){
		c_ClassDecl* t_idecl=t_[t_2];
		t_2=t_2+1;
		if((t_ifaces).Length()!=0){
			t_ifaces=t_ifaces+String(L",",1);
		}
		t_ifaces=t_ifaces+p_TypeInfo(t_idecl->m_objectType);
	}
	c_StringStack* t_consts=(new c_StringStack)->m_new2();
	c_StringStack* t_globals=(new c_StringStack)->m_new2();
	c_StringStack* t_fields=(new c_StringStack)->m_new2();
	c_StringStack* t_methods=(new c_StringStack)->m_new2();
	c_StringStack* t_functions=(new c_StringStack)->m_new2();
	c_StringStack* t_ctors=(new c_StringStack)->m_new2();
	c_Enumerator3* t_3=t_cdecl->p_Decls()->p_ObjectEnumerator();
	while(t_3->p_HasNext()){
		c_Decl* t_decl=t_3->p_NextObject();
		if((dynamic_cast<c_AliasDecl*>(t_decl))!=0){
			continue;
		}
		if(!((t_decl->p_IsSemanted())!=0)){
			continue;
		}
		c_ConstDecl* t_pdecl=dynamic_cast<c_ConstDecl*>(t_decl);
		if((t_pdecl)!=0){
			String t_p=p_Emit2(t_pdecl);
			if((t_p).Length()!=0){
				t_consts->p_Push(t_p);
			}
			continue;
		}
		c_GlobalDecl* t_gdecl=dynamic_cast<c_GlobalDecl*>(t_decl);
		if((t_gdecl)!=0){
			String t_g=p_Emit6(t_gdecl);
			if((t_g).Length()!=0){
				t_globals->p_Push(t_g);
			}
			continue;
		}
		c_FieldDecl* t_tdecl=dynamic_cast<c_FieldDecl*>(t_decl);
		if((t_tdecl)!=0){
			String t_f=p_Emit5(t_tdecl);
			if((t_f).Length()!=0){
				t_fields->p_Push(t_f);
			}
			continue;
		}
		c_FuncDecl* t_fdecl=dynamic_cast<c_FuncDecl*>(t_decl);
		if((t_fdecl)!=0){
			String t_f2=p_Emit4(t_fdecl);
			if((t_f2).Length()!=0){
				if(t_fdecl->p_IsCtor()){
					t_ctors->p_Push(t_f2);
				}else{
					if(t_fdecl->p_IsMethod()){
						t_methods->p_Push(t_f2);
					}else{
						t_functions->p_Push(t_f2);
					}
				}
			}
			continue;
		}
	}
	p_Emit(String(L"Class ",6)+t_ident+String(L" Extends ClassInfo",18));
	p_Emit(String(L" Method New()",13));
	p_Emit(String(L"  Super.New(\"",13)+t_name+String(L"\",",2)+String(p_Attrs(t_cdecl))+String(L",",1)+t_sclass+String(L",[",2)+t_ifaces+String(L"])",2));
	String t_1=t_name;
	if(t_1==String(L"cerberus.boxes.BoolObject",25)){
		p_Emit(String(L"  _boolClass=Self",17));
	}else{
		if(t_1==String(L"cerberus.boxes.IntObject",24)){
			p_Emit(String(L"  _intClass=Self",16));
		}else{
			if(t_1==String(L"cerberus.boxes.FloatObject",26)){
				p_Emit(String(L"  _floatClass=Self",18));
			}else{
				if(t_1==String(L"cerberus.boxes.StringObject",27)){
					p_Emit(String(L"  _stringClass=Self",19));
				}
			}
		}
	}
	p_Emit(String(L" End",4));
	if(t_name.StartsWith(String(L"cerberus.boxes.ArrayObject<",27))){
		c_Type* t_elemType=t_cdecl->m_instArgs[0];
		String t_elemExpr=p_TypeExpr(t_elemType,false);
		int t_i=t_elemExpr.Find(String(L"[]",2),0);
		if(t_i==-1){
			t_i=t_elemExpr.Length();
		}
		String t_ARRAY_PREFIX=m_modexprs->p_Get(m_boxesmod->m_filepath)+String(L".ArrayObject<",13);
		p_Emit(String(L" Method ElementType:ClassInfo() Property",40));
		p_Emit(String(L"  Return ",9)+p_TypeInfo(t_elemType));
		p_Emit(String(L" End",4));
		p_Emit(String(L" Method ArrayLength:Int(i:Object) Property",42));
		p_Emit(String(L"  Return ",9)+t_ARRAY_PREFIX+t_elemExpr+String(L">(i).value.Length",17));
		p_Emit(String(L" End",4));
		p_Emit(String(L" Method GetElement:Object(i:Object,e)",37));
		p_Emit(String(L"  Return ",9)+p_Box(t_elemType,t_ARRAY_PREFIX+t_elemExpr+String(L">(i).value[e]",13)));
		p_Emit(String(L" End",4));
		p_Emit(String(L" Method SetElement:Void(i:Object,e,v:Object)",44));
		p_Emit(String(L"  ",2)+t_ARRAY_PREFIX+t_elemExpr+String(L">(i).value[e]=",14)+p_Unbox(t_elemType,String(L"v",1)));
		p_Emit(String(L" End",4));
		p_Emit(String(L" Method NewArray:Object(l:Int)",30));
		p_Emit(String(L"  Return ",9)+p_Box((t_elemType->p_ArrayOf()),String(L"New ",4)+t_elemExpr.Slice(0,t_i)+String(L"[l]",3)+t_elemExpr.Slice(t_i)));
		p_Emit(String(L" End",4));
	}
	if(!((t_cdecl->p_IsAbstract())!=0) && !((t_cdecl->p_IsExtern())!=0)){
		p_Emit(String(L" Method NewInstance:Object()",28));
		p_Emit(String(L"  Return New ",13)+t_expr);
		p_Emit(String(L" End",4));
	}
	p_Emit(String(L" Method Init()",14));
	if((t_consts->p_Length2())!=0){
		p_Emit(String(L"  _consts=new ConstInfo[",24)+String(t_consts->p_Length2())+String(L"]",1));
		for(int t_i2=0;t_i2<t_consts->p_Length2();t_i2=t_i2+1){
			p_Emit(String(L"  _consts[",10)+String(t_i2)+String(L"]=",2)+t_consts->p_Get2(t_i2));
		}
	}
	if((t_globals->p_Length2())!=0){
		p_Emit(String(L"  _globals=new GlobalInfo[",26)+String(t_globals->p_Length2())+String(L"]",1));
		for(int t_i3=0;t_i3<t_globals->p_Length2();t_i3=t_i3+1){
			p_Emit(String(L"  _globals[",11)+String(t_i3)+String(L"]=New ",6)+t_globals->p_Get2(t_i3));
		}
	}
	if((t_fields->p_Length2())!=0){
		p_Emit(String(L"  _fields=New FieldInfo[",24)+String(t_fields->p_Length2())+String(L"]",1));
		for(int t_i4=0;t_i4<t_fields->p_Length2();t_i4=t_i4+1){
			p_Emit(String(L"  _fields[",10)+String(t_i4)+String(L"]=New ",6)+t_fields->p_Get2(t_i4));
		}
	}
	if((t_methods->p_Length2())!=0){
		p_Emit(String(L"  _methods=New MethodInfo[",26)+String(t_methods->p_Length2())+String(L"]",1));
		for(int t_i5=0;t_i5<t_methods->p_Length2();t_i5=t_i5+1){
			p_Emit(String(L"  _methods[",11)+String(t_i5)+String(L"]=New ",6)+t_methods->p_Get2(t_i5));
		}
	}
	if((t_functions->p_Length2())!=0){
		p_Emit(String(L"  _functions=New FunctionInfo[",30)+String(t_functions->p_Length2())+String(L"]",1));
		for(int t_i6=0;t_i6<t_functions->p_Length2();t_i6=t_i6+1){
			p_Emit(String(L"  _functions[",13)+String(t_i6)+String(L"]=New ",6)+t_functions->p_Get2(t_i6));
		}
	}
	if((t_ctors->p_Length2())!=0){
		p_Emit(String(L"  _ctors=New FunctionInfo[",26)+String(t_ctors->p_Length2())+String(L"]",1));
		for(int t_i7=0;t_i7<t_ctors->p_Length2();t_i7=t_i7+1){
			p_Emit(String(L"  _ctors[",9)+String(t_i7)+String(L"]=New ",6)+t_ctors->p_Get2(t_i7));
		}
	}
	p_Emit(String(L" InitR()",8));
	p_Emit(String(L" End",4));
	p_Emit(String(L"End",3));
	return t_ident;
}
String c_Reflector::p_Emit4(c_FuncDecl* t_fdecl){
	if(!p_ValidType(t_fdecl->m_retType)){
		return String();
	}
	Array<c_ArgDecl* > t_=t_fdecl->m_argDecls;
	int t_2=0;
	while(t_2<t_.Length()){
		c_ArgDecl* t_arg=t_[t_2];
		t_2=t_2+1;
		if(!p_ValidType(t_arg->m_type)){
			return String();
		}
	}
	String t_name=p_DeclExpr((t_fdecl),true);
	String t_expr=p_DeclExpr((t_fdecl),false);
	String t_ident=p_Mung(t_name);
	String t_rtype=p_TypeInfo(t_fdecl->m_retType);
	String t_base=String(L"FunctionInfo",12);
	if(t_fdecl->p_IsMethod()){
		String t_clas=p_DeclExpr((t_fdecl->p_ClassScope()),false);
		t_expr=t_clas+String(L"(i).",4)+t_fdecl->m_ident;
		t_base=String(L"MethodInfo",10);
	}
	Array<String > t_argtys=Array<String >(t_fdecl->m_argDecls.Length());
	for(int t_i=0;t_i<t_argtys.Length();t_i=t_i+1){
		t_argtys[t_i]=p_TypeInfo(t_fdecl->m_argDecls[t_i]->m_type);
	}
	p_Emit(String(L"Class ",6)+t_ident+String(L" Extends ",9)+t_base);
	p_Emit(String(L" Method New()",13));
	p_Emit(String(L"  Super.New(\"",13)+t_name+String(L"\",",2)+String(p_Attrs(t_fdecl))+String(L",",1)+t_rtype+String(L",[",2)+String(L",",1).Join(t_argtys)+String(L"])",2));
	p_Emit(String(L" End",4));
	if(t_fdecl->p_IsMethod()){
		p_Emit(String(L" Method Invoke:Object(i:Object,p:Object[])",42));
	}else{
		p_Emit(String(L" Method Invoke:Object(p:Object[])",33));
	}
	c_StringStack* t_args=(new c_StringStack)->m_new2();
	for(int t_i2=0;t_i2<t_fdecl->m_argDecls.Length();t_i2=t_i2+1){
		c_ArgDecl* t_arg2=t_fdecl->m_argDecls[t_i2];
		t_args->p_Push(p_Unbox(t_arg2->m_type,String(L"p[",2)+String(t_i2)+String(L"]",1)));
	}
	if(t_fdecl->p_IsCtor()){
		c_ClassDecl* t_cdecl=t_fdecl->p_ClassScope();
		if((t_cdecl->p_IsAbstract())!=0){
			p_Emit(String(L"  Return Null",13));
		}else{
			p_Emit(String(L"  Return New ",13)+p_DeclExpr((t_cdecl),false)+String(L"(",1)+t_args->p_Join(String(L",",1))+String(L")",1));
		}
	}else{
		if((dynamic_cast<c_VoidType*>(t_fdecl->m_retType))!=0){
			p_Emit(String(L"  ",2)+t_expr+String(L"(",1)+t_args->p_Join(String(L",",1))+String(L")",1));
		}else{
			p_Emit(String(L"  Return ",9)+p_Box(t_fdecl->m_retType,t_expr+String(L"(",1)+t_args->p_Join(String(L",",1))+String(L")",1)));
		}
	}
	p_Emit(String(L" End",4));
	p_Emit(String(L"End",3));
	return t_ident;
}
String c_Reflector::p_Emit5(c_FieldDecl* t_tdecl){
	if(!p_ValidType(t_tdecl->m_type)){
		return String();
	}
	String t_name=t_tdecl->m_ident;
	String t_ident=p_Mung(t_name);
	String t_type=p_TypeInfo(t_tdecl->m_type);
	String t_clas=p_DeclExpr((t_tdecl->p_ClassScope()),false);
	String t_expr=t_clas+String(L"(i).",4)+t_tdecl->m_ident;
	p_Emit(String(L"Class ",6)+t_ident+String(L" Extends FieldInfo",18));
	p_Emit(String(L" Method New()",13));
	p_Emit(String(L"  Super.New(\"",13)+t_name+String(L"\",",2)+String(p_Attrs(t_tdecl))+String(L",",1)+t_type+String(L")",1));
	p_Emit(String(L" End",4));
	p_Emit(String(L" Method GetValue:Object(i:Object)",33));
	p_Emit(String(L"  Return ",9)+p_Box(t_tdecl->m_type,t_expr));
	p_Emit(String(L" End",4));
	p_Emit(String(L" Method SetValue:Void(i:Object,v:Object)",40));
	p_Emit(String(L"  ",2)+t_expr+String(L"=",1)+p_Unbox(t_tdecl->m_type,String(L"v",1)));
	p_Emit(String(L" End",4));
	p_Emit(String(L"End",3));
	return t_ident;
}
String c_Reflector::p_Emit6(c_GlobalDecl* t_gdecl){
	if(!p_ValidType(t_gdecl->m_type)){
		return String();
	}
	String t_name=p_DeclExpr((t_gdecl),true);
	String t_expr=p_DeclExpr((t_gdecl),false);
	String t_ident=p_Mung(t_name);
	String t_type=p_TypeInfo(t_gdecl->m_type);
	p_Emit(String(L"Class ",6)+t_ident+String(L" Extends GlobalInfo",19));
	p_Emit(String(L" Method New()",13));
	p_Emit(String(L"  Super.New(\"",13)+t_name+String(L"\",",2)+String(p_Attrs(t_gdecl))+String(L",",1)+t_type+String(L")",1));
	p_Emit(String(L" End",4));
	p_Emit(String(L" Method GetValue:Object()",25));
	p_Emit(String(L"  Return ",9)+p_Box(t_gdecl->m_type,t_expr));
	p_Emit(String(L" End",4));
	p_Emit(String(L" Method SetValue:Void(v:Object)",31));
	p_Emit(String(L"  ",2)+t_expr+String(L"=",1)+p_Unbox(t_gdecl->m_type,String(L"v",1)));
	p_Emit(String(L" End",4));
	p_Emit(String(L"End",3));
	return t_ident;
}
int c_Reflector::p_Semant3(c_AppDecl* t_app){
	String t_filter=bb_config_GetConfigVar(String(L"REFLECTION_FILTER",17));
	if(!((t_filter).Length()!=0)){
		return 0;
	}
	t_filter=t_filter.Replace(String(L";",1),String(L"|",1));
	m_debug=bb_config_GetConfigVar(String(L"DEBUG_REFLECTION",16))==String(L"1",1);
	c_ValueEnumerator* t_=t_app->m_imported->p_Values()->p_ObjectEnumerator();
	while(t_->p_HasNext()){
		c_ModuleDecl* t_mdecl=t_->p_NextObject();
		String t_path=t_mdecl->m_rmodpath;
		if(t_path==String(L"reflection",10)){
			m_refmod=t_mdecl;
		}else{
			if(t_path==String(L"cerberus.lang",13)){
				m_langmod=t_mdecl;
			}else{
				if(t_path==String(L"cerberus.boxes",14)){
					m_boxesmod=t_mdecl;
				}
			}
		}
	}
	if(!((m_refmod)!=0)){
		bbError(String(L"reflection module not found!",28));
	}
	if(m_debug){
		bbPrint(String(L"Semanting all",13));
	}
	c_ValueEnumerator* t_2=t_app->m_imported->p_Values()->p_ObjectEnumerator();
	while(t_2->p_HasNext()){
		c_ModuleDecl* t_mdecl2=t_2->p_NextObject();
		String t_path2=t_mdecl2->m_rmodpath;
		if(t_mdecl2!=m_boxesmod && t_mdecl2!=m_langmod && !m_MatchPath(t_path2,t_filter)){
			continue;
		}
		String t_expr=p_Mung(t_path2);
		m_refmod->p_InsertDecl((new c_AliasDecl)->m_new(t_expr,0,(t_mdecl2)));
		m_modexprs->p_Set2(t_mdecl2->m_filepath,t_expr);
		m_refmods->p_Insert(t_mdecl2->m_filepath);
		t_mdecl2->p_SemantAll();
	}
	do{
		int t_n=t_app->m_allSemantedDecls->p_Count();
		c_ValueEnumerator* t_3=t_app->m_imported->p_Values()->p_ObjectEnumerator();
		while(t_3->p_HasNext()){
			c_ModuleDecl* t_mdecl3=t_3->p_NextObject();
			if(!m_refmods->p_Contains(t_mdecl3->m_filepath)){
				continue;
			}
			t_mdecl3->p_SemantAll();
		}
		t_n=t_app->m_allSemantedDecls->p_Count()-t_n;
		if(!((t_n)!=0)){
			break;
		}
		if(m_debug){
			bbPrint(String(L"Semanting more: ",16)+String(t_n));
		}
	}while(!(false));
	c_Enumerator3* t_4=t_app->m_allSemantedDecls->p_ObjectEnumerator();
	while(t_4->p_HasNext()){
		c_Decl* t_decl=t_4->p_NextObject();
		if(!m_refmods->p_Contains(t_decl->p_ModuleScope()->m_filepath)){
			continue;
		}
		c_ClassDecl* t_cdecl=dynamic_cast<c_ClassDecl*>(t_decl);
		if(((t_cdecl)!=0) && p_ValidClass(t_cdecl)){
			m_classids->p_Set7(p_DeclExpr((t_cdecl),true),m_classdecls->p_Length2());
			m_classdecls->p_Push25(t_cdecl);
			continue;
		}
	}
	c_StringStack* t_classes=(new c_StringStack)->m_new2();
	c_StringStack* t_consts=(new c_StringStack)->m_new2();
	c_StringStack* t_globals=(new c_StringStack)->m_new2();
	c_StringStack* t_functions=(new c_StringStack)->m_new2();
	if(m_debug){
		bbPrint(String(L"Generating reflection info",26));
	}
	c_Enumerator3* t_5=t_app->m_allSemantedDecls->p_ObjectEnumerator();
	while(t_5->p_HasNext()){
		c_Decl* t_decl2=t_5->p_NextObject();
		if(!m_refmods->p_Contains(t_decl2->p_ModuleScope()->m_filepath)){
			continue;
		}
		c_ConstDecl* t_pdecl=dynamic_cast<c_ConstDecl*>(t_decl2);
		if((t_pdecl)!=0){
			String t_p=p_Emit2(t_pdecl);
			if((t_p).Length()!=0){
				t_consts->p_Push(t_p);
			}
			continue;
		}
		c_GlobalDecl* t_gdecl=dynamic_cast<c_GlobalDecl*>(t_decl2);
		if((t_gdecl)!=0){
			String t_g=p_Emit6(t_gdecl);
			if((t_g).Length()!=0){
				t_globals->p_Push(t_g);
			}
			continue;
		}
		c_FuncDecl* t_fdecl=dynamic_cast<c_FuncDecl*>(t_decl2);
		if((t_fdecl)!=0){
			String t_f=p_Emit4(t_fdecl);
			if((t_f).Length()!=0){
				t_functions->p_Push(t_f);
			}
			continue;
		}
	}
	if(m_debug){
		bbPrint(String(L"Finalizing classes",18));
	}
	t_app->p_FinalizeClasses();
	if(m_debug){
		bbPrint(String(L"Generating class reflection info",32));
	}
	for(int t_i=0;t_i<m_classdecls->p_Length2();t_i=t_i+1){
		t_classes->p_Push(p_Emit3(m_classdecls->p_Get2(t_i)));
	}
	p_Emit(String(L"Global _init:=__init()",22));
	p_Emit(String(L"Function __init()",17));
	if((t_classes->p_Length2())!=0){
		p_Emit(String(L" _classes=New ClassInfo[",24)+String(t_classes->p_Length2())+String(L"]",1));
		for(int t_i2=0;t_i2<t_classes->p_Length2();t_i2=t_i2+1){
			p_Emit(String(L" _classes[",10)+String(t_i2)+String(L"]=New ",6)+t_classes->p_Get2(t_i2));
		}
		for(int t_i3=0;t_i3<t_classes->p_Length2();t_i3=t_i3+1){
			p_Emit(String(L" _classes[",10)+String(t_i3)+String(L"].Init()",8));
		}
	}
	if((t_consts->p_Length2())!=0){
		p_Emit(String(L" _consts=new ConstInfo[",23)+String(t_consts->p_Length2())+String(L"]",1));
		for(int t_i4=0;t_i4<t_consts->p_Length2();t_i4=t_i4+1){
			p_Emit(String(L" _consts[",9)+String(t_i4)+String(L"]=",2)+t_consts->p_Get2(t_i4));
		}
	}
	if((t_globals->p_Length2())!=0){
		p_Emit(String(L" _globals=New GlobalInfo[",25)+String(t_globals->p_Length2())+String(L"]",1));
		for(int t_i5=0;t_i5<t_globals->p_Length2();t_i5=t_i5+1){
			p_Emit(String(L" _globals[",10)+String(t_i5)+String(L"]=New ",6)+t_globals->p_Get2(t_i5));
		}
	}
	if((t_functions->p_Length2())!=0){
		p_Emit(String(L" _functions=New FunctionInfo[",29)+String(t_functions->p_Length2())+String(L"]",1));
		for(int t_i6=0;t_i6<t_functions->p_Length2();t_i6=t_i6+1){
			p_Emit(String(L" _functions[",12)+String(t_i6)+String(L"]=New ",6)+t_functions->p_Get2(t_i6));
		}
	}
	p_Emit(String(L" _getClass=New __GetClass",25));
	p_Emit(String(L"End",3));
	p_Emit(String(L"Class __GetClass Extends _GetClass",34));
	p_Emit(String(L" Method GetClass:ClassInfo(o:Object)",36));
	for(int t_i7=t_classes->p_Length2()-1;t_i7>=0;t_i7=t_i7+-1){
		String t_expr2=p_DeclExpr((m_classdecls->p_Get2(t_i7)),false);
		p_Emit(String(L"  If ",5)+t_expr2+String(L"(o)<>Null Return _classes[",26)+String(t_i7)+String(L"]",1));
	}
	p_Emit(String(L"  Return _unknownClass",22));
	p_Emit(String(L" End",4));
	p_Emit(String(L"End",3));
	String t_source=m_output->p_Join(String(L"\n",1))+String(L"\n",1);
	int t_attrs=8388608;
	if(m_debug){
		bbPrint(String(L"Reflection source:\n",19)+t_source);
	}else{
		t_attrs|=4194304;
	}
	bb_parser_ParseSource(t_source,t_app,m_refmod,t_attrs);
	m_refmod->p_FindValDecl(String(L"_init",5));
	t_app->p_Semant();
	return 0;
}
void c_Reflector::mark(){
	Object::mark();
}
c_MapValues::c_MapValues(){
	m_map=0;
}
c_MapValues* c_MapValues::m_new(c_Map5* t_map){
	this->m_map=t_map;
	return this;
}
c_MapValues* c_MapValues::m_new2(){
	return this;
}
c_ValueEnumerator* c_MapValues::p_ObjectEnumerator(){
	return (new c_ValueEnumerator)->m_new(m_map->p_FirstNode());
}
void c_MapValues::mark(){
	Object::mark();
}
c_ValueEnumerator::c_ValueEnumerator(){
	m_node=0;
}
c_ValueEnumerator* c_ValueEnumerator::m_new(c_Node7* t_node){
	this->m_node=t_node;
	return this;
}
c_ValueEnumerator* c_ValueEnumerator::m_new2(){
	return this;
}
bool c_ValueEnumerator::p_HasNext(){
	return m_node!=0;
}
c_ModuleDecl* c_ValueEnumerator::p_NextObject(){
	c_Node7* t_t=m_node;
	m_node=m_node->p_NextNode();
	return t_t->m_value;
}
void c_ValueEnumerator::mark(){
	Object::mark();
}
c_Map8::c_Map8(){
	m_root=0;
}
c_Map8* c_Map8::m_new(){
	return this;
}
c_Node18* c_Map8::p_FindNode(String t_key){
	c_Node18* t_node=m_root;
	while((t_node)!=0){
		int t_cmp=p_Compare(t_key,t_node->m_key);
		if(t_cmp>0){
			t_node=t_node->m_right;
		}else{
			if(t_cmp<0){
				t_node=t_node->m_left;
			}else{
				return t_node;
			}
		}
	}
	return t_node;
}
bool c_Map8::p_Contains(String t_key){
	return p_FindNode(t_key)!=0;
}
int c_Map8::p_Get(String t_key){
	c_Node18* t_node=p_FindNode(t_key);
	if((t_node)!=0){
		return t_node->m_value;
	}
	return 0;
}
int c_Map8::p_RotateLeft8(c_Node18* t_node){
	c_Node18* t_child=t_node->m_right;
	t_node->m_right=t_child->m_left;
	if((t_child->m_left)!=0){
		t_child->m_left->m_parent=t_node;
	}
	t_child->m_parent=t_node->m_parent;
	if((t_node->m_parent)!=0){
		if(t_node==t_node->m_parent->m_left){
			t_node->m_parent->m_left=t_child;
		}else{
			t_node->m_parent->m_right=t_child;
		}
	}else{
		m_root=t_child;
	}
	t_child->m_left=t_node;
	t_node->m_parent=t_child;
	return 0;
}
int c_Map8::p_RotateRight8(c_Node18* t_node){
	c_Node18* t_child=t_node->m_left;
	t_node->m_left=t_child->m_right;
	if((t_child->m_right)!=0){
		t_child->m_right->m_parent=t_node;
	}
	t_child->m_parent=t_node->m_parent;
	if((t_node->m_parent)!=0){
		if(t_node==t_node->m_parent->m_right){
			t_node->m_parent->m_right=t_child;
		}else{
			t_node->m_parent->m_left=t_child;
		}
	}else{
		m_root=t_child;
	}
	t_child->m_right=t_node;
	t_node->m_parent=t_child;
	return 0;
}
int c_Map8::p_InsertFixup8(c_Node18* t_node){
	while(((t_node->m_parent)!=0) && t_node->m_parent->m_color==-1 && ((t_node->m_parent->m_parent)!=0)){
		if(t_node->m_parent==t_node->m_parent->m_parent->m_left){
			c_Node18* t_uncle=t_node->m_parent->m_parent->m_right;
			if(((t_uncle)!=0) && t_uncle->m_color==-1){
				t_node->m_parent->m_color=1;
				t_uncle->m_color=1;
				t_uncle->m_parent->m_color=-1;
				t_node=t_uncle->m_parent;
			}else{
				if(t_node==t_node->m_parent->m_right){
					t_node=t_node->m_parent;
					p_RotateLeft8(t_node);
				}
				t_node->m_parent->m_color=1;
				t_node->m_parent->m_parent->m_color=-1;
				p_RotateRight8(t_node->m_parent->m_parent);
			}
		}else{
			c_Node18* t_uncle2=t_node->m_parent->m_parent->m_left;
			if(((t_uncle2)!=0) && t_uncle2->m_color==-1){
				t_node->m_parent->m_color=1;
				t_uncle2->m_color=1;
				t_uncle2->m_parent->m_color=-1;
				t_node=t_uncle2->m_parent;
			}else{
				if(t_node==t_node->m_parent->m_left){
					t_node=t_node->m_parent;
					p_RotateRight8(t_node);
				}
				t_node->m_parent->m_color=1;
				t_node->m_parent->m_parent->m_color=-1;
				p_RotateLeft8(t_node->m_parent->m_parent);
			}
		}
	}
	m_root->m_color=1;
	return 0;
}
bool c_Map8::p_Set7(String t_key,int t_value){
	c_Node18* t_node=m_root;
	c_Node18* t_parent=0;
	int t_cmp=0;
	while((t_node)!=0){
		t_parent=t_node;
		t_cmp=p_Compare(t_key,t_node->m_key);
		if(t_cmp>0){
			t_node=t_node->m_right;
		}else{
			if(t_cmp<0){
				t_node=t_node->m_left;
			}else{
				t_node->m_value=t_value;
				return false;
			}
		}
	}
	t_node=(new c_Node18)->m_new(t_key,t_value,-1,t_parent);
	if((t_parent)!=0){
		if(t_cmp>0){
			t_parent->m_right=t_node;
		}else{
			t_parent->m_left=t_node;
		}
		p_InsertFixup8(t_node);
	}else{
		m_root=t_node;
	}
	return true;
}
void c_Map8::mark(){
	Object::mark();
}
c_StringMap7::c_StringMap7(){
}
c_StringMap7* c_StringMap7::m_new(){
	c_Map8::m_new();
	return this;
}
int c_StringMap7::p_Compare(String t_lhs,String t_rhs){
	return t_lhs.Compare(t_rhs);
}
void c_StringMap7::mark(){
	c_Map8::mark();
}
c_Node18::c_Node18(){
	m_key=String();
	m_right=0;
	m_left=0;
	m_value=0;
	m_color=0;
	m_parent=0;
}
c_Node18* c_Node18::m_new(String t_key,int t_value,int t_color,c_Node18* t_parent){
	this->m_key=t_key;
	this->m_value=t_value;
	this->m_color=t_color;
	this->m_parent=t_parent;
	return this;
}
c_Node18* c_Node18::m_new2(){
	return this;
}
void c_Node18::mark(){
	Object::mark();
}
c_Enumerator5::c_Enumerator5(){
	m__list=0;
	m__curr=0;
}
c_Enumerator5* c_Enumerator5::m_new(c_List8* t_list){
	m__list=t_list;
	m__curr=t_list->m__head->m__succ;
	return this;
}
c_Enumerator5* c_Enumerator5::m_new2(){
	return this;
}
bool c_Enumerator5::p_HasNext(){
	while(m__curr->m__succ->m__pred!=m__curr){
		m__curr=m__curr->m__succ;
	}
	return m__curr!=m__list->m__head;
}
c_ClassDecl* c_Enumerator5::p_NextObject(){
	c_ClassDecl* t_data=m__curr->m__data;
	m__curr=m__curr->m__succ;
	return t_data;
}
void c_Enumerator5::mark(){
	Object::mark();
}
c_Stack9::c_Stack9(){
	m_data=Array<c_ClassDecl* >();
	m_length=0;
}
c_Stack9* c_Stack9::m_new(){
	return this;
}
c_Stack9* c_Stack9::m_new2(Array<c_ClassDecl* > t_data){
	this->m_data=t_data.Slice(0);
	this->m_length=t_data.Length();
	return this;
}
c_ClassDecl* c_Stack9::m_NIL;
void c_Stack9::p_Length(int t_newlength){
	if(t_newlength<m_length){
		for(int t_i=t_newlength;t_i<m_length;t_i=t_i+1){
			m_data[t_i]=m_NIL;
		}
	}else{
		if(t_newlength>m_data.Length()){
			m_data=m_data.Resize(bb_math_Max(m_length*2+10,t_newlength));
		}
	}
	m_length=t_newlength;
}
int c_Stack9::p_Length2(){
	return m_length;
}
void c_Stack9::p_Push25(c_ClassDecl* t_value){
	if(m_length==m_data.Length()){
		m_data=m_data.Resize(m_length*2+10);
	}
	m_data[m_length]=t_value;
	m_length+=1;
}
void c_Stack9::p_Push26(Array<c_ClassDecl* > t_values,int t_offset,int t_count){
	for(int t_i=0;t_i<t_count;t_i=t_i+1){
		p_Push25(t_values[t_offset+t_i]);
	}
}
void c_Stack9::p_Push27(Array<c_ClassDecl* > t_values,int t_offset){
	p_Push26(t_values,t_offset,t_values.Length()-t_offset);
}
c_ClassDecl* c_Stack9::p_Get2(int t_index){
	return m_data[t_index];
}
void c_Stack9::mark(){
	Object::mark();
}
int bb_parser_ParseSource(String t_source,c_AppDecl* t_app,c_ModuleDecl* t_mdecl,int t_defattrs){
	c_Toker* t_toker=(new c_Toker)->m_new(String(L"$SOURCE",7),t_source);
	c_Parser* t_parser=(new c_Parser)->m_new(t_toker,t_app,t_mdecl,t_defattrs);
	t_parser->p_ParseMain();
	return 0;
}
c_Translator::c_Translator(){
}
c_Translator* c_Translator::m_new(){
	return this;
}
void c_Translator::mark(){
	Object::mark();
}
c_Translator* bb_translator__trans;
int bb_os_DeleteDir(String t_path,bool t_recursive){
	if(!t_recursive){
		return DeleteDir(t_path);
	}
	int t_4=FileType(t_path);
	if(t_4==0){
		return 1;
	}else{
		if(t_4==1){
			return 0;
		}
	}
	Array<String > t_=LoadDir(t_path);
	int t_2=0;
	while(t_2<t_.Length()){
		String t_f=t_[t_2];
		t_2=t_2+1;
		if(t_f==String(L".",1) || t_f==String(L"..",2)){
			continue;
		}
		String t_fpath=t_path+String(L"/",1)+t_f;
		if(FileType(t_fpath)==2){
			if(!((bb_os_DeleteDir(t_fpath,true))!=0)){
				return 0;
			}
		}else{
			if(!((DeleteFile(t_fpath))!=0)){
				return 0;
			}
		}
	}
	return DeleteDir(t_path);
}
int bb_os_CopyDir(String t_srcpath,String t_dstpath,bool t_recursive,bool t_hidden){
	if(FileType(t_srcpath)!=2){
		return 0;
	}
	Array<String > t_files=LoadDir(t_srcpath);
	int t_2=FileType(t_dstpath);
	if(t_2==0){
		if(!((CreateDir(t_dstpath))!=0)){
			return 0;
		}
	}else{
		if(t_2==1){
			return 0;
		}
	}
	Array<String > t_=t_files;
	int t_3=0;
	while(t_3<t_.Length()){
		String t_f=t_[t_3];
		t_3=t_3+1;
		if(!t_hidden && t_f.StartsWith(String(L".",1))){
			continue;
		}
		String t_srcp=t_srcpath+String(L"/",1)+t_f;
		String t_dstp=t_dstpath+String(L"/",1)+t_f;
		int t_32=FileType(t_srcp);
		if(t_32==1){
			if(!((CopyFile(t_srcp,t_dstp))!=0)){
				return 0;
			}
		}else{
			if(t_32==2){
				if(t_recursive && !((bb_os_CopyDir(t_srcp,t_dstp,t_recursive,t_hidden))!=0)){
					return 0;
				}
			}
		}
	}
	return 1;
}
int bbMain(){
	c_TransCC* t_tcc=(new c_TransCC)->m_new();
	t_tcc->p_Run(AppArgs());
	return 0;
}
c_CTranslator::c_CTranslator(){
	m_funcMungs=(new c_StringMap8)->m_new();
	m_mungedFuncs=(new c_StringMap9)->m_new();
	m_mungedScopes=(new c_StringMap10)->m_new();
	m_indent=String();
	m_lines=(new c_StringStack)->m_new2();
	m_emitDebugInfo=false;
	m_unreachable=0;
	m_broken=0;
}
c_CTranslator* c_CTranslator::m_new(){
	c_Translator::m_new();
	return this;
}
int c_CTranslator::p_MungMethodDecl(c_FuncDecl* t_fdecl){
	if((t_fdecl->m_munged).Length()!=0){
		return 0;
	}
	if((t_fdecl->m_overrides)!=0){
		p_MungMethodDecl(t_fdecl->m_overrides);
		t_fdecl->m_munged=t_fdecl->m_overrides->m_munged;
		return 0;
	}
	c_FuncDeclList* t_funcs=m_funcMungs->p_Get(t_fdecl->m_ident);
	if((t_funcs)!=0){
		c_Enumerator4* t_=t_funcs->p_ObjectEnumerator();
		while(t_->p_HasNext()){
			c_FuncDecl* t_tdecl=t_->p_NextObject();
			if(t_fdecl->p_EqualsArgs(t_tdecl)){
				t_fdecl->m_munged=t_tdecl->m_munged;
				return 0;
			}
		}
	}else{
		t_funcs=(new c_FuncDeclList)->m_new();
		m_funcMungs->p_Set8(t_fdecl->m_ident,t_funcs);
	}
	String t_id=t_fdecl->m_ident;
	if(m_mungedFuncs->p_Contains(t_id)){
		int t_n=1;
		do{
			t_n+=1;
			t_id=t_fdecl->m_ident+String(t_n);
		}while(!(!m_mungedFuncs->p_Contains(t_id)));
	}
	m_mungedFuncs->p_Set9(t_id,t_fdecl);
	t_fdecl->m_munged=String(L"p_",2)+t_id;
	t_funcs->p_AddLast6(t_fdecl);
	return 0;
}
int c_CTranslator::p_MungDecl(c_Decl* t_decl){
	if((t_decl->m_munged).Length()!=0){
		return 0;
	}
	c_FuncDecl* t_fdecl=dynamic_cast<c_FuncDecl*>(t_decl);
	if(((t_fdecl)!=0) && t_fdecl->p_IsMethod()){
		return p_MungMethodDecl(t_fdecl);
	}
	String t_id=t_decl->m_ident;
	String t_munged=String();
	String t_scope=String();
	if((dynamic_cast<c_LocalDecl*>(t_decl))!=0){
		t_scope=String(L"$",1);
		t_munged=String(L"t_",2)+t_id;
	}else{
		if((dynamic_cast<c_ClassDecl*>(t_decl))!=0){
			t_scope=String();
			t_munged=String(L"c_",2)+t_id;
		}else{
			if((dynamic_cast<c_ModuleDecl*>(t_decl))!=0){
				t_scope=String();
				t_munged=String(L"bb_",3)+t_id;
			}else{
				if((dynamic_cast<c_ClassDecl*>(t_decl->m_scope))!=0){
					t_scope=t_decl->m_scope->m_munged;
					t_munged=String(L"m_",2)+t_id;
				}else{
					if((dynamic_cast<c_ModuleDecl*>(t_decl->m_scope))!=0){
						if(bb_config_ENV_LANG==String(L"cs",2) || bb_config_ENV_LANG==String(L"java",4)){
							t_scope=t_decl->m_scope->m_munged;
							t_munged=String(L"g_",2)+t_id;
						}else{
							t_scope=String();
							t_munged=t_decl->m_scope->m_munged+String(L"_",1)+t_id;
						}
					}else{
						bb_config_InternalErr(String(L"Internal error",14));
					}
				}
			}
		}
	}
	c_StringSet* t_set=m_mungedScopes->p_Get(t_scope);
	if((t_set)!=0){
		if(t_set->p_Contains(t_munged.ToLower())){
			int t_id2=1;
			do{
				t_id2+=1;
				String t_t=t_munged+String(t_id2);
				if(t_set->p_Contains(t_t.ToLower())){
					continue;
				}
				t_munged=t_t;
				break;
			}while(!(false));
		}
	}else{
		if(t_scope==String(L"$",1)){
			bbPrint(String(L"OOPS2",5));
			bb_config_InternalErr(String(L"Internal error",14));
		}
		t_set=(new c_StringSet)->m_new();
		m_mungedScopes->p_Set10(t_scope,t_set);
	}
	t_set->p_Insert(t_munged.ToLower());
	t_decl->m_munged=t_munged;
	return 0;
}
int c_CTranslator::p_Emit(String t_t){
	if(!((t_t).Length()!=0)){
		return 0;
	}
	if(t_t.StartsWith(String(L"}",1))){
		m_indent=m_indent.Slice(0,m_indent.Length()-1);
	}
	m_lines->p_Push(m_indent+t_t);
	if(t_t.EndsWith(String(L"{",1))){
		m_indent=m_indent+String(L"\t",1);
	}
	return 0;
}
int c_CTranslator::p_BeginLocalScope(){
	m_mungedScopes->p_Set10(String(L"$",1),(new c_StringSet)->m_new());
	return 0;
}
String c_CTranslator::p_Bra(String t_str){
	if(t_str.StartsWith(String(L"(",1)) && t_str.EndsWith(String(L")",1))){
		int t_n=1;
		for(int t_i=1;t_i<t_str.Length()-1;t_i=t_i+1){
			String t_1=t_str.Slice(t_i,t_i+1);
			if(t_1==String(L"(",1)){
				t_n+=1;
			}else{
				if(t_1==String(L")",1)){
					t_n-=1;
					if(!((t_n)!=0)){
						return String(L"(",1)+t_str+String(L")",1);
					}
				}
			}
		}
		if(t_n==1){
			return t_str;
		}
	}
	return String(L"(",1)+t_str+String(L")",1);
}
int c_CTranslator::p_EmitEnter(c_FuncDecl* t_func){
	return 0;
}
int c_CTranslator::p_EmitEnterBlock(){
	return 0;
}
int c_CTranslator::p_EmitSetErr(String t_errInfo){
	return 0;
}
String c_CTranslator::p_CreateLocal(c_Expr* t_expr){
	c_LocalDecl* t_tmp=(new c_LocalDecl)->m_new(String(),0,t_expr->m_exprType,t_expr);
	p_MungDecl(t_tmp);
	p_Emit(p_TransLocalDecl(t_tmp->m_munged,t_expr)+String(L";",1));
	return t_tmp->m_munged;
}
String c_CTranslator::p_TransExprNS(c_Expr* t_expr){
	if(!t_expr->p_SideEffects()){
		return t_expr->p_Trans();
	}
	return p_CreateLocal(t_expr);
}
int c_CTranslator::p_EmitLeave(){
	return 0;
}
int c_CTranslator::p_EmitLeaveBlock(){
	return 0;
}
int c_CTranslator::p_EmitBlock(c_BlockDecl* t_block,bool t_realBlock){
	bb_decl_PushEnv(t_block);
	c_FuncDecl* t_func=dynamic_cast<c_FuncDecl*>(t_block);
	if((t_func)!=0){
		m_emitDebugInfo=bb_config_ENV_CONFIG!=String(L"release",7);
		if((t_func->m_attrs&4194304)!=0){
			m_emitDebugInfo=false;
		}
		if(m_emitDebugInfo){
			p_EmitEnter(t_func);
		}
	}else{
		if(m_emitDebugInfo && t_realBlock){
			p_EmitEnterBlock();
		}
	}
	c_Stmt* t_lastStmt=0;
	c_Enumerator6* t_=t_block->m_stmts->p_ObjectEnumerator();
	while(t_->p_HasNext()){
		c_Stmt* t_stmt=t_->p_NextObject();
		bb_config__errInfo=t_stmt->m_errInfo;
		if((m_unreachable)!=0){
			break;
		}
		t_lastStmt=t_stmt;
		if(m_emitDebugInfo){
			c_ReturnStmt* t_rs=dynamic_cast<c_ReturnStmt*>(t_stmt);
			if((t_rs)!=0){
				if((t_rs->m_expr)!=0){
					if((t_stmt->m_errInfo).Length()!=0){
						p_EmitSetErr(t_stmt->m_errInfo);
					}
					String t_t_expr=p_TransExprNS(t_rs->m_expr);
					p_EmitLeave();
					p_Emit(String(L"return ",7)+t_t_expr+String(L";",1));
				}else{
					p_EmitLeave();
					p_Emit(String(L"return;",7));
				}
				m_unreachable=1;
				continue;
			}
			if((t_stmt->m_errInfo).Length()!=0){
				p_EmitSetErr(t_stmt->m_errInfo);
			}
		}
		String t_t=t_stmt->p_Trans();
		if((t_t).Length()!=0){
			p_Emit(t_t+String(L";",1));
		}
	}
	bb_config__errInfo=String();
	int t_unr=m_unreachable;
	m_unreachable=0;
	if((t_unr)!=0){
		if(((t_func)!=0) && bb_config_ENV_LANG==String(L"as",2) && !((dynamic_cast<c_VoidType*>(t_func->m_retType))!=0)){
			if(!((dynamic_cast<c_ReturnStmt*>(t_lastStmt))!=0)){
				p_Emit(String(L"return ",7)+p_TransValue(t_func->m_retType,String())+String(L";",1));
			}
		}
	}else{
		if((t_func)!=0){
			if(m_emitDebugInfo){
				p_EmitLeave();
			}
			if(!((dynamic_cast<c_VoidType*>(t_func->m_retType))!=0)){
				if(t_func->p_IsCtor()){
					p_Emit(String(L"return this;",12));
				}else{
					if((t_func->p_ModuleScope()->p_IsStrict())!=0){
						bb_config__errInfo=t_func->m_errInfo;
						bb_config_Err(String(L"Missing return statement.",25));
					}
					p_Emit(String(L"return ",7)+p_TransValue(t_func->m_retType,String())+String(L";",1));
				}
			}
		}else{
			if(m_emitDebugInfo && t_realBlock){
				p_EmitLeaveBlock();
			}
		}
	}
	bb_decl_PopEnv();
	return t_unr;
}
int c_CTranslator::p_EndLocalScope(){
	m_mungedScopes->p_Set10(String(L"$",1),0);
	return 0;
}
String c_CTranslator::p_JoinLines(){
	String t_code=m_lines->p_Join(String(L"\n",1));
	m_lines->p_Clear();
	return t_code;
}
String c_CTranslator::p_Enquote(String t_str){
	return bb_config_Enquote(t_str,bb_config_ENV_LANG);
}
int c_CTranslator::p_BeginLoop(){
	return 0;
}
int c_CTranslator::p_EndLoop(){
	return 0;
}
int c_CTranslator::p_ExprPri(c_Expr* t_expr){
	if((dynamic_cast<c_NewObjectExpr*>(t_expr))!=0){
		return 3;
	}else{
		if((dynamic_cast<c_UnaryExpr*>(t_expr))!=0){
			String t_5=dynamic_cast<c_UnaryExpr*>(t_expr)->m_op;
			if(t_5==String(L"+",1) || t_5==String(L"-",1) || t_5==String(L"~",1) || t_5==String(L"not",3)){
				return 3;
			}
			bb_config_InternalErr(String(L"Internal error",14));
		}else{
			if((dynamic_cast<c_BinaryExpr*>(t_expr))!=0){
				String t_6=dynamic_cast<c_BinaryExpr*>(t_expr)->m_op;
				if(t_6==String(L"*",1) || t_6==String(L"/",1) || t_6==String(L"mod",3)){
					return 4;
				}else{
					if(t_6==String(L"+",1) || t_6==String(L"-",1)){
						return 5;
					}else{
						if(t_6==String(L"shl",3) || t_6==String(L"shr",3)){
							return 6;
						}else{
							if(t_6==String(L"<",1) || t_6==String(L"<=",2) || t_6==String(L">",1) || t_6==String(L">=",2)){
								return 7;
							}else{
								if(t_6==String(L"=",1) || t_6==String(L"<>",2)){
									return 8;
								}else{
									if(t_6==String(L"&",1)){
										return 9;
									}else{
										if(t_6==String(L"~",1)){
											return 10;
										}else{
											if(t_6==String(L"|",1)){
												return 11;
											}else{
												if(t_6==String(L"and",3)){
													return 12;
												}else{
													if(t_6==String(L"or",2)){
														return 13;
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
				bb_config_InternalErr(String(L"Internal error",14));
			}
		}
	}
	return 2;
}
String c_CTranslator::p_TransSubExpr(c_Expr* t_expr,int t_pri){
	String t_t_expr=t_expr->p_Trans();
	if(p_ExprPri(t_expr)>t_pri){
		t_t_expr=p_Bra(t_t_expr);
	}
	return t_t_expr;
}
String c_CTranslator::p_TransStmtExpr(c_StmtExpr* t_expr){
	String t_t=t_expr->m_stmt->p_Trans();
	if((t_t).Length()!=0){
		p_Emit(t_t+String(L";",1));
	}
	return t_expr->m_expr->p_Trans();
}
String c_CTranslator::p_TransVarExpr(c_VarExpr* t_expr){
	c_VarDecl* t_decl=t_expr->m_decl;
	if(t_decl->m_munged.StartsWith(String(L"$",1))){
		return p_TransIntrinsicExpr((t_decl),0,Array<c_Expr* >());
	}
	if((dynamic_cast<c_LocalDecl*>(t_decl))!=0){
		return t_decl->m_munged;
	}
	if((dynamic_cast<c_FieldDecl*>(t_decl))!=0){
		return p_TransField(dynamic_cast<c_FieldDecl*>(t_decl),0);
	}
	if((dynamic_cast<c_GlobalDecl*>(t_decl))!=0){
		return p_TransGlobal(dynamic_cast<c_GlobalDecl*>(t_decl));
	}
	bb_config_InternalErr(String(L"Internal error",14));
	return String();
}
String c_CTranslator::p_TransMemberVarExpr(c_MemberVarExpr* t_expr){
	c_VarDecl* t_decl=t_expr->m_decl;
	if(t_decl->m_munged.StartsWith(String(L"$",1))){
		return p_TransIntrinsicExpr((t_decl),t_expr->m_expr,Array<c_Expr* >());
	}
	if((dynamic_cast<c_FieldDecl*>(t_decl))!=0){
		return p_TransField(dynamic_cast<c_FieldDecl*>(t_decl),t_expr->m_expr);
	}
	bb_config_InternalErr(String(L"Internal error",14));
	return String();
}
String c_CTranslator::p_TransInvokeExpr(c_InvokeExpr* t_expr){
	c_FuncDecl* t_decl=t_expr->m_decl;
	String t_t=String();
	if(t_decl->m_munged.StartsWith(String(L"$",1))){
		return p_TransIntrinsicExpr((t_decl),0,t_expr->m_args);
	}
	if((t_decl)!=0){
		return p_TransFunc(t_decl,t_expr->m_args,0);
	}
	bb_config_InternalErr(String(L"Internal error",14));
	return String();
}
String c_CTranslator::p_TransInvokeMemberExpr(c_InvokeMemberExpr* t_expr){
	c_FuncDecl* t_decl=t_expr->m_decl;
	String t_t=String();
	if(t_decl->m_munged.StartsWith(String(L"$",1))){
		return p_TransIntrinsicExpr((t_decl),t_expr->m_expr,t_expr->m_args);
	}
	if((t_decl)!=0){
		return p_TransFunc(t_decl,t_expr->m_args,t_expr->m_expr);
	}
	bb_config_InternalErr(String(L"Internal error",14));
	return String();
}
String c_CTranslator::p_TransInvokeSuperExpr(c_InvokeSuperExpr* t_expr){
	c_FuncDecl* t_decl=t_expr->m_funcDecl;
	String t_t=String();
	if(t_decl->m_munged.StartsWith(String(L"$",1))){
		return p_TransIntrinsicExpr((t_decl),(t_expr),Array<c_Expr* >());
	}
	if((t_decl)!=0){
		return p_TransSuperFunc(t_decl,t_expr->m_args);
	}
	bb_config_InternalErr(String(L"Internal error",14));
	return String();
}
String c_CTranslator::p_TransExprStmt(c_ExprStmt* t_stmt){
	return t_stmt->m_expr->p_TransStmt();
}
String c_CTranslator::p_TransAssignOp(String t_op){
	String t_4=t_op;
	if(t_4==String(L"~=",2)){
		return String(L"^=",2);
	}else{
		if(t_4==String(L"mod=",4)){
			return String(L"%=",2);
		}else{
			if(t_4==String(L"shl=",4)){
				return String(L"<<=",3);
			}else{
				if(t_4==String(L"shr=",4)){
					return String(L">>=",3);
				}
			}
		}
	}
	return t_op;
}
String c_CTranslator::p_TransAssignStmt2(c_AssignStmt* t_stmt){
	return t_stmt->m_lhs->p_TransVar()+p_TransAssignOp(t_stmt->m_op)+t_stmt->m_rhs->p_Trans();
}
String c_CTranslator::p_TransAssignStmt(c_AssignStmt* t_stmt){
	if(!((t_stmt->m_rhs)!=0)){
		return t_stmt->m_lhs->p_Trans();
	}
	if((t_stmt->m_tmp1)!=0){
		p_MungDecl(t_stmt->m_tmp1);
		p_Emit(p_TransLocalDecl(t_stmt->m_tmp1->m_munged,t_stmt->m_tmp1->m_init)+String(L";",1));
	}
	if((t_stmt->m_tmp2)!=0){
		p_MungDecl(t_stmt->m_tmp2);
		p_Emit(p_TransLocalDecl(t_stmt->m_tmp2->m_munged,t_stmt->m_tmp2->m_init)+String(L";",1));
	}
	return p_TransAssignStmt2(t_stmt);
}
String c_CTranslator::p_TransReturnStmt(c_ReturnStmt* t_stmt){
	String t_t=String(L"return",6);
	if((t_stmt->m_expr)!=0){
		t_t=t_t+(String(L" ",1)+t_stmt->m_expr->p_Trans());
	}
	m_unreachable=1;
	return t_t;
}
String c_CTranslator::p_TransContinueStmt(c_ContinueStmt* t_stmt){
	m_unreachable=1;
	return String(L"continue",8);
}
String c_CTranslator::p_TransBreakStmt(c_BreakStmt* t_stmt){
	m_unreachable=1;
	m_broken+=1;
	return String(L"break",5);
}
String c_CTranslator::p_TransBlock(c_BlockDecl* t_block){
	p_EmitBlock(t_block,false);
	return String();
}
String c_CTranslator::p_TransDeclStmt(c_DeclStmt* t_stmt){
	c_LocalDecl* t_decl=dynamic_cast<c_LocalDecl*>(t_stmt->m_decl);
	if((t_decl)!=0){
		p_MungDecl(t_decl);
		return p_TransLocalDecl(t_decl->m_munged,t_decl->m_init);
	}
	c_ConstDecl* t_cdecl=dynamic_cast<c_ConstDecl*>(t_stmt->m_decl);
	if((t_cdecl)!=0){
		return String();
	}
	bb_config_InternalErr(String(L"Internal error",14));
	return String();
}
String c_CTranslator::p_TransIfStmt(c_IfStmt* t_stmt){
	if(((dynamic_cast<c_ConstExpr*>(t_stmt->m_expr))!=0) && bb_config_ENV_LANG!=String(L"java",4)){
		if((dynamic_cast<c_ConstExpr*>(t_stmt->m_expr)->m_value).Length()!=0){
			if(!t_stmt->m_thenBlock->m_stmts->p_IsEmpty()){
				p_Emit(String(L"if(true){",9));
				if((p_EmitBlock(t_stmt->m_thenBlock,true))!=0){
					m_unreachable=1;
				}
				p_Emit(String(L"}",1));
			}
		}else{
			if(!t_stmt->m_elseBlock->m_stmts->p_IsEmpty()){
				p_Emit(String(L"if(true){",9));
				if((p_EmitBlock(t_stmt->m_elseBlock,true))!=0){
					m_unreachable=1;
				}
				p_Emit(String(L"}",1));
			}
		}
	}else{
		if(!t_stmt->m_elseBlock->m_stmts->p_IsEmpty()){
			p_Emit(String(L"if",2)+p_Bra(t_stmt->m_expr->p_Trans())+String(L"{",1));
			int t_unr=p_EmitBlock(t_stmt->m_thenBlock,true);
			p_Emit(String(L"}else{",6));
			int t_unr2=p_EmitBlock(t_stmt->m_elseBlock,true);
			p_Emit(String(L"}",1));
			if(((t_unr)!=0) && ((t_unr2)!=0)){
				m_unreachable=1;
			}
		}else{
			p_Emit(String(L"if",2)+p_Bra(t_stmt->m_expr->p_Trans())+String(L"{",1));
			int t_unr3=p_EmitBlock(t_stmt->m_thenBlock,true);
			p_Emit(String(L"}",1));
		}
	}
	return String();
}
String c_CTranslator::p_TransWhileStmt(c_WhileStmt* t_stmt){
	int t_nbroken=m_broken;
	p_Emit(String(L"while",5)+p_Bra(t_stmt->m_expr->p_Trans())+String(L"{",1));
	p_BeginLoop();
	int t_unr=p_EmitBlock(t_stmt->m_block,true);
	p_EndLoop();
	p_Emit(String(L"}",1));
	if(m_broken==t_nbroken && ((dynamic_cast<c_ConstExpr*>(t_stmt->m_expr))!=0) && ((dynamic_cast<c_ConstExpr*>(t_stmt->m_expr)->m_value).Length()!=0)){
		m_unreachable=1;
	}
	m_broken=t_nbroken;
	return String();
}
String c_CTranslator::p_TransRepeatStmt(c_RepeatStmt* t_stmt){
	int t_nbroken=m_broken;
	p_Emit(String(L"do{",3));
	p_BeginLoop();
	int t_unr=p_EmitBlock(t_stmt->m_block,true);
	p_EndLoop();
	p_Emit(String(L"}while(!",8)+p_Bra(t_stmt->m_expr->p_Trans())+String(L");",2));
	if(m_broken==t_nbroken && ((dynamic_cast<c_ConstExpr*>(t_stmt->m_expr))!=0) && !((dynamic_cast<c_ConstExpr*>(t_stmt->m_expr)->m_value).Length()!=0)){
		m_unreachable=1;
	}
	m_broken=t_nbroken;
	return String();
}
String c_CTranslator::p_TransForStmt(c_ForStmt* t_stmt){
	int t_nbroken=m_broken;
	String t_init=t_stmt->m_init->p_Trans();
	String t_expr=t_stmt->m_expr->p_Trans();
	String t_incr=t_stmt->m_incr->p_Trans();
	p_Emit(String(L"for(",4)+t_init+String(L";",1)+t_expr+String(L";",1)+t_incr+String(L"){",2));
	p_BeginLoop();
	int t_unr=p_EmitBlock(t_stmt->m_block,true);
	p_EndLoop();
	p_Emit(String(L"}",1));
	if(m_broken==t_nbroken && ((dynamic_cast<c_ConstExpr*>(t_stmt->m_expr))!=0) && ((dynamic_cast<c_ConstExpr*>(t_stmt->m_expr)->m_value).Length()!=0)){
		m_unreachable=1;
	}
	m_broken=t_nbroken;
	return String();
}
String c_CTranslator::p_TransTryStmt(c_TryStmt* t_stmt){
	bb_config_Err(String(L"TODO!",5));
	return String();
}
String c_CTranslator::p_TransThrowStmt(c_ThrowStmt* t_stmt){
	m_unreachable=1;
	return String(L"throw ",6)+t_stmt->m_expr->p_Trans();
}
String c_CTranslator::p_TransUnaryOp(String t_op){
	String t_2=t_op;
	if(t_2==String(L"+",1)){
		return String(L"+",1);
	}else{
		if(t_2==String(L"-",1)){
			return String(L"-",1);
		}else{
			if(t_2==String(L"~",1)){
				return t_op;
			}else{
				if(t_2==String(L"not",3)){
					return String(L"!",1);
				}
			}
		}
	}
	bb_config_InternalErr(String(L"Internal error",14));
	return String();
}
String c_CTranslator::p_TransBinaryOp(String t_op,String t_rhs){
	String t_3=t_op;
	if(t_3==String(L"+",1) || t_3==String(L"-",1)){
		if(t_rhs.StartsWith(t_op)){
			return t_op+String(L" ",1);
		}
		return t_op;
	}else{
		if(t_3==String(L"*",1) || t_3==String(L"/",1)){
			return t_op;
		}else{
			if(t_3==String(L"shl",3)){
				return String(L"<<",2);
			}else{
				if(t_3==String(L"shr",3)){
					return String(L">>",2);
				}else{
					if(t_3==String(L"mod",3)){
						return String(L" % ",3);
					}else{
						if(t_3==String(L"and",3)){
							return String(L" && ",4);
						}else{
							if(t_3==String(L"or",2)){
								return String(L" || ",4);
							}else{
								if(t_3==String(L"=",1)){
									return String(L"==",2);
								}else{
									if(t_3==String(L"<>",2)){
										return String(L"!=",2);
									}else{
										if(t_3==String(L"<",1) || t_3==String(L"<=",2) || t_3==String(L">",1) || t_3==String(L">=",2)){
											return t_op;
										}else{
											if(t_3==String(L"&",1) || t_3==String(L"|",1)){
												return t_op;
											}else{
												if(t_3==String(L"~",1)){
													return String(L"^",1);
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
	bb_config_InternalErr(String(L"Internal error",14));
	return String();
}
void c_CTranslator::mark(){
	c_Translator::mark();
}
c_JavaTranslator::c_JavaTranslator(){
	m_langutil=false;
	m_unsafe=0;
}
c_JavaTranslator* c_JavaTranslator::m_new(){
	c_CTranslator::m_new();
	return this;
}
String c_JavaTranslator::p_TransType(c_Type* t_ty){
	if((dynamic_cast<c_VoidType*>(t_ty))!=0){
		return String(L"void",4);
	}
	if((dynamic_cast<c_BoolType*>(t_ty))!=0){
		return String(L"boolean",7);
	}
	if((dynamic_cast<c_IntType*>(t_ty))!=0){
		return String(L"int",3);
	}
	if((dynamic_cast<c_FloatType*>(t_ty))!=0){
		return String(L"float",5);
	}
	if((dynamic_cast<c_StringType*>(t_ty))!=0){
		return String(L"String",6);
	}
	if((dynamic_cast<c_ArrayType*>(t_ty))!=0){
		return p_TransType(dynamic_cast<c_ArrayType*>(t_ty)->m_elemType)+String(L"[]",2);
	}
	if((dynamic_cast<c_ObjectType*>(t_ty))!=0){
		return t_ty->p_GetClass()->m_munged;
	}
	bb_config_InternalErr(String(L"Internal error",14));
	return String();
}
int c_JavaTranslator::p_EmitFuncDecl(c_FuncDecl* t_decl){
	m_unsafe=((t_decl->m_ident.EndsWith(String(L"__UNSAFE__",10)))?1:0);
	p_BeginLocalScope();
	String t_args=String();
	Array<c_ArgDecl* > t_=t_decl->m_argDecls;
	int t_2=0;
	while(t_2<t_.Length()){
		c_ArgDecl* t_arg=t_[t_2];
		t_2=t_2+1;
		p_MungDecl(t_arg);
		if((t_args).Length()!=0){
			t_args=t_args+String(L",",1);
		}
		t_args=t_args+(p_TransType(t_arg->m_type)+String(L" ",1)+t_arg->m_munged);
	}
	String t_t=p_TransType(t_decl->m_retType)+String(L" ",1)+t_decl->m_munged+p_Bra(t_args);
	if(((t_decl->p_ClassScope())!=0) && ((t_decl->p_ClassScope()->p_IsInterface())!=0)){
		p_Emit(String(L"public ",7)+t_t+String(L";",1));
	}else{
		if((t_decl->p_IsAbstract())!=0){
			p_Emit(String(L"public abstract ",16)+t_t+String(L";",1));
		}else{
			String t_q=String(L"public ",7);
			if(t_decl->p_IsStatic()){
				t_q=t_q+String(L"static ",7);
			}else{
				if(!t_decl->p_IsVirtual()){
					t_q=t_q+String(L"final ",6);
				}
			}
			p_Emit(t_q+t_t+String(L"{",1));
			p_EmitBlock((t_decl),true);
			p_Emit(String(L"}",1));
		}
	}
	p_EndLocalScope();
	m_unsafe=0;
	return 0;
}
String c_JavaTranslator::p_TransDecl(c_Decl* t_decl){
	String t_id=t_decl->m_munged;
	c_ValDecl* t_vdecl=dynamic_cast<c_ValDecl*>(t_decl);
	if((t_vdecl)!=0){
		return p_TransType(t_vdecl->m_type)+String(L" ",1)+t_id;
	}
	bb_config_InternalErr(String(L"Internal error",14));
	return String();
}
int c_JavaTranslator::p_EmitClassDecl(c_ClassDecl* t_classDecl){
	String t_classid=t_classDecl->m_munged;
	String t_superid=t_classDecl->m_superClass->m_munged;
	if((t_classDecl->p_IsInterface())!=0){
		String t_bases=String();
		Array<c_ClassDecl* > t_=t_classDecl->m_implments;
		int t_2=0;
		while(t_2<t_.Length()){
			c_ClassDecl* t_iface=t_[t_2];
			t_2=t_2+1;
			if((t_bases).Length()!=0){
				t_bases=t_bases+String(L",",1);
			}else{
				t_bases=String(L" extends ",9);
			}
			t_bases=t_bases+t_iface->m_munged;
		}
		p_Emit(String(L"interface ",10)+t_classid+t_bases+String(L"{",1));
		c_Enumerator3* t_3=t_classDecl->p_Semanted()->p_ObjectEnumerator();
		while(t_3->p_HasNext()){
			c_Decl* t_decl=t_3->p_NextObject();
			c_FuncDecl* t_fdecl=dynamic_cast<c_FuncDecl*>(t_decl);
			if(!((t_fdecl)!=0)){
				continue;
			}
			p_EmitFuncDecl(t_fdecl);
		}
		p_Emit(String(L"}",1));
		return 0;
	}
	String t_bases2=String();
	Array<c_ClassDecl* > t_4=t_classDecl->m_implments;
	int t_5=0;
	while(t_5<t_4.Length()){
		c_ClassDecl* t_iface2=t_4[t_5];
		t_5=t_5+1;
		if((t_bases2).Length()!=0){
			t_bases2=t_bases2+String(L",",1);
		}else{
			t_bases2=String(L" implements ",12);
		}
		t_bases2=t_bases2+t_iface2->m_munged;
	}
	String t_q=String();
	if((t_classDecl->p_IsAbstract())!=0){
		t_q=String(L"abstract ",9);
	}else{
		if((t_classDecl->p_IsFinal())!=0){
			t_q=String(L"final ",6);
		}
	}
	p_Emit(t_q+String(L"class ",6)+t_classid+String(L" extends ",9)+t_superid+t_bases2+String(L"{",1));
	c_Enumerator3* t_6=t_classDecl->p_Semanted()->p_ObjectEnumerator();
	while(t_6->p_HasNext()){
		c_Decl* t_decl2=t_6->p_NextObject();
		c_FieldDecl* t_tdecl=dynamic_cast<c_FieldDecl*>(t_decl2);
		if((t_tdecl)!=0){
			p_Emit(p_TransDecl(t_tdecl)+String(L"=",1)+t_tdecl->m_init->p_Trans()+String(L";",1));
			continue;
		}
		c_FuncDecl* t_fdecl2=dynamic_cast<c_FuncDecl*>(t_decl2);
		if((t_fdecl2)!=0){
			p_EmitFuncDecl(t_fdecl2);
			continue;
		}
		c_GlobalDecl* t_gdecl=dynamic_cast<c_GlobalDecl*>(t_decl2);
		if((t_gdecl)!=0){
			p_Emit(String(L"static ",7)+p_TransDecl(t_gdecl)+String(L";",1));
			continue;
		}
	}
	p_Emit(String(L"}",1));
	return 0;
}
String c_JavaTranslator::p_TransStatic(c_Decl* t_decl){
	if(((t_decl->p_IsExtern())!=0) && ((dynamic_cast<c_ModuleDecl*>(t_decl->m_scope))!=0)){
		return t_decl->m_munged;
	}else{
		if(((bb_decl__env)!=0) && ((t_decl->m_scope)!=0) && t_decl->m_scope==(bb_decl__env->p_ClassScope())){
			return t_decl->m_munged;
		}else{
			if((dynamic_cast<c_ClassDecl*>(t_decl->m_scope))!=0){
				return t_decl->m_scope->m_munged+String(L".",1)+t_decl->m_munged;
			}else{
				if((dynamic_cast<c_ModuleDecl*>(t_decl->m_scope))!=0){
					return t_decl->m_scope->m_munged+String(L".",1)+t_decl->m_munged;
				}
			}
		}
	}
	bb_config_InternalErr(String(L"Internal error",14));
	return String();
}
String c_JavaTranslator::p_TransGlobal(c_GlobalDecl* t_decl){
	return p_TransStatic(t_decl);
}
String c_JavaTranslator::p_TransApp(c_AppDecl* t_app){
	m_langutil=bb_config_GetConfigVar(String(L"ANDROID_LANGUTIL_ENABLED",24))==String(L"1",1);
	t_app->m_mainModule->m_munged=String(L"bb_",3);
	t_app->m_mainFunc->m_munged=String(L"bbMain",6);
	c_ValueEnumerator* t_=t_app->m_imported->p_Values()->p_ObjectEnumerator();
	while(t_->p_HasNext()){
		c_ModuleDecl* t_decl=t_->p_NextObject();
		p_MungDecl(t_decl);
	}
	c_Enumerator3* t_2=t_app->p_Semanted()->p_ObjectEnumerator();
	while(t_2->p_HasNext()){
		c_Decl* t_decl2=t_2->p_NextObject();
		p_MungDecl(t_decl2);
		c_ClassDecl* t_cdecl=dynamic_cast<c_ClassDecl*>(t_decl2);
		if(!((t_cdecl)!=0)){
			continue;
		}
		c_Enumerator3* t_3=t_cdecl->p_Semanted()->p_ObjectEnumerator();
		while(t_3->p_HasNext()){
			c_Decl* t_decl3=t_3->p_NextObject();
			if(((dynamic_cast<c_FuncDecl*>(t_decl3))!=0) && dynamic_cast<c_FuncDecl*>(t_decl3)->p_IsCtor()){
				t_decl3->m_ident=t_cdecl->m_ident+String(L"_",1)+t_decl3->m_ident;
			}
			p_MungDecl(t_decl3);
		}
	}
	c_Enumerator3* t_4=t_app->p_Semanted()->p_ObjectEnumerator();
	while(t_4->p_HasNext()){
		c_Decl* t_decl4=t_4->p_NextObject();
		c_ClassDecl* t_cdecl2=dynamic_cast<c_ClassDecl*>(t_decl4);
		if((t_cdecl2)!=0){
			p_EmitClassDecl(t_cdecl2);
		}
	}
	c_ValueEnumerator* t_5=t_app->m_imported->p_Values()->p_ObjectEnumerator();
	while(t_5->p_HasNext()){
		c_ModuleDecl* t_mdecl=t_5->p_NextObject();
		p_Emit(String(L"class ",6)+t_mdecl->m_munged+String(L"{",1));
		c_Enumerator3* t_6=t_mdecl->p_Semanted()->p_ObjectEnumerator();
		while(t_6->p_HasNext()){
			c_Decl* t_decl5=t_6->p_NextObject();
			if(((t_decl5->p_IsExtern())!=0) || ((t_decl5->m_scope->p_ClassScope())!=0)){
				continue;
			}
			c_GlobalDecl* t_gdecl=dynamic_cast<c_GlobalDecl*>(t_decl5);
			if((t_gdecl)!=0){
				p_Emit(String(L"static ",7)+p_TransDecl(t_gdecl)+String(L";",1));
				continue;
			}
			c_FuncDecl* t_fdecl=dynamic_cast<c_FuncDecl*>(t_decl5);
			if((t_fdecl)!=0){
				p_EmitFuncDecl(t_fdecl);
				continue;
			}
		}
		if(t_mdecl==t_app->m_mainModule){
			p_BeginLocalScope();
			p_Emit(String(L"public static int bbInit(){",27));
			c_Enumerator7* t_7=t_app->m_semantedGlobals->p_ObjectEnumerator();
			while(t_7->p_HasNext()){
				c_GlobalDecl* t_decl6=t_7->p_NextObject();
				p_Emit(p_TransGlobal(t_decl6)+String(L"=",1)+t_decl6->m_init->p_Trans()+String(L";",1));
			}
			p_Emit(String(L"return 0;",9));
			p_Emit(String(L"}",1));
			p_EndLocalScope();
		}
		p_Emit(String(L"}",1));
	}
	return p_JoinLines();
}
String c_JavaTranslator::p_TransValue(c_Type* t_ty,String t_value){
	if((t_value).Length()!=0){
		if(((dynamic_cast<c_IntType*>(t_ty))!=0) && t_value.StartsWith(String(L"$",1))){
			return String(L"0x",2)+t_value.Slice(1);
		}
		if((dynamic_cast<c_BoolType*>(t_ty))!=0){
			return String(L"true",4);
		}
		if((dynamic_cast<c_IntType*>(t_ty))!=0){
			return t_value;
		}
		if((dynamic_cast<c_FloatType*>(t_ty))!=0){
			return t_value+String(L"f",1);
		}
		if((dynamic_cast<c_StringType*>(t_ty))!=0){
			return p_Enquote(t_value);
		}
	}else{
		if((dynamic_cast<c_BoolType*>(t_ty))!=0){
			return String(L"false",5);
		}
		if((dynamic_cast<c_NumericType*>(t_ty))!=0){
			return String(L"0",1);
		}
		if((dynamic_cast<c_StringType*>(t_ty))!=0){
			return String(L"\"\"",2);
		}
		if((dynamic_cast<c_ArrayType*>(t_ty))!=0){
			c_Type* t_elemTy=dynamic_cast<c_ArrayType*>(t_ty)->m_elemType;
			if((dynamic_cast<c_BoolType*>(t_elemTy))!=0){
				return String(L"bb_std_lang.emptyBoolArray",26);
			}
			if((dynamic_cast<c_IntType*>(t_elemTy))!=0){
				return String(L"bb_std_lang.emptyIntArray",25);
			}
			if((dynamic_cast<c_FloatType*>(t_elemTy))!=0){
				return String(L"bb_std_lang.emptyFloatArray",27);
			}
			if((dynamic_cast<c_StringType*>(t_elemTy))!=0){
				return String(L"bb_std_lang.emptyStringArray",28);
			}
			String t_t=String(L"[0]",3);
			while((dynamic_cast<c_ArrayType*>(t_elemTy))!=0){
				t_elemTy=dynamic_cast<c_ArrayType*>(t_elemTy)->m_elemType;
				t_t=t_t+String(L"[]",2);
			}
			return String(L"new ",4)+p_TransType(t_elemTy)+t_t;
		}
		if((dynamic_cast<c_ObjectType*>(t_ty))!=0){
			return String(L"null",4);
		}
	}
	bb_config_InternalErr(String(L"Internal error",14));
	return String();
}
String c_JavaTranslator::p_TransLocalDecl(String t_munged,c_Expr* t_init){
	return p_TransType(t_init->m_exprType)+String(L" ",1)+t_munged+String(L"=",1)+t_init->p_Trans();
}
int c_JavaTranslator::p_EmitEnter(c_FuncDecl* t_func){
	if((m_unsafe)!=0){
		return 0;
	}
	p_Emit(String(L"bb_std_lang.pushErr();",22));
	return 0;
}
int c_JavaTranslator::p_EmitSetErr(String t_info){
	if((m_unsafe)!=0){
		return 0;
	}
	p_Emit(String(L"bb_std_lang.errInfo=\"",21)+t_info.Replace(String(L"\\",1),String(L"/",1))+String(L"\";",2));
	return 0;
}
int c_JavaTranslator::p_EmitLeave(){
	if((m_unsafe)!=0){
		return 0;
	}
	p_Emit(String(L"bb_std_lang.popErr();",21));
	return 0;
}
String c_JavaTranslator::p_TransField(c_FieldDecl* t_decl,c_Expr* t_lhs){
	if((t_lhs)!=0){
		return p_TransSubExpr(t_lhs,2)+String(L".",1)+t_decl->m_munged;
	}
	return t_decl->m_munged;
}
String c_JavaTranslator::p_TransArgs(Array<c_Expr* > t_args){
	String t_t=String();
	Array<c_Expr* > t_=t_args;
	int t_2=0;
	while(t_2<t_.Length()){
		c_Expr* t_arg=t_[t_2];
		t_2=t_2+1;
		if((t_t).Length()!=0){
			t_t=t_t+String(L",",1);
		}
		t_t=t_t+t_arg->p_Trans();
	}
	return p_Bra(t_t);
}
String c_JavaTranslator::p_TransFunc(c_FuncDecl* t_decl,Array<c_Expr* > t_args,c_Expr* t_lhs){
	if(t_decl->p_IsMethod()){
		if((t_lhs)!=0){
			return p_TransSubExpr(t_lhs,2)+String(L".",1)+t_decl->m_munged+p_TransArgs(t_args);
		}
		return t_decl->m_munged+p_TransArgs(t_args);
	}
	return p_TransStatic(t_decl)+p_TransArgs(t_args);
}
String c_JavaTranslator::p_TransSuperFunc(c_FuncDecl* t_decl,Array<c_Expr* > t_args){
	return String(L"super.",6)+t_decl->m_munged+p_TransArgs(t_args);
}
String c_JavaTranslator::p_TransConstExpr(c_ConstExpr* t_expr){
	return p_TransValue(t_expr->m_exprType,t_expr->m_value);
}
String c_JavaTranslator::p_TransNewObjectExpr(c_NewObjectExpr* t_expr){
	String t_t=String(L"(new ",5)+t_expr->m_classDecl->m_munged+String(L"())",3);
	if((t_expr->m_ctor)!=0){
		t_t=t_t+(String(L".",1)+t_expr->m_ctor->m_munged+p_TransArgs(t_expr->m_args));
	}
	return t_t;
}
String c_JavaTranslator::p_TransNewArrayExpr(c_NewArrayExpr* t_expr){
	String t_texpr=t_expr->m_expr->p_Trans();
	c_Type* t_elemTy=dynamic_cast<c_ArrayType*>(t_expr->m_exprType)->m_elemType;
	if((dynamic_cast<c_StringType*>(t_elemTy))!=0){
		return String(L"bb_std_lang.stringArray",23)+p_Bra(t_texpr);
	}
	String t_t=String(L"[",1)+t_texpr+String(L"]",1);
	while((dynamic_cast<c_ArrayType*>(t_elemTy))!=0){
		t_elemTy=dynamic_cast<c_ArrayType*>(t_elemTy)->m_elemType;
		t_t=t_t+String(L"[]",2);
	}
	return String(L"new ",4)+p_TransType(t_elemTy)+t_t;
}
String c_JavaTranslator::p_TransSelfExpr(c_SelfExpr* t_expr){
	return String(L"this",4);
}
String c_JavaTranslator::p_TransCastExpr(c_CastExpr* t_expr){
	String t_texpr=p_Bra(t_expr->m_expr->p_Trans());
	c_Type* t_dst=t_expr->m_exprType;
	c_Type* t_src=t_expr->m_expr->m_exprType;
	if((dynamic_cast<c_BoolType*>(t_dst))!=0){
		if((dynamic_cast<c_BoolType*>(t_src))!=0){
			return t_texpr;
		}
		if((dynamic_cast<c_IntType*>(t_src))!=0){
			return p_Bra(t_texpr+String(L"!=0",3));
		}
		if((dynamic_cast<c_FloatType*>(t_src))!=0){
			return p_Bra(t_texpr+String(L"!=0.0f",6));
		}
		if((dynamic_cast<c_StringType*>(t_src))!=0){
			return p_Bra(t_texpr+String(L".length()!=0",12));
		}
		if((dynamic_cast<c_ArrayType*>(t_src))!=0){
			return p_Bra(t_texpr+String(L".length!=0",10));
		}
		if((dynamic_cast<c_ObjectType*>(t_src))!=0){
			return p_Bra(t_texpr+String(L"!=null",6));
		}
	}else{
		if((dynamic_cast<c_IntType*>(t_dst))!=0){
			if((dynamic_cast<c_BoolType*>(t_src))!=0){
				return p_Bra(t_texpr+String(L"?1:0",4));
			}
			if((dynamic_cast<c_IntType*>(t_src))!=0){
				return t_texpr;
			}
			if((dynamic_cast<c_FloatType*>(t_src))!=0){
				return String(L"(int)",5)+t_texpr;
			}
			if(m_langutil){
				if((dynamic_cast<c_StringType*>(t_src))!=0){
					return String(L"LangUtil.parseInt(",18)+t_texpr+String(L".trim())",8);
				}
			}else{
				if((dynamic_cast<c_StringType*>(t_src))!=0){
					return String(L"Integer.parseInt(",17)+t_texpr+String(L".trim())",8);
				}
			}
		}else{
			if((dynamic_cast<c_FloatType*>(t_dst))!=0){
				if((dynamic_cast<c_IntType*>(t_src))!=0){
					return String(L"(float)",7)+t_texpr;
				}
				if((dynamic_cast<c_FloatType*>(t_src))!=0){
					return t_texpr;
				}
				if(m_langutil){
					if((dynamic_cast<c_StringType*>(t_src))!=0){
						return String(L"LangUtil.parseFloat(",20)+t_texpr+String(L".trim())",8);
					}
				}else{
					if((dynamic_cast<c_StringType*>(t_src))!=0){
						return String(L"Float.parseFloat(",17)+t_texpr+String(L".trim())",8);
					}
				}
			}else{
				if((dynamic_cast<c_StringType*>(t_dst))!=0){
					if((dynamic_cast<c_IntType*>(t_src))!=0){
						return String(L"String.valueOf",14)+t_texpr;
					}
					if((dynamic_cast<c_FloatType*>(t_src))!=0){
						return String(L"String.valueOf",14)+t_texpr;
					}
					if((dynamic_cast<c_StringType*>(t_src))!=0){
						return t_texpr;
					}
				}else{
					if(((dynamic_cast<c_ObjectType*>(t_dst))!=0) && ((dynamic_cast<c_ObjectType*>(t_src))!=0)){
						if((t_src->p_GetClass()->p_ExtendsClass(t_dst->p_GetClass()))!=0){
							return t_texpr;
						}else{
							return String(L"bb_std_lang.as(",15)+p_TransType(t_dst)+String(L".class,",7)+t_texpr+String(L")",1);
						}
					}
				}
			}
		}
	}
	bb_config_Err(String(L"Java translator can't convert ",30)+t_src->p_ToString()+String(L" to ",4)+t_dst->p_ToString());
	return String();
}
String c_JavaTranslator::p_TransUnaryExpr(c_UnaryExpr* t_expr){
	String t_texpr=t_expr->m_expr->p_Trans();
	if(p_ExprPri(t_expr->m_expr)>p_ExprPri(t_expr)){
		t_texpr=p_Bra(t_texpr);
	}
	return p_TransUnaryOp(t_expr->m_op)+t_texpr;
}
String c_JavaTranslator::p_TransBinaryExpr(c_BinaryExpr* t_expr){
	String t_lhs=t_expr->m_lhs->p_Trans();
	String t_rhs=t_expr->m_rhs->p_Trans();
	if(((dynamic_cast<c_BinaryCompareExpr*>(t_expr))!=0) && ((dynamic_cast<c_StringType*>(t_expr->m_lhs->m_exprType))!=0) && ((dynamic_cast<c_StringType*>(t_expr->m_rhs->m_exprType))!=0)){
		if(p_ExprPri(t_expr->m_lhs)>2){
			t_lhs=p_Bra(t_lhs);
		}
		return p_Bra(t_lhs+String(L".compareTo",10)+p_Bra(t_rhs)+p_TransBinaryOp(t_expr->m_op,String())+String(L"0",1));
	}
	int t_pri=p_ExprPri(t_expr);
	if(p_ExprPri(t_expr->m_lhs)>t_pri){
		t_lhs=p_Bra(t_lhs);
	}
	if(p_ExprPri(t_expr->m_rhs)>=t_pri){
		t_rhs=p_Bra(t_rhs);
	}
	return t_lhs+p_TransBinaryOp(t_expr->m_op,t_rhs)+t_rhs;
}
String c_JavaTranslator::p_TransIndexExpr(c_IndexExpr* t_expr){
	String t_texpr=t_expr->m_expr->p_Trans();
	String t_index=t_expr->m_index->p_Trans();
	if((dynamic_cast<c_StringType*>(t_expr->m_expr->m_exprType))!=0){
		return String(L"(int)",5)+t_texpr+String(L".charAt(",8)+t_index+String(L")",1);
	}
	return t_texpr+String(L"[",1)+t_index+String(L"]",1);
}
String c_JavaTranslator::p_TransSliceExpr(c_SliceExpr* t_expr){
	String t_texpr=t_expr->m_expr->p_Trans();
	String t_from=String(L",0",2);
	String t_term=String();
	if((t_expr->m_from)!=0){
		t_from=String(L",",1)+t_expr->m_from->p_Trans();
	}
	if((t_expr->m_term)!=0){
		t_term=String(L",",1)+t_expr->m_term->p_Trans();
	}
	if((dynamic_cast<c_ArrayType*>(t_expr->m_exprType))!=0){
		return String(L"((",2)+p_TransType(t_expr->m_exprType)+String(L")bb_std_lang.sliceArray",23)+p_Bra(t_texpr+t_from+t_term)+String(L")",1);
	}else{
		if((dynamic_cast<c_StringType*>(t_expr->m_exprType))!=0){
			return String(L"bb_std_lang.slice(",18)+t_texpr+t_from+t_term+String(L")",1);
		}
	}
	bb_config_InternalErr(String(L"Internal error",14));
	return String();
}
String c_JavaTranslator::p_TransArrayExpr(c_ArrayExpr* t_expr){
	String t_t=String();
	Array<c_Expr* > t_=t_expr->m_exprs;
	int t_2=0;
	while(t_2<t_.Length()){
		c_Expr* t_elem=t_[t_2];
		t_2=t_2+1;
		if((t_t).Length()!=0){
			t_t=t_t+String(L",",1);
		}
		t_t=t_t+t_elem->p_Trans();
	}
	return String(L"new ",4)+p_TransType(t_expr->m_exprType)+String(L"{",1)+t_t+String(L"}",1);
}
String c_JavaTranslator::p_TransIntrinsicExpr(c_Decl* t_decl,c_Expr* t_expr,Array<c_Expr* > t_args){
	String t_texpr=String();
	String t_arg0=String();
	String t_arg1=String();
	String t_arg2=String();
	if((t_expr)!=0){
		t_texpr=p_TransSubExpr(t_expr,2);
	}
	if(t_args.Length()>0 && ((t_args[0])!=0)){
		t_arg0=t_args[0]->p_Trans();
	}
	if(t_args.Length()>1 && ((t_args[1])!=0)){
		t_arg1=t_args[1]->p_Trans();
	}
	if(t_args.Length()>2 && ((t_args[2])!=0)){
		t_arg2=t_args[2]->p_Trans();
	}
	String t_id=t_decl->m_munged.Slice(1);
	String t_fmath=String(L"(float)Math.",12);
	String t_1=t_id;
	if(t_1==String(L"print",5)){
		return String(L"bb_std_lang.print",17)+p_Bra(t_arg0);
	}else{
		if(t_1==String(L"error",5)){
			return String(L"bb_std_lang.error",17)+p_Bra(t_arg0);
		}else{
			if(t_1==String(L"debuglog",8)){
				return String(L"bb_std_lang.debugLog",20)+p_Bra(t_arg0);
			}else{
				if(t_1==String(L"debugstop",9)){
					return String(L"bb_std_lang.debugStop()",23);
				}else{
					if(t_1==String(L"length",6)){
						if((dynamic_cast<c_StringType*>(t_expr->m_exprType))!=0){
							return t_texpr+String(L".length()",9);
						}
						return String(L"bb_std_lang.length",18)+p_Bra(t_texpr);
					}else{
						if(t_1==String(L"resize",6)){
							c_Type* t_ty=dynamic_cast<c_ArrayType*>(t_expr->m_exprType)->m_elemType;
							if((dynamic_cast<c_StringType*>(t_ty))!=0){
								return String(L"bb_std_lang.resize(",19)+t_texpr+String(L",",1)+t_arg0+String(L")",1);
							}
							String t_ety=p_TransType(t_ty);
							return String(L"(",1)+t_ety+String(L"[])bb_std_lang.resize(",22)+t_texpr+String(L",",1)+t_arg0+String(L",",1)+t_ety+String(L".class)",7);
						}else{
							if(t_1==String(L"compare",7)){
								return t_texpr+String(L".compareTo",10)+p_Bra(t_arg0);
							}else{
								if(t_1==String(L"find",4)){
									return t_texpr+String(L".indexOf",8)+p_Bra(t_arg0+String(L",",1)+t_arg1);
								}else{
									if(t_1==String(L"findlast",8)){
										return t_texpr+String(L".lastIndexOf",12)+p_Bra(t_arg0);
									}else{
										if(t_1==String(L"findlast2",9)){
											return t_texpr+String(L".lastIndexOf",12)+p_Bra(t_arg0+String(L",",1)+t_arg1);
										}else{
											if(t_1==String(L"trim",4)){
												return t_texpr+String(L".trim()",7);
											}else{
												if(t_1==String(L"join",4)){
													return String(L"bb_std_lang.join",16)+p_Bra(t_texpr+String(L",",1)+t_arg0);
												}else{
													if(t_1==String(L"split",5)){
														return String(L"bb_std_lang.split",17)+p_Bra(t_texpr+String(L",",1)+t_arg0);
													}else{
														if(t_1==String(L"replace",7)){
															return String(L"bb_std_lang.replace",19)+p_Bra(t_texpr+String(L",",1)+t_arg0+String(L",",1)+t_arg1);
														}else{
															if(t_1==String(L"tolower",7)){
																return t_texpr+String(L".toLowerCase()",14);
															}else{
																if(t_1==String(L"toupper",7)){
																	return t_texpr+String(L".toUpperCase()",14);
																}else{
																	if(t_1==String(L"contains",8)){
																		return p_Bra(t_texpr+String(L".indexOf",8)+p_Bra(t_arg0)+String(L"!=-1",4));
																	}else{
																		if(t_1==String(L"startswith",10)){
																			return t_texpr+String(L".startsWith",11)+p_Bra(t_arg0);
																		}else{
																			if(t_1==String(L"endswith",8)){
																				return t_texpr+String(L".endsWith",9)+p_Bra(t_arg0);
																			}else{
																				if(t_1==String(L"tochars",7)){
																					return String(L"bb_std_lang.toChars",19)+p_Bra(t_texpr);
																				}else{
																					if(t_1==String(L"fromchar",8)){
																						return String(L"String.valueOf",14)+p_Bra(String(L"(char)",6)+p_Bra(t_arg0));
																					}else{
																						if(t_1==String(L"fromchars",9)){
																							return String(L"bb_std_lang.fromChars",21)+p_Bra(t_arg0);
																						}else{
																							if(t_1==String(L"sin",3) || t_1==String(L"cos",3)){
																								return t_fmath+t_id+p_Bra(p_Bra(t_arg0)+String(L"*bb_std_lang.D2R",16));
																							}else{
																								if(t_1==String(L"tan",3)){
																									return String(L"(float)Math.",12)+t_id+p_Bra(p_Bra(t_arg0)+String(L"*bb_std_lang.D2R",16));
																								}else{
																									if(t_1==String(L"asin",4) || t_1==String(L"acos",4) || t_1==String(L"atan",4)){
																										return String(L"(float)",7)+p_Bra(String(L"Math.",5)+t_id+p_Bra(t_arg0)+String(L"*bb_std_lang.R2D",16));
																									}else{
																										if(t_1==String(L"atan2",5)){
																											return String(L"(float)",7)+p_Bra(String(L"Math.",5)+t_id+p_Bra(t_arg0+String(L",",1)+t_arg1)+String(L"*bb_std_lang.R2D",16));
																										}else{
																											if(t_1==String(L"sinr",4) || t_1==String(L"cosr",4)){
																												return t_fmath+t_id.Slice(0,-1)+p_Bra(t_arg0);
																											}else{
																												if(t_1==String(L"tanr",4)){
																													return String(L"(float)Math.",12)+t_id.Slice(0,-1)+p_Bra(t_arg0);
																												}else{
																													if(t_1==String(L"asinr",5) || t_1==String(L"acosr",5) || t_1==String(L"atanr",5)){
																														return String(L"(float)Math.",12)+t_id.Slice(0,-1)+p_Bra(t_arg0);
																													}else{
																														if(t_1==String(L"atan2r",6)){
																															return String(L"(float)Math.",12)+t_id.Slice(0,-1)+p_Bra(t_arg0+String(L",",1)+t_arg1);
																														}else{
																															if(t_1==String(L"sqrt",4) || t_1==String(L"floor",5) || t_1==String(L"ceil",4)){
																																return t_fmath+t_id+p_Bra(t_arg0);
																															}else{
																																if(t_1==String(L"log",3) || t_1==String(L"exp",3)){
																																	return String(L"(float)Math.",12)+t_id+p_Bra(t_arg0);
																																}else{
																																	if(t_1==String(L"pow",3)){
																																		return String(L"(float)Math.",12)+t_id+p_Bra(t_arg0+String(L",",1)+t_arg1);
																																	}
																																}
																															}
																														}
																													}
																												}
																											}
																										}
																									}
																								}
																							}
																						}
																					}
																				}
																			}
																		}
																	}
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
	bb_config_InternalErr(String(L"Internal error",14));
	return String();
}
String c_JavaTranslator::p_TransTryStmt(c_TryStmt* t_stmt){
	p_Emit(String(L"try{",4));
	int t_unr=p_EmitBlock(t_stmt->m_block,true);
	Array<c_CatchStmt* > t_=t_stmt->m_catches;
	int t_2=0;
	while(t_2<t_.Length()){
		c_CatchStmt* t_c=t_[t_2];
		t_2=t_2+1;
		p_MungDecl(t_c->m_init);
		p_Emit(String(L"}catch(",7)+p_TransType(t_c->m_init->m_type)+String(L" ",1)+t_c->m_init->m_munged+String(L"){",2));
		int t_unr2=p_EmitBlock(t_c->m_block,true);
	}
	p_Emit(String(L"}",1));
	return String();
}
void c_JavaTranslator::mark(){
	c_CTranslator::mark();
}
bool bb_transcc_MatchPathAlt(String t_text,String t_alt){
	if(!t_alt.Contains(String(L"*",1))){
		return t_alt==t_text;
	}
	Array<String > t_bits=t_alt.Split(String(L"*",1));
	if(!t_text.StartsWith(t_bits[0])){
		return false;
	}
	int t_n=t_bits.Length()-1;
	int t_i=t_bits[0].Length();
	for(int t_j=1;t_j<t_n;t_j=t_j+1){
		String t_bit=t_bits[t_j];
		t_i=t_text.Find(t_bit,t_i);
		if(t_i==-1){
			return false;
		}
		t_i+=t_bit.Length();
	}
	return t_text.Slice(t_i).EndsWith(t_bits[t_n]);
}
bool bb_transcc_MatchPath(String t_text,String t_pattern){
	t_text=String(L"/",1)+t_text;
	Array<String > t_alts=t_pattern.Split(String(L"|",1));
	bool t_match=false;
	Array<String > t_=t_alts;
	int t_2=0;
	while(t_2<t_.Length()){
		String t_alt=t_[t_2];
		t_2=t_2+1;
		if(!((t_alt).Length()!=0)){
			continue;
		}
		if(t_alt.StartsWith(String(L"!",1))){
			if(bb_transcc_MatchPathAlt(t_text,t_alt.Slice(1))){
				return false;
			}
		}else{
			if(bb_transcc_MatchPathAlt(t_text,t_alt)){
				t_match=true;
			}
		}
	}
	return t_match;
}
String bb_transcc_ReplaceBlock(String t_text,String t_tag,String t_repText,String t_mark){
	String t_beginTag=t_mark+String(L"${",2)+t_tag+String(L"_BEGIN}",7);
	int t_i=t_text.Find(t_beginTag,0);
	if(t_i==-1){
		bb_transcc_Die(String(L"Error updating target project - can't find block begin tag '",60)+t_tag+String(L"'. You may need to delete target .build directory.",50));
	}
	t_i+=t_beginTag.Length();
	while(t_i<t_text.Length() && (int)t_text[t_i-1]!=10){
		t_i+=1;
	}
	String t_endTag=t_mark+String(L"${",2)+t_tag+String(L"_END}",5);
	int t_i2=t_text.Find(t_endTag,t_i-1);
	if(t_i2==-1){
		bb_transcc_Die(String(L"Error updating target project - can't find block end tag '",58)+t_tag+String(L"'.",2));
	}
	if(!((t_repText).Length()!=0) || (int)t_repText[t_repText.Length()-1]==10){
		t_i2+=1;
	}
	return t_text.Slice(0,t_i)+t_repText+t_text.Slice(t_i2);
}
c_NodeEnumerator3::c_NodeEnumerator3(){
	m_node=0;
}
c_NodeEnumerator3* c_NodeEnumerator3::m_new(c_Node2* t_node){
	this->m_node=t_node;
	return this;
}
c_NodeEnumerator3* c_NodeEnumerator3::m_new2(){
	return this;
}
bool c_NodeEnumerator3::p_HasNext(){
	return m_node!=0;
}
c_Node2* c_NodeEnumerator3::p_NextObject(){
	c_Node2* t_t=m_node;
	m_node=m_node->p_NextNode();
	return t_t;
}
void c_NodeEnumerator3::mark(){
	Object::mark();
}
String bb_config_Enquote(String t_str,String t_lang){
	String t_1=t_lang;
	if(t_1==String(L"cpp",3) || t_1==String(L"java",4) || t_1==String(L"as",2) || t_1==String(L"js",2) || t_1==String(L"cs",2)){
		t_str=t_str.Replace(String(L"\\",1),String(L"\\\\",2));
		t_str=t_str.Replace(String(L"\"",1),String(L"\\\"",2));
		t_str=t_str.Replace(String(L"\n",1),String(L"\\n",2));
		t_str=t_str.Replace(String(L"\r",1),String(L"\\r",2));
		t_str=t_str.Replace(String(L"\t",1),String(L"\\t",2));
		for(int t_i=0;t_i<t_str.Length();t_i=t_i+1){
			if((int)t_str[t_i]>=32 && (int)t_str[t_i]<128){
				continue;
			}
			String t_t=String();
			int t_n=(int)t_str[t_i];
			while((t_n)!=0){
				int t_c=(t_n&15)+48;
				if(t_c>=58){
					t_c+=39;
				}
				t_t=String((Char)(t_c),1)+t_t;
				t_n=t_n>>4&268435455;
			}
			if(!((t_t).Length()!=0)){
				t_t=String(L"0",1);
			}
			String t_2=t_lang;
			if(t_2==String(L"cpp",3)){
				t_t=String(L"\" L\"\\x",6)+t_t+String(L"\" L\"",4);
			}else{
				t_t=String(L"\\u",2)+(String(L"0000",4)+t_t).Slice(-4);
			}
			t_str=t_str.Slice(0,t_i)+t_t+t_str.Slice(t_i+1);
			t_i+=t_t.Length()-1;
		}
		String t_3=t_lang;
		if(t_3==String(L"cpp",3)){
			t_str=String(L"L\"",2)+t_str+String(L"\"",1);
		}else{
			t_str=String(L"\"",1)+t_str+String(L"\"",1);
		}
		return t_str;
	}
	bb_config_InternalErr(String(L"Internal error",14));
	return String();
}
c_CppTranslator::c_CppTranslator(){
	m_unsafe=false;
	m_gc_mode=0;
	m_dbgLocals=(new c_Stack10)->m_new();
	m_lastDbgInfo=String();
	m_pure=0;
}
c_CppTranslator* c_CppTranslator::m_new(){
	c_CTranslator::m_new();
	return this;
}
String c_CppTranslator::p_TransType(c_Type* t_ty){
	if((dynamic_cast<c_VoidType*>(t_ty))!=0){
		return String(L"void",4);
	}
	if((dynamic_cast<c_BoolType*>(t_ty))!=0){
		return String(L"bool",4);
	}
	if((dynamic_cast<c_IntType*>(t_ty))!=0){
		return String(L"int",3);
	}
	if((dynamic_cast<c_FloatType*>(t_ty))!=0){
		return String(L"Float",5);
	}
	if((dynamic_cast<c_StringType*>(t_ty))!=0){
		return String(L"String",6);
	}
	if((dynamic_cast<c_ArrayType*>(t_ty))!=0){
		return String(L"Array<",6)+p_TransRefType(dynamic_cast<c_ArrayType*>(t_ty)->m_elemType)+String(L" >",2);
	}
	if((dynamic_cast<c_ObjectType*>(t_ty))!=0){
		return t_ty->p_GetClass()->m_munged+String(L"*",1);
	}
	bb_config_InternalErr(String(L"Internal error",14));
	return String();
}
String c_CppTranslator::p_TransRefType(c_Type* t_ty){
	return p_TransType(t_ty);
}
String c_CppTranslator::p_TransValue(c_Type* t_ty,String t_value){
	if((t_value).Length()!=0){
		if((dynamic_cast<c_BoolType*>(t_ty))!=0){
			return String(L"true",4);
		}
		if((dynamic_cast<c_IntType*>(t_ty))!=0){
			return t_value;
		}
		if((dynamic_cast<c_FloatType*>(t_ty))!=0){
			return String(L"FLOAT(",6)+t_value+String(L")",1);
		}
		if((dynamic_cast<c_StringType*>(t_ty))!=0){
			return String(L"String(",7)+p_Enquote(t_value)+String(L",",1)+String(t_value.Length())+String(L")",1);
		}
	}else{
		if((dynamic_cast<c_BoolType*>(t_ty))!=0){
			return String(L"false",5);
		}
		if((dynamic_cast<c_NumericType*>(t_ty))!=0){
			return String(L"0",1);
		}
		if((dynamic_cast<c_StringType*>(t_ty))!=0){
			return String(L"String()",8);
		}
		if((dynamic_cast<c_ArrayType*>(t_ty))!=0){
			return String(L"Array<",6)+p_TransRefType(dynamic_cast<c_ArrayType*>(t_ty)->m_elemType)+String(L" >()",4);
		}
		if((dynamic_cast<c_ObjectType*>(t_ty))!=0){
			return String(L"0",1);
		}
	}
	bb_config_InternalErr(String(L"Internal error",14));
	return String();
}
c_Expr* c_CppTranslator::p_Uncast(c_Expr* t_expr){
	do{
		c_CastExpr* t_cexpr=dynamic_cast<c_CastExpr*>(t_expr);
		if(!((t_cexpr)!=0)){
			return t_expr;
		}
		t_expr=t_cexpr->m_expr;
	}while(!(false));
}
bool c_CppTranslator::p_IsGcObject(c_Expr* t_expr){
	t_expr=p_Uncast(t_expr);
	if((dynamic_cast<c_ConstExpr*>(t_expr))!=0){
		return false;
	}
	if(!((dynamic_cast<c_ObjectType*>(t_expr->m_exprType))!=0) && !((dynamic_cast<c_ArrayType*>(t_expr->m_exprType))!=0)){
		return false;
	}
	if(((dynamic_cast<c_ObjectType*>(t_expr->m_exprType))!=0) && !((t_expr->m_exprType->p_GetClass()->p_ExtendsObject())!=0)){
		return false;
	}
	return true;
}
String c_CppTranslator::p_GcRetain(c_Expr* t_expr,String t_texpr){
	if(!((t_texpr).Length()!=0)){
		t_texpr=t_expr->p_Trans();
	}
	if(m_unsafe || m_gc_mode!=2 || !p_IsGcObject(t_expr)){
		return t_texpr;
	}
	t_expr=p_Uncast(t_expr);
	if(((dynamic_cast<c_NewObjectExpr*>(t_expr))!=0) || ((dynamic_cast<c_NewArrayExpr*>(t_expr))!=0) || ((dynamic_cast<c_ArrayExpr*>(t_expr))!=0)){
		return t_texpr;
	}
	if(((dynamic_cast<c_VarExpr*>(t_expr))!=0) && ((dynamic_cast<c_LocalDecl*>(dynamic_cast<c_VarExpr*>(t_expr)->m_decl))!=0)){
		return t_texpr;
	}
	return String(L"gc_retain(",10)+t_texpr+String(L")",1);
}
String c_CppTranslator::p_TransLocalDecl(String t_munged,c_Expr* t_init){
	String t_tinit=p_GcRetain(t_init,String());
	return p_TransType(t_init->m_exprType)+String(L" ",1)+t_munged+String(L"=",1)+t_tinit;
}
int c_CppTranslator::p_BeginLocalScope(){
	c_CTranslator::p_BeginLocalScope();
	return 0;
}
int c_CppTranslator::p_EndLocalScope(){
	c_CTranslator::p_EndLocalScope();
	m_dbgLocals->p_Clear();
	m_lastDbgInfo=String();
	return 0;
}
int c_CppTranslator::p_EmitEnter(c_FuncDecl* t_func){
	if(m_unsafe){
		return 0;
	}
	String t_id=t_func->m_ident;
	if((dynamic_cast<c_ClassDecl*>(t_func->m_scope))!=0){
		t_id=t_func->m_scope->m_ident+String(L".",1)+t_id;
	}
	p_Emit(String(L"DBG_ENTER(\"",11)+t_id+String(L"\")",2));
	if(t_func->p_IsCtor() || t_func->p_IsMethod()){
		p_Emit(t_func->m_scope->m_munged+String(L" *self=this;",12));
		p_Emit(String(L"DBG_LOCAL(self,\"Self\")",22));
	}
	return 0;
}
int c_CppTranslator::p_EmitEnterBlock(){
	if(m_unsafe){
		return 0;
	}
	p_Emit(String(L"DBG_BLOCK();",12));
	return 0;
}
bool c_CppTranslator::p_IsDebuggable(c_Type* t_type){
	return true;
}
int c_CppTranslator::p_EmitSetErr(String t_info){
	if(m_unsafe){
		return 0;
	}
	if(t_info==m_lastDbgInfo){
		return 0;
	}
	m_lastDbgInfo=t_info;
	c_Enumerator8* t_=m_dbgLocals->p_ObjectEnumerator();
	while(t_->p_HasNext()){
		c_LocalDecl* t_decl=t_->p_NextObject();
		if(((t_decl->m_ident).Length()!=0) && p_IsDebuggable(t_decl->m_type)){
			p_Emit(String(L"DBG_LOCAL(",10)+t_decl->m_munged+String(L",\"",2)+t_decl->m_ident+String(L"\")",2));
		}
	}
	m_dbgLocals->p_Clear();
	p_Emit(String(L"DBG_INFO(\"",10)+t_info.Replace(String(L"\\",1),String(L"/",1))+String(L"\");",3));
	return 0;
}
int c_CppTranslator::p_EmitLeaveBlock(){
	m_dbgLocals->p_Clear();
	return 0;
}
String c_CppTranslator::p_TransStatic(c_Decl* t_decl){
	if(((t_decl->p_IsExtern())!=0) && ((dynamic_cast<c_ModuleDecl*>(t_decl->m_scope))!=0)){
		return t_decl->m_munged;
	}else{
		if(((bb_decl__env)!=0) && ((t_decl->m_scope)!=0) && t_decl->m_scope==(bb_decl__env->p_ClassScope())){
			return t_decl->m_munged;
		}else{
			if((dynamic_cast<c_ClassDecl*>(t_decl->m_scope))!=0){
				return t_decl->m_scope->m_munged+String(L"::",2)+t_decl->m_munged;
			}else{
				if((dynamic_cast<c_ModuleDecl*>(t_decl->m_scope))!=0){
					return t_decl->m_munged;
				}
			}
		}
	}
	bb_config_InternalErr(String(L"Internal error",14));
	return String();
}
String c_CppTranslator::p_TransGlobal(c_GlobalDecl* t_decl){
	return p_TransStatic(t_decl);
}
int c_CppTranslator::p_EmitFuncProto(c_FuncDecl* t_decl){
	String t_args=String();
	Array<c_ArgDecl* > t_=t_decl->m_argDecls;
	int t_2=0;
	while(t_2<t_.Length()){
		c_ArgDecl* t_arg=t_[t_2];
		t_2=t_2+1;
		if((t_args).Length()!=0){
			t_args=t_args+String(L",",1);
		}
		t_args=t_args+p_TransType(t_arg->m_type);
	}
	String t_t=p_TransType(t_decl->m_retType)+String(L" ",1)+t_decl->m_munged+p_Bra(t_args);
	if((t_decl->p_IsAbstract())!=0){
		t_t=t_t+String(L"=0",2);
	}
	String t_q=String();
	if(t_decl->p_IsMethod() && t_decl->p_IsVirtual() && !((t_decl->m_overrides)!=0)){
		t_q=t_q+String(L"virtual ",8);
	}else{
		if(t_decl->p_IsStatic() && ((t_decl->p_ClassScope())!=0)){
			t_q=t_q+String(L"static ",7);
		}
	}
	p_Emit(t_q+t_t+String(L";",1));
	return 0;
}
int c_CppTranslator::p_EmitClassProto(c_ClassDecl* t_classDecl){
	String t_classid=t_classDecl->m_munged;
	String t_superid=t_classDecl->m_superClass->m_munged;
	if((t_classDecl->p_IsInterface())!=0){
		String t_bases=String();
		Array<c_ClassDecl* > t_=t_classDecl->m_implments;
		int t_2=0;
		while(t_2<t_.Length()){
			c_ClassDecl* t_iface=t_[t_2];
			t_2=t_2+1;
			if((t_bases).Length()!=0){
				t_bases=t_bases+String(L",",1);
			}else{
				t_bases=String(L" : ",3);
			}
			t_bases=t_bases+(String(L"public virtual ",15)+t_iface->m_munged);
		}
		if(!((t_bases).Length()!=0)){
			t_bases=String(L" : public virtual gc_interface",30);
		}
		p_Emit(String(L"class ",6)+t_classid+t_bases+String(L"{",1));
		p_Emit(String(L"public:",7));
		c_Enumerator3* t_3=t_classDecl->p_Semanted()->p_ObjectEnumerator();
		while(t_3->p_HasNext()){
			c_Decl* t_decl=t_3->p_NextObject();
			c_FuncDecl* t_fdecl=dynamic_cast<c_FuncDecl*>(t_decl);
			if(!((t_fdecl)!=0)){
				continue;
			}
			p_EmitFuncProto(t_fdecl);
		}
		p_Emit(String(L"};",2));
		return 0;
	}
	String t_bases2=String(L" : public ",10)+t_superid;
	Array<c_ClassDecl* > t_4=t_classDecl->m_implments;
	int t_5=0;
	while(t_5<t_4.Length()){
		c_ClassDecl* t_iface2=t_4[t_5];
		t_5=t_5+1;
		t_bases2=t_bases2+(String(L",public virtual ",16)+t_iface2->m_munged);
	}
	p_Emit(String(L"class ",6)+t_classid+t_bases2+String(L"{",1));
	p_Emit(String(L"public:",7));
	c_Enumerator3* t_6=t_classDecl->p_Semanted()->p_ObjectEnumerator();
	while(t_6->p_HasNext()){
		c_Decl* t_decl2=t_6->p_NextObject();
		c_FieldDecl* t_fdecl2=dynamic_cast<c_FieldDecl*>(t_decl2);
		if((t_fdecl2)!=0){
			p_Emit(p_TransRefType(t_fdecl2->m_type)+String(L" ",1)+t_fdecl2->m_munged+String(L";",1));
			continue;
		}
	}
	p_Emit(t_classid+String(L"();",3));
	c_Enumerator3* t_7=t_classDecl->p_Semanted()->p_ObjectEnumerator();
	while(t_7->p_HasNext()){
		c_Decl* t_decl3=t_7->p_NextObject();
		c_FuncDecl* t_fdecl3=dynamic_cast<c_FuncDecl*>(t_decl3);
		if((t_fdecl3)!=0){
			p_EmitFuncProto(t_fdecl3);
			continue;
		}
		c_GlobalDecl* t_gdecl=dynamic_cast<c_GlobalDecl*>(t_decl3);
		if((t_gdecl)!=0){
			p_Emit(String(L"static ",7)+p_TransRefType(t_gdecl->m_type)+String(L" ",1)+t_gdecl->m_munged+String(L";",1));
			continue;
		}
	}
	p_Emit(String(L"void mark();",12));
	if(bb_config_ENV_CONFIG==String(L"debug",5)){
		p_Emit(String(L"String debug();",15));
	}
	p_Emit(String(L"};",2));
	if(bb_config_ENV_CONFIG==String(L"debug",5)){
		p_Emit(String(L"String dbg_type(",16)+t_classid+String(L"**p){return \"",13)+t_classDecl->m_ident+String(L"\";}",3));
	}
	return 0;
}
int c_CppTranslator::p_BeginLoop(){
	if(m_gc_mode!=2){
		return 0;
	}
	p_Emit(String(L"GC_ENTER",8));
	return 0;
}
int c_CppTranslator::p_EndLoop(){
	if(m_gc_mode!=2){
		return 0;
	}
	return 0;
}
int c_CppTranslator::p_EmitFuncDecl(c_FuncDecl* t_decl){
	if((t_decl->p_IsAbstract())!=0){
		return 0;
	}
	m_unsafe=t_decl->m_ident.EndsWith(String(L"__UNSAFE__",10));
	p_BeginLocalScope();
	String t_args=String();
	Array<c_ArgDecl* > t_=t_decl->m_argDecls;
	int t_2=0;
	while(t_2<t_.Length()){
		c_ArgDecl* t_arg=t_[t_2];
		t_2=t_2+1;
		p_MungDecl(t_arg);
		if((t_args).Length()!=0){
			t_args=t_args+String(L",",1);
		}
		t_args=t_args+(p_TransType(t_arg->m_type)+String(L" ",1)+t_arg->m_munged);
		m_dbgLocals->p_Push28(t_arg);
	}
	String t_id=t_decl->m_munged;
	if((t_decl->p_ClassScope())!=0){
		t_id=t_decl->p_ClassScope()->m_munged+String(L"::",2)+t_id;
	}
	p_Emit(p_TransType(t_decl->m_retType)+String(L" ",1)+t_id+p_Bra(t_args)+String(L"{",1));
	p_BeginLoop();
	p_EmitBlock((t_decl),true);
	p_EndLoop();
	p_Emit(String(L"}",1));
	p_EndLocalScope();
	m_unsafe=false;
	return 0;
}
String c_CppTranslator::p_TransField(c_FieldDecl* t_decl,c_Expr* t_lhs){
	if((t_lhs)!=0){
		return p_TransSubExpr(t_lhs,2)+String(L"->",2)+t_decl->m_munged;
	}
	return t_decl->m_munged;
}
int c_CppTranslator::p_EmitMark(String t_id,c_Type* t_ty,bool t_queue){
	if(m_gc_mode==0){
		return 0;
	}
	if(!((dynamic_cast<c_ObjectType*>(t_ty))!=0) && !((dynamic_cast<c_ArrayType*>(t_ty))!=0)){
		return 0;
	}
	if(((dynamic_cast<c_ObjectType*>(t_ty))!=0) && !((t_ty->p_GetClass()->p_ExtendsObject())!=0)){
		return 0;
	}
	if(t_queue){
		p_Emit(String(L"gc_mark_q(",10)+t_id+String(L");",2));
	}else{
		p_Emit(String(L"gc_mark(",8)+t_id+String(L");",2));
	}
	return 0;
}
int c_CppTranslator::p_EmitClassDecl(c_ClassDecl* t_classDecl){
	if((t_classDecl->p_IsInterface())!=0){
		return 0;
	}
	String t_classid=t_classDecl->m_munged;
	String t_superid=t_classDecl->m_superClass->m_munged;
	p_BeginLocalScope();
	p_Emit(t_classid+String(L"::",2)+t_classid+String(L"(){",3));
	if(m_gc_mode==2){
		p_Emit(String(L"GC_CTOR",7));
	}
	c_Enumerator3* t_=t_classDecl->p_Semanted()->p_ObjectEnumerator();
	while(t_->p_HasNext()){
		c_Decl* t_decl=t_->p_NextObject();
		c_FieldDecl* t_fdecl=dynamic_cast<c_FieldDecl*>(t_decl);
		if(!((t_fdecl)!=0)){
			continue;
		}
		p_Emit(p_TransField(t_fdecl,0)+String(L"=",1)+t_fdecl->m_init->p_Trans()+String(L";",1));
	}
	p_Emit(String(L"}",1));
	p_EndLocalScope();
	c_Enumerator3* t_2=t_classDecl->p_Semanted()->p_ObjectEnumerator();
	while(t_2->p_HasNext()){
		c_Decl* t_decl2=t_2->p_NextObject();
		c_FuncDecl* t_fdecl2=dynamic_cast<c_FuncDecl*>(t_decl2);
		if((t_fdecl2)!=0){
			p_EmitFuncDecl(t_fdecl2);
			continue;
		}
		c_GlobalDecl* t_gdecl=dynamic_cast<c_GlobalDecl*>(t_decl2);
		if((t_gdecl)!=0){
			p_Emit(p_TransRefType(t_gdecl->m_type)+String(L" ",1)+t_classid+String(L"::",2)+t_gdecl->m_munged+String(L";",1));
			continue;
		}
	}
	p_Emit(String(L"void ",5)+t_classid+String(L"::mark(){",9));
	if((t_classDecl->m_superClass)!=0){
		p_Emit(t_classDecl->m_superClass->m_munged+String(L"::mark();",9));
	}
	c_Enumerator3* t_3=t_classDecl->p_Semanted()->p_ObjectEnumerator();
	while(t_3->p_HasNext()){
		c_Decl* t_decl3=t_3->p_NextObject();
		c_FieldDecl* t_fdecl3=dynamic_cast<c_FieldDecl*>(t_decl3);
		if((t_fdecl3)!=0){
			p_EmitMark(p_TransField(t_fdecl3,0),t_fdecl3->m_type,true);
		}
	}
	p_Emit(String(L"}",1));
	if(bb_config_ENV_CONFIG==String(L"debug",5)){
		p_Emit(String(L"String ",7)+t_classid+String(L"::debug(){",10));
		p_Emit(String(L"String t=\"(",11)+t_classDecl->m_ident+String(L")\\n\";",5));
		if(((t_classDecl->m_superClass)!=0) && !((t_classDecl->m_superClass->p_IsExtern())!=0)){
			p_Emit(String(L"t=",2)+t_classDecl->m_superClass->m_munged+String(L"::debug()+t;",12));
		}
		c_Enumerator3* t_4=t_classDecl->p_Decls()->p_ObjectEnumerator();
		while(t_4->p_HasNext()){
			c_Decl* t_decl4=t_4->p_NextObject();
			if(!((t_decl4->p_IsSemanted())!=0)){
				continue;
			}
			c_VarDecl* t_vdecl=dynamic_cast<c_VarDecl*>(t_decl4);
			if(!((t_vdecl)!=0)){
				continue;
			}
			if(!p_IsDebuggable(t_vdecl->m_type)){
				continue;
			}
			if((dynamic_cast<c_FieldDecl*>(t_decl4))!=0){
				p_Emit(String(L"t+=dbg_decl(\"",13)+t_decl4->m_ident+String(L"\",&",3)+t_decl4->m_munged+String(L");",2));
			}else{
				if((dynamic_cast<c_GlobalDecl*>(t_decl4))!=0){
					p_Emit(String(L"t+=dbg_decl(\"",13)+t_decl4->m_ident+String(L"\",&",3)+t_classDecl->m_munged+String(L"::",2)+t_decl4->m_munged+String(L");",2));
				}
			}
		}
		p_Emit(String(L"return t;",9));
		p_Emit(String(L"}",1));
	}
	return 0;
}
String c_CppTranslator::p_TransApp(c_AppDecl* t_app){
	if(!((bb_config_GetConfigVar(String(L"CPP_GC_MODE",11))).Length()!=0)){
		bb_config_SetConfigVar(String(L"CPP_GC_MODE",11),String(L"1",1),(c_Type::m_boolType));
	}
	m_gc_mode=(bb_config_GetConfigVar(String(L"CPP_GC_MODE",11))).ToInt();
	t_app->m_mainFunc->m_munged=String(L"bbMain",6);
	c_ValueEnumerator* t_=t_app->m_imported->p_Values()->p_ObjectEnumerator();
	while(t_->p_HasNext()){
		c_ModuleDecl* t_decl=t_->p_NextObject();
		p_MungDecl(t_decl);
	}
	c_Enumerator3* t_2=t_app->p_Semanted()->p_ObjectEnumerator();
	while(t_2->p_HasNext()){
		c_Decl* t_decl2=t_2->p_NextObject();
		p_MungDecl(t_decl2);
		c_ClassDecl* t_cdecl=dynamic_cast<c_ClassDecl*>(t_decl2);
		if(!((t_cdecl)!=0)){
			continue;
		}
		p_Emit(String(L"class ",6)+t_decl2->m_munged+String(L";",1));
		c_Enumerator3* t_3=t_cdecl->p_Semanted()->p_ObjectEnumerator();
		while(t_3->p_HasNext()){
			c_Decl* t_decl3=t_3->p_NextObject();
			p_MungDecl(t_decl3);
		}
	}
	c_Enumerator3* t_4=t_app->p_Semanted()->p_ObjectEnumerator();
	while(t_4->p_HasNext()){
		c_Decl* t_decl4=t_4->p_NextObject();
		c_GlobalDecl* t_gdecl=dynamic_cast<c_GlobalDecl*>(t_decl4);
		if((t_gdecl)!=0){
			p_Emit(String(L"extern ",7)+p_TransRefType(t_gdecl->m_type)+String(L" ",1)+t_gdecl->m_munged+String(L";",1));
			continue;
		}
		c_FuncDecl* t_fdecl=dynamic_cast<c_FuncDecl*>(t_decl4);
		if((t_fdecl)!=0){
			p_EmitFuncProto(t_fdecl);
			continue;
		}
		c_ClassDecl* t_cdecl2=dynamic_cast<c_ClassDecl*>(t_decl4);
		if((t_cdecl2)!=0){
			p_EmitClassProto(t_cdecl2);
			continue;
		}
	}
	c_Enumerator3* t_5=t_app->m_allSemantedDecls->p_ObjectEnumerator();
	while(t_5->p_HasNext()){
		c_Decl* t_decl5=t_5->p_NextObject();
		c_ClassDecl* t_cdecl3=dynamic_cast<c_ClassDecl*>(t_decl5);
		if(!((t_cdecl3)!=0) || ((t_cdecl3->p_ExtendsObject())!=0) || t_cdecl3->m_munged==String(L"String",6) || t_cdecl3->m_munged==String(L"Array",5)){
			continue;
		}
		p_Emit(String(L"void gc_mark( ",14)+t_cdecl3->m_munged+String(L" *p ){}",7));
		if(bb_config_ENV_CONFIG==String(L"debug",5)){
			p_Emit(String(L"String dbg_type( ",17)+t_cdecl3->m_munged+String(L" **p ){ return \"",16)+t_decl5->m_ident+String(L"\"; }",4));
			p_Emit(String(L"String dbg_value( ",18)+t_cdecl3->m_munged+String(L" **p ){ return dbg_ptr_value( *p ); }",37));
		}
	}
	c_Enumerator3* t_6=t_app->p_Semanted()->p_ObjectEnumerator();
	while(t_6->p_HasNext()){
		c_Decl* t_decl6=t_6->p_NextObject();
		c_GlobalDecl* t_gdecl2=dynamic_cast<c_GlobalDecl*>(t_decl6);
		if((t_gdecl2)!=0){
			p_Emit(p_TransRefType(t_gdecl2->m_type)+String(L" ",1)+t_gdecl2->m_munged+String(L";",1));
			continue;
		}
		c_FuncDecl* t_fdecl2=dynamic_cast<c_FuncDecl*>(t_decl6);
		if((t_fdecl2)!=0){
			p_EmitFuncDecl(t_fdecl2);
			continue;
		}
		c_ClassDecl* t_cdecl4=dynamic_cast<c_ClassDecl*>(t_decl6);
		if((t_cdecl4)!=0){
			p_EmitClassDecl(t_cdecl4);
			continue;
		}
	}
	p_BeginLocalScope();
	p_Emit(String(L"int bbInit(){",13));
	p_Emit(String(L"GC_CTOR",7));
	c_Enumerator7* t_7=t_app->m_semantedGlobals->p_ObjectEnumerator();
	while(t_7->p_HasNext()){
		c_GlobalDecl* t_decl7=t_7->p_NextObject();
		String t_munged=p_TransGlobal(t_decl7);
		p_Emit(t_munged+String(L"=",1)+t_decl7->m_init->p_Trans()+String(L";",1));
		if(bb_config_ENV_CONFIG==String(L"debug",5) && p_IsDebuggable(t_decl7->m_type)){
			p_Emit(String(L"DBG_GLOBAL(\"",12)+t_decl7->m_ident+String(L"\",&",3)+t_munged+String(L");",2));
		}
	}
	p_Emit(String(L"return 0;",9));
	p_Emit(String(L"}",1));
	p_EndLocalScope();
	p_Emit(String(L"void gc_mark(){",15));
	c_Enumerator7* t_8=t_app->m_semantedGlobals->p_ObjectEnumerator();
	while(t_8->p_HasNext()){
		c_GlobalDecl* t_decl8=t_8->p_NextObject();
		p_EmitMark(p_TransGlobal(t_decl8),t_decl8->m_type,true);
	}
	p_Emit(String(L"}",1));
	return p_JoinLines();
}
int c_CppTranslator::p_CheckSafe(c_Decl* t_decl){
	if(!m_unsafe || ((t_decl->p_IsExtern())!=0) || t_decl->m_ident.EndsWith(String(L"__UNSAFE__",10))){
		return 0;
	}
	bb_config_Err(String(L"Unsafe call!!!!!",16));
	return 0;
}
String c_CppTranslator::p_TransArgs2(Array<c_Expr* > t_args,c_FuncDecl* t_decl){
	String t_t=String();
	Array<c_Expr* > t_=t_args;
	int t_2=0;
	while(t_2<t_.Length()){
		c_Expr* t_arg=t_[t_2];
		t_2=t_2+1;
		if((t_t).Length()!=0){
			t_t=t_t+String(L",",1);
		}
		String t_targ=p_GcRetain(t_arg,String());
		t_t=t_t+t_targ;
	}
	return p_Bra(t_t);
}
String c_CppTranslator::p_TransFunc(c_FuncDecl* t_decl,Array<c_Expr* > t_args,c_Expr* t_lhs){
	m_pure=0;
	p_CheckSafe(t_decl);
	if(t_decl->p_IsMethod()){
		if((t_lhs)!=0){
			return p_TransSubExpr(t_lhs,2)+String(L"->",2)+t_decl->m_munged+p_TransArgs2(t_args,t_decl);
		}
		return t_decl->m_munged+p_TransArgs2(t_args,t_decl);
	}
	return p_TransStatic(t_decl)+p_TransArgs2(t_args,t_decl);
}
String c_CppTranslator::p_TransSuperFunc(c_FuncDecl* t_decl,Array<c_Expr* > t_args){
	m_pure=0;
	p_CheckSafe(t_decl);
	return t_decl->p_ClassScope()->m_munged+String(L"::",2)+t_decl->m_munged+p_TransArgs2(t_args,t_decl);
}
String c_CppTranslator::p_TransConstExpr(c_ConstExpr* t_expr){
	return p_TransValue(t_expr->m_exprType,t_expr->m_value);
}
String c_CppTranslator::p_TransNewObjectExpr(c_NewObjectExpr* t_expr){
	m_pure=0;
	String t_t=String(L"(new ",5)+t_expr->m_classDecl->m_munged+String(L")",1);
	if((t_expr->m_ctor)!=0){
		t_t=t_t+(String(L"->",2)+t_expr->m_ctor->m_munged+p_TransArgs2(t_expr->m_args,t_expr->m_ctor));
	}
	return t_t;
}
String c_CppTranslator::p_TransNewArrayExpr(c_NewArrayExpr* t_expr){
	m_pure=0;
	String t_texpr=t_expr->m_expr->p_Trans();
	return String(L"Array<",6)+p_TransRefType(t_expr->m_ty)+String(L" >",2)+p_Bra(t_expr->m_expr->p_Trans());
}
String c_CppTranslator::p_TransSelfExpr(c_SelfExpr* t_expr){
	return String(L"this",4);
}
String c_CppTranslator::p_TransCastExpr(c_CastExpr* t_expr){
	String t_t=p_Bra(t_expr->m_expr->p_Trans());
	c_Type* t_dst=t_expr->m_exprType;
	c_Type* t_src=t_expr->m_expr->m_exprType;
	if((dynamic_cast<c_BoolType*>(t_dst))!=0){
		if((dynamic_cast<c_BoolType*>(t_src))!=0){
			return t_t;
		}
		if((dynamic_cast<c_IntType*>(t_src))!=0){
			return p_Bra(t_t+String(L"!=0",3));
		}
		if((dynamic_cast<c_FloatType*>(t_src))!=0){
			return p_Bra(t_t+String(L"!=0",3));
		}
		if((dynamic_cast<c_ArrayType*>(t_src))!=0){
			return p_Bra(t_t+String(L".Length()!=0",12));
		}
		if((dynamic_cast<c_StringType*>(t_src))!=0){
			return p_Bra(t_t+String(L".Length()!=0",12));
		}
		if((dynamic_cast<c_ObjectType*>(t_src))!=0){
			return p_Bra(t_t+String(L"!=0",3));
		}
	}else{
		if((dynamic_cast<c_IntType*>(t_dst))!=0){
			if((dynamic_cast<c_BoolType*>(t_src))!=0){
				return p_Bra(t_t+String(L"?1:0",4));
			}
			if((dynamic_cast<c_IntType*>(t_src))!=0){
				return t_t;
			}
			if((dynamic_cast<c_FloatType*>(t_src))!=0){
				return String(L"int",3)+p_Bra(t_t);
			}
			if((dynamic_cast<c_StringType*>(t_src))!=0){
				return t_t+String(L".ToInt()",8);
			}
		}else{
			if((dynamic_cast<c_FloatType*>(t_dst))!=0){
				if((dynamic_cast<c_IntType*>(t_src))!=0){
					return String(L"Float",5)+p_Bra(t_t);
				}
				if((dynamic_cast<c_FloatType*>(t_src))!=0){
					return t_t;
				}
				if((dynamic_cast<c_StringType*>(t_src))!=0){
					return t_t+String(L".ToFloat()",10);
				}
			}else{
				if((dynamic_cast<c_StringType*>(t_dst))!=0){
					if((dynamic_cast<c_IntType*>(t_src))!=0){
						return String(L"String",6)+p_Bra(t_t);
					}
					if((dynamic_cast<c_FloatType*>(t_src))!=0){
						return String(L"String",6)+p_Bra(t_t);
					}
					if((dynamic_cast<c_StringType*>(t_src))!=0){
						return t_t;
					}
				}else{
					if(((dynamic_cast<c_ObjectType*>(t_dst))!=0) && ((dynamic_cast<c_ObjectType*>(t_src))!=0)){
						if(((t_src->p_GetClass()->p_IsInterface())!=0) && !((t_dst->p_GetClass()->p_IsInterface())!=0)){
							return String(L"dynamic_cast<",13)+p_TransType(t_dst)+String(L">",1)+p_Bra(t_t);
						}else{
							if((t_src->p_GetClass()->p_ExtendsClass(t_dst->p_GetClass()))!=0){
								return t_t;
							}else{
								return String(L"dynamic_cast<",13)+p_TransType(t_dst)+String(L">",1)+p_Bra(t_t);
							}
						}
					}
				}
			}
		}
	}
	bb_config_Err(String(L"C++ translator can't convert ",29)+t_src->p_ToString()+String(L" to ",4)+t_dst->p_ToString());
	return String();
}
String c_CppTranslator::p_TransUnaryExpr(c_UnaryExpr* t_expr){
	int t_pri=p_ExprPri(t_expr);
	String t_t_expr=p_TransSubExpr(t_expr->m_expr,t_pri);
	return p_TransUnaryOp(t_expr->m_op)+t_t_expr;
}
String c_CppTranslator::p_TransBinaryExpr(c_BinaryExpr* t_expr){
	int t_pri=p_ExprPri(t_expr);
	String t_t_lhs=p_TransSubExpr(t_expr->m_lhs,t_pri);
	String t_t_rhs=p_TransSubExpr(t_expr->m_rhs,t_pri-1);
	if(t_expr->m_op==String(L"mod",3) && ((dynamic_cast<c_FloatType*>(t_expr->m_exprType))!=0)){
		return String(L"(Float)fmod(",12)+t_t_lhs+String(L",",1)+t_t_rhs+String(L")",1);
	}
	return t_t_lhs+p_TransBinaryOp(t_expr->m_op,t_t_rhs)+t_t_rhs;
}
String c_CppTranslator::p_TransIndexExpr(c_IndexExpr* t_expr){
	String t_t_expr=p_TransSubExpr(t_expr->m_expr,2);
	String t_t_index=t_expr->m_index->p_Trans();
	if((dynamic_cast<c_StringType*>(t_expr->m_expr->m_exprType))!=0){
		if(bb_config_ENV_CONFIG==String(L"debug",5)){
			return String(L"(int)",5)+t_t_expr+String(L".At(",4)+t_t_index+String(L")",1);
		}
		return String(L"(int)",5)+t_t_expr+String(L"[",1)+t_t_index+String(L"]",1);
	}
	if(bb_config_ENV_CONFIG==String(L"debug",5)){
		return t_t_expr+String(L".At(",4)+t_t_index+String(L")",1);
	}
	return t_t_expr+String(L"[",1)+t_t_index+String(L"]",1);
}
String c_CppTranslator::p_TransSliceExpr(c_SliceExpr* t_expr){
	String t_t_expr=p_TransSubExpr(t_expr->m_expr,2);
	String t_t_args=String(L"0",1);
	if((t_expr->m_from)!=0){
		t_t_args=t_expr->m_from->p_Trans();
	}
	if((t_expr->m_term)!=0){
		t_t_args=t_t_args+(String(L",",1)+t_expr->m_term->p_Trans());
	}
	return t_t_expr+String(L".Slice(",7)+t_t_args+String(L")",1);
}
String c_CppTranslator::p_TransArrayExpr(c_ArrayExpr* t_expr){
	m_pure=0;
	c_Type* t_elemType=dynamic_cast<c_ArrayType*>(t_expr->m_exprType)->m_elemType;
	String t_t=String();
	Array<c_Expr* > t_=t_expr->m_exprs;
	int t_2=0;
	while(t_2<t_.Length()){
		c_Expr* t_elem=t_[t_2];
		t_2=t_2+1;
		String t_e=t_elem->p_Trans();
		if((t_t).Length()!=0){
			t_t=t_t+String(L",",1);
		}
		t_t=t_t+t_e;
	}
	c_LocalDecl* t_tmp=(new c_LocalDecl)->m_new(String(),0,(c_Type::m_voidType),0);
	p_MungDecl(t_tmp);
	p_Emit(p_TransRefType(t_elemType)+String(L" ",1)+t_tmp->m_munged+String(L"[]={",4)+t_t+String(L"};",2));
	return String(L"Array<",6)+p_TransRefType(t_elemType)+String(L" >(",3)+t_tmp->m_munged+String(L",",1)+String(t_expr->m_exprs.Length())+String(L")",1);
}
String c_CppTranslator::p_TransIntrinsicExpr(c_Decl* t_decl,c_Expr* t_expr,Array<c_Expr* > t_args){
	m_pure=0;
	String t_texpr=String();
	String t_arg0=String();
	String t_arg1=String();
	String t_arg2=String();
	if((t_expr)!=0){
		t_texpr=p_TransSubExpr(t_expr,2);
	}
	if(t_args.Length()>0 && ((t_args[0])!=0)){
		t_arg0=t_args[0]->p_Trans();
	}
	if(t_args.Length()>1 && ((t_args[1])!=0)){
		t_arg1=t_args[1]->p_Trans();
	}
	if(t_args.Length()>2 && ((t_args[2])!=0)){
		t_arg2=t_args[2]->p_Trans();
	}
	String t_id=t_decl->m_munged.Slice(1);
	String t_id2=t_id.Slice(0,1).ToUpper()+t_id.Slice(1);
	String t_1=t_id;
	if(t_1==String(L"print",5)){
		return String(L"bbPrint",7)+p_Bra(t_arg0);
	}else{
		if(t_1==String(L"error",5)){
			return String(L"bbError",7)+p_Bra(t_arg0);
		}else{
			if(t_1==String(L"debuglog",8)){
				return String(L"bbDebugLog",10)+p_Bra(t_arg0);
			}else{
				if(t_1==String(L"debugstop",9)){
					return String(L"bbDebugStop()",13);
				}else{
					if(t_1==String(L"length",6)){
						return t_texpr+String(L".Length()",9);
					}else{
						if(t_1==String(L"resize",6)){
							return t_texpr+String(L".Resize",7)+p_Bra(t_arg0);
						}else{
							if(t_1==String(L"compare",7)){
								return t_texpr+String(L".Compare",8)+p_Bra(t_arg0);
							}else{
								if(t_1==String(L"find",4)){
									return t_texpr+String(L".Find",5)+p_Bra(t_arg0+String(L",",1)+t_arg1);
								}else{
									if(t_1==String(L"findlast",8)){
										return t_texpr+String(L".FindLast",9)+p_Bra(t_arg0);
									}else{
										if(t_1==String(L"findlast2",9)){
											return t_texpr+String(L".FindLast",9)+p_Bra(t_arg0+String(L",",1)+t_arg1);
										}else{
											if(t_1==String(L"trim",4)){
												return t_texpr+String(L".Trim()",7);
											}else{
												if(t_1==String(L"join",4)){
													return t_texpr+String(L".Join",5)+p_Bra(t_arg0);
												}else{
													if(t_1==String(L"split",5)){
														return t_texpr+String(L".Split",6)+p_Bra(t_arg0);
													}else{
														if(t_1==String(L"replace",7)){
															return t_texpr+String(L".Replace",8)+p_Bra(t_arg0+String(L",",1)+t_arg1);
														}else{
															if(t_1==String(L"tolower",7)){
																return t_texpr+String(L".ToLower()",10);
															}else{
																if(t_1==String(L"toupper",7)){
																	return t_texpr+String(L".ToUpper()",10);
																}else{
																	if(t_1==String(L"contains",8)){
																		return t_texpr+String(L".Contains",9)+p_Bra(t_arg0);
																	}else{
																		if(t_1==String(L"startswith",10)){
																			return t_texpr+String(L".StartsWith",11)+p_Bra(t_arg0);
																		}else{
																			if(t_1==String(L"endswith",8)){
																				return t_texpr+String(L".EndsWith",9)+p_Bra(t_arg0);
																			}else{
																				if(t_1==String(L"tochars",7)){
																					return t_texpr+String(L".ToChars()",10);
																				}else{
																					if(t_1==String(L"fromchar",8)){
																						return String(L"String",6)+p_Bra(String(L"(Char)",6)+p_Bra(t_arg0)+String(L",1",2));
																					}else{
																						if(t_1==String(L"fromchars",9)){
																							return String(L"String::FromChars",17)+p_Bra(t_arg0);
																						}else{
																							if(t_1==String(L"sin",3) || t_1==String(L"cos",3) || t_1==String(L"tan",3)){
																								return String(L"(Float)",7)+t_id+p_Bra(p_Bra(t_arg0)+String(L"*D2R",4));
																							}else{
																								if(t_1==String(L"asin",4) || t_1==String(L"acos",4) || t_1==String(L"atan",4)){
																									return String(L"(Float)",7)+p_Bra(t_id+p_Bra(t_arg0)+String(L"*R2D",4));
																								}else{
																									if(t_1==String(L"atan2",5)){
																										return String(L"(Float)",7)+p_Bra(t_id+p_Bra(t_arg0+String(L",",1)+t_arg1)+String(L"*R2D",4));
																									}else{
																										if(t_1==String(L"sinr",4) || t_1==String(L"cosr",4) || t_1==String(L"tanr",4)){
																											return String(L"(Float)",7)+t_id.Slice(0,-1)+p_Bra(t_arg0);
																										}else{
																											if(t_1==String(L"asinr",5) || t_1==String(L"acosr",5) || t_1==String(L"atanr",5)){
																												return String(L"(Float)",7)+t_id.Slice(0,-1)+p_Bra(t_arg0);
																											}else{
																												if(t_1==String(L"atan2r",6)){
																													return String(L"(Float)",7)+t_id.Slice(0,-1)+p_Bra(t_arg0+String(L",",1)+t_arg1);
																												}else{
																													if(t_1==String(L"sqrt",4) || t_1==String(L"floor",5) || t_1==String(L"ceil",4) || t_1==String(L"log",3) || t_1==String(L"exp",3)){
																														return String(L"(Float)",7)+t_id+p_Bra(t_arg0);
																													}else{
																														if(t_1==String(L"pow",3)){
																															return String(L"(Float)",7)+t_id+p_Bra(t_arg0+String(L",",1)+t_arg1);
																														}
																													}
																												}
																											}
																										}
																									}
																								}
																							}
																						}
																					}
																				}
																			}
																		}
																	}
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
	bb_config_InternalErr(String(L"Internal error",14));
	return String();
}
String c_CppTranslator::p_TransTryStmt(c_TryStmt* t_stmt){
	p_Emit(String(L"try{",4));
	int t_unr=p_EmitBlock(t_stmt->m_block,true);
	Array<c_CatchStmt* > t_=t_stmt->m_catches;
	int t_2=0;
	while(t_2<t_.Length()){
		c_CatchStmt* t_c=t_[t_2];
		t_2=t_2+1;
		p_MungDecl(t_c->m_init);
		p_Emit(String(L"}catch(",7)+p_TransType(t_c->m_init->m_type)+String(L" ",1)+t_c->m_init->m_munged+String(L"){",2));
		m_dbgLocals->p_Push28(t_c->m_init);
		int t_unr2=p_EmitBlock(t_c->m_block,true);
	}
	p_Emit(String(L"}",1));
	return String();
}
String c_CppTranslator::p_TransDeclStmt(c_DeclStmt* t_stmt){
	c_LocalDecl* t_decl=dynamic_cast<c_LocalDecl*>(t_stmt->m_decl);
	if((t_decl)!=0){
		if((t_decl->m_ident).Length()!=0){
			m_dbgLocals->p_Push28(t_decl);
		}
		p_MungDecl(t_decl);
		return p_TransLocalDecl(t_decl->m_munged,t_decl->m_init);
	}
	c_ConstDecl* t_cdecl=dynamic_cast<c_ConstDecl*>(t_stmt->m_decl);
	if((t_cdecl)!=0){
		return String();
	}
	bb_config_InternalErr(String(L"Internal error",14));
	return String();
}
bool c_CppTranslator::p_IsLocalVar(c_Expr* t_expr){
	t_expr=p_Uncast(t_expr);
	c_VarExpr* t_vexpr=dynamic_cast<c_VarExpr*>(t_expr);
	return ((t_vexpr)!=0) && ((dynamic_cast<c_LocalDecl*>(t_vexpr->m_decl))!=0);
}
String c_CppTranslator::p_TransAssignStmt2(c_AssignStmt* t_stmt){
	if(m_gc_mode==0 || t_stmt->m_op!=String(L"=",1) || !p_IsGcObject(t_stmt->m_rhs)){
		return c_CTranslator::p_TransAssignStmt2(t_stmt);
	}
	String t_tlhs=t_stmt->m_lhs->p_TransVar();
	String t_trhs=t_stmt->m_rhs->p_Trans();
	if(p_IsLocalVar(t_stmt->m_lhs)){
		return t_tlhs+String(L"=",1)+p_GcRetain(t_stmt->m_rhs,t_trhs);
	}
	return String(L"gc_assign(",10)+t_tlhs+String(L",",1)+t_trhs+String(L")",1);
}
void c_CppTranslator::mark(){
	c_CTranslator::mark();
}
c_JsTranslator::c_JsTranslator(){
}
c_JsTranslator* c_JsTranslator::m_new(){
	c_CTranslator::m_new();
	return this;
}
String c_JsTranslator::p_TransValue(c_Type* t_ty,String t_value){
	if((t_value).Length()!=0){
		if((dynamic_cast<c_BoolType*>(t_ty))!=0){
			return String(L"true",4);
		}
		if((dynamic_cast<c_NumericType*>(t_ty))!=0){
			return t_value;
		}
		if((dynamic_cast<c_StringType*>(t_ty))!=0){
			return p_Enquote(t_value);
		}
	}else{
		if((dynamic_cast<c_BoolType*>(t_ty))!=0){
			return String(L"false",5);
		}
		if((dynamic_cast<c_NumericType*>(t_ty))!=0){
			return String(L"0",1);
		}
		if((dynamic_cast<c_StringType*>(t_ty))!=0){
			return String(L"\"\"",2);
		}
		if((dynamic_cast<c_ArrayType*>(t_ty))!=0){
			return String(L"[]",2);
		}
		if((dynamic_cast<c_ObjectType*>(t_ty))!=0){
			return String(L"null",4);
		}
	}
	bb_config_InternalErr(String(L"Internal error",14));
	return String();
}
String c_JsTranslator::p_TransLocalDecl(String t_munged,c_Expr* t_init){
	return String(L"var ",4)+t_munged+String(L"=",1)+t_init->p_Trans();
}
int c_JsTranslator::p_EmitEnter(c_FuncDecl* t_func){
	p_Emit(String(L"push_err();",11));
	return 0;
}
int c_JsTranslator::p_EmitSetErr(String t_info){
	p_Emit(String(L"err_info=\"",10)+t_info.Replace(String(L"\\",1),String(L"/",1))+String(L"\";",2));
	return 0;
}
int c_JsTranslator::p_EmitLeave(){
	p_Emit(String(L"pop_err();",10));
	return 0;
}
String c_JsTranslator::p_TransStatic(c_Decl* t_decl){
	if(((t_decl->p_IsExtern())!=0) && ((dynamic_cast<c_ModuleDecl*>(t_decl->m_scope))!=0)){
		return t_decl->m_munged;
	}else{
		if(((bb_decl__env)!=0) && ((t_decl->m_scope)!=0) && t_decl->m_scope==(bb_decl__env->p_ClassScope())){
			return t_decl->m_scope->m_munged+String(L".",1)+t_decl->m_munged;
		}else{
			if((dynamic_cast<c_ClassDecl*>(t_decl->m_scope))!=0){
				return t_decl->m_scope->m_munged+String(L".",1)+t_decl->m_munged;
			}else{
				if((dynamic_cast<c_ModuleDecl*>(t_decl->m_scope))!=0){
					return t_decl->m_munged;
				}
			}
		}
	}
	bb_config_InternalErr(String(L"Internal error",14));
	return String();
}
String c_JsTranslator::p_TransGlobal(c_GlobalDecl* t_decl){
	return p_TransStatic(t_decl);
}
String c_JsTranslator::p_TransField(c_FieldDecl* t_decl,c_Expr* t_lhs){
	String t_t_lhs=String(L"this",4);
	if((t_lhs)!=0){
		t_t_lhs=p_TransSubExpr(t_lhs,2);
		if(bb_config_ENV_CONFIG==String(L"debug",5)){
			t_t_lhs=String(L"dbg_object",10)+p_Bra(t_t_lhs);
		}
	}
	return t_t_lhs+String(L".",1)+t_decl->m_munged;
}
int c_JsTranslator::p_EmitFuncDecl(c_FuncDecl* t_decl){
	p_BeginLocalScope();
	String t_args=String();
	Array<c_ArgDecl* > t_=t_decl->m_argDecls;
	int t_2=0;
	while(t_2<t_.Length()){
		c_ArgDecl* t_arg=t_[t_2];
		t_2=t_2+1;
		p_MungDecl(t_arg);
		if((t_args).Length()!=0){
			t_args=t_args+String(L",",1);
		}
		t_args=t_args+t_arg->m_munged;
	}
	t_args=p_Bra(t_args);
	if(t_decl->p_IsMethod()){
		p_Emit(t_decl->m_scope->m_munged+String(L".prototype.",11)+t_decl->m_munged+String(L"=function",9)+t_args+String(L"{",1));
	}else{
		if((t_decl->p_ClassScope())!=0){
			p_Emit(p_TransStatic(t_decl)+String(L"=function",9)+t_args+String(L"{",1));
		}else{
			p_Emit(String(L"function ",9)+t_decl->m_munged+t_args+String(L"{",1));
		}
	}
	if(!((t_decl->p_IsAbstract())!=0)){
		p_EmitBlock((t_decl),true);
	}
	p_Emit(String(L"}",1));
	p_EndLocalScope();
	return 0;
}
int c_JsTranslator::p_EmitClassDecl(c_ClassDecl* t_classDecl){
	if((t_classDecl->p_IsInterface())!=0){
		return 0;
	}
	String t_classid=t_classDecl->m_munged;
	String t_superid=t_classDecl->m_superClass->m_munged;
	p_Emit(String(L"function ",9)+t_classid+String(L"(){",3));
	p_Emit(t_superid+String(L".call(this);",12));
	c_Enumerator3* t_=t_classDecl->p_Semanted()->p_ObjectEnumerator();
	while(t_->p_HasNext()){
		c_Decl* t_decl=t_->p_NextObject();
		c_FieldDecl* t_fdecl=dynamic_cast<c_FieldDecl*>(t_decl);
		if((t_fdecl)!=0){
			p_Emit(String(L"this.",5)+t_fdecl->m_munged+String(L"=",1)+t_fdecl->m_init->p_Trans()+String(L";",1));
		}
	}
	String t_impls=String();
	c_ClassDecl* t_tdecl=t_classDecl;
	c_StringSet* t_iset=(new c_StringSet)->m_new();
	while((t_tdecl)!=0){
		Array<c_ClassDecl* > t_2=t_tdecl->m_implmentsAll;
		int t_3=0;
		while(t_3<t_2.Length()){
			c_ClassDecl* t_iface=t_2[t_3];
			t_3=t_3+1;
			String t_t=t_iface->m_munged;
			if(t_iset->p_Contains(t_t)){
				continue;
			}
			t_iset->p_Insert(t_t);
			if((t_impls).Length()!=0){
				t_impls=t_impls+String(L",",1);
			}
			t_impls=t_impls+(t_t+String(L":1",2));
		}
		t_tdecl=t_tdecl->m_superClass;
	}
	if((t_impls).Length()!=0){
		p_Emit(String(L"this.implments={",16)+t_impls+String(L"};",2));
	}
	p_Emit(String(L"}",1));
	if(t_superid!=String(L"Object",6)){
		p_Emit(t_classid+String(L".prototype=extend_class(",24)+t_superid+String(L");",2));
	}
	c_Enumerator3* t_4=t_classDecl->p_Semanted()->p_ObjectEnumerator();
	while(t_4->p_HasNext()){
		c_Decl* t_decl2=t_4->p_NextObject();
		if((t_decl2->p_IsExtern())!=0){
			continue;
		}
		c_FuncDecl* t_fdecl2=dynamic_cast<c_FuncDecl*>(t_decl2);
		if((t_fdecl2)!=0){
			p_EmitFuncDecl(t_fdecl2);
			continue;
		}
		c_GlobalDecl* t_gdecl=dynamic_cast<c_GlobalDecl*>(t_decl2);
		if((t_gdecl)!=0){
			p_Emit(p_TransGlobal(t_gdecl)+String(L"=",1)+p_TransValue(t_gdecl->m_type,String())+String(L";",1));
			continue;
		}
	}
	return 0;
}
String c_JsTranslator::p_TransApp(c_AppDecl* t_app){
	t_app->m_mainFunc->m_munged=String(L"bbMain",6);
	c_ValueEnumerator* t_=t_app->m_imported->p_Values()->p_ObjectEnumerator();
	while(t_->p_HasNext()){
		c_ModuleDecl* t_decl=t_->p_NextObject();
		p_MungDecl(t_decl);
	}
	c_Enumerator3* t_2=t_app->p_Semanted()->p_ObjectEnumerator();
	while(t_2->p_HasNext()){
		c_Decl* t_decl2=t_2->p_NextObject();
		p_MungDecl(t_decl2);
		c_ClassDecl* t_cdecl=dynamic_cast<c_ClassDecl*>(t_decl2);
		if(!((t_cdecl)!=0)){
			continue;
		}
		c_Enumerator3* t_3=t_cdecl->p_Semanted()->p_ObjectEnumerator();
		while(t_3->p_HasNext()){
			c_Decl* t_decl3=t_3->p_NextObject();
			p_MungDecl(t_decl3);
		}
	}
	c_Enumerator3* t_4=t_app->p_Semanted()->p_ObjectEnumerator();
	while(t_4->p_HasNext()){
		c_Decl* t_decl4=t_4->p_NextObject();
		c_GlobalDecl* t_gdecl=dynamic_cast<c_GlobalDecl*>(t_decl4);
		if((t_gdecl)!=0){
			p_Emit(String(L"var ",4)+p_TransGlobal(t_gdecl)+String(L"=",1)+p_TransValue(t_gdecl->m_type,String())+String(L";",1));
			continue;
		}
		c_FuncDecl* t_fdecl=dynamic_cast<c_FuncDecl*>(t_decl4);
		if((t_fdecl)!=0){
			p_EmitFuncDecl(t_fdecl);
			continue;
		}
		c_ClassDecl* t_cdecl2=dynamic_cast<c_ClassDecl*>(t_decl4);
		if((t_cdecl2)!=0){
			p_EmitClassDecl(t_cdecl2);
			continue;
		}
	}
	p_Emit(String(L"function bbInit(){",18));
	c_Enumerator7* t_5=t_app->m_semantedGlobals->p_ObjectEnumerator();
	while(t_5->p_HasNext()){
		c_GlobalDecl* t_decl5=t_5->p_NextObject();
		p_Emit(p_TransGlobal(t_decl5)+String(L"=",1)+t_decl5->m_init->p_Trans()+String(L";",1));
	}
	p_Emit(String(L"}",1));
	return p_JoinLines();
}
String c_JsTranslator::p_TransArgs3(Array<c_Expr* > t_args,String t_first){
	String t_t=t_first;
	Array<c_Expr* > t_=t_args;
	int t_2=0;
	while(t_2<t_.Length()){
		c_Expr* t_arg=t_[t_2];
		t_2=t_2+1;
		if((t_t).Length()!=0){
			t_t=t_t+String(L",",1);
		}
		t_t=t_t+t_arg->p_Trans();
	}
	return p_Bra(t_t);
}
String c_JsTranslator::p_TransFunc(c_FuncDecl* t_decl,Array<c_Expr* > t_args,c_Expr* t_lhs){
	if(t_decl->p_IsMethod()){
		String t_t_lhs=String(L"this",4);
		if((t_lhs)!=0){
			t_t_lhs=p_TransSubExpr(t_lhs,2);
		}
		return t_t_lhs+String(L".",1)+t_decl->m_munged+p_TransArgs3(t_args,String());
	}
	return p_TransStatic(t_decl)+p_TransArgs3(t_args,String());
}
String c_JsTranslator::p_TransSuperFunc(c_FuncDecl* t_decl,Array<c_Expr* > t_args){
	if(t_decl->p_IsCtor()){
		return p_TransStatic(t_decl)+String(L".call",5)+p_TransArgs3(t_args,String(L"this",4));
	}
	return t_decl->m_scope->m_munged+String(L".prototype.",11)+t_decl->m_munged+String(L".call",5)+p_TransArgs3(t_args,String(L"this",4));
}
String c_JsTranslator::p_TransConstExpr(c_ConstExpr* t_expr){
	return p_TransValue(t_expr->m_exprType,t_expr->m_value);
}
String c_JsTranslator::p_TransNewObjectExpr(c_NewObjectExpr* t_expr){
	String t_t=String(L"new ",4)+t_expr->m_classDecl->m_munged;
	if((t_expr->m_ctor)!=0){
		t_t=p_TransStatic(t_expr->m_ctor)+String(L".call",5)+p_TransArgs3(t_expr->m_args,t_t);
	}else{
		t_t=String(L"(",1)+t_t+String(L")",1);
	}
	return t_t;
}
String c_JsTranslator::p_TransNewArrayExpr(c_NewArrayExpr* t_expr){
	String t_texpr=t_expr->m_expr->p_Trans();
	c_Type* t_ty=dynamic_cast<c_ArrayType*>(t_expr->m_exprType)->m_elemType;
	if((dynamic_cast<c_BoolType*>(t_ty))!=0){
		return String(L"new_bool_array(",15)+t_texpr+String(L")",1);
	}
	if((dynamic_cast<c_NumericType*>(t_ty))!=0){
		return String(L"new_number_array(",17)+t_texpr+String(L")",1);
	}
	if((dynamic_cast<c_StringType*>(t_ty))!=0){
		return String(L"new_string_array(",17)+t_texpr+String(L")",1);
	}
	if((dynamic_cast<c_ObjectType*>(t_ty))!=0){
		return String(L"new_object_array(",17)+t_texpr+String(L")",1);
	}
	if((dynamic_cast<c_ArrayType*>(t_ty))!=0){
		return String(L"new_array_array(",16)+t_texpr+String(L")",1);
	}
	bb_config_InternalErr(String(L"Internal error",14));
	return String();
}
String c_JsTranslator::p_TransSelfExpr(c_SelfExpr* t_expr){
	return String(L"this",4);
}
String c_JsTranslator::p_TransCastExpr(c_CastExpr* t_expr){
	c_Type* t_dst=t_expr->m_exprType;
	c_Type* t_src=t_expr->m_expr->m_exprType;
	String t_texpr=p_Bra(t_expr->m_expr->p_Trans());
	if((dynamic_cast<c_BoolType*>(t_dst))!=0){
		if((dynamic_cast<c_BoolType*>(t_src))!=0){
			return t_texpr;
		}
		if((dynamic_cast<c_IntType*>(t_src))!=0){
			return p_Bra(t_texpr+String(L"!=0",3));
		}
		if((dynamic_cast<c_FloatType*>(t_src))!=0){
			return p_Bra(t_texpr+String(L"!=0.0",5));
		}
		if((dynamic_cast<c_StringType*>(t_src))!=0){
			return p_Bra(t_texpr+String(L".length!=0",10));
		}
		if((dynamic_cast<c_ArrayType*>(t_src))!=0){
			return p_Bra(t_texpr+String(L".length!=0",10));
		}
		if((dynamic_cast<c_ObjectType*>(t_src))!=0){
			return p_Bra(t_texpr+String(L"!=null",6));
		}
	}else{
		if((dynamic_cast<c_IntType*>(t_dst))!=0){
			if((dynamic_cast<c_BoolType*>(t_src))!=0){
				return p_Bra(t_texpr+String(L"?1:0",4));
			}
			if((dynamic_cast<c_IntType*>(t_src))!=0){
				return t_texpr;
			}
			if((dynamic_cast<c_FloatType*>(t_src))!=0){
				return p_Bra(t_texpr+String(L"|0",2));
			}
			if((dynamic_cast<c_StringType*>(t_src))!=0){
				return String(L"parseInt",8)+p_Bra(t_texpr+String(L",10",3));
			}
		}else{
			if((dynamic_cast<c_FloatType*>(t_dst))!=0){
				if((dynamic_cast<c_NumericType*>(t_src))!=0){
					return t_texpr;
				}
				if((dynamic_cast<c_StringType*>(t_src))!=0){
					return String(L"parseFloat",10)+t_texpr;
				}
			}else{
				if((dynamic_cast<c_StringType*>(t_dst))!=0){
					if((dynamic_cast<c_NumericType*>(t_src))!=0){
						return String(L"String",6)+t_texpr;
					}
					if((dynamic_cast<c_StringType*>(t_src))!=0){
						return t_texpr;
					}
				}else{
					if(((dynamic_cast<c_ObjectType*>(t_dst))!=0) && ((dynamic_cast<c_ObjectType*>(t_src))!=0)){
						if((t_src->p_GetClass()->p_ExtendsClass(t_dst->p_GetClass()))!=0){
							return t_texpr;
						}else{
							if((t_dst->p_GetClass()->p_IsInterface())!=0){
								return String(L"object_implements",17)+p_Bra(t_texpr+String(L",\"",2)+t_dst->p_GetClass()->m_munged+String(L"\"",1));
							}else{
								return String(L"object_downcast",15)+p_Bra(t_texpr+String(L",",1)+t_dst->p_GetClass()->m_munged);
							}
						}
					}
				}
			}
		}
	}
	bb_config_Err(String(L"JS translator can't convert ",28)+t_src->p_ToString()+String(L" to ",4)+t_dst->p_ToString());
	return String();
}
String c_JsTranslator::p_TransUnaryExpr(c_UnaryExpr* t_expr){
	int t_pri=p_ExprPri(t_expr);
	String t_t_expr=p_TransSubExpr(t_expr->m_expr,t_pri);
	return p_TransUnaryOp(t_expr->m_op)+t_t_expr;
}
String c_JsTranslator::p_TransBinaryExpr(c_BinaryExpr* t_expr){
	int t_pri=p_ExprPri(t_expr);
	String t_t_lhs=p_TransSubExpr(t_expr->m_lhs,t_pri);
	String t_t_rhs=p_TransSubExpr(t_expr->m_rhs,t_pri-1);
	String t_t_expr=t_t_lhs+p_TransBinaryOp(t_expr->m_op,t_t_rhs)+t_t_rhs;
	if(t_expr->m_op==String(L"/",1) && ((dynamic_cast<c_IntType*>(t_expr->m_exprType))!=0)){
		t_t_expr=p_Bra(p_Bra(t_t_expr)+String(L"|0",2));
	}
	return t_t_expr;
}
String c_JsTranslator::p_TransIndexExpr(c_IndexExpr* t_expr){
	String t_t_expr=p_TransSubExpr(t_expr->m_expr,2);
	if((dynamic_cast<c_StringType*>(t_expr->m_expr->m_exprType))!=0){
		String t_t_index=t_expr->m_index->p_Trans();
		if(bb_config_ENV_CONFIG==String(L"debug",5)){
			return String(L"dbg_charCodeAt(",15)+t_t_expr+String(L",",1)+t_t_index+String(L")",1);
		}
		return t_t_expr+String(L".charCodeAt(",12)+t_t_index+String(L")",1);
	}else{
		if(bb_config_ENV_CONFIG==String(L"debug",5)){
			String t_t_index2=t_expr->m_index->p_Trans();
			return String(L"dbg_array(",10)+t_t_expr+String(L",",1)+t_t_index2+String(L")[dbg_index]",12);
		}else{
			String t_t_index3=t_expr->m_index->p_Trans();
			return t_t_expr+String(L"[",1)+t_t_index3+String(L"]",1);
		}
	}
}
String c_JsTranslator::p_TransSliceExpr(c_SliceExpr* t_expr){
	String t_t_expr=p_TransSubExpr(t_expr->m_expr,2);
	String t_t_args=String(L"0",1);
	if((t_expr->m_from)!=0){
		t_t_args=t_expr->m_from->p_Trans();
	}
	if((t_expr->m_term)!=0){
		t_t_args=t_t_args+(String(L",",1)+t_expr->m_term->p_Trans());
	}
	return t_t_expr+String(L".slice(",7)+t_t_args+String(L")",1);
}
String c_JsTranslator::p_TransArrayExpr(c_ArrayExpr* t_expr){
	String t_t=String();
	Array<c_Expr* > t_=t_expr->m_exprs;
	int t_2=0;
	while(t_2<t_.Length()){
		c_Expr* t_elem=t_[t_2];
		t_2=t_2+1;
		if((t_t).Length()!=0){
			t_t=t_t+String(L",",1);
		}
		t_t=t_t+t_elem->p_Trans();
	}
	return String(L"[",1)+t_t+String(L"]",1);
}
String c_JsTranslator::p_TransTryStmt(c_TryStmt* t_stmt){
	p_Emit(String(L"try{",4));
	int t_unr=p_EmitBlock(t_stmt->m_block,true);
	p_Emit(String(L"}catch(_eek_){",14));
	for(int t_i=0;t_i<t_stmt->m_catches.Length();t_i=t_i+1){
		c_CatchStmt* t_c=t_stmt->m_catches[t_i];
		p_MungDecl(t_c->m_init);
		if((t_i)!=0){
			p_Emit(String(L"}else if(",9)+t_c->m_init->m_munged+String(L"=object_downcast(_eek_,",23)+t_c->m_init->m_type->p_GetClass()->m_munged+String(L")){",3));
		}else{
			p_Emit(String(L"if(",3)+t_c->m_init->m_munged+String(L"=object_downcast(_eek_,",23)+t_c->m_init->m_type->p_GetClass()->m_munged+String(L")){",3));
		}
		int t_unr2=p_EmitBlock(t_c->m_block,true);
	}
	p_Emit(String(L"}else{",6));
	p_Emit(String(L"throw _eek_;",12));
	p_Emit(String(L"}",1));
	p_Emit(String(L"}",1));
	return String();
}
String c_JsTranslator::p_TransIntrinsicExpr(c_Decl* t_decl,c_Expr* t_expr,Array<c_Expr* > t_args){
	String t_texpr=String();
	String t_arg0=String();
	String t_arg1=String();
	String t_arg2=String();
	if((t_expr)!=0){
		t_texpr=p_TransSubExpr(t_expr,2);
	}
	if(t_args.Length()>0 && ((t_args[0])!=0)){
		t_arg0=t_args[0]->p_Trans();
	}
	if(t_args.Length()>1 && ((t_args[1])!=0)){
		t_arg1=t_args[1]->p_Trans();
	}
	if(t_args.Length()>2 && ((t_args[2])!=0)){
		t_arg2=t_args[2]->p_Trans();
	}
	String t_id=t_decl->m_munged.Slice(1);
	String t_1=t_id;
	if(t_1==String(L"print",5)){
		return String(L"print",5)+p_Bra(t_arg0);
	}else{
		if(t_1==String(L"error",5)){
			return String(L"error",5)+p_Bra(t_arg0);
		}else{
			if(t_1==String(L"debuglog",8)){
				return String(L"debugLog",8)+p_Bra(t_arg0);
			}else{
				if(t_1==String(L"debugstop",9)){
					return String(L"debugStop()",11);
				}else{
					if(t_1==String(L"length",6)){
						return t_texpr+String(L".length",7);
					}else{
						if(t_1==String(L"resize",6)){
							c_Type* t_ty=dynamic_cast<c_ArrayType*>(t_expr->m_exprType)->m_elemType;
							if((dynamic_cast<c_BoolType*>(t_ty))!=0){
								return String(L"resize_bool_array",17)+p_Bra(t_texpr+String(L",",1)+t_arg0);
							}
							if((dynamic_cast<c_NumericType*>(t_ty))!=0){
								return String(L"resize_number_array",19)+p_Bra(t_texpr+String(L",",1)+t_arg0);
							}
							if((dynamic_cast<c_StringType*>(t_ty))!=0){
								return String(L"resize_string_array",19)+p_Bra(t_texpr+String(L",",1)+t_arg0);
							}
							if((dynamic_cast<c_ArrayType*>(t_ty))!=0){
								return String(L"resize_array_array",18)+p_Bra(t_texpr+String(L",",1)+t_arg0);
							}
							if((dynamic_cast<c_ObjectType*>(t_ty))!=0){
								return String(L"resize_object_array",19)+p_Bra(t_texpr+String(L",",1)+t_arg0);
							}
							bb_config_InternalErr(String(L"Internal error",14));
						}else{
							if(t_1==String(L"compare",7)){
								return String(L"string_compare",14)+p_Bra(t_texpr+String(L",",1)+t_arg0);
							}else{
								if(t_1==String(L"find",4)){
									return t_texpr+String(L".indexOf",8)+p_Bra(t_arg0+String(L",",1)+t_arg1);
								}else{
									if(t_1==String(L"findlast",8)){
										return t_texpr+String(L".lastIndexOf",12)+p_Bra(t_arg0);
									}else{
										if(t_1==String(L"findlast2",9)){
											return t_texpr+String(L".lastIndexOf",12)+p_Bra(t_arg0+String(L",",1)+t_arg1);
										}else{
											if(t_1==String(L"trim",4)){
												return String(L"string_trim",11)+p_Bra(t_texpr);
											}else{
												if(t_1==String(L"join",4)){
													return t_arg0+String(L".join",5)+p_Bra(t_texpr);
												}else{
													if(t_1==String(L"split",5)){
														return t_texpr+String(L".split",6)+p_Bra(t_arg0);
													}else{
														if(t_1==String(L"replace",7)){
															return String(L"string_replace",14)+p_Bra(t_texpr+String(L",",1)+t_arg0+String(L",",1)+t_arg1);
														}else{
															if(t_1==String(L"tolower",7)){
																return t_texpr+String(L".toLowerCase()",14);
															}else{
																if(t_1==String(L"toupper",7)){
																	return t_texpr+String(L".toUpperCase()",14);
																}else{
																	if(t_1==String(L"contains",8)){
																		return p_Bra(t_texpr+String(L".indexOf",8)+p_Bra(t_arg0)+String(L"!=-1",4));
																	}else{
																		if(t_1==String(L"startswith",10)){
																			return String(L"string_startswith",17)+p_Bra(t_texpr+String(L",",1)+t_arg0);
																		}else{
																			if(t_1==String(L"endswith",8)){
																				return String(L"string_endswith",15)+p_Bra(t_texpr+String(L",",1)+t_arg0);
																			}else{
																				if(t_1==String(L"tochars",7)){
																					return String(L"string_tochars",14)+p_Bra(t_texpr);
																				}else{
																					if(t_1==String(L"fromchar",8)){
																						return String(L"String.fromCharCode",19)+p_Bra(t_arg0);
																					}else{
																						if(t_1==String(L"fromchars",9)){
																							return String(L"string_fromchars",16)+p_Bra(t_arg0);
																						}else{
																							if(t_1==String(L"sin",3) || t_1==String(L"cos",3) || t_1==String(L"tan",3)){
																								return String(L"Math.",5)+t_id+p_Bra(p_Bra(t_arg0)+String(L"*D2R",4));
																							}else{
																								if(t_1==String(L"asin",4) || t_1==String(L"acos",4) || t_1==String(L"atan",4)){
																									return p_Bra(String(L"Math.",5)+t_id+p_Bra(t_arg0)+String(L"*R2D",4));
																								}else{
																									if(t_1==String(L"atan2",5)){
																										return p_Bra(String(L"Math.",5)+t_id+p_Bra(t_arg0+String(L",",1)+t_arg1)+String(L"*R2D",4));
																									}else{
																										if(t_1==String(L"sinr",4) || t_1==String(L"cosr",4) || t_1==String(L"tanr",4)){
																											return String(L"Math.",5)+t_id.Slice(0,-1)+p_Bra(t_arg0);
																										}else{
																											if(t_1==String(L"asinr",5) || t_1==String(L"acosr",5) || t_1==String(L"atanr",5)){
																												return String(L"Math.",5)+t_id.Slice(0,-1)+p_Bra(t_arg0);
																											}else{
																												if(t_1==String(L"atan2r",6)){
																													return String(L"Math.",5)+t_id.Slice(0,-1)+p_Bra(t_arg0+String(L",",1)+t_arg1);
																												}else{
																													if(t_1==String(L"sqrt",4) || t_1==String(L"floor",5) || t_1==String(L"ceil",4) || t_1==String(L"log",3) || t_1==String(L"exp",3)){
																														return String(L"Math.",5)+t_id+p_Bra(t_arg0);
																													}else{
																														if(t_1==String(L"pow",3)){
																															return String(L"Math.",5)+t_id+p_Bra(t_arg0+String(L",",1)+t_arg1);
																														}
																													}
																												}
																											}
																										}
																									}
																								}
																							}
																						}
																					}
																				}
																			}
																		}
																	}
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
	bb_config_InternalErr(String(L"Internal error",14));
	return String();
}
void c_JsTranslator::mark(){
	c_CTranslator::mark();
}
int bb_html5_Info_Width;
int bb_html5_Info_Height;
c_Stream::c_Stream(){
}
c_Stream* c_Stream::m_new(){
	return this;
}
void c_Stream::mark(){
	Object::mark();
}
c_FileStream::c_FileStream(){
	m__stream=0;
}
BBFileStream* c_FileStream::m_OpenStream(String t_path,String t_mode){
	BBFileStream* t_stream=(new BBFileStream);
	String t_fmode=t_mode;
	if(t_fmode==String(L"a",1)){
		t_fmode=String(L"u",1);
	}
	if(!t_stream->Open(t_path,t_fmode)){
		return 0;
	}
	if(t_mode==String(L"a",1)){
		t_stream->Seek(t_stream->Length());
	}
	return t_stream;
}
c_FileStream* c_FileStream::m_new(String t_path,String t_mode){
	c_Stream::m_new();
	m__stream=m_OpenStream(t_path,t_mode);
	if(!((m__stream)!=0)){
		bbError(String(L"Failed to open stream",21));
	}
	return this;
}
c_FileStream* c_FileStream::m_new2(BBFileStream* t_stream){
	c_Stream::m_new();
	m__stream=t_stream;
	return this;
}
c_FileStream* c_FileStream::m_new3(){
	c_Stream::m_new();
	return this;
}
c_FileStream* c_FileStream::m_Open(String t_path,String t_mode){
	BBFileStream* t_stream=m_OpenStream(t_path,t_mode);
	if((t_stream)!=0){
		return (new c_FileStream)->m_new2(t_stream);
	}
	return 0;
}
int c_FileStream::p_Read(c_DataBuffer* t_buffer,int t_offset,int t_count){
	return m__stream->Read(t_buffer,t_offset,t_count);
}
void c_FileStream::p_Close(){
	if(!((m__stream)!=0)){
		return;
	}
	m__stream->Close();
	m__stream=0;
}
int c_FileStream::p_Eof(){
	return m__stream->Eof();
}
int c_FileStream::p_Position(){
	return m__stream->Position();
}
int c_FileStream::p_Seek(int t_position){
	return m__stream->Seek(t_position);
}
void c_FileStream::mark(){
	c_Stream::mark();
}
c_DataBuffer::c_DataBuffer(){
}
c_DataBuffer* c_DataBuffer::m_new(int t_length,bool t_direct){
	if(!_New(t_length)){
		bbError(String(L"Allocate DataBuffer failed",26));
	}
	return this;
}
c_DataBuffer* c_DataBuffer::m_new2(){
	return this;
}
void c_DataBuffer::mark(){
	BBDataBuffer::mark();
}
int bb_html5_GetInfo_PNG(String t_path){
	c_FileStream* t_f=c_FileStream::m_Open(t_path,String(L"r",1));
	if((t_f)!=0){
		c_DataBuffer* t_data=(new c_DataBuffer)->m_new(32,false);
		int t_n=t_f->p_Read(t_data,0,24);
		t_f->p_Close();
		if(t_n==24 && t_data->PeekByte(1)==80 && t_data->PeekByte(2)==78 && t_data->PeekByte(3)==71){
			bb_html5_Info_Width=(t_data->PeekByte(16)&255)<<24|(t_data->PeekByte(17)&255)<<16|(t_data->PeekByte(18)&255)<<8|t_data->PeekByte(19)&255;
			bb_html5_Info_Height=(t_data->PeekByte(20)&255)<<24|(t_data->PeekByte(21)&255)<<16|(t_data->PeekByte(22)&255)<<8|t_data->PeekByte(23)&255;
			return 0;
		}
	}
	return -1;
}
int bb_html5_GetInfo_JPG(String t_path){
	c_FileStream* t_f=c_FileStream::m_Open(t_path,String(L"r",1));
	if((t_f)!=0){
		c_DataBuffer* t_buf=(new c_DataBuffer)->m_new(32,false);
		if(t_f->p_Read(t_buf,0,2)==2 && (t_buf->PeekByte(0)&255)==255 && (t_buf->PeekByte(1)&255)==216){
			do{
				while(t_f->p_Read(t_buf,0,1)==1 && (t_buf->PeekByte(0)&255)!=255){
				}
				if((t_f->p_Eof())!=0){
					break;
				}
				while(t_f->p_Read(t_buf,0,1)==1 && (t_buf->PeekByte(0)&255)==255){
				}
				if((t_f->p_Eof())!=0){
					break;
				}
				int t_marker=t_buf->PeekByte(0)&255;
				int t_1=t_marker;
				if(t_1==208 || t_1==209 || t_1==210 || t_1==211 || t_1==212 || t_1==213 || t_1==214 || t_1==215 || t_1==216 || t_1==217 || t_1==0 || t_1==255){
					continue;
				}
				if(t_f->p_Read(t_buf,0,2)!=2){
					break;
				}
				int t_datalen=((t_buf->PeekByte(0)&255)<<8|t_buf->PeekByte(1)&255)-2;
				int t_2=t_marker;
				if(t_2==192 || t_2==193 || t_2==194 || t_2==195){
					if(((t_datalen)!=0) && t_f->p_Read(t_buf,0,5)==5){
						int t_bpp=t_buf->PeekByte(0)&255;
						bb_html5_Info_Width=(t_buf->PeekByte(3)&255)<<8|t_buf->PeekByte(4)&255;
						bb_html5_Info_Height=(t_buf->PeekByte(1)&255)<<8|t_buf->PeekByte(2)&255;
						t_f->p_Close();
						return 0;
					}
				}
				int t_pos=t_f->p_Position()+t_datalen;
				if(t_f->p_Seek(t_pos)!=t_pos){
					break;
				}
			}while(!(false));
		}
		t_f->p_Close();
	}
	return -1;
}
int bb_html5_GetInfo_GIF(String t_path){
	c_FileStream* t_f=c_FileStream::m_Open(t_path,String(L"r",1));
	if((t_f)!=0){
		c_DataBuffer* t_data=(new c_DataBuffer)->m_new(32,false);
		int t_n=t_f->p_Read(t_data,0,10);
		t_f->p_Close();
		if(t_n==10 && t_data->PeekByte(0)==71 && t_data->PeekByte(1)==73 && t_data->PeekByte(2)==70){
			bb_html5_Info_Width=(t_data->PeekByte(7)&255)<<8|t_data->PeekByte(6)&255;
			bb_html5_Info_Height=(t_data->PeekByte(9)&255)<<8|t_data->PeekByte(8)&255;
			return 0;
		}
	}
	return -1;
}
c_AsTranslator::c_AsTranslator(){
}
c_AsTranslator* c_AsTranslator::m_new(){
	c_CTranslator::m_new();
	return this;
}
String c_AsTranslator::p_TransValue(c_Type* t_ty,String t_value){
	if((t_value).Length()!=0){
		if(((dynamic_cast<c_IntType*>(t_ty))!=0) && t_value.StartsWith(String(L"$",1))){
			return String(L"0x",2)+t_value.Slice(1);
		}
		if((dynamic_cast<c_BoolType*>(t_ty))!=0){
			return String(L"true",4);
		}
		if((dynamic_cast<c_NumericType*>(t_ty))!=0){
			return t_value;
		}
		if((dynamic_cast<c_StringType*>(t_ty))!=0){
			return p_Enquote(t_value);
		}
	}else{
		if((dynamic_cast<c_BoolType*>(t_ty))!=0){
			return String(L"false",5);
		}
		if((dynamic_cast<c_NumericType*>(t_ty))!=0){
			return String(L"0",1);
		}
		if((dynamic_cast<c_StringType*>(t_ty))!=0){
			return String(L"\"\"",2);
		}
		if((dynamic_cast<c_ArrayType*>(t_ty))!=0){
			return String(L"[]",2);
		}
		if((dynamic_cast<c_ObjectType*>(t_ty))!=0){
			return String(L"null",4);
		}
	}
	bb_config_InternalErr(String(L"Internal error",14));
	return String();
}
String c_AsTranslator::p_TransType(c_Type* t_ty){
	if((dynamic_cast<c_VoidType*>(t_ty))!=0){
		return String(L"void",4);
	}
	if((dynamic_cast<c_BoolType*>(t_ty))!=0){
		return String(L"Boolean",7);
	}
	if((dynamic_cast<c_IntType*>(t_ty))!=0){
		return String(L"int",3);
	}
	if((dynamic_cast<c_FloatType*>(t_ty))!=0){
		return String(L"Number",6);
	}
	if((dynamic_cast<c_StringType*>(t_ty))!=0){
		return String(L"String",6);
	}
	if((dynamic_cast<c_ArrayType*>(t_ty))!=0){
		return String(L"Array",5);
	}
	if((dynamic_cast<c_ObjectType*>(t_ty))!=0){
		return dynamic_cast<c_ObjectType*>(t_ty)->m_classDecl->m_munged;
	}
	bb_config_InternalErr(String(L"Internal error",14));
	return String();
}
String c_AsTranslator::p_TransLocalDecl(String t_munged,c_Expr* t_init){
	return String(L"var ",4)+t_munged+String(L":",1)+p_TransType(t_init->m_exprType)+String(L"=",1)+t_init->p_Trans();
}
int c_AsTranslator::p_EmitEnter(c_FuncDecl* t_func){
	p_Emit(String(L"pushErr();",10));
	return 0;
}
int c_AsTranslator::p_EmitSetErr(String t_info){
	p_Emit(String(L"_errInfo=\"",10)+t_info.Replace(String(L"\\",1),String(L"/",1))+String(L"\";",2));
	return 0;
}
int c_AsTranslator::p_EmitLeave(){
	p_Emit(String(L"popErr();",9));
	return 0;
}
String c_AsTranslator::p_TransStatic(c_Decl* t_decl){
	if(((t_decl->p_IsExtern())!=0) && ((dynamic_cast<c_ModuleDecl*>(t_decl->m_scope))!=0)){
		return t_decl->m_munged;
	}else{
		if(((bb_decl__env)!=0) && ((t_decl->m_scope)!=0) && t_decl->m_scope==(bb_decl__env->p_ClassScope())){
			return t_decl->m_munged;
		}else{
			if((dynamic_cast<c_ClassDecl*>(t_decl->m_scope))!=0){
				return t_decl->m_scope->m_munged+String(L".",1)+t_decl->m_munged;
			}else{
				if((dynamic_cast<c_ModuleDecl*>(t_decl->m_scope))!=0){
					return t_decl->m_munged;
				}
			}
		}
	}
	bb_config_InternalErr(String(L"Internal error",14));
	return String();
}
String c_AsTranslator::p_TransGlobal(c_GlobalDecl* t_decl){
	return p_TransStatic(t_decl);
}
String c_AsTranslator::p_TransField(c_FieldDecl* t_decl,c_Expr* t_lhs){
	if((t_lhs)!=0){
		String t_t_lhs=p_TransSubExpr(t_lhs,2);
		if(bb_config_ENV_CONFIG==String(L"debug",5)){
			t_t_lhs=String(L"dbg_object",10)+p_Bra(t_t_lhs);
		}
		return t_t_lhs+String(L".",1)+t_decl->m_munged;
	}
	return t_decl->m_munged;
}
String c_AsTranslator::p_TransValDecl(c_ValDecl* t_decl){
	return t_decl->m_munged+String(L":",1)+p_TransType(t_decl->m_type);
}
int c_AsTranslator::p_EmitFuncDecl(c_FuncDecl* t_decl){
	p_BeginLocalScope();
	String t_args=String();
	Array<c_ArgDecl* > t_=t_decl->m_argDecls;
	int t_2=0;
	while(t_2<t_.Length()){
		c_ArgDecl* t_arg=t_[t_2];
		t_2=t_2+1;
		p_MungDecl(t_arg);
		if((t_args).Length()!=0){
			t_args=t_args+String(L",",1);
		}
		t_args=t_args+p_TransValDecl(t_arg);
	}
	String t_t=String(L"function ",9)+t_decl->m_munged+p_Bra(t_args)+String(L":",1)+p_TransType(t_decl->m_retType);
	c_ClassDecl* t_cdecl=t_decl->p_ClassScope();
	if(((t_cdecl)!=0) && ((t_cdecl->p_IsInterface())!=0)){
		p_Emit(t_t+String(L";",1));
	}else{
		String t_q=String(L"internal ",9);
		if((t_cdecl)!=0){
			t_q=String(L"public ",7);
			if(t_decl->p_IsStatic()){
				t_q=t_q+String(L"static ",7);
			}
			if((t_decl->m_overrides)!=0){
				t_q=t_q+String(L"override ",9);
			}
		}
		p_Emit(t_q+t_t+String(L"{",1));
		if((t_decl->p_IsAbstract())!=0){
			if((dynamic_cast<c_VoidType*>(t_decl->m_retType))!=0){
				p_Emit(String(L"return;",7));
			}else{
				p_Emit(String(L"return ",7)+p_TransValue(t_decl->m_retType,String())+String(L";",1));
			}
		}else{
			p_EmitBlock((t_decl),true);
		}
		p_Emit(String(L"}",1));
	}
	p_EndLocalScope();
	return 0;
}
int c_AsTranslator::p_EmitClassDecl(c_ClassDecl* t_classDecl){
	String t_classid=t_classDecl->m_munged;
	String t_superid=t_classDecl->m_superClass->m_munged;
	if((t_classDecl->p_IsInterface())!=0){
		String t_bases=String();
		Array<c_ClassDecl* > t_=t_classDecl->m_implments;
		int t_2=0;
		while(t_2<t_.Length()){
			c_ClassDecl* t_iface=t_[t_2];
			t_2=t_2+1;
			if((t_bases).Length()!=0){
				t_bases=t_bases+String(L",",1);
			}else{
				t_bases=String(L" extends ",9);
			}
			t_bases=t_bases+t_iface->m_munged;
		}
		p_Emit(String(L"interface ",10)+t_classid+t_bases+String(L"{",1));
		c_Enumerator3* t_3=t_classDecl->p_Semanted()->p_ObjectEnumerator();
		while(t_3->p_HasNext()){
			c_Decl* t_decl=t_3->p_NextObject();
			c_FuncDecl* t_fdecl=dynamic_cast<c_FuncDecl*>(t_decl);
			if(!((t_fdecl)!=0)){
				continue;
			}
			p_EmitFuncDecl(t_fdecl);
		}
		p_Emit(String(L"}",1));
		return 0;
	}
	String t_bases2=String();
	Array<c_ClassDecl* > t_4=t_classDecl->m_implments;
	int t_5=0;
	while(t_5<t_4.Length()){
		c_ClassDecl* t_iface2=t_4[t_5];
		t_5=t_5+1;
		if((t_bases2).Length()!=0){
			t_bases2=t_bases2+String(L",",1);
		}else{
			t_bases2=String(L" implements ",12);
		}
		t_bases2=t_bases2+t_iface2->m_munged;
	}
	p_Emit(String(L"class ",6)+t_classid+String(L" extends ",9)+t_superid+t_bases2+String(L"{",1));
	c_Enumerator3* t_6=t_classDecl->p_Semanted()->p_ObjectEnumerator();
	while(t_6->p_HasNext()){
		c_Decl* t_decl2=t_6->p_NextObject();
		c_FieldDecl* t_tdecl=dynamic_cast<c_FieldDecl*>(t_decl2);
		if((t_tdecl)!=0){
			p_Emit(String(L"internal var ",13)+p_TransValDecl(t_tdecl)+String(L"=",1)+t_tdecl->m_init->p_Trans()+String(L";",1));
			continue;
		}
		c_GlobalDecl* t_gdecl=dynamic_cast<c_GlobalDecl*>(t_decl2);
		if((t_gdecl)!=0){
			p_Emit(String(L"internal static var ",20)+p_TransValDecl(t_gdecl)+String(L";",1));
			continue;
		}
		c_FuncDecl* t_fdecl2=dynamic_cast<c_FuncDecl*>(t_decl2);
		if((t_fdecl2)!=0){
			p_EmitFuncDecl(t_fdecl2);
			continue;
		}
	}
	p_Emit(String(L"}",1));
	return 0;
}
String c_AsTranslator::p_TransApp(c_AppDecl* t_app){
	t_app->m_mainFunc->m_munged=String(L"bbMain",6);
	c_ValueEnumerator* t_=t_app->m_imported->p_Values()->p_ObjectEnumerator();
	while(t_->p_HasNext()){
		c_ModuleDecl* t_decl=t_->p_NextObject();
		p_MungDecl(t_decl);
	}
	c_Enumerator3* t_2=t_app->p_Semanted()->p_ObjectEnumerator();
	while(t_2->p_HasNext()){
		c_Decl* t_decl2=t_2->p_NextObject();
		p_MungDecl(t_decl2);
		c_ClassDecl* t_cdecl=dynamic_cast<c_ClassDecl*>(t_decl2);
		if(!((t_cdecl)!=0)){
			continue;
		}
		c_Enumerator3* t_3=t_cdecl->p_Semanted()->p_ObjectEnumerator();
		while(t_3->p_HasNext()){
			c_Decl* t_decl3=t_3->p_NextObject();
			if(((dynamic_cast<c_FuncDecl*>(t_decl3))!=0) && dynamic_cast<c_FuncDecl*>(t_decl3)->p_IsCtor()){
				t_decl3->m_ident=t_cdecl->m_ident+String(L"_",1)+t_decl3->m_ident;
			}
			p_MungDecl(t_decl3);
		}
	}
	c_Enumerator3* t_4=t_app->p_Semanted()->p_ObjectEnumerator();
	while(t_4->p_HasNext()){
		c_Decl* t_decl4=t_4->p_NextObject();
		c_GlobalDecl* t_gdecl=dynamic_cast<c_GlobalDecl*>(t_decl4);
		if((t_gdecl)!=0){
			p_Emit(String(L"var ",4)+p_TransValDecl(t_gdecl)+String(L";",1));
			continue;
		}
		c_FuncDecl* t_fdecl=dynamic_cast<c_FuncDecl*>(t_decl4);
		if((t_fdecl)!=0){
			p_EmitFuncDecl(t_fdecl);
			continue;
		}
		c_ClassDecl* t_cdecl2=dynamic_cast<c_ClassDecl*>(t_decl4);
		if((t_cdecl2)!=0){
			p_EmitClassDecl(t_cdecl2);
			continue;
		}
	}
	p_BeginLocalScope();
	p_Emit(String(L"function bbInit():void{",23));
	c_Enumerator7* t_5=t_app->m_semantedGlobals->p_ObjectEnumerator();
	while(t_5->p_HasNext()){
		c_GlobalDecl* t_decl5=t_5->p_NextObject();
		p_Emit(p_TransGlobal(t_decl5)+String(L"=",1)+t_decl5->m_init->p_Trans()+String(L";",1));
	}
	p_Emit(String(L"}",1));
	p_EndLocalScope();
	return p_JoinLines();
}
String c_AsTranslator::p_TransArgs(Array<c_Expr* > t_args){
	String t_t=String();
	Array<c_Expr* > t_=t_args;
	int t_2=0;
	while(t_2<t_.Length()){
		c_Expr* t_arg=t_[t_2];
		t_2=t_2+1;
		if((t_t).Length()!=0){
			t_t=t_t+String(L",",1);
		}
		t_t=t_t+t_arg->p_Trans();
	}
	return p_Bra(t_t);
}
String c_AsTranslator::p_TransFunc(c_FuncDecl* t_decl,Array<c_Expr* > t_args,c_Expr* t_lhs){
	if(t_decl->p_IsMethod()){
		String t_t_lhs=String(L"this",4);
		if((t_lhs)!=0){
			t_t_lhs=p_TransSubExpr(t_lhs,2);
		}
		return t_t_lhs+String(L".",1)+t_decl->m_munged+p_TransArgs(t_args);
	}
	return p_TransStatic(t_decl)+p_TransArgs(t_args);
}
String c_AsTranslator::p_TransSuperFunc(c_FuncDecl* t_decl,Array<c_Expr* > t_args){
	return String(L"super.",6)+t_decl->m_munged+p_TransArgs(t_args);
}
String c_AsTranslator::p_TransConstExpr(c_ConstExpr* t_expr){
	return p_TransValue(t_expr->m_exprType,t_expr->m_value);
}
String c_AsTranslator::p_TransNewObjectExpr(c_NewObjectExpr* t_expr){
	String t_t=String(L"(new ",5)+t_expr->m_classDecl->m_munged+String(L")",1);
	if((t_expr->m_ctor)!=0){
		t_t=t_t+(String(L".",1)+t_expr->m_ctor->m_munged+p_TransArgs(t_expr->m_args));
	}
	return t_t;
}
String c_AsTranslator::p_TransNewArrayExpr(c_NewArrayExpr* t_expr){
	String t_texpr=t_expr->m_expr->p_Trans();
	c_Type* t_ty=t_expr->m_ty;
	if((dynamic_cast<c_BoolType*>(t_ty))!=0){
		return String(L"new_bool_array(",15)+t_texpr+String(L")",1);
	}
	if((dynamic_cast<c_NumericType*>(t_ty))!=0){
		return String(L"new_number_array(",17)+t_texpr+String(L")",1);
	}
	if((dynamic_cast<c_StringType*>(t_ty))!=0){
		return String(L"new_string_array(",17)+t_texpr+String(L")",1);
	}
	if((dynamic_cast<c_ObjectType*>(t_ty))!=0){
		return String(L"new_object_array(",17)+t_texpr+String(L")",1);
	}
	if((dynamic_cast<c_ArrayType*>(t_ty))!=0){
		return String(L"new_array_array(",16)+t_texpr+String(L")",1);
	}
	bb_config_InternalErr(String(L"Internal error",14));
	return String();
}
String c_AsTranslator::p_TransSelfExpr(c_SelfExpr* t_expr){
	return String(L"this",4);
}
String c_AsTranslator::p_TransCastExpr(c_CastExpr* t_expr){
	c_Type* t_dst=t_expr->m_exprType;
	c_Type* t_src=t_expr->m_expr->m_exprType;
	String t_texpr=p_Bra(t_expr->m_expr->p_Trans());
	if((dynamic_cast<c_BoolType*>(t_dst))!=0){
		if((dynamic_cast<c_BoolType*>(t_src))!=0){
			return t_texpr;
		}
		if((dynamic_cast<c_IntType*>(t_src))!=0){
			return p_Bra(t_texpr+String(L"!=0",3));
		}
		if((dynamic_cast<c_FloatType*>(t_src))!=0){
			return p_Bra(t_texpr+String(L"!=0.0",5));
		}
		if((dynamic_cast<c_StringType*>(t_src))!=0){
			return p_Bra(t_texpr+String(L".length!=0",10));
		}
		if((dynamic_cast<c_ArrayType*>(t_src))!=0){
			return p_Bra(t_texpr+String(L".length!=0",10));
		}
		if((dynamic_cast<c_ObjectType*>(t_src))!=0){
			return p_Bra(t_texpr+String(L"!=null",6));
		}
	}else{
		if((dynamic_cast<c_IntType*>(t_dst))!=0){
			if((dynamic_cast<c_BoolType*>(t_src))!=0){
				return p_Bra(t_texpr+String(L"?1:0",4));
			}
			if((dynamic_cast<c_IntType*>(t_src))!=0){
				return t_texpr;
			}
			if((dynamic_cast<c_FloatType*>(t_src))!=0){
				return p_Bra(t_texpr+String(L"|0",2));
			}
			if((dynamic_cast<c_StringType*>(t_src))!=0){
				return String(L"parseInt",8)+p_Bra(t_texpr+String(L",10",3));
			}
		}else{
			if((dynamic_cast<c_FloatType*>(t_dst))!=0){
				if((dynamic_cast<c_NumericType*>(t_src))!=0){
					return t_texpr;
				}
				if((dynamic_cast<c_StringType*>(t_src))!=0){
					return String(L"parseFloat",10)+t_texpr;
				}
			}else{
				if((dynamic_cast<c_StringType*>(t_dst))!=0){
					if((dynamic_cast<c_NumericType*>(t_src))!=0){
						return String(L"String",6)+t_texpr;
					}
					if((dynamic_cast<c_StringType*>(t_src))!=0){
						return t_texpr;
					}
				}else{
					if(((dynamic_cast<c_ObjectType*>(t_dst))!=0) && ((dynamic_cast<c_ObjectType*>(t_src))!=0)){
						if((t_src->p_GetClass()->p_ExtendsClass(t_dst->p_GetClass()))!=0){
							return t_texpr;
						}else{
							return p_Bra(t_texpr+String(L" as ",4)+p_TransType(t_dst));
						}
					}
				}
			}
		}
	}
	bb_config_Err(String(L"AS translator can't convert ",28)+t_src->p_ToString()+String(L" to ",4)+t_dst->p_ToString());
	return String();
}
String c_AsTranslator::p_TransUnaryExpr(c_UnaryExpr* t_expr){
	int t_pri=p_ExprPri(t_expr);
	String t_t_expr=p_TransSubExpr(t_expr->m_expr,t_pri);
	return p_TransUnaryOp(t_expr->m_op)+t_t_expr;
}
String c_AsTranslator::p_TransBinaryExpr(c_BinaryExpr* t_expr){
	int t_pri=p_ExprPri(t_expr);
	String t_t_lhs=p_TransSubExpr(t_expr->m_lhs,t_pri);
	String t_t_rhs=p_TransSubExpr(t_expr->m_rhs,t_pri-1);
	String t_t_expr=t_t_lhs+p_TransBinaryOp(t_expr->m_op,t_t_rhs)+t_t_rhs;
	if(t_expr->m_op==String(L"/",1) && ((dynamic_cast<c_IntType*>(t_expr->m_exprType))!=0)){
		t_t_expr=p_Bra(p_Bra(t_t_expr)+String(L"|0",2));
	}
	return t_t_expr;
}
String c_AsTranslator::p_TransIndexExpr(c_IndexExpr* t_expr){
	String t_t_expr=p_TransSubExpr(t_expr->m_expr,2);
	if((dynamic_cast<c_StringType*>(t_expr->m_expr->m_exprType))!=0){
		String t_t_index=t_expr->m_index->p_Trans();
		if(bb_config_ENV_CONFIG==String(L"debug",5)){
			return String(L"dbg_charCodeAt(",15)+t_t_expr+String(L",",1)+t_t_index+String(L")",1);
		}
		return t_t_expr+String(L".charCodeAt(",12)+t_t_index+String(L")",1);
	}else{
		if(bb_config_ENV_CONFIG==String(L"debug",5)){
			String t_t_index2=t_expr->m_index->p_Trans();
			return String(L"dbg_array(",10)+t_t_expr+String(L",",1)+t_t_index2+String(L")[dbg_index]",12);
		}else{
			String t_t_index3=t_expr->m_index->p_Trans();
			return t_t_expr+String(L"[",1)+t_t_index3+String(L"]",1);
		}
	}
}
String c_AsTranslator::p_TransSliceExpr(c_SliceExpr* t_expr){
	String t_t_expr=p_TransSubExpr(t_expr->m_expr,2);
	String t_t_args=String(L"0",1);
	if((t_expr->m_from)!=0){
		t_t_args=t_expr->m_from->p_Trans();
	}
	if((t_expr->m_term)!=0){
		t_t_args=t_t_args+(String(L",",1)+t_expr->m_term->p_Trans());
	}
	return t_t_expr+String(L".slice(",7)+t_t_args+String(L")",1);
}
String c_AsTranslator::p_TransArrayExpr(c_ArrayExpr* t_expr){
	String t_t=String();
	Array<c_Expr* > t_=t_expr->m_exprs;
	int t_2=0;
	while(t_2<t_.Length()){
		c_Expr* t_elem=t_[t_2];
		t_2=t_2+1;
		if((t_t).Length()!=0){
			t_t=t_t+String(L",",1);
		}
		t_t=t_t+t_elem->p_Trans();
	}
	return String(L"[",1)+t_t+String(L"]",1);
}
String c_AsTranslator::p_TransIntrinsicExpr(c_Decl* t_decl,c_Expr* t_expr,Array<c_Expr* > t_args){
	String t_texpr=String();
	String t_arg0=String();
	String t_arg1=String();
	String t_arg2=String();
	if((t_expr)!=0){
		t_texpr=p_TransSubExpr(t_expr,2);
	}
	if(t_args.Length()>0 && ((t_args[0])!=0)){
		t_arg0=t_args[0]->p_Trans();
	}
	if(t_args.Length()>1 && ((t_args[1])!=0)){
		t_arg1=t_args[1]->p_Trans();
	}
	if(t_args.Length()>2 && ((t_args[2])!=0)){
		t_arg2=t_args[2]->p_Trans();
	}
	String t_id=t_decl->m_munged.Slice(1);
	String t_1=t_id;
	if(t_1==String(L"print",5)){
		return String(L"print",5)+p_Bra(t_arg0);
	}else{
		if(t_1==String(L"error",5)){
			return String(L"error",5)+p_Bra(t_arg0);
		}else{
			if(t_1==String(L"debuglog",8)){
				return String(L"debugLog",8)+p_Bra(t_arg0);
			}else{
				if(t_1==String(L"debugstop",9)){
					return String(L"debugStop()",11);
				}else{
					if(t_1==String(L"length",6)){
						return t_texpr+String(L".length",7);
					}else{
						if(t_1==String(L"resize",6)){
							c_Type* t_ty=dynamic_cast<c_ArrayType*>(t_expr->m_exprType)->m_elemType;
							if((dynamic_cast<c_BoolType*>(t_ty))!=0){
								return String(L"resize_bool_array",17)+p_Bra(t_texpr+String(L",",1)+t_arg0);
							}
							if((dynamic_cast<c_NumericType*>(t_ty))!=0){
								return String(L"resize_number_array",19)+p_Bra(t_texpr+String(L",",1)+t_arg0);
							}
							if((dynamic_cast<c_StringType*>(t_ty))!=0){
								return String(L"resize_string_array",19)+p_Bra(t_texpr+String(L",",1)+t_arg0);
							}
							if((dynamic_cast<c_ArrayType*>(t_ty))!=0){
								return String(L"resize_array_array",18)+p_Bra(t_texpr+String(L",",1)+t_arg0);
							}
							if((dynamic_cast<c_ObjectType*>(t_ty))!=0){
								return String(L"resize_object_array",19)+p_Bra(t_texpr+String(L",",1)+t_arg0);
							}
							bb_config_InternalErr(String(L"Internal error",14));
						}else{
							if(t_1==String(L"compare",7)){
								return String(L"string_compare",14)+p_Bra(t_texpr+String(L",",1)+t_arg0);
							}else{
								if(t_1==String(L"find",4)){
									return t_texpr+String(L".indexOf",8)+p_Bra(t_arg0+String(L",",1)+t_arg1);
								}else{
									if(t_1==String(L"findlast",8)){
										return t_texpr+String(L".lastIndexOf",12)+p_Bra(t_arg0);
									}else{
										if(t_1==String(L"findlast2",9)){
											return t_texpr+String(L".lastIndexOf",12)+p_Bra(t_arg0+String(L",",1)+t_arg1);
										}else{
											if(t_1==String(L"trim",4)){
												return String(L"string_trim",11)+p_Bra(t_texpr);
											}else{
												if(t_1==String(L"join",4)){
													return t_arg0+String(L".join",5)+p_Bra(t_texpr);
												}else{
													if(t_1==String(L"split",5)){
														return t_texpr+String(L".split",6)+p_Bra(t_arg0);
													}else{
														if(t_1==String(L"replace",7)){
															return String(L"string_replace",14)+p_Bra(t_texpr+String(L",",1)+t_arg0+String(L",",1)+t_arg1);
														}else{
															if(t_1==String(L"tolower",7)){
																return t_texpr+String(L".toLowerCase()",14);
															}else{
																if(t_1==String(L"toupper",7)){
																	return t_texpr+String(L".toUpperCase()",14);
																}else{
																	if(t_1==String(L"contains",8)){
																		return p_Bra(t_texpr+String(L".indexOf",8)+p_Bra(t_arg0)+String(L"!=-1",4));
																	}else{
																		if(t_1==String(L"startswith",10)){
																			return String(L"string_startswith",17)+p_Bra(t_texpr+String(L",",1)+t_arg0);
																		}else{
																			if(t_1==String(L"endswith",8)){
																				return String(L"string_endswith",15)+p_Bra(t_texpr+String(L",",1)+t_arg0);
																			}else{
																				if(t_1==String(L"tochars",7)){
																					return String(L"string_tochars",14)+p_Bra(t_texpr);
																				}else{
																					if(t_1==String(L"fromchar",8)){
																						return String(L"String.fromCharCode",19)+p_Bra(t_arg0);
																					}else{
																						if(t_1==String(L"fromchars",9)){
																							return String(L"string_fromchars",16)+p_Bra(t_arg0);
																						}else{
																							if(t_1==String(L"sin",3) || t_1==String(L"cos",3) || t_1==String(L"tan",3)){
																								return String(L"Math.",5)+t_id+p_Bra(p_Bra(t_arg0)+String(L"*D2R",4));
																							}else{
																								if(t_1==String(L"asin",4) || t_1==String(L"acos",4) || t_1==String(L"atan",4)){
																									return p_Bra(String(L"Math.",5)+t_id+p_Bra(t_arg0)+String(L"*R2D",4));
																								}else{
																									if(t_1==String(L"atan2",5)){
																										return p_Bra(String(L"Math.",5)+t_id+p_Bra(t_arg0+String(L",",1)+t_arg1)+String(L"*R2D",4));
																									}else{
																										if(t_1==String(L"sinr",4) || t_1==String(L"cosr",4) || t_1==String(L"tanr",4)){
																											return String(L"Math.",5)+t_id.Slice(0,-1)+p_Bra(t_arg0);
																										}else{
																											if(t_1==String(L"asinr",5) || t_1==String(L"acosr",5) || t_1==String(L"atanr",5)){
																												return String(L"Math.",5)+t_id.Slice(0,-1)+p_Bra(t_arg0);
																											}else{
																												if(t_1==String(L"atan2r",6)){
																													return String(L"Math.",5)+t_id.Slice(0,-1)+p_Bra(t_arg0+String(L",",1)+t_arg1);
																												}else{
																													if(t_1==String(L"sqrt",4) || t_1==String(L"floor",5) || t_1==String(L"ceil",4) || t_1==String(L"log",3) || t_1==String(L"exp",3)){
																														return String(L"Math.",5)+t_id+p_Bra(t_arg0);
																													}else{
																														if(t_1==String(L"pow",3)){
																															return String(L"Math.",5)+t_id+p_Bra(t_arg0+String(L",",1)+t_arg1);
																														}
																													}
																												}
																											}
																										}
																									}
																								}
																							}
																						}
																					}
																				}
																			}
																		}
																	}
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
	bb_config_InternalErr(String(L"Internal error",14));
	return String();
}
String c_AsTranslator::p_TransTryStmt(c_TryStmt* t_stmt){
	p_Emit(String(L"try{",4));
	int t_unr=p_EmitBlock(t_stmt->m_block,true);
	Array<c_CatchStmt* > t_=t_stmt->m_catches;
	int t_2=0;
	while(t_2<t_.Length()){
		c_CatchStmt* t_c=t_[t_2];
		t_2=t_2+1;
		p_MungDecl(t_c->m_init);
		p_Emit(String(L"}catch(",7)+t_c->m_init->m_munged+String(L":",1)+p_TransType(t_c->m_init->m_type)+String(L"){",2));
		int t_unr2=p_EmitBlock(t_c->m_block,true);
	}
	p_Emit(String(L"}",1));
	return String();
}
void c_AsTranslator::mark(){
	c_CTranslator::mark();
}
c_CsTranslator::c_CsTranslator(){
}
c_CsTranslator* c_CsTranslator::m_new(){
	c_CTranslator::m_new();
	return this;
}
String c_CsTranslator::p_TransType(c_Type* t_ty){
	if((dynamic_cast<c_VoidType*>(t_ty))!=0){
		return String(L"void",4);
	}
	if((dynamic_cast<c_BoolType*>(t_ty))!=0){
		return String(L"bool",4);
	}
	if((dynamic_cast<c_IntType*>(t_ty))!=0){
		return String(L"int",3);
	}
	if((dynamic_cast<c_FloatType*>(t_ty))!=0){
		return String(L"float",5);
	}
	if((dynamic_cast<c_StringType*>(t_ty))!=0){
		return String(L"String",6);
	}
	if((dynamic_cast<c_ArrayType*>(t_ty))!=0){
		return p_TransType(dynamic_cast<c_ArrayType*>(t_ty)->m_elemType)+String(L"[]",2);
	}
	if((dynamic_cast<c_ObjectType*>(t_ty))!=0){
		return t_ty->p_GetClass()->m_munged;
	}
	bb_config_InternalErr(String(L"Internal error",14));
	return String();
}
String c_CsTranslator::p_TransValue(c_Type* t_ty,String t_value){
	if((t_value).Length()!=0){
		if(((dynamic_cast<c_IntType*>(t_ty))!=0) && t_value.StartsWith(String(L"$",1))){
			return String(L"0x",2)+t_value.Slice(1);
		}
		if((dynamic_cast<c_BoolType*>(t_ty))!=0){
			return String(L"true",4);
		}
		if((dynamic_cast<c_IntType*>(t_ty))!=0){
			return t_value;
		}
		if((dynamic_cast<c_FloatType*>(t_ty))!=0){
			return t_value+String(L"f",1);
		}
		if((dynamic_cast<c_StringType*>(t_ty))!=0){
			return p_Enquote(t_value);
		}
	}else{
		if((dynamic_cast<c_BoolType*>(t_ty))!=0){
			return String(L"false",5);
		}
		if((dynamic_cast<c_NumericType*>(t_ty))!=0){
			return String(L"0",1);
		}
		if((dynamic_cast<c_StringType*>(t_ty))!=0){
			return String(L"\"\"",2);
		}
		if((dynamic_cast<c_ArrayType*>(t_ty))!=0){
			c_Type* t_elemTy=dynamic_cast<c_ArrayType*>(t_ty)->m_elemType;
			String t_t=String(L"[0]",3);
			while((dynamic_cast<c_ArrayType*>(t_elemTy))!=0){
				t_elemTy=dynamic_cast<c_ArrayType*>(t_elemTy)->m_elemType;
				t_t=t_t+String(L"[]",2);
			}
			return String(L"new ",4)+p_TransType(t_elemTy)+t_t;
		}
		if((dynamic_cast<c_ObjectType*>(t_ty))!=0){
			return String(L"null",4);
		}
	}
	bb_config_InternalErr(String(L"Internal error",14));
	return String();
}
String c_CsTranslator::p_TransLocalDecl(String t_munged,c_Expr* t_init){
	return p_TransType(t_init->m_exprType)+String(L" ",1)+t_munged+String(L"=",1)+t_init->p_Trans();
}
int c_CsTranslator::p_EmitEnter(c_FuncDecl* t_func){
	p_Emit(String(L"bb_std_lang.pushErr();",22));
	return 0;
}
int c_CsTranslator::p_EmitSetErr(String t_info){
	p_Emit(String(L"bb_std_lang.errInfo=\"",21)+t_info.Replace(String(L"\\",1),String(L"/",1))+String(L"\";",2));
	return 0;
}
int c_CsTranslator::p_EmitLeave(){
	p_Emit(String(L"bb_std_lang.popErr();",21));
	return 0;
}
String c_CsTranslator::p_TransStatic(c_Decl* t_decl){
	if(((t_decl->p_IsExtern())!=0) && ((dynamic_cast<c_ModuleDecl*>(t_decl->m_scope))!=0)){
		return t_decl->m_munged;
	}else{
		if(((bb_decl__env)!=0) && ((t_decl->m_scope)!=0) && t_decl->m_scope==(bb_decl__env->p_ClassScope())){
			return t_decl->m_munged;
		}else{
			if((dynamic_cast<c_ClassDecl*>(t_decl->m_scope))!=0){
				return t_decl->m_scope->m_munged+String(L".",1)+t_decl->m_munged;
			}else{
				if((dynamic_cast<c_ModuleDecl*>(t_decl->m_scope))!=0){
					return t_decl->m_scope->m_munged+String(L".",1)+t_decl->m_munged;
				}
			}
		}
	}
	bb_config_InternalErr(String(L"Internal error",14));
	return String();
}
String c_CsTranslator::p_TransGlobal(c_GlobalDecl* t_decl){
	return p_TransStatic(t_decl);
}
String c_CsTranslator::p_TransField(c_FieldDecl* t_decl,c_Expr* t_lhs){
	if((t_lhs)!=0){
		return p_TransSubExpr(t_lhs,2)+String(L".",1)+t_decl->m_munged;
	}
	return t_decl->m_munged;
}
int c_CsTranslator::p_EmitFuncDecl(c_FuncDecl* t_decl){
	p_BeginLocalScope();
	String t_args=String();
	Array<c_ArgDecl* > t_=t_decl->m_argDecls;
	int t_2=0;
	while(t_2<t_.Length()){
		c_ArgDecl* t_arg=t_[t_2];
		t_2=t_2+1;
		p_MungDecl(t_arg);
		if((t_args).Length()!=0){
			t_args=t_args+String(L",",1);
		}
		t_args=t_args+(p_TransType(t_arg->m_type)+String(L" ",1)+t_arg->m_munged);
	}
	String t_t=p_TransType(t_decl->m_retType)+String(L" ",1)+t_decl->m_munged+p_Bra(t_args);
	if(((t_decl->p_ClassScope())!=0) && ((t_decl->p_ClassScope()->p_IsInterface())!=0)){
		p_Emit(t_t+String(L";",1));
	}else{
		if((t_decl->p_IsAbstract())!=0){
			if((t_decl->m_overrides)!=0){
				p_Emit(String(L"public abstract override ",25)+t_t+String(L";",1));
			}else{
				p_Emit(String(L"public abstract ",16)+t_t+String(L";",1));
			}
		}else{
			String t_q=String(L"public ",7);
			if(t_decl->p_IsStatic()){
				t_q=t_q+String(L"static ",7);
			}else{
				if((t_decl->m_overrides)!=0){
					t_q=t_q+String(L"override ",9);
					if(!t_decl->p_IsVirtual()){
						t_q=t_q+String(L"sealed ",7);
					}
				}else{
					if(t_decl->p_IsVirtual()){
						t_q=t_q+String(L"virtual ",8);
					}
				}
			}
			p_Emit(t_q+t_t+String(L"{",1));
			p_EmitBlock((t_decl),true);
			p_Emit(String(L"}",1));
		}
	}
	p_EndLocalScope();
	return 0;
}
String c_CsTranslator::p_TransDecl(c_Decl* t_decl){
	c_ValDecl* t_vdecl=dynamic_cast<c_ValDecl*>(t_decl);
	if((t_vdecl)!=0){
		return p_TransType(t_vdecl->m_type)+String(L" ",1)+t_decl->m_munged;
	}
	bb_config_InternalErr(String(L"Internal error",14));
	return String();
}
int c_CsTranslator::p_EmitClassDecl(c_ClassDecl* t_classDecl){
	String t_classid=t_classDecl->m_munged;
	if((t_classDecl->p_IsInterface())!=0){
		String t_bases=String();
		Array<c_ClassDecl* > t_=t_classDecl->m_implments;
		int t_2=0;
		while(t_2<t_.Length()){
			c_ClassDecl* t_iface=t_[t_2];
			t_2=t_2+1;
			if((t_bases).Length()!=0){
				t_bases=t_bases+String(L",",1);
			}else{
				t_bases=String(L" : ",3);
			}
			t_bases=t_bases+t_iface->m_munged;
		}
		p_Emit(String(L"interface ",10)+t_classid+t_bases+String(L"{",1));
		c_Enumerator3* t_3=t_classDecl->p_Semanted()->p_ObjectEnumerator();
		while(t_3->p_HasNext()){
			c_Decl* t_decl=t_3->p_NextObject();
			c_FuncDecl* t_fdecl=dynamic_cast<c_FuncDecl*>(t_decl);
			if(!((t_fdecl)!=0)){
				continue;
			}
			p_EmitFuncDecl(t_fdecl);
		}
		p_Emit(String(L"}",1));
		return 0;
	}
	String t_superid=t_classDecl->m_superClass->m_munged;
	String t_bases2=String(L" : ",3)+t_superid;
	Array<c_ClassDecl* > t_4=t_classDecl->m_implments;
	int t_5=0;
	while(t_5<t_4.Length()){
		c_ClassDecl* t_iface2=t_4[t_5];
		t_5=t_5+1;
		t_bases2=t_bases2+(String(L",",1)+t_iface2->m_munged);
	}
	String t_q=String();
	if((t_classDecl->p_IsAbstract())!=0){
		t_q=t_q+String(L"abstract ",9);
	}else{
		if((t_classDecl->p_IsFinal())!=0){
			t_q=t_q+String(L"sealed ",7);
		}
	}
	p_Emit(t_q+String(L"class ",6)+t_classid+t_bases2+String(L"{",1));
	c_Enumerator3* t_6=t_classDecl->p_Semanted()->p_ObjectEnumerator();
	while(t_6->p_HasNext()){
		c_Decl* t_decl2=t_6->p_NextObject();
		c_FieldDecl* t_tdecl=dynamic_cast<c_FieldDecl*>(t_decl2);
		if((t_tdecl)!=0){
			p_Emit(String(L"public ",7)+p_TransDecl(t_tdecl)+String(L"=",1)+t_tdecl->m_init->p_Trans()+String(L";",1));
			continue;
		}
		c_FuncDecl* t_fdecl2=dynamic_cast<c_FuncDecl*>(t_decl2);
		if((t_fdecl2)!=0){
			p_EmitFuncDecl(t_fdecl2);
			continue;
		}
		c_GlobalDecl* t_gdecl=dynamic_cast<c_GlobalDecl*>(t_decl2);
		if((t_gdecl)!=0){
			p_Emit(String(L"public static ",14)+p_TransDecl(t_gdecl)+String(L";",1));
			continue;
		}
	}
	p_Emit(String(L"}",1));
	return 0;
}
String c_CsTranslator::p_TransApp(c_AppDecl* t_app){
	t_app->m_mainModule->m_munged=String(L"bb_",3);
	t_app->m_mainFunc->m_munged=String(L"bbMain",6);
	c_ValueEnumerator* t_=t_app->m_imported->p_Values()->p_ObjectEnumerator();
	while(t_->p_HasNext()){
		c_ModuleDecl* t_decl=t_->p_NextObject();
		p_MungDecl(t_decl);
	}
	c_Enumerator3* t_2=t_app->p_Semanted()->p_ObjectEnumerator();
	while(t_2->p_HasNext()){
		c_Decl* t_decl2=t_2->p_NextObject();
		p_MungDecl(t_decl2);
		c_ClassDecl* t_cdecl=dynamic_cast<c_ClassDecl*>(t_decl2);
		if(!((t_cdecl)!=0)){
			continue;
		}
		c_Enumerator3* t_3=t_cdecl->p_Semanted()->p_ObjectEnumerator();
		while(t_3->p_HasNext()){
			c_Decl* t_decl3=t_3->p_NextObject();
			if(((dynamic_cast<c_FuncDecl*>(t_decl3))!=0) && dynamic_cast<c_FuncDecl*>(t_decl3)->p_IsCtor()){
				t_decl3->m_ident=t_cdecl->m_ident+String(L"_",1)+t_decl3->m_ident;
			}
			p_MungDecl(t_decl3);
		}
	}
	c_Enumerator3* t_4=t_app->p_Semanted()->p_ObjectEnumerator();
	while(t_4->p_HasNext()){
		c_Decl* t_decl4=t_4->p_NextObject();
		c_ClassDecl* t_cdecl2=dynamic_cast<c_ClassDecl*>(t_decl4);
		if((t_cdecl2)!=0){
			p_EmitClassDecl(t_cdecl2);
			continue;
		}
	}
	c_ValueEnumerator* t_5=t_app->m_imported->p_Values()->p_ObjectEnumerator();
	while(t_5->p_HasNext()){
		c_ModuleDecl* t_mdecl=t_5->p_NextObject();
		p_Emit(String(L"class ",6)+t_mdecl->m_munged+String(L"{",1));
		c_Enumerator3* t_6=t_mdecl->p_Semanted()->p_ObjectEnumerator();
		while(t_6->p_HasNext()){
			c_Decl* t_decl5=t_6->p_NextObject();
			if(((t_decl5->p_IsExtern())!=0) || ((t_decl5->m_scope->p_ClassScope())!=0)){
				continue;
			}
			c_GlobalDecl* t_gdecl=dynamic_cast<c_GlobalDecl*>(t_decl5);
			if((t_gdecl)!=0){
				p_Emit(String(L"public static ",14)+p_TransDecl(t_gdecl)+String(L";",1));
				continue;
			}
			c_FuncDecl* t_fdecl=dynamic_cast<c_FuncDecl*>(t_decl5);
			if((t_fdecl)!=0){
				p_EmitFuncDecl(t_fdecl);
				continue;
			}
		}
		if(t_mdecl==t_app->m_mainModule){
			p_BeginLocalScope();
			p_Emit(String(L"public static int bbInit(){",27));
			c_Enumerator7* t_7=t_app->m_semantedGlobals->p_ObjectEnumerator();
			while(t_7->p_HasNext()){
				c_GlobalDecl* t_decl6=t_7->p_NextObject();
				p_Emit(p_TransGlobal(t_decl6)+String(L"=",1)+t_decl6->m_init->p_Trans()+String(L";",1));
			}
			p_Emit(String(L"return 0;",9));
			p_Emit(String(L"}",1));
			p_EndLocalScope();
		}
		p_Emit(String(L"}",1));
	}
	return p_JoinLines();
}
String c_CsTranslator::p_TransArgs(Array<c_Expr* > t_args){
	String t_t=String();
	Array<c_Expr* > t_=t_args;
	int t_2=0;
	while(t_2<t_.Length()){
		c_Expr* t_arg=t_[t_2];
		t_2=t_2+1;
		if((t_t).Length()!=0){
			t_t=t_t+String(L",",1);
		}
		t_t=t_t+t_arg->p_Trans();
	}
	return p_Bra(t_t);
}
String c_CsTranslator::p_TransFunc(c_FuncDecl* t_decl,Array<c_Expr* > t_args,c_Expr* t_lhs){
	if(t_decl->p_IsMethod()){
		if((t_lhs)!=0){
			return p_TransSubExpr(t_lhs,2)+String(L".",1)+t_decl->m_munged+p_TransArgs(t_args);
		}
		return t_decl->m_munged+p_TransArgs(t_args);
	}
	return p_TransStatic(t_decl)+p_TransArgs(t_args);
}
String c_CsTranslator::p_TransSuperFunc(c_FuncDecl* t_decl,Array<c_Expr* > t_args){
	return String(L"base.",5)+t_decl->m_munged+p_TransArgs(t_args);
}
String c_CsTranslator::p_TransConstExpr(c_ConstExpr* t_expr){
	return p_TransValue(t_expr->m_exprType,t_expr->m_value);
}
String c_CsTranslator::p_TransNewObjectExpr(c_NewObjectExpr* t_expr){
	String t_t=String(L"(new ",5)+t_expr->m_classDecl->m_munged+String(L"())",3);
	if((t_expr->m_ctor)!=0){
		t_t=t_t+(String(L".",1)+t_expr->m_ctor->m_munged+p_TransArgs(t_expr->m_args));
	}
	return t_t;
}
String c_CsTranslator::p_TransNewArrayExpr(c_NewArrayExpr* t_expr){
	String t_texpr=t_expr->m_expr->p_Trans();
	c_Type* t_elemTy=dynamic_cast<c_ArrayType*>(t_expr->m_exprType)->m_elemType;
	if((dynamic_cast<c_StringType*>(t_elemTy))!=0){
		return String(L"bb_std_lang.stringArray",23)+p_Bra(t_texpr);
	}
	String t_t=String(L"[",1)+t_texpr+String(L"]",1);
	while((dynamic_cast<c_ArrayType*>(t_elemTy))!=0){
		t_elemTy=dynamic_cast<c_ArrayType*>(t_elemTy)->m_elemType;
		t_t=t_t+String(L"[]",2);
	}
	return String(L"new ",4)+p_TransType(t_elemTy)+t_t;
}
String c_CsTranslator::p_TransSelfExpr(c_SelfExpr* t_expr){
	return String(L"this",4);
}
String c_CsTranslator::p_TransCastExpr(c_CastExpr* t_expr){
	c_Type* t_dst=t_expr->m_exprType;
	c_Type* t_src=t_expr->m_expr->m_exprType;
	String t_uexpr=t_expr->m_expr->p_Trans();
	String t_texpr=p_Bra(t_uexpr);
	if((dynamic_cast<c_BoolType*>(t_dst))!=0){
		if((dynamic_cast<c_BoolType*>(t_src))!=0){
			return t_texpr;
		}
		if((dynamic_cast<c_IntType*>(t_src))!=0){
			return p_Bra(t_texpr+String(L"!=0",3));
		}
		if((dynamic_cast<c_FloatType*>(t_src))!=0){
			return p_Bra(t_texpr+String(L"!=0.0f",6));
		}
		if((dynamic_cast<c_StringType*>(t_src))!=0){
			return p_Bra(t_texpr+String(L".Length!=0",10));
		}
		if((dynamic_cast<c_ArrayType*>(t_src))!=0){
			return p_Bra(t_texpr+String(L".Length!=0",10));
		}
		if((dynamic_cast<c_ObjectType*>(t_src))!=0){
			return p_Bra(t_texpr+String(L"!=null",6));
		}
	}else{
		if((dynamic_cast<c_IntType*>(t_dst))!=0){
			if((dynamic_cast<c_BoolType*>(t_src))!=0){
				return p_Bra(t_texpr+String(L"?1:0",4));
			}
			if((dynamic_cast<c_IntType*>(t_src))!=0){
				return t_texpr;
			}
			if((dynamic_cast<c_FloatType*>(t_src))!=0){
				return String(L"(int)",5)+t_texpr;
			}
			if((dynamic_cast<c_StringType*>(t_src))!=0){
				return String(L"int.Parse",9)+t_texpr;
			}
		}else{
			if((dynamic_cast<c_FloatType*>(t_dst))!=0){
				if((dynamic_cast<c_IntType*>(t_src))!=0){
					return String(L"(float)",7)+t_texpr;
				}
				if((dynamic_cast<c_FloatType*>(t_src))!=0){
					return t_texpr;
				}
				if((dynamic_cast<c_StringType*>(t_src))!=0){
					if(bb_config_ENV_TARGET==String(L"xna",3)){
						return String(L"float.Parse",11)+p_Bra(t_uexpr+String(L",CultureInfo.InvariantCulture",29));
					}
					return String(L"float.Parse",11)+p_Bra(t_uexpr);
				}
			}else{
				if((dynamic_cast<c_StringType*>(t_dst))!=0){
					if((dynamic_cast<c_IntType*>(t_src))!=0){
						return t_texpr+String(L".ToString()",11);
					}
					if((dynamic_cast<c_FloatType*>(t_src))!=0){
						if(bb_config_ENV_TARGET==String(L"xna",3)){
							return t_texpr+String(L".ToString(CultureInfo.InvariantCulture)",39);
						}
						return t_texpr+String(L".ToString()",11);
					}
					if((dynamic_cast<c_StringType*>(t_src))!=0){
						return t_texpr;
					}
				}else{
					if(((dynamic_cast<c_ObjectType*>(t_dst))!=0) && ((dynamic_cast<c_ObjectType*>(t_src))!=0)){
						if((t_src->p_GetClass()->p_ExtendsClass(t_dst->p_GetClass()))!=0){
							return t_texpr;
						}else{
							return String(L"(",1)+t_texpr+String(L" as ",4)+p_TransType(t_dst)+String(L")",1);
						}
					}
				}
			}
		}
	}
	bb_config_Err(String(L"CS translator can't convert ",28)+t_src->p_ToString()+String(L" to ",4)+t_dst->p_ToString());
	return String();
}
String c_CsTranslator::p_TransUnaryExpr(c_UnaryExpr* t_expr){
	int t_pri=p_ExprPri(t_expr);
	String t_t_expr=p_TransSubExpr(t_expr->m_expr,t_pri);
	return p_TransUnaryOp(t_expr->m_op)+t_t_expr;
}
String c_CsTranslator::p_TransBinaryExpr(c_BinaryExpr* t_expr){
	if(((dynamic_cast<c_BinaryCompareExpr*>(t_expr))!=0) && ((dynamic_cast<c_StringType*>(t_expr->m_lhs->m_exprType))!=0) && ((dynamic_cast<c_StringType*>(t_expr->m_rhs->m_exprType))!=0)){
		return p_Bra(p_TransSubExpr(t_expr->m_lhs,2)+String(L".CompareTo(",11)+t_expr->m_rhs->p_Trans()+String(L")",1)+p_TransBinaryOp(t_expr->m_op,String())+String(L"0",1));
	}
	int t_pri=p_ExprPri(t_expr);
	String t_t_lhs=p_TransSubExpr(t_expr->m_lhs,t_pri);
	String t_t_rhs=p_TransSubExpr(t_expr->m_rhs,t_pri-1);
	return t_t_lhs+p_TransBinaryOp(t_expr->m_op,t_t_rhs)+t_t_rhs;
}
String c_CsTranslator::p_TransIndexExpr(c_IndexExpr* t_expr){
	String t_t_expr=p_TransSubExpr(t_expr->m_expr,2);
	String t_t_index=t_expr->m_index->p_Trans();
	if((dynamic_cast<c_StringType*>(t_expr->m_expr->m_exprType))!=0){
		return String(L"(int)",5)+t_t_expr+String(L"[",1)+t_t_index+String(L"]",1);
	}
	return t_t_expr+String(L"[",1)+t_t_index+String(L"]",1);
}
String c_CsTranslator::p_TransSliceExpr(c_SliceExpr* t_expr){
	String t_t_expr=t_expr->m_expr->p_Trans();
	String t_t_args=String(L"0",1);
	if((t_expr->m_from)!=0){
		t_t_args=t_expr->m_from->p_Trans();
	}
	if((t_expr->m_term)!=0){
		t_t_args=t_t_args+(String(L",",1)+t_expr->m_term->p_Trans());
	}
	return String(L"((",2)+p_TransType(t_expr->m_exprType)+String(L")bb_std_lang.slice(",19)+t_t_expr+String(L",",1)+t_t_args+String(L"))",2);
}
String c_CsTranslator::p_TransArrayExpr(c_ArrayExpr* t_expr){
	String t_t=String();
	Array<c_Expr* > t_=t_expr->m_exprs;
	int t_2=0;
	while(t_2<t_.Length()){
		c_Expr* t_elem=t_[t_2];
		t_2=t_2+1;
		if((t_t).Length()!=0){
			t_t=t_t+String(L",",1);
		}
		t_t=t_t+t_elem->p_Trans();
	}
	return String(L"new ",4)+p_TransType(t_expr->m_exprType)+String(L"{",1)+t_t+String(L"}",1);
}
String c_CsTranslator::p_TransIntrinsicExpr(c_Decl* t_decl,c_Expr* t_expr,Array<c_Expr* > t_args){
	String t_texpr=String();
	String t_arg0=String();
	String t_arg1=String();
	String t_arg2=String();
	if((t_expr)!=0){
		t_texpr=p_TransSubExpr(t_expr,2);
	}
	if(t_args.Length()>0 && ((t_args[0])!=0)){
		t_arg0=t_args[0]->p_Trans();
	}
	if(t_args.Length()>1 && ((t_args[1])!=0)){
		t_arg1=t_args[1]->p_Trans();
	}
	if(t_args.Length()>2 && ((t_args[2])!=0)){
		t_arg2=t_args[2]->p_Trans();
	}
	String t_id=t_decl->m_munged.Slice(1);
	String t_id2=t_id.Slice(0,1).ToUpper()+t_id.Slice(1);
	String t_1=t_id;
	if(t_1==String(L"print",5)){
		return String(L"bb_std_lang.Print",17)+p_Bra(t_arg0);
	}else{
		if(t_1==String(L"error",5)){
			return String(L"bb_std_lang.Error",17)+p_Bra(t_arg0);
		}else{
			if(t_1==String(L"debuglog",8)){
				return String(L"bb_std_lang.DebugLog",20)+p_Bra(t_arg0);
			}else{
				if(t_1==String(L"debugstop",9)){
					return String(L"bb_std_lang.DebugStop()",23);
				}else{
					if(t_1==String(L"length",6)){
						if((dynamic_cast<c_StringType*>(t_expr->m_exprType))!=0){
							return t_texpr+String(L".Length",7);
						}
						return String(L"bb_std_lang.length",18)+p_Bra(t_texpr);
					}else{
						if(t_1==String(L"resize",6)){
							c_Type* t_ty=dynamic_cast<c_ArrayType*>(t_expr->m_exprType)->m_elemType;
							if((dynamic_cast<c_StringType*>(t_ty))!=0){
								return String(L"bb_std_lang.resize(",19)+t_texpr+String(L",",1)+t_arg0+String(L")",1);
							}
							String t_ety=p_TransType(t_ty);
							return String(L"(",1)+t_ety+String(L"[])bb_std_lang.resize(",22)+t_texpr+String(L",",1)+t_arg0+String(L",typeof(",8)+t_ety+String(L"))",2);
						}else{
							if(t_1==String(L"compare",7)){
								return t_texpr+String(L".CompareTo",10)+p_Bra(t_arg0);
							}else{
								if(t_1==String(L"find",4)){
									return t_texpr+String(L".IndexOf",8)+p_Bra(t_arg0+String(L",",1)+t_arg1);
								}else{
									if(t_1==String(L"findlast",8)){
										return t_texpr+String(L".LastIndexOf",12)+p_Bra(t_arg0);
									}else{
										if(t_1==String(L"findlast2",9)){
											return t_texpr+String(L".LastIndexOf",12)+p_Bra(t_arg0+String(L",",1)+t_arg1);
										}else{
											if(t_1==String(L"trim",4)){
												return t_texpr+String(L".Trim()",7);
											}else{
												if(t_1==String(L"join",4)){
													return String(L"String.Join",11)+p_Bra(t_texpr+String(L",",1)+t_arg0);
												}else{
													if(t_1==String(L"split",5)){
														return String(L"bb_std_lang.split",17)+p_Bra(t_texpr+String(L",",1)+t_arg0);
													}else{
														if(t_1==String(L"replace",7)){
															return t_texpr+String(L".Replace",8)+p_Bra(t_arg0+String(L",",1)+t_arg1);
														}else{
															if(t_1==String(L"tolower",7)){
																return t_texpr+String(L".ToLower()",10);
															}else{
																if(t_1==String(L"toupper",7)){
																	return t_texpr+String(L".ToUpper()",10);
																}else{
																	if(t_1==String(L"contains",8)){
																		return p_Bra(t_texpr+String(L".IndexOf",8)+p_Bra(t_arg0)+String(L"!=-1",4));
																	}else{
																		if(t_1==String(L"startswith",10)){
																			return t_texpr+String(L".StartsWith",11)+p_Bra(t_arg0);
																		}else{
																			if(t_1==String(L"endswith",8)){
																				return t_texpr+String(L".EndsWith",9)+p_Bra(t_arg0);
																			}else{
																				if(t_1==String(L"tochars",7)){
																					return String(L"bb_std_lang.toChars",19)+p_Bra(t_texpr);
																				}else{
																					if(t_1==String(L"fromchar",8)){
																						return String(L"new String",10)+p_Bra(String(L"(char)",6)+p_Bra(t_arg0)+String(L",1",2));
																					}else{
																						if(t_1==String(L"fromchars",9)){
																							return String(L"bb_std_lang.fromChars",21)+p_Bra(t_arg0);
																						}else{
																							if(t_1==String(L"sin",3) || t_1==String(L"cos",3) || t_1==String(L"tan",3)){
																								return String(L"(float)Math.",12)+t_id2+p_Bra(p_Bra(t_arg0)+String(L"*bb_std_lang.D2R",16));
																							}else{
																								if(t_1==String(L"asin",4) || t_1==String(L"acos",4) || t_1==String(L"atan",4)){
																									return String(L"(float)",7)+p_Bra(String(L"Math.",5)+t_id2+p_Bra(t_arg0)+String(L"*bb_std_lang.R2D",16));
																								}else{
																									if(t_1==String(L"atan2",5)){
																										return String(L"(float)",7)+p_Bra(String(L"Math.",5)+t_id2+p_Bra(t_arg0+String(L",",1)+t_arg1)+String(L"*bb_std_lang.R2D",16));
																									}else{
																										if(t_1==String(L"sinr",4) || t_1==String(L"cosr",4) || t_1==String(L"tanr",4)){
																											return String(L"(float)Math.",12)+t_id2.Slice(0,-1)+p_Bra(t_arg0);
																										}else{
																											if(t_1==String(L"asinr",5) || t_1==String(L"acosr",5) || t_1==String(L"atanr",5)){
																												return String(L"(float)Math.",12)+t_id2.Slice(0,-1)+p_Bra(t_arg0);
																											}else{
																												if(t_1==String(L"atan2r",6)){
																													return String(L"(float)Math.",12)+t_id2.Slice(0,-1)+p_Bra(t_arg0+String(L",",1)+t_arg1);
																												}else{
																													if(t_1==String(L"sqrt",4) || t_1==String(L"floor",5) || t_1==String(L"log",3) || t_1==String(L"exp",3)){
																														return String(L"(float)Math.",12)+t_id2+p_Bra(t_arg0);
																													}else{
																														if(t_1==String(L"ceil",4)){
																															return String(L"(float)Math.Ceiling",19)+p_Bra(t_arg0);
																														}else{
																															if(t_1==String(L"pow",3)){
																																return String(L"(float)Math.",12)+t_id2+p_Bra(t_arg0+String(L",",1)+t_arg1);
																															}
																														}
																													}
																												}
																											}
																										}
																									}
																								}
																							}
																						}
																					}
																				}
																			}
																		}
																	}
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
	bb_config_InternalErr(String(L"Internal error",14));
	return String();
}
String c_CsTranslator::p_TransTryStmt(c_TryStmt* t_stmt){
	p_Emit(String(L"try{",4));
	int t_unr=p_EmitBlock(t_stmt->m_block,true);
	Array<c_CatchStmt* > t_=t_stmt->m_catches;
	int t_2=0;
	while(t_2<t_.Length()){
		c_CatchStmt* t_c=t_[t_2];
		t_2=t_2+1;
		p_MungDecl(t_c->m_init);
		p_Emit(String(L"}catch(",7)+p_TransType(t_c->m_init->m_type)+String(L" ",1)+t_c->m_init->m_munged+String(L"){",2));
		int t_unr2=p_EmitBlock(t_c->m_block,true);
	}
	p_Emit(String(L"}",1));
	return String();
}
void c_CsTranslator::mark(){
	c_CTranslator::mark();
}
c_List11::c_List11(){
	m__head=((new c_HeadNode11)->m_new());
}
c_List11* c_List11::m_new(){
	return this;
}
c_Node19* c_List11::p_AddLast11(c_ModuleDecl* t_data){
	return (new c_Node19)->m_new(m__head,m__head->m__pred,t_data);
}
c_List11* c_List11::m_new2(Array<c_ModuleDecl* > t_data){
	Array<c_ModuleDecl* > t_=t_data;
	int t_2=0;
	while(t_2<t_.Length()){
		c_ModuleDecl* t_t=t_[t_2];
		t_2=t_2+1;
		p_AddLast11(t_t);
	}
	return this;
}
bool c_List11::p_IsEmpty(){
	return m__head->m__succ==m__head;
}
c_ModuleDecl* c_List11::p_RemoveLast(){
	c_ModuleDecl* t_data=m__head->m__pred->m__data;
	m__head->m__pred->p_Remove();
	return t_data;
}
bool c_List11::p_Equals5(c_ModuleDecl* t_lhs,c_ModuleDecl* t_rhs){
	return t_lhs==t_rhs;
}
c_Node19* c_List11::p_FindLast9(c_ModuleDecl* t_value,c_Node19* t_start){
	while(t_start!=m__head){
		if(p_Equals5(t_value,t_start->m__data)){
			return t_start;
		}
		t_start=t_start->m__pred;
	}
	return 0;
}
c_Node19* c_List11::p_FindLast10(c_ModuleDecl* t_value){
	return p_FindLast9(t_value,m__head->m__pred);
}
void c_List11::p_RemoveLast6(c_ModuleDecl* t_value){
	c_Node19* t_node=p_FindLast10(t_value);
	if((t_node)!=0){
		t_node->p_Remove();
	}
}
void c_List11::mark(){
	Object::mark();
}
c_Node19::c_Node19(){
	m__succ=0;
	m__pred=0;
	m__data=0;
}
c_Node19* c_Node19::m_new(c_Node19* t_succ,c_Node19* t_pred,c_ModuleDecl* t_data){
	m__succ=t_succ;
	m__pred=t_pred;
	m__succ->m__pred=this;
	m__pred->m__succ=this;
	m__data=t_data;
	return this;
}
c_Node19* c_Node19::m_new2(){
	return this;
}
int c_Node19::p_Remove(){
	m__succ->m__pred=m__pred;
	m__pred->m__succ=m__succ;
	return 0;
}
void c_Node19::mark(){
	Object::mark();
}
c_HeadNode11::c_HeadNode11(){
}
c_HeadNode11* c_HeadNode11::m_new(){
	c_Node19::m_new2();
	m__succ=(this);
	m__pred=(this);
	return this;
}
void c_HeadNode11::mark(){
	c_Node19::mark();
}
c_Enumerator6::c_Enumerator6(){
	m__list=0;
	m__curr=0;
}
c_Enumerator6* c_Enumerator6::m_new(c_List7* t_list){
	m__list=t_list;
	m__curr=t_list->m__head->m__succ;
	return this;
}
c_Enumerator6* c_Enumerator6::m_new2(){
	return this;
}
bool c_Enumerator6::p_HasNext(){
	while(m__curr->m__succ->m__pred!=m__curr){
		m__curr=m__curr->m__succ;
	}
	return m__curr!=m__list->m__head;
}
c_Stmt* c_Enumerator6::p_NextObject(){
	c_Stmt* t_data=m__curr->m__data;
	m__curr=m__curr->m__succ;
	return t_data;
}
void c_Enumerator6::mark(){
	Object::mark();
}
c_InvokeExpr::c_InvokeExpr(){
	m_decl=0;
	m_args=Array<c_Expr* >();
}
c_InvokeExpr* c_InvokeExpr::m_new(c_FuncDecl* t_decl,Array<c_Expr* > t_args){
	c_Expr::m_new();
	this->m_decl=t_decl;
	this->m_args=t_args;
	return this;
}
c_InvokeExpr* c_InvokeExpr::m_new2(){
	c_Expr::m_new();
	return this;
}
c_Expr* c_InvokeExpr::p_Semant(){
	if((m_exprType)!=0){
		return (this);
	}
	m_exprType=m_decl->m_retType;
	m_args=p_CastArgs(m_args,m_decl);
	return (this);
}
String c_InvokeExpr::p_ToString(){
	String t_t=String(L"InvokeExpr(",11)+m_decl->p_ToString();
	Array<c_Expr* > t_=m_args;
	int t_2=0;
	while(t_2<t_.Length()){
		c_Expr* t_arg=t_[t_2];
		t_2=t_2+1;
		t_t=t_t+(String(L",",1)+t_arg->p_ToString());
	}
	return t_t+String(L")",1);
}
String c_InvokeExpr::p_Trans(){
	return bb_translator__trans->p_TransInvokeExpr(this);
}
String c_InvokeExpr::p_TransStmt(){
	return bb_translator__trans->p_TransInvokeExpr(this);
}
void c_InvokeExpr::mark(){
	c_Expr::mark();
}
c_StmtExpr::c_StmtExpr(){
	m_stmt=0;
	m_expr=0;
}
c_StmtExpr* c_StmtExpr::m_new(c_Stmt* t_stmt,c_Expr* t_expr){
	c_Expr::m_new();
	this->m_stmt=t_stmt;
	this->m_expr=t_expr;
	return this;
}
c_StmtExpr* c_StmtExpr::m_new2(){
	c_Expr::m_new();
	return this;
}
c_Expr* c_StmtExpr::p_Semant(){
	if((m_exprType)!=0){
		return (this);
	}
	m_stmt->p_Semant();
	m_expr=m_expr->p_Semant();
	m_exprType=m_expr->m_exprType;
	return (this);
}
c_Expr* c_StmtExpr::p_Copy(){
	return ((new c_StmtExpr)->m_new(m_stmt,p_CopyExpr(m_expr)));
}
String c_StmtExpr::p_ToString(){
	return String(L"StmtExpr(,",10)+m_expr->p_ToString()+String(L")",1);
}
String c_StmtExpr::p_Trans(){
	return bb_translator__trans->p_TransStmtExpr(this);
}
void c_StmtExpr::mark(){
	c_Expr::mark();
}
c_MemberVarExpr::c_MemberVarExpr(){
	m_expr=0;
	m_decl=0;
}
c_MemberVarExpr* c_MemberVarExpr::m_new(c_Expr* t_expr,c_VarDecl* t_decl){
	c_Expr::m_new();
	this->m_expr=t_expr;
	this->m_decl=t_decl;
	return this;
}
c_MemberVarExpr* c_MemberVarExpr::m_new2(){
	c_Expr::m_new();
	return this;
}
c_Expr* c_MemberVarExpr::p_Semant(){
	if((m_exprType)!=0){
		return (this);
	}
	if(!((m_decl->p_IsSemanted())!=0)){
		bb_config_InternalErr(String(L"Internal error",14));
	}
	m_exprType=m_decl->m_type;
	return (this);
}
String c_MemberVarExpr::p_ToString(){
	return String(L"MemberVarExpr(",14)+m_expr->p_ToString()+String(L",",1)+m_decl->p_ToString()+String(L")",1);
}
bool c_MemberVarExpr::p_SideEffects(){
	return m_expr->p_SideEffects();
}
c_Expr* c_MemberVarExpr::p_SemantSet(String t_op,c_Expr* t_rhs){
	return p_Semant();
}
String c_MemberVarExpr::p_Trans(){
	return bb_translator__trans->p_TransMemberVarExpr(this);
}
String c_MemberVarExpr::p_TransVar(){
	return bb_translator__trans->p_TransMemberVarExpr(this);
}
void c_MemberVarExpr::mark(){
	c_Expr::mark();
}
c_VarExpr::c_VarExpr(){
	m_decl=0;
}
c_VarExpr* c_VarExpr::m_new(c_VarDecl* t_decl){
	c_Expr::m_new();
	this->m_decl=t_decl;
	return this;
}
c_VarExpr* c_VarExpr::m_new2(){
	c_Expr::m_new();
	return this;
}
c_Expr* c_VarExpr::p_Semant(){
	if((m_exprType)!=0){
		return (this);
	}
	if(!((m_decl->p_IsSemanted())!=0)){
		bb_config_InternalErr(String(L"Internal error",14));
	}
	m_exprType=m_decl->m_type;
	return (this);
}
String c_VarExpr::p_ToString(){
	return String(L"VarExpr(",8)+m_decl->p_ToString()+String(L")",1);
}
bool c_VarExpr::p_SideEffects(){
	return false;
}
c_Expr* c_VarExpr::p_SemantSet(String t_op,c_Expr* t_rhs){
	return p_Semant();
}
String c_VarExpr::p_Trans(){
	p_Semant();
	return bb_translator__trans->p_TransVarExpr(this);
}
String c_VarExpr::p_TransVar(){
	p_Semant();
	return bb_translator__trans->p_TransVarExpr(this);
}
void c_VarExpr::mark(){
	c_Expr::mark();
}
int bb_decl__loopnest;
c_Map9::c_Map9(){
	m_root=0;
}
c_Map9* c_Map9::m_new(){
	return this;
}
c_Node20* c_Map9::p_FindNode(String t_key){
	c_Node20* t_node=m_root;
	while((t_node)!=0){
		int t_cmp=p_Compare(t_key,t_node->m_key);
		if(t_cmp>0){
			t_node=t_node->m_right;
		}else{
			if(t_cmp<0){
				t_node=t_node->m_left;
			}else{
				return t_node;
			}
		}
	}
	return t_node;
}
c_FuncDeclList* c_Map9::p_Get(String t_key){
	c_Node20* t_node=p_FindNode(t_key);
	if((t_node)!=0){
		return t_node->m_value;
	}
	return 0;
}
int c_Map9::p_RotateLeft9(c_Node20* t_node){
	c_Node20* t_child=t_node->m_right;
	t_node->m_right=t_child->m_left;
	if((t_child->m_left)!=0){
		t_child->m_left->m_parent=t_node;
	}
	t_child->m_parent=t_node->m_parent;
	if((t_node->m_parent)!=0){
		if(t_node==t_node->m_parent->m_left){
			t_node->m_parent->m_left=t_child;
		}else{
			t_node->m_parent->m_right=t_child;
		}
	}else{
		m_root=t_child;
	}
	t_child->m_left=t_node;
	t_node->m_parent=t_child;
	return 0;
}
int c_Map9::p_RotateRight9(c_Node20* t_node){
	c_Node20* t_child=t_node->m_left;
	t_node->m_left=t_child->m_right;
	if((t_child->m_right)!=0){
		t_child->m_right->m_parent=t_node;
	}
	t_child->m_parent=t_node->m_parent;
	if((t_node->m_parent)!=0){
		if(t_node==t_node->m_parent->m_right){
			t_node->m_parent->m_right=t_child;
		}else{
			t_node->m_parent->m_left=t_child;
		}
	}else{
		m_root=t_child;
	}
	t_child->m_right=t_node;
	t_node->m_parent=t_child;
	return 0;
}
int c_Map9::p_InsertFixup9(c_Node20* t_node){
	while(((t_node->m_parent)!=0) && t_node->m_parent->m_color==-1 && ((t_node->m_parent->m_parent)!=0)){
		if(t_node->m_parent==t_node->m_parent->m_parent->m_left){
			c_Node20* t_uncle=t_node->m_parent->m_parent->m_right;
			if(((t_uncle)!=0) && t_uncle->m_color==-1){
				t_node->m_parent->m_color=1;
				t_uncle->m_color=1;
				t_uncle->m_parent->m_color=-1;
				t_node=t_uncle->m_parent;
			}else{
				if(t_node==t_node->m_parent->m_right){
					t_node=t_node->m_parent;
					p_RotateLeft9(t_node);
				}
				t_node->m_parent->m_color=1;
				t_node->m_parent->m_parent->m_color=-1;
				p_RotateRight9(t_node->m_parent->m_parent);
			}
		}else{
			c_Node20* t_uncle2=t_node->m_parent->m_parent->m_left;
			if(((t_uncle2)!=0) && t_uncle2->m_color==-1){
				t_node->m_parent->m_color=1;
				t_uncle2->m_color=1;
				t_uncle2->m_parent->m_color=-1;
				t_node=t_uncle2->m_parent;
			}else{
				if(t_node==t_node->m_parent->m_left){
					t_node=t_node->m_parent;
					p_RotateRight9(t_node);
				}
				t_node->m_parent->m_color=1;
				t_node->m_parent->m_parent->m_color=-1;
				p_RotateLeft9(t_node->m_parent->m_parent);
			}
		}
	}
	m_root->m_color=1;
	return 0;
}
bool c_Map9::p_Set8(String t_key,c_FuncDeclList* t_value){
	c_Node20* t_node=m_root;
	c_Node20* t_parent=0;
	int t_cmp=0;
	while((t_node)!=0){
		t_parent=t_node;
		t_cmp=p_Compare(t_key,t_node->m_key);
		if(t_cmp>0){
			t_node=t_node->m_right;
		}else{
			if(t_cmp<0){
				t_node=t_node->m_left;
			}else{
				t_node->m_value=t_value;
				return false;
			}
		}
	}
	t_node=(new c_Node20)->m_new(t_key,t_value,-1,t_parent);
	if((t_parent)!=0){
		if(t_cmp>0){
			t_parent->m_right=t_node;
		}else{
			t_parent->m_left=t_node;
		}
		p_InsertFixup9(t_node);
	}else{
		m_root=t_node;
	}
	return true;
}
void c_Map9::mark(){
	Object::mark();
}
c_StringMap8::c_StringMap8(){
}
c_StringMap8* c_StringMap8::m_new(){
	c_Map9::m_new();
	return this;
}
int c_StringMap8::p_Compare(String t_lhs,String t_rhs){
	return t_lhs.Compare(t_rhs);
}
void c_StringMap8::mark(){
	c_Map9::mark();
}
c_Node20::c_Node20(){
	m_key=String();
	m_right=0;
	m_left=0;
	m_value=0;
	m_color=0;
	m_parent=0;
}
c_Node20* c_Node20::m_new(String t_key,c_FuncDeclList* t_value,int t_color,c_Node20* t_parent){
	this->m_key=t_key;
	this->m_value=t_value;
	this->m_color=t_color;
	this->m_parent=t_parent;
	return this;
}
c_Node20* c_Node20::m_new2(){
	return this;
}
void c_Node20::mark(){
	Object::mark();
}
c_Map10::c_Map10(){
	m_root=0;
}
c_Map10* c_Map10::m_new(){
	return this;
}
c_Node21* c_Map10::p_FindNode(String t_key){
	c_Node21* t_node=m_root;
	while((t_node)!=0){
		int t_cmp=p_Compare(t_key,t_node->m_key);
		if(t_cmp>0){
			t_node=t_node->m_right;
		}else{
			if(t_cmp<0){
				t_node=t_node->m_left;
			}else{
				return t_node;
			}
		}
	}
	return t_node;
}
bool c_Map10::p_Contains(String t_key){
	return p_FindNode(t_key)!=0;
}
int c_Map10::p_RotateLeft10(c_Node21* t_node){
	c_Node21* t_child=t_node->m_right;
	t_node->m_right=t_child->m_left;
	if((t_child->m_left)!=0){
		t_child->m_left->m_parent=t_node;
	}
	t_child->m_parent=t_node->m_parent;
	if((t_node->m_parent)!=0){
		if(t_node==t_node->m_parent->m_left){
			t_node->m_parent->m_left=t_child;
		}else{
			t_node->m_parent->m_right=t_child;
		}
	}else{
		m_root=t_child;
	}
	t_child->m_left=t_node;
	t_node->m_parent=t_child;
	return 0;
}
int c_Map10::p_RotateRight10(c_Node21* t_node){
	c_Node21* t_child=t_node->m_left;
	t_node->m_left=t_child->m_right;
	if((t_child->m_right)!=0){
		t_child->m_right->m_parent=t_node;
	}
	t_child->m_parent=t_node->m_parent;
	if((t_node->m_parent)!=0){
		if(t_node==t_node->m_parent->m_right){
			t_node->m_parent->m_right=t_child;
		}else{
			t_node->m_parent->m_left=t_child;
		}
	}else{
		m_root=t_child;
	}
	t_child->m_right=t_node;
	t_node->m_parent=t_child;
	return 0;
}
int c_Map10::p_InsertFixup10(c_Node21* t_node){
	while(((t_node->m_parent)!=0) && t_node->m_parent->m_color==-1 && ((t_node->m_parent->m_parent)!=0)){
		if(t_node->m_parent==t_node->m_parent->m_parent->m_left){
			c_Node21* t_uncle=t_node->m_parent->m_parent->m_right;
			if(((t_uncle)!=0) && t_uncle->m_color==-1){
				t_node->m_parent->m_color=1;
				t_uncle->m_color=1;
				t_uncle->m_parent->m_color=-1;
				t_node=t_uncle->m_parent;
			}else{
				if(t_node==t_node->m_parent->m_right){
					t_node=t_node->m_parent;
					p_RotateLeft10(t_node);
				}
				t_node->m_parent->m_color=1;
				t_node->m_parent->m_parent->m_color=-1;
				p_RotateRight10(t_node->m_parent->m_parent);
			}
		}else{
			c_Node21* t_uncle2=t_node->m_parent->m_parent->m_left;
			if(((t_uncle2)!=0) && t_uncle2->m_color==-1){
				t_node->m_parent->m_color=1;
				t_uncle2->m_color=1;
				t_uncle2->m_parent->m_color=-1;
				t_node=t_uncle2->m_parent;
			}else{
				if(t_node==t_node->m_parent->m_left){
					t_node=t_node->m_parent;
					p_RotateRight10(t_node);
				}
				t_node->m_parent->m_color=1;
				t_node->m_parent->m_parent->m_color=-1;
				p_RotateLeft10(t_node->m_parent->m_parent);
			}
		}
	}
	m_root->m_color=1;
	return 0;
}
bool c_Map10::p_Set9(String t_key,c_FuncDecl* t_value){
	c_Node21* t_node=m_root;
	c_Node21* t_parent=0;
	int t_cmp=0;
	while((t_node)!=0){
		t_parent=t_node;
		t_cmp=p_Compare(t_key,t_node->m_key);
		if(t_cmp>0){
			t_node=t_node->m_right;
		}else{
			if(t_cmp<0){
				t_node=t_node->m_left;
			}else{
				t_node->m_value=t_value;
				return false;
			}
		}
	}
	t_node=(new c_Node21)->m_new(t_key,t_value,-1,t_parent);
	if((t_parent)!=0){
		if(t_cmp>0){
			t_parent->m_right=t_node;
		}else{
			t_parent->m_left=t_node;
		}
		p_InsertFixup10(t_node);
	}else{
		m_root=t_node;
	}
	return true;
}
void c_Map10::mark(){
	Object::mark();
}
c_StringMap9::c_StringMap9(){
}
c_StringMap9* c_StringMap9::m_new(){
	c_Map10::m_new();
	return this;
}
int c_StringMap9::p_Compare(String t_lhs,String t_rhs){
	return t_lhs.Compare(t_rhs);
}
void c_StringMap9::mark(){
	c_Map10::mark();
}
c_Node21::c_Node21(){
	m_key=String();
	m_right=0;
	m_left=0;
	m_value=0;
	m_color=0;
	m_parent=0;
}
c_Node21* c_Node21::m_new(String t_key,c_FuncDecl* t_value,int t_color,c_Node21* t_parent){
	this->m_key=t_key;
	this->m_value=t_value;
	this->m_color=t_color;
	this->m_parent=t_parent;
	return this;
}
c_Node21* c_Node21::m_new2(){
	return this;
}
void c_Node21::mark(){
	Object::mark();
}
c_Map11::c_Map11(){
	m_root=0;
}
c_Map11* c_Map11::m_new(){
	return this;
}
c_Node22* c_Map11::p_FindNode(String t_key){
	c_Node22* t_node=m_root;
	while((t_node)!=0){
		int t_cmp=p_Compare(t_key,t_node->m_key);
		if(t_cmp>0){
			t_node=t_node->m_right;
		}else{
			if(t_cmp<0){
				t_node=t_node->m_left;
			}else{
				return t_node;
			}
		}
	}
	return t_node;
}
c_StringSet* c_Map11::p_Get(String t_key){
	c_Node22* t_node=p_FindNode(t_key);
	if((t_node)!=0){
		return t_node->m_value;
	}
	return 0;
}
int c_Map11::p_RotateLeft11(c_Node22* t_node){
	c_Node22* t_child=t_node->m_right;
	t_node->m_right=t_child->m_left;
	if((t_child->m_left)!=0){
		t_child->m_left->m_parent=t_node;
	}
	t_child->m_parent=t_node->m_parent;
	if((t_node->m_parent)!=0){
		if(t_node==t_node->m_parent->m_left){
			t_node->m_parent->m_left=t_child;
		}else{
			t_node->m_parent->m_right=t_child;
		}
	}else{
		m_root=t_child;
	}
	t_child->m_left=t_node;
	t_node->m_parent=t_child;
	return 0;
}
int c_Map11::p_RotateRight11(c_Node22* t_node){
	c_Node22* t_child=t_node->m_left;
	t_node->m_left=t_child->m_right;
	if((t_child->m_right)!=0){
		t_child->m_right->m_parent=t_node;
	}
	t_child->m_parent=t_node->m_parent;
	if((t_node->m_parent)!=0){
		if(t_node==t_node->m_parent->m_right){
			t_node->m_parent->m_right=t_child;
		}else{
			t_node->m_parent->m_left=t_child;
		}
	}else{
		m_root=t_child;
	}
	t_child->m_right=t_node;
	t_node->m_parent=t_child;
	return 0;
}
int c_Map11::p_InsertFixup11(c_Node22* t_node){
	while(((t_node->m_parent)!=0) && t_node->m_parent->m_color==-1 && ((t_node->m_parent->m_parent)!=0)){
		if(t_node->m_parent==t_node->m_parent->m_parent->m_left){
			c_Node22* t_uncle=t_node->m_parent->m_parent->m_right;
			if(((t_uncle)!=0) && t_uncle->m_color==-1){
				t_node->m_parent->m_color=1;
				t_uncle->m_color=1;
				t_uncle->m_parent->m_color=-1;
				t_node=t_uncle->m_parent;
			}else{
				if(t_node==t_node->m_parent->m_right){
					t_node=t_node->m_parent;
					p_RotateLeft11(t_node);
				}
				t_node->m_parent->m_color=1;
				t_node->m_parent->m_parent->m_color=-1;
				p_RotateRight11(t_node->m_parent->m_parent);
			}
		}else{
			c_Node22* t_uncle2=t_node->m_parent->m_parent->m_left;
			if(((t_uncle2)!=0) && t_uncle2->m_color==-1){
				t_node->m_parent->m_color=1;
				t_uncle2->m_color=1;
				t_uncle2->m_parent->m_color=-1;
				t_node=t_uncle2->m_parent;
			}else{
				if(t_node==t_node->m_parent->m_left){
					t_node=t_node->m_parent;
					p_RotateRight11(t_node);
				}
				t_node->m_parent->m_color=1;
				t_node->m_parent->m_parent->m_color=-1;
				p_RotateLeft11(t_node->m_parent->m_parent);
			}
		}
	}
	m_root->m_color=1;
	return 0;
}
bool c_Map11::p_Set10(String t_key,c_StringSet* t_value){
	c_Node22* t_node=m_root;
	c_Node22* t_parent=0;
	int t_cmp=0;
	while((t_node)!=0){
		t_parent=t_node;
		t_cmp=p_Compare(t_key,t_node->m_key);
		if(t_cmp>0){
			t_node=t_node->m_right;
		}else{
			if(t_cmp<0){
				t_node=t_node->m_left;
			}else{
				t_node->m_value=t_value;
				return false;
			}
		}
	}
	t_node=(new c_Node22)->m_new(t_key,t_value,-1,t_parent);
	if((t_parent)!=0){
		if(t_cmp>0){
			t_parent->m_right=t_node;
		}else{
			t_parent->m_left=t_node;
		}
		p_InsertFixup11(t_node);
	}else{
		m_root=t_node;
	}
	return true;
}
void c_Map11::mark(){
	Object::mark();
}
c_StringMap10::c_StringMap10(){
}
c_StringMap10* c_StringMap10::m_new(){
	c_Map11::m_new();
	return this;
}
int c_StringMap10::p_Compare(String t_lhs,String t_rhs){
	return t_lhs.Compare(t_rhs);
}
void c_StringMap10::mark(){
	c_Map11::mark();
}
c_Node22::c_Node22(){
	m_key=String();
	m_right=0;
	m_left=0;
	m_value=0;
	m_color=0;
	m_parent=0;
}
c_Node22* c_Node22::m_new(String t_key,c_StringSet* t_value,int t_color,c_Node22* t_parent){
	this->m_key=t_key;
	this->m_value=t_value;
	this->m_color=t_color;
	this->m_parent=t_parent;
	return this;
}
c_Node22* c_Node22::m_new2(){
	return this;
}
void c_Node22::mark(){
	Object::mark();
}
c_Enumerator7::c_Enumerator7(){
	m__list=0;
	m__curr=0;
}
c_Enumerator7* c_Enumerator7::m_new(c_List10* t_list){
	m__list=t_list;
	m__curr=t_list->m__head->m__succ;
	return this;
}
c_Enumerator7* c_Enumerator7::m_new2(){
	return this;
}
bool c_Enumerator7::p_HasNext(){
	while(m__curr->m__succ->m__pred!=m__curr){
		m__curr=m__curr->m__succ;
	}
	return m__curr!=m__list->m__head;
}
c_GlobalDecl* c_Enumerator7::p_NextObject(){
	c_GlobalDecl* t_data=m__curr->m__data;
	m__curr=m__curr->m__succ;
	return t_data;
}
void c_Enumerator7::mark(){
	Object::mark();
}
c_Stack10::c_Stack10(){
	m_data=Array<c_LocalDecl* >();
	m_length=0;
}
c_Stack10* c_Stack10::m_new(){
	return this;
}
c_Stack10* c_Stack10::m_new2(Array<c_LocalDecl* > t_data){
	this->m_data=t_data.Slice(0);
	this->m_length=t_data.Length();
	return this;
}
c_LocalDecl* c_Stack10::m_NIL;
void c_Stack10::p_Clear(){
	for(int t_i=0;t_i<m_length;t_i=t_i+1){
		m_data[t_i]=m_NIL;
	}
	m_length=0;
}
c_Enumerator8* c_Stack10::p_ObjectEnumerator(){
	return (new c_Enumerator8)->m_new(this);
}
void c_Stack10::p_Length(int t_newlength){
	if(t_newlength<m_length){
		for(int t_i=t_newlength;t_i<m_length;t_i=t_i+1){
			m_data[t_i]=m_NIL;
		}
	}else{
		if(t_newlength>m_data.Length()){
			m_data=m_data.Resize(bb_math_Max(m_length*2+10,t_newlength));
		}
	}
	m_length=t_newlength;
}
int c_Stack10::p_Length2(){
	return m_length;
}
void c_Stack10::p_Push28(c_LocalDecl* t_value){
	if(m_length==m_data.Length()){
		m_data=m_data.Resize(m_length*2+10);
	}
	m_data[m_length]=t_value;
	m_length+=1;
}
void c_Stack10::p_Push29(Array<c_LocalDecl* > t_values,int t_offset,int t_count){
	for(int t_i=0;t_i<t_count;t_i=t_i+1){
		p_Push28(t_values[t_offset+t_i]);
	}
}
void c_Stack10::p_Push30(Array<c_LocalDecl* > t_values,int t_offset){
	p_Push29(t_values,t_offset,t_values.Length()-t_offset);
}
void c_Stack10::mark(){
	Object::mark();
}
c_Enumerator8::c_Enumerator8(){
	m_stack=0;
	m_index=0;
}
c_Enumerator8* c_Enumerator8::m_new(c_Stack10* t_stack){
	this->m_stack=t_stack;
	return this;
}
c_Enumerator8* c_Enumerator8::m_new2(){
	return this;
}
bool c_Enumerator8::p_HasNext(){
	return m_index<m_stack->p_Length2();
}
c_LocalDecl* c_Enumerator8::p_NextObject(){
	m_index+=1;
	return m_stack->m_data[m_index-1];
}
void c_Enumerator8::mark(){
	Object::mark();
}
int bbInit(){
	GC_CTOR
	c_Type::m_stringType=(new c_StringType)->m_new();
	bb_config__errInfo=String();
	bb_config__cfgScope=(new c_ConfigScope)->m_new();
	bb_config__cfgScopeStack=(new c_Stack2)->m_new();
	bb_decl__env=0;
	bb_decl__envStack=(new c_List2)->m_new();
	c_Toker::m__keywords=0;
	c_Toker::m__symbols=0;
	c_Toker::m__tokenFlags=0;
	bb_config_ENV_MODPATH=String();
	bb_parser_FILE_EXT=String(L".cxs",4);
	bb_parser_FILE_EXT_OLD=String(L".monkey",7);
	c_BlockTrace::m__Blocks=(new c_BlockTrace)->m_new();
	bb_config_ENV_SAFEMODE=0;
	c_Type::m_intType=(new c_IntType)->m_new();
	c_Type::m_floatType=(new c_FloatType)->m_new();
	c_Type::m_boolType=(new c_BoolType)->m_new();
	c_Type::m_voidType=(new c_VoidType)->m_new();
	c_Type::m_objectType=(new c_IdentType)->m_new(String(L"cerberus.object",15),Array<c_Type* >());
	c_Type::m_throwableType=(new c_IdentType)->m_new(String(L"cerberus.throwable",18),Array<c_Type* >());
	c_Type::m_emptyArrayType=(new c_ArrayType)->m_new(c_Type::m_voidType);
	c_Type::m_nullObjectType=(new c_IdentType)->m_new(String(),Array<c_Type* >());
	c_Stack8::m_NIL=0;
	bb_config__errStack=(new c_StringList)->m_new2();
	c_Stack3::m_NIL=0;
	c_Stack2::m_NIL=0;
	bb_config_ENV_HOST=String();
	bb_config_ENV_CONFIG=String();
	bb_config_ENV_TARGET=String();
	bb_config_ENV_LANG=String();
	c_Stack9::m_NIL=0;
	c_Stack::m_NIL=String();
	bb_translator__trans=0;
	bb_html5_Info_Width=0;
	bb_html5_Info_Height=0;
	c_ClassDecl::m_nullObjectClass=(new c_ClassDecl)->m_new(String(L"{NULL}",6),1280,Array<String >(),0,Array<c_IdentType* >());
	bb_decl__loopnest=0;
	c_Stack10::m_NIL=0;
	return 0;
}
void gc_mark(){
}
//${TRANSCODE_END}

String BBPathToFilePath( String path ){
	return path;
}

int main( int argc,const char **argv ){

	new BBGame();

	try{
	
		bb_std_main( argc,argv );
		
	}catch( ThrowableObject *ex ){
	
		bbPrint( "Cerberus Runtime Error : Uncaught Cerberus Exception" );
	
	}catch( const char *err ){
	
	}
}
