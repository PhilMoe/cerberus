> Cerberus&nbsp;X language reference

This manual describes the syntax and general concepts behind the core Cerberus&nbsp;X language.

>> Contents

<div class="multicolumn">
[About this reference](#about)~n
[Programs](#programs)~n
[Declarations](#declarations)~n
[Strict mode](#strict)~n
[Lines of code](#codelines)~n
[Comments](#comments)~n
[Identifiers](#identifiers)~n
&emsp;[Language keywords](#keywords)~n
&emsp;[Reserved identifiers](#keywords)~n
&emsp;[Cerberus X naming conventions](#naming)~n
[Literals](#literals)~n
[Types](#types)~n
&emsp;[The Bool type](#type_bool)~n
&emsp;&emsp;[Boolean literals](#literal_bool)~n
&emsp;[The Int type](#type_int)~n
&emsp;&emsp;[Integer literals](#literal_int)~n
&emsp;&emsp;[Hexadecimal literals](#literal_hex)~n
&emsp;[The Float type](#type_float)~n
&emsp;&emsp;[Floating point literals](#literal_float)~n
&emsp;[The String type](#type_string)~n
&emsp;&emsp;[String indexing and slicing](#string_indexing)~n
&emsp;&emsp;[String methods](#string_methods)~n
&emsp;&emsp;[String literals](#literal_string)~n
&emsp;&emsp;[String escape sequences](#string_escaping)~n
&emsp;&emsp;[Character literals](#literal_char)~n
&emsp;[The Array type](#type_array)~n
&emsp;&emsp;[Array indexing and slicing](#array_indexing)~n
&emsp;&emsp;[Array methods](#array_methods)~n
&emsp;&emsp;[Array literals](#literal_array)~n
&emsp;[The Object type](#type_object)~n
&emsp;&emsp;[Object literals](#literal_object)~n
[Variables](#variables)~n
&emsp;[Local variables](#locals)~n
&emsp;[Global variables](#globals)~n
&emsp;[Field variables](#fields)~n
[Constants](#constants)~n
[Enumerations](#enumerates)~n
[Expressions](#expressions)~n
&emsp;[Operators](#operators)~n
&emsp;[Order of operations (Precedence)](#operators)~n
&emsp;[Balancing argument types](#balancing)~n
&emsp;[Conditional operators](#conditional_ops)~n
&emsp;[Bitwise operators](#bitwise_ops)~n
&emsp;[Implicit conversions](#implicit_conversions)~n
&emsp;[Explicit conversions](#explicit_conversions)~n
&emsp;[Boxing and unboxing conversions](#boxing)~n
[Statements](#statements)~n
&emsp;[The If statement](#statement_if)~n
&emsp;[The Select statement](#statement_select)~n
&emsp;[The While loop](#loop_while)~n
&emsp;[The Repeat loop](#loop_repeat)~n
&emsp;[The numeric For loop](#loop_for)~n
&emsp;[The For EachIn loop](#loop_eachin)~n
&emsp;[Exit and Continue](#exit_continue)~n
&emsp;[Assignment statements](#assignments)~n
&emsp;[Update assignment statements](#assignments)~n
&emsp;[Expression statements](#exp_statements)~n
[Functions](#functions)~n
&emsp;[Function overloading](#overloading)~n
[Methods](#methods)~n
&emsp;[Property Methods](#properties)~n
[Classes](#classes)~n
&emsp;[Constructors](#constructors)~n
[Generics](#generics)~n
[Interfaces](#interfaces)~n
[Exceptions](#exceptions)~n
[Modules](#modules)~n
&emsp;[Alias](#alias)~n
[Public and private](#visibility)~n
[External declarations](#extern)~n
[Preprocessor](#preprocessor)~n
&emsp;[Custom preprocessor directives](#preprocessor_customs)~n
[I've Seen...](#iveseen)~n
[Glossary](#glossary)~n
</div>


>> <a name="about"></a> About this reference

A monospaced font is used for program code examples, for example:
<pre>
Function Main()
    Print "Hello World!"
End
</pre>

Language syntax explanations are generally formatted as follows:

* Anything that appears in monospaced font indicates syntax and pseudo-code. For example: `Print %StringLiteral%` means the keyword 'Print' followed by a string literal.
* Anything that appears in *bold* indicates literal text. For example: *Function* means the actual text 'Function'.
* Anything that appears in %italics% indicates other syntax. For example: %Identifier% means any text that is a valid identifier.
* Anything that appears in square brackets [ ] is optional. For example: [ *Step* ] means the literal text *Step* is optional.
* The pipe character | is use for alternatives. For example: *To* | *Until* means you can use *To* or *Until* - but not both.
* A three dots ellipsis is used to indicate repetition.

These rules are not strictly followed. Where it makes sense to do so, syntax may be shown in a simplified form with explanatory notes.


>> <a name="programs"></a> Programs

Every Cerberus&nbsp;X program has a 'main module' that must contain a public function called `*Main*` that takes no parameters and returns an integer. For example:

<pre>
Function Main:Int()             ' take nothing
    Print "That's all folks!"   ' do something
	Return 0                    ' return 0 to indicate everything went fine
End
</pre>

This is the entry point of the program and is where program execution begins. 

If you are using the mojo framework of modules, you must create a new class (which extends the base mojo.app class) and create a new instance of it in the `Main` function. See the [[mojo.app|mojo.app Module Reference]] for more information. An example of this is:

<pre>
Import mojo.app
Import mojo.graphics

Class MyApp Extends App
    Method OnRender()
        DrawText "Hello World!",0,0
    End
End

Function Main()
    New MyApp
End
</pre>


>> <a name="declarations"></a> Declarations

A Cerberus&nbsp;X program consists of one or more modules, each of which is a separate file, consisting of a series of declarations. 

A declaration associates a 'meaning' with an identifier. For example, this declaration...

<pre>
Global x:Int
</pre>

...indicates that the identifier `x` is a global variable of type 'Int' (an integer).

Cerberus&nbsp;X supports the following kinds of declarations:

* [Modules](#modules)
* [Constants](#constants)
* [Integer enumerations](#enumerates)
* [Local](#locals), [Global](#globals) and [Field](#fields) variables
* [Classes](#classes)
* [Functions](#functions)
* [Methods](#methods)

A module is itself a kind of declaration and is represented by a single source file. The name of the module is taken from the name of the source file. For example, if your file is named "particles.cxs" then the module will be called "particles".

Modules may 'import' other modules, which may in turn import other modules and so on. For more details about that, refer to the [Modules](#modules) section.


>> <a name="strict"></a> Strict mode

By default, Cerberus&nbsp;X allows you to take certain shortcuts when programming.

However, Cerberus&nbsp;X also offers a strict mode for programmers who prefer a stricter language definition.

The differences between strict and non-strict mode are:

* In non-strict mode, variable type, function return type and function parameter types can be optionally omitted. In this case they will default to Int. In strict mode, you must always specify the type of all variables, functions return values and function parameters.
* In non-strict mode, Return statements can be omitted at the end of a function. In this case, a Return statement will be automatically generated that will return an appropriate default value for the function type. That is, False for bool, 0 for int and float, "" for string, [] for arrays and Null for objects. In strict mode, a function that does not return Void must end with a Return statement.
* In non-strict mode, the brackets around function call parameters are optional if the function is being used as a statement, or if the function can be called with no parameters. In strict mode, functions returning a value must have their call parameters enclosed in brackets.

To use strict mode, the `Strict` directive must be placed at the very top of your module. For example:

<pre>
Strict

Import mojo

' in Strict mode, type definition for functions is compulsory:
Function Main:Int()
    ' in Strict mode, functions returning a value must be invoked with brackets:
    Print "the year is "+GetDate()[0]
    ' in Strict mode, functions returning a value must use the Return keyword:
    Return 0
End
</pre>

Most of the examples in this document will be presented in non-strict form.


>> <a name="codelines"></a> Lines of code

Lines of code are terminated by a newline character. Usually, you want to put one statement per line, but it's possible to put multiple statements on one line using the `*;*` character.

It's also possible to break long lines of code into multiple lines, but only after:

* commas (`*,*` in parameter lists, array element lists and enumerations)
* opening brackets
* the scope member access operator `.`
* all mathematical and logical [operators](#operators) 


>> <a name="comments"></a> Comments

You can add line comments to your programs using the `*'*` (apostrophe) character. Everything following the `'` character until the end of the line will be ignored.

You can add block comments to your programs using the `#Rem` and `#End` [preprocessor directives](#preprocessor). These must appear at the start of a new line, although they may optionally have whitespace characters in front. Everything between `#Rem` and `#End` will be ignored. Block comments can also be nested.

Here is an example of using comments:

<pre>
Print "Hello World"                 'This is a line comment!

#Rem                                'start of a block comment
Print "The sound of silence!"       'inside a block comment
#End
</pre>


>> <a name="identifiers"></a> Identifiers

Identifiers must start with an alphabetic character, or a single underscore followed by an alphabetic character. The rest of the identifier may contain any combination of alphanumeric characters and/or underscores.

Identifiers are case sensitive (except for language keywords - see below). For example, `player`, `Player`, `PLAYER` and `PLayER` are all different identifiers. This allows you to reuse the same name for different purposes. For example, `Actor` may refer to a class while `actor` refers to an object of that class.

Here are some examples of valid Cerberus&nbsp;X identifiers:

<pre>
score
player1
player_up
_internal
helloworld
HelloWorld
</pre>


>>> <a name="keywords"></a> Language keywords and reserved identifiers

The following identifiers are [[Keywords|Language keywords]] and are reserved for use by the Cerberus&nbsp;X language:

<pre>
Void Strict Public Private Property Bool Int Float String Array
Object Mod Continue Exit Import Extern New Self Super Try Catch
Eachin True False Not Extends Abstract Final Select Case Default
Const Enumerate Local Global Field Method Function Class And Or Shl Shr
End If Then Else ElseIf EndIf While Wend Repeat Until Forever 
For To Step Next Return Module Interface Implements Inline Throw
</pre>

Language keywords are case insensitive - for example, you may use the keyword `function`, `Function` or indeed even `fUNCTION` (not recommended) to declare a function.

The keywords `Module`, `Inline` and `Array` are not currently used by the Cerberus&nbsp;X language but are reserved for future use.


>>> <a name="naming"></a> Cerberus X naming conventions

The standard Cerberus&nbsp;X modules use a simple naming convention:

* All-caps case (eg: '`ALLCAPS`' ): [Constants](#constants).
* Pascal case (eg: '`PascalCase`' ): [Globals](#globals), [functions](#functions), [classes](#classes), [methods](#methods), [properties](#properties).
* Camel case (eg: '`camelCase`' ): [Fields](#fields), [locals](#locals) and function parameters.

You are of course free to use your own convention, but for the sake of consistency it is recommended that this convention be used for the public interface of any modules you create which are intended for use by the Cerberus&nbsp;X community.


>> <a name="literals"></a> Literals

Literals are values within the code used in assignments or comparisons.

<pre>
True            ' Bool literal
1234            ' Integer literal
$CAFEBABE       ' Hexadecimal literal
9.81            ' Floating point literal
"Hello World"   ' String literal
`A`             ' Character literal
[2,4,6]         ' Array literal
</pre>

See also: [Boolean literals](#literal_bool), [Integer literals](#literal_int), [Hexadecimal literals](#literal_hex), [Floating point literals](#literal_float), [String literals](#literal_string), [Character literals](#literal_char), [Array literals](#literal_array), [Object literals](#literal_object)


>> <a name="types"></a> Types

Cerberus&nbsp;X is a statically typed language, which means that all variables, function parameters, function return values and expressions have an associated type that is known at compile time.

The following types are supported:

| Type                          | Long notation           | Short notation
| [Boolean](#type_bool)         | `*:Bool*`               | `*?*`
| [Integer](#type_int)          | `*:Int*`                | `*\%*`
| [Floating Point](#type_float) | `*:Float*`              | `*#*`
| [String](#type_string)        | `*:String*`             | `*$*`
| [Array](#type_array)          | `*:*%ElementType%*[]*`  |
| [Object](#type_object)        | `*:*%ClassIdentifier%`  |


>>> <a name="type_bool"></a> The Bool type

Values of type 'Bool' are boolean values used to express the result of conditional expressions, such as the comparison operators, and to represent a true/false 'state' in general. A boolean value can only be either true or false. 

The syntax used for declaring values and variables of boolean type is `*:Bool*`. For example:

<pre>
Local gamePaused:Bool = False
</pre>

Boolean values are usually generated by the use of the comparison operators, for example:

<pre>
If livesLeft<>0
    doSomething()
End
</pre>

However, in some circumstances Cerberus&nbsp;X will automatically convert a non-bool value to bool. This will occur when evaluating an expression for use with the `If` or `While` statements; the `Until` part of a `Repeat` loop; and when evaluating the arguments for the `Not`, `Or` and `And` operators. For example:

<pre>
If livesLeft
    doSomething()
End
</pre>

See the [conversions section in the expressions chapter](#implicit_conversions) for more information.

Also, notice that boolean identifiers can also be declared by using the `*?*` character. This two lines of source code are both valid and syntactically correct:

<pre>
Local myVariable:Bool = True
Local myVariable? = True
</pre>


>>>> <a name="literal_bool"></a> Boolean literals

The keywords `True` and `False` can be used as 'pseudo' boolean literals:

<pre>
True
False
</pre>


>>> <a name="type_int"></a> The Int type

Values of type 'Int' are signed integer values - that is, values with no fractional part. The range of integer values supported is target dependent, but is at least 32 bits. A 32 bit integer can represent a range of values from: -2,147,483,648 to 2,147,483,647

The syntax used for declaring values and variables of integer type is `*:Int*`. For example:

<pre>
Local x:Int = 5
</pre>

Also, notice that integer identifiers can also be declared by using the `*%*` character. This two lines of source code are both valid and syntactically correct:
<pre>
Local myVariable:Int = 1024
Local myVariable% = 1024
</pre>


>>>> <a name="literal_int"></a> Integer literals

Integer literals are sequences of digits without a fractional part:

<pre>
0
1234
</pre>


>>>> <a name="literal_hex"></a> Hexadecimal literals

Hexadecimal literals are also supported with the `*$*` prefix. For example, the following are also valid integer literals:

<pre>
$3D0DEAD
$CAFEBABE
</pre>


>>> <a name="type_float"></a> The Float type

Values of type 'Float' are signed numeric values with both an integer and fractional part. The range of floating point values support is target dependent, but is at least 32 bits.

The syntax used for declaring values and variables of floating point type is `*:Float*`.  For example:

<pre>
Local gravity:Float = 9.81
</pre>

Also, notice that floating point identifiers can also be declared by using the `*#*` character. This two lines of source code are both valid and syntactically correct:
<pre>
Local myVariable:Float = 3.141516
Local myVariable# = 3.141516
</pre>


>>>> <a name="literal_float"></a> Floating point literals

Floating point literals are sequences of digits that include a fractional part, for example:

<pre>
.0
0.0
.5
0.5
1.0
1.5
1.00001
3.14159265
</pre>


>>> <a name="type_string"></a> The String type

Values of type 'String' are used to represent sequences of characters, such as text. The size of each character in a string value is target dependent, but is at least 8 bits.

The syntax used for declaring values and variables of string type is `*:String*`. For example:

<pre>
Local name:String = "John Smith"
</pre>

Also, notice that string identifiers can also be declared by using the `*$*` character. This two lines of source code are both valid and syntactically correct:
<pre>
Local message:String = "Hello world"
Local message$ = "Hello world"
</pre>

Strings are immutable meaning that once they are created they cannot be modified. Operations that 'modify' a string will always return a new string.


>>>> <a name="string_indexing"></a> String indexing and slicing

Strings can also be indexed and sliced.

The syntax for indexing a string is: `%StringExpression% *[* %IndexExpression% *]*`

Indexing a string returns the character code of the character at %IndexExpression%. Index 0 is the first character in the string.

%IndexExpression% must be greater than or equal to 0 and less than the length of %StringExpression% otherwise an error occurs.

Here are some examples of indexing a string:

<pre>
Print "ABC"[0]                ' prints 65 - the character code of 'A'
Print "ABC"[1]                ' prints 66 - the character code of 'B'
Print "Hi~n"[2]               ' prints 10 - the character code of '~n'
</pre>

The syntax for slicing a string is: `%StringExpression% *[* %StartExpression% *..* %EndExpression% *]*`

Slicing a string returns a new string consisting of the characters within %StringExpression% from index %StartExpression% (inclusively) to index %EndExpression% (exclusively).

Both %StartExpression% and %EndExpression% are optional. If %StartExpression% is omitted, it defaults to 0. If %EndExpression% is omitted, it defaults to the length of the string.

%StartExpression% and %EndExpression% can also be negative, in which case they refer to offsets from the end of the string.

Here are some examples of slicing a string:

<pre>
Print "Hello World"[4..7]     ' prints "o W'
Print "Hello World"[..5]      ' prints "Hello"
Print "Hello World"[6..]      ' prints "World"
Print "Hello World"[..]       ' prints "Hello World"
Print "Hello World"[-4..-2]   ' prints "or"
</pre>


>>>> <a name="string_methods"></a> String Methods

Strings can be concatenated (joined) using the `*+*` operator. Additionally, Strings support a number of 'pseudo' methods and functions, as documented in the [[String|String class]].

For example:

<pre>
Print "Hello "+"World"				'prints "Hello World"
Print "  Hello World  ~n".Trim()	'prints "Hello World"
Print "Hello World".ToUpper()		'prints "HELLO WORLD"
</pre>


>>>> <a name="literal_string"></a> String literals

String literals are sequences of characters enclosed in `*""*` (quotation marks):

<pre>
"Hello world"
"1234"
</pre>


>>>> <a name="string_escaping"></a> String escape sequences

String literals may also include escape sequences - sequences of characters used to represent unprintable characters.

You can use the following escape sequences in string literals:

| Escape sequence | Character code
| `~q`            | 34 (quotation mark ")
| `~g`            | 96 (back-tick &#96;)
| `~n`            | 10 (newline)
| `~r`            | 13 (return)
| `~t`            | 9 (tabulator)
| `~z`            | 0 (null)
| `~u006F`        | unicode char 0x006F
| `~~`            | 126 (tilde ~)

Here are some examples of string literals using escape sequences:

<pre>
"~qHello World~q"
"~tIndented~n"
</pre>


>>>> <a name="literal_char"></a> Character literals

Character literals are single printable characters enclosed in `*&#96;&#96;*` (grave accents or back-ticks). They allow you to put character codes directly into the code:

<pre>
`A`
</pre>

Character literals support the same [escape sequences](#string_escaping) as strings do.
They're typically used for string analysis:

<pre>
Local txt$ = "ABC"
If txt[0] = `A` Then Print "Yes, that string starts with 'A'"
</pre>


>>> <a name="type_array"></a> The Array type

An array is a linear sequence of values that can be addressed using an integer index. Arrays in Cerberus&nbsp;X cannot be multi-dimensional.

Each array has an associated element type - that is, the type of the elements actually contained in the array. Due to the nature of Cerberus&nbsp;X, an array's element type is a purely static property. It is only known at compile time so arrays cannot be downcast at runtime.

The syntax used for declaring values and variables of array type is: `*:* %ElementType% *[]*`

For example:

<pre>
Local box:Int[]            ' an array of ints
Local ratio:Float[]        ' an array of floats
Local thing:Int[][]        ' an array of arrays of ints
</pre>


>>>> <a name="array_indexing"></a> Array indexing and slicing

The syntax for indexing an array is: `%ArrayExpression% *[* %IndexExpression% *]*`. For example:

<pre>
Local score:Int[]=[10,20,30]  'a comma separated sequence
Print score[1]                'prints "20"
</pre>

Indexing an array yields a 'pseudo variable' of the array's element type that can be both read from and written to.

%IndexExpression% must be an integer expression greater than or equal to 0 and less than the length of the array otherwise an error occurs.

Like strings, arrays can also be sliced. The syntax for slicing an array is: `%ArrayExpression% *[* %StartExpression% *..* %EndExpression% *]*`.

Slicing an array returns 'sub array' of %ArrayExpression% from index %StartExpression% (inclusively) to index %EndExpression% (exclusively).

Both %StartExpression% and %EndExpression% are optional. If %StartExpression% is omitted, it defaults to 0. If %EndExpression% is omitted, it defaults to the length of the array.

%StartExpression% and %EndExpression% can also be negative, in which case they refer to offsets from the end of the array.

Here is an example of slicing an array:

<pre>
Local text:String[]=["Cruel","Hello","World","There"]    'a comma separated sequence
Local helloWorld:=text[1..3]                             'contains ["Hello","World"]
</pre>


>>>> <a name="array_methods"></a> Array methods

Arrays also support a number of 'pseudo' methods, as documented in the [[Array|Array class]]:

For example:

<pre>
Local text:String[]=["Hello","There","World"]   ' a comma separated sequence
Print text.Length                               ' prints '3'
text=text.Resize( 2 )
Print text.Length                               ' prints '2'
</pre>


>>>> <a name="literal_array"></a> Array literals

An array literal is a (possibly empty) comma separated sequence of expressions enclosed with `*[*` and `*]*`. The expressions used in an array literal must be of the same type. For example:

<pre>
Local box:Int[]=[]                              ' an empty array literal
Local scores:Int[]=[10,20,30]                   ' a comma separated sequence
Local text:String[]=["Hello","There","World"]   ' a comma separated sequence
</pre>


>>> <a name="type_object"></a> The Object type

An object is an instance of a class, and contains a set of constants, variables, methods and functions.

The syntax used for declaring values and variables of object type is: `*:* %ClassIdentifier%`

For example:

<pre>
Local mine:MyClass = New MyClass
</pre>

Please see the [classes](#classes) section for more information on declaring classes and creating objects.


>>>> <a name="literal_object"></a> Object literals

The keyword `Null` can be used as 'pseudo' object literal, representing the null object, which can be used for comparisons or to 'reset' a reference:

<pre>
Null
</pre>


>> <a name="variables"></a> Variables

A variable is a storage location used to hold values that change while your program runs.

All variables have an identifier, a type, and an optional initialiser - an expression used to set the variable to an initial value.

The type of a variable can either be declared literally, or can be deduced from the variable's initialiser.


>>> <a name="locals"></a> Local variables

Local variables are temporary variables that disappear when the local scope they are declared in is destroyed.

Local variables may be declared within any local scope.

Each of the following creates a local scope:

* The statements inside a function or method.
* The statements inside an If, Else If or If block.
* The statements inside a Case or Default block.
* The statements inside a While, Repeat or For loop.

The syntax for declaring a local variable is:

`*Local* %Identifier% *:* %Type% [ *=* %Expression% ]`

Or...

`*Local* %Identifier% *:=* %Expression%`

For example:

<pre>
Local age:Int=10
Local age:=10
</pre>


>>> <a name="globals"></a> Global variables

Global variables are variables that persist during the execution of your program.

Global variables may be declared at module scope, or within a class declaration.

The syntax for declaring a global variable is:

`*Global* %Identifier% *:* %Type% [ *=* %Expression% ]`

Or...

`*Global* %Identifier% *:=* %Expression%`

For example:

<pre>
Global isPlayerAlive:Bool = True
</pre>


>>> <a name="fields"></a> Field variables

Field variables are variables that persist as long as the object they belong to. 

Field variables can only be declared within a class declaration.

The syntax for declaring a field variable is:

`*Field* %Identifier% *:* %Type% [ *=* %Expression% ]`

Or...

`*Field* %Identifier% *:=* %Expression%`


>> <a name="constants"></a> Constants

A constant is a value that is evaluated at compile time, and that does not change throughout the execution of a program.

Constants may be declared at module scope, within class scope or within any local scope.

The syntax for declaring a constant is:

`*Const* %Identifier% *:* %Type% *=* %Expression%`

Or...

`*Const* %Identifier% *:=* %Expression%`


>> <a name="enumerates"></a> Integer enumerations

An enumeration is a sequence of constant integer values that are evaluated at compile time, and that do not change throughout the execution of a program.

Enumerations may be declared at module scope, within class scope or within any local scope. 

Their corresponding values are assigned automatically and unless you state a specific value, start with 0.

The syntax for declaring an enumeration is:

`*Enumerate* %Identifier% *,* %Identifier% *,* %Identifier% [ *,* ...]`

Or...

`*Enumerate* %Identifier% *=* %Startvalue% *,* %Identifier% *,* %Identifier% *=* %Startvalue% [ *,* ...]`


>> <a name="expressions"></a> Expressions

Expressions are the parts of a program that perform calculations, make logical comparisons and return values from methods or functions. Expressions always evaluate to - or are used to evaluate to - a value of certain type.


>>> <a name="operators"></a> Operators and Order of Operations (Precedence)

The following table shows the order of operators in Cerberus&nbsp;X:

| Operator syntax   | Description | [Update assignment](#assignments) equivalent
| `New` %ClassType% | Create a new object |
| `Null`            | The null object |
| `True`            | Boolean true |
| `False`           | Boolean false |
| `Self`            | Self object reference |
| `Super`           | Super object reference |
| %Literal%         | Literal |
| %Identifier%      | Identifier |
| | |
| `.` %Identifier%  | Scope member access |
| `(` %ExpressionSeq% `)` | Invoke |
| `[` %IndexExpression% `]` | Index |
| | |
| `+`               | Unary plus |
| `-`               | Unary minus |
| `~`               | Bitwise complement |
| `Not`             | Boolean inverse |
| | |
| `*`               | Multiplication | `\*=`
| `/`               | Division | `/=`
| `Mod`             | Modulus | `Mod=`
| `Shl`             | Bitwise shift left | `Shl=`
| `Shr`             | Bitwise shift right (signed) | `Shr=`
| | |
| `+`               | Addition | `+=`
| `-`               | Subtraction | `-=`
| | |
| `&`               | Bitwise 'and' | `&=`
| `~`               | Bitwise 'xor' | `~=`
| | |
| `&#124;`          | Bitwise 'or' | `&#124;=`
| | |
| `=`               | Equals |
| `\<`              | Less than |
| `\>`              | Greater than |
| `\<=`             | Less than or equals |
| `\>=`             | Greater than or equals |
| `\<\>`            | Not equals |
| | |
| `And`             | Conditional 'and' |
| | |
| `Or`              | Conditional 'or' |

From `+` (unary plus) onward, the operator may be followed by a line break.

Note that in update assignments the right-hand-side is completely evaluated first before the update takes place.


>>> <a name="balancing"></a> Balancing argument types

When performing binary arithmetic (`*`, `/`, `Mod`, `+`, `-`) or comparison operations (`=`, `\<`, `\>`, `\<=`, `\>=`, `\<\>`), operator arguments are 'balanced' according to the following rules:

* If either operand is not string, float or int, then error,
* else if either operand is a string, then the balanced type is string,
* else if either operand is a float, then the balanced type is float,
* else the balanced type is int.

In the case of arithmetic operations, arguments are first implicitly converted to the balanced type if necessary, and the result is also of the balanced type.

In the case of comparison operations, arguments are first implicitly converted to the balanced type if necessary, and the result is boolean.

The only valid arithmetic operation that can be performed on strings is addition, which performs string concatenation on the arguments.


>>> <a name="conditional_ops"></a> Conditional operators

The arguments of conditional operations (`And`, `Or`) are first converted to boolean if necessary and the result is boolean.

In the case of `Or`, if the left-hand-side expression evaluates to true, the right-hand-side expression is not evaluated.  

For example:

<pre>
If car<>Null Or GetSpeed()>10 Then...
</pre>

In the above example, if car is not null, then the right-hand-side of the `Or` is not evaluated - ie: the `GetSpeed` function is never called.

In the case of `And`, if the left-hand-side expression evaluates to false, the right-hand-side expression is not evaluated.  

For example:

<pre>
If enemies.Count > 0 And HasEnemyInSight() Then ...
</pre>

In the above example, if `enemies.Count` is \<= 0, then the right-hand-side of the And is not evaluated - ie: the `HasEnemyInSight` function is never called.


>>> <a name="bitwise_ops"></a> Bitwise operators

When performing bitwise operations (`Shl`, `Shr`, `&`, `|`, `~`), arguments are first implicitly converted to integers if necessary before the operation is performed. The result is also an integer.


>>> <a name="implicit_conversions"></a> Implicit conversions

Implicit conversions are automatic conversions performed when assigning a value to a variable, passing parameters to a function, returning a value from a function or when balancing operator operands.

Cerberus&nbsp;X supports the following implicit conversions:

| Source type          | Target type       | Notes
| Boolean              | Integer           | Result is 1 if source is true, 0 if false.
| Integer              | Floating point    |
| Integer              | String            |
| Floating point       | Integer           | Value is converted by discarding fractional part.
| Floating point       | String            | Conversion is target dependent.
| Derived class object | Base class object | Upcast operation.


>>> <a name="explicit_conversions"></a> Explicit conversions

Explicit conversions are conversions from one type to another type which can be performed manually by the programmer .

The syntax for performing an explicit conversion is: `%TargetType% *(* %Expression% *)*`

For example:

<pre>
Local energyFloat:Float = 120.1000002001

Local energyInt:Int = Int(energyFloat)         'Is 120 now
</pre>

You can perform the following explicit conversions in Cerberus&nbsp;X:

| Source type          | Target type          | Notes
| Integer              | Boolean              | Result is true if source \<\> 0, else false.
| Floating point       | Boolean              | Result is true if source \<\> 0.0, else false.
| Array                | Boolean              | Result is true if source.Length \<\> 0, else false.
| Object               | Boolean              | Result is true if source \<\> null, else false.
| String               | Boolean              | Result is true if source \<\> "", else false.
| String               | Integer              | Conversion is target dependent.
| String               | Floating point       | Conversion is target dependent.
| Base class object    | Derived class object | Result is null if source is not a superclass of derived class.

In some circumstances, Cerberus&nbsp;X will automatically perform an explicit conversion of a non-bool value to bool for you. This will occur when evaluating an expression for use with the `If` and `While` statements; the `Until` part of a `Repeat` loop; and when evaluating the arguments for the `Not`, `Or` and `And` operators. This allows you to use 'shortcut' code such as: `If x Then y` without the need to compare `x` with `0`, `""`, `[]` or `Null`.


>>> <a name="boxing"></a> Boxing and unboxing conversions

A 'box' object is an object designed to contain a single primitive int, float or string value. The process of placing a value into a box object is known as 'boxing', while extracting a value from an object is known as 'unboxing'. To help with writing box objects, Cerberus&nbsp;X provides some simple features for boxing and unboxing values:

* An int, float or string value will be automatically converted to a new box object if that object provides a suitable `New( %Int% )`, `New( %Float% )` or `New( %String% )` constructor.
* An object will be automatically converted to an int, float or string value if that object provides a suitable `ToInt:Int()`, `ToFloat:Float()` or `ToString:String()` method.

For example, here is a simple box class designed to hold an integer value:

<pre>
Class IntBox
    Field value:Int

    Method New( value:Int )
        Self.value=value
    End

    Method ToInt:Int()
        Return value
    End
End

Function Main()
    Local box:IntBox
    box=10

    Local t:Int=box
    Print t
End
</pre>


>> <a name="statements"></a> Statements

Program statements may only appear within method or function declarations.

A `*;*` character may optionally appear after any statement, and multiple statements may be placed on the same source code line if separated by the `*;*` character.


>>> <a name="statement_if"></a> The If statement

The `If` statement allows you to conditionally execute a block of statements depending on the result of a series of boolean expressions.

The first boolean expression that evaluates to true will cause the associated block of statements to be executed. No further boolean expressions will be evaluated.

If no boolean expression evaluates to true, then the final `Else` block will be executed if present.

The syntax for the If statement is:

`*If* %Expression% [ *Then* ]`~n
`&nbsp;&nbsp;&nbsp;&nbsp; %Statements...%`~n
`*ElseIf* %Expression% [ *Then* ]`~n
`&nbsp;&nbsp;&nbsp;&nbsp; %Statements...%`~n
`*Else*`~n
`&nbsp;&nbsp;&nbsp;&nbsp; %Statements...%`~n
`*EndIf*`

There may be any number of `ElseIf` blocks, or none. The final `Else` block is optional.

`*End*` or `*End If*` may be used instead of `*EndIf*`, and `*Else If*` may be used instead of `*ElseIf*`.

In addtion, a simple one line version of If is also supported:

`*If* %Expression% [ *Then* ] %Statement% [ *Else* %Statement% ]`


>>> <a name="statement_select"></a> The Select statement

The `Select` statement allows you to execute a block of statements depending on a series of comparisons.

The first comparison to produce a match will cause the associated block of statements to be executed.

If no comparisons produce a match, then the final `Default` block will be executed if present.

The syntax for the Select statement is:

`*Select* %Expression%`~n
`*Case* %Expression% [ *,* %Expression%... ]`~n
`&nbsp;&nbsp;&nbsp;&nbsp; %Statements...%`~n
`*Default*`~n
`&nbsp;&nbsp;&nbsp;&nbsp; %Statements...%`~n
`*End* [ *Select* ]`

There may be any number of `Case` blocks, or none. The final `Default` block is optional. If the `Default` block is present, it must appear after all `Case` blocks.


>>> <a name="loop_while"></a> The While loop

The `While` loop allows you to execute a block of statements repeatedly while a boolean expression evaluates to true.

Note that a `While` loop may never actually execute any of it's statements if the expression evaluates to false when the loop is entered.

The syntax for the `While` loop is:

`*While* %Expression%`~n
`&nbsp;&nbsp;&nbsp;&nbsp; %Statements...%`~n
`*Wend*`

`*End*` or `*End While*` may be used instead of `*Wend*`.

[Exit and Continue](#exit_continue) may be used within a `While` loop to abruptly terminate or continue loop execution.


>>> <a name="loop_repeat"></a> The Repeat loop

Like the `While` loop, the `Repeat` loop also allows you to execute a block of statement repeatedly while a boolean expression evaluates to true.

However, unlike a `While` loop, a `Repeat` loop is guaranteed to execute at least once, as the boolean expression is not evaluated until the end of the loop.

The syntax for `Repeat`/`Until` loops is:

`*Repeat*`~n
`&nbsp;&nbsp;&nbsp;&nbsp; %Statements...%`~n
`*Until* %Expression%`

Or...

`*Repeat*`~n
`&nbsp;&nbsp;&nbsp;&nbsp; %Statements...%`~n
`*Forever*`

[Exit and Continue](#exit_continue) may be used within a `Repeat` loop to abruptly terminate or continue loop execution.


>>> <a name="loop_for"></a> The numeric For loop

A numeric `For` loop will continue executing until the value of a numeric index variable reaches an exit value.

The index variable is automatically updated every loop iteration by adding a constant step value.

The syntax for a numeric `For` loop is:

`*For* [ *Local* ] %IndexVariable% *=* %FirstValue% *To* | *Until* %LastValue% [ *Step* %StepValue% ]`~n
`&nbsp;&nbsp;&nbsp;&nbsp; %Statements...%`~n
`*Next*`

`*End*` or `*End For*` may be used instead of `*Next*`.

If present, `Local` will create a new local index variable that only exists for the duration of the loop. In addition, %IndexVariable% must include the variable type, or `:=` must be used instead of `=` to implicitly set the variable's type.

If `Local` is not present, %IndexVariable% must be a valid, existing variable.

The use of `To` or `Until` determines whether %LastValue% should be inclusive or exclusive.

If `To` is used, the loop will exit once the index variable is greater than %LastValue% (or less than if %StepValue% is negative).

If `Until` is used, the loop will exit once the index variable is greater than or equal to %LastValue% (or less than or equal to if %StepValue% is negative).

If omitted, %StepValue% defaults to 1.

[Exit and Continue](#exit_continue) may be used within a numeric `For` loop to abruptly terminate or continue loop execution.


>>> <a name="loop_eachin"></a> The For EachIn loop

A `For` `EachIn` loop allows you to iterate through the elements of a collection.

A collection is either an array, a string, or a specially designed object.

The syntax for a For EachIn loop is:

`*For* [ *Local* ] %IndexVariable% *=* *EachIn* %Collection%`~n
`&nbsp;&nbsp;&nbsp;&nbsp; %Statements...%`~n
`*Next*`

`*End*` or `*End For*` may be used instead of `*Next*`.

If present, `*Local*` will create a new local index variable that only exists for the duration of the loop. In addition, %IndexVariable% must include the variable type, or `:=` must be used instead of `=` to implicitly set the variable's type.

If `Local` is not present, %IndexVariable% must be a valid, existing variable.

If %Collection% is an array, the loop will iterate through each element of the array, and the type of the index variable must match the element type of the array.

If %Collection% is a string, the loop will iterate through each each character code of the string, and the type of the index variable must be numeric.

If %Collection% is an object, it must provide the following method:

<pre>
Method ObjectEnumerator:Object()
</pre>

The object returned by this method must itself provide the following methods:

<pre>
Method HasNext:Bool()
Method NextObject:Object()
</pre>

This allows you to build 'collection' style objects, such as the [[cerberus.list|List]] and [[cerberus.map|Map]] classes included in the standard Cerberus&nbsp;X modules that can be iterated through using For EachIn loops.


>>> <a name="exit_continue"></a> Exit and Continue

`*Exit*` can be used within `While`, `Repeat` and `For` loops to abruptly exit the loop before the loop termination condition has been met.

`*Continue*` can be used within `While`, `Repeat` and `For` loops to force the loop to abruptly skip to the next loop iteration, skipping over any statements that may be remaining in the current loop iteration.


>>> <a name="assignments"></a> Assignment and Update Assignment statements


An assignment statement modifies a variable's value, and has the syntax:

`%VarExpression% %Operator% %Expression%`

Where %VarExpression% is an expression that evaluates to a variable, and %Operator% is one of the following:

| Operator  | Description
| `=`       | Assignment
| `\*=`     | Multiplication update assignment
| `/=`      | Division update assignment
| `Mod=`    | Modulus update assignment
| `Shl=`    | Bitwise shift left update assignment
| `Shr=`    | Bitwise shift right (signed) update assignment
| `+=`      | Addition update assignment
| `-=`      | Subtraction update assignment
| `&=`      | Bitwise 'and' update assignment
| `~=`      | Bitwise 'xor' update assignment
| `&#124;=` | Bitwise 'or' update assignment

The `*=*` operator is used for plain assignment, while the remaining operators are used for update assignments. An update assignment is a short notation equivalent to:

`%VarExpression% *=* %VarExpression% %Operator% *(* %Expression% *)*`


>>> <a name="exp_statements"></a> Expression statements

You may also use certain expressions as program statements. These are:

* Function or method call expressions.
* `*New*` expression.


>> <a name="functions"></a> Functions

A function is a self contained block of statements that can be called (or invoked) repeatedly from elsewhere in the program. Functions can also be passed parameters and return a result.

The syntax for declaring a function is:

`*Function* %Identifier% *:* %ReturnType% *(* %Parameters% *)*`~n
`&nbsp;&nbsp;&nbsp;&nbsp; %Statements...%`~n
`*End* [ *Function* ]`

Functions that don't return a value use `*:Void*` as %ReturnType%.

For example:

<pre>
Function Eat:Void( amount:Int )
    ...
End
</pre>

%Parameters% is a comma separated sequence of function parameters:

`%Identifier% *:* %Type% [ *=* %InitExpression% ]`

Or...

`%Identifier% *:=* %InitExpression%`

If you provide an %InitExpression% when declaring a function parameter, this means that the parameter has a default value and that the parameter can be optionally omitted when the function is called.

Once you have declared a function, it can be called with the syntax: 

`*FunctionIdentifier* *(* %Arguments% *)*`

where %Arguments% is a comma separated sequence of expressions.

For example:

<pre>
Function Sum:Int( x:Int,y:Int )
    Return x+y
End

Function Main()
    Print Sum( 10,20 )
End
</pre>

Here is an example of using default parameters:

<pre>
Function Sum( x:Int=0,y:Int=0,z:Int=0 )
    Print x+y+z
End

Function Main()
    Print Sum()         'same as calling Sum( 0,0,0 )
    Print Sum( 10,20 )  'same as calling Sum( 10,20,0 )
    Print Sum( 10,,30 ) 'same as calling Sum( 10,0,30 )
End
</pre>


>>> <a name="overloading"></a> Function overloading

Functions can also be overloaded. This means that multiple declarations can share the same name, as long as they each have different parameters. Methods can be overloaded in exactly the same way as functions.

When a function is called, Cerberus&nbsp;X looks at the number and type of the parameters used in the call and looks for a matching overloaded version to use. For example:

<pre>
Function Add( value:Int )
End

Function Add( value:Float )
End

Function Add( value:String )
End

Function Main()
    Add( 10 )   'calls first version as 10 is of type Int
    Add( 10.0 ) 'calls second version as 10.0 is of type Float
    Add( "10" ) 'calls third version as "10" is of type String
End
</pre>

The number of parameters can also be used to differentiate between overloaded functions. For example:

<pre>
Function Set( x )
End

Function Set( x, y )
End

Function Main()
    Set( 10 )    'calls first version
    Set( 10,20 ) 'calls second version as it has two parameters
End
</pre>

When determining which overloaded version to actually use, Cerberus&nbsp;X uses the following logic:

* If an overloaded version is found that is an exact match for the number and type of function call parameters, that version is used. Note that if the function call involves the use of any default parameters, it is not considered an exact match.
* Otherwise, if there is exactly one overloaded version that can be called by [implicitly converting](#implicit_conversions) the function call parameters, that version is used.
* Otherwise, an error is generated. In this case, you will need to manually cast some or all of the function call parameters to create an exact match.

For example:

<pre>
Function Add( value:Int )
End

Function Add( value:String )
End

Function Main()
    Add( 10 )   'OK, calls first version
    Add( "10" ) 'OK, calls second version
    Add( 10.0 ) 'error - unable to determine which version to call
End
</pre>

The error is caused by the fact that the function call parameter  - '10.0' - is a floating point value and can therefore be implicitly converted to either an integer or a string, so Cerberus&nbsp;X cannot decide which overload to use.

To solve this problem, you would need to explicitly cast the parameter to either an integer or a string to give Cerberus&nbsp;X a 'hint' about which version you want used.  For example:

<pre>
Add( Int(10.0) )        'Casts the float to an integer, calls first version
</pre>


>> <a name="methods"></a> Methods

A Method is a function that is bound to a class. A method has implicit access to all members of its class, such as fields, globals and other methods and functions. Methods can be [overloaded](#overloading) in exactly the same way as functions.

The syntax for declaring a method is similar to that for declaring a function:

`*Method* %Identifier% *:* %ReturnType% *(* %Parameters% *)* [ *Property* ]`~n
`&nbsp;&nbsp;&nbsp;&nbsp; %Statements...%`~n
`*End* [ *Method* ]`

Within a method you can also use the `Self` and `Super` keywords:

* `*Self*` may be used within a method to access the object the method is associated with.
* `*Super*` may be used within a method to call 'super class' methods.


>>> <a name="properties"></a> Property methods

The optional `*Property*` keyword can be used to declare a 'property method'.

A property method with 0 parameters can be invoked without any brackets. A property method with 1 parameter can be invoked be using it as the left-hand-side of an assignment statement, in which case the right-hand-side expression of the assignment is passed to the property method.

You can therefore create methods that behave like fields, but actually execute code when they are read or written. You can use [method overloading](#overloading) to provide both read and write property methods, or provide just a read method, or even just a write method. For example:

<pre>
Class MyClass
    Field _value:Int
    Method Value( val:Int ) Property
        _value = val
        Print "Set _value to "+_value
    End
End

Function Main()
    Local myObject := New MyClass
    myObject.Value = 100          ' sets _value and outputs "Set _value to 100"
End
</pre>

It is illegal to declare a property method with 2 or more parameters.


>> <a name="classes"></a> Classes

A class is a kind of 'blueprint' for creating objects at runtime.

The syntax for declaring a class is:

`*Class* %Identifier% [ *<* %Parameters% *>* ] [ *Extends* %BaseClass% ] [ *Implements* %Interfaces% ]`~n
`&nbsp;&nbsp;&nbsp;&nbsp; %Declarations...%`~n
`*End* [ *Class* ]`

Classes can contain [field](#fields), [method](#methods), [constant](#constants), [global](#globals) and [function](#functions) declarations.

If no base class is specified using `Extends`, the class defaults to extending the built in Object class.

The `Implements` keyword is used to implement interfaces, and must be followed by a comma separated list of interface names. Please refer to the [Interfaces](#interfaces) section for more on interfaces. 

Fields and methods are class members only accessible via a valid object reference of that class. But constants, globals and functions can be accessed via the class identifier itself. As a class is also a valid scope, any non-private constants, globals and functions declared within a class can be accessed outside of the class using the scope member access operator '`.`'. For example:

<pre>
Class C
   Global T
End

Function Main()
    C.T=10
End
</pre>

Once you have declared a class, you can create objects of that class at runtime using the `New` operator. For example:

<pre>
Class MyClass
    Field x,y,z
End

Function Main()
    Local myObject:=New MyClass
    myObject.x=10
    myObject.y=20
    myObject.z=30
End
</pre>


>>> <a name="constructors"></a> Constructors

Constructors are methods that are called each time an object is created with `New`.

To declare a constructor, you simply declare a class method and name it `*New*`. Constructors may not have a type declaration nor a return statement.

Constructors can take parameters and can be overloaded.

To invoke a super class constructor within a constructor, use the `*Super*` keyword.

<pre>
Class MyClass
    Field _value:Int
    Method New( val:Int )               ' constructor or MyClass
        _value = val
    End
End

Function Main()
    Local myObject := New MyClass(100)  ' calls the constructor of MyClass
    Print myObject._value               ' prints "100"
End
</pre>


>> <a name="generics"></a> Generic classes

Generic classes allow you to write code that is not specific to a single data type.

A generic class is declared in a similar way to a normal class, only with an additional set of 'type parameters' enclosed within `*<*` and `*>*`.

For example:

<pre>
Class Pointer<T>
    Method Set( data:T )
        _data=data
    End
    
    Method Get:T()
        Return _data
    End
    
    Private

    Field _data:T

End
</pre>

Type parameters can be any valid identifier. Here, `T` is such a type parameter.

Within the declaration of a generic class, type parameters may be used anywhere a type is normally expected, for example, when declaring variables and function return types, and when creating new objects or arrays.

When it comes to actually using a generic class, you must provide actual types to be used in place of type parameters. Types parameters can be of any valid type, including int, float, string and array.

For example:

<pre>
Class Actor
End

Function Main()
    Local pointer:Pointer<Actor>
    pointer=New Pointer<Actor>
    pointer.Set New Actor
    Local actor:=pointer.Get()
End
</pre>

The syntax `Pointer\<Actor\>` indicates an 'instantiation' of the generic class `Pointer\<T\>`.

This is in itself a unique class, so each time you use the `Pointer\<T\>` class with a different type for `T`, you are actually creating a whole new class.

Generic classes are commonly used for writing container classes such as lists, stacks and so on, and the standard Cerberus&nbsp;X modules provide a set of simple generic container classes.


>> <a name="interfaces"></a> Interfaces

An interface is similar to a class, except that it can only contain constants and abstract methods.

Classes can implement an interface using the `*Implements*` keyword in the class declaration.

Classes that implement an interface must declare each method declared in the interface.

An interface can be used where ever a class is expected, for example when declaring the types of variables, or function return types. An interface cannot however be used with `New`.

An Interface can also optionally extend existing interfaces, in which cases all methods in all extended interfaces must be declared by any implementing classes.

Interfaces can not be generic.

The syntax for declaring an interface is:

`*Interface* %Identifier% [ *Extends* %Interfaces% ]`~n
`&nbsp;&nbsp;&nbsp;&nbsp; %Declarations...%`~n
`*End* [ *Interface* ]`

All methods declared inside an interface are automatically treated as [abstract](Abstract), and can therefore have no 'body'.

Here is an example of using interfaces:

<pre>
Interface Moveable
    Method Move()
End

Interface Drawable
    Method Draw()
End

Class Actor Implements Moveable,Drawable
    Method Move()
        Print "Actor.Move()"
    End
    Method Draw()
        Print "Actor.Draw()"
    End
End

Function Move( moveable:Moveable ) ' moveable can be any class, as long as it implements 'Moveable'
    moveable.Move
End

Function Draw( drawable:Drawable ) ' drawable can be any class, as long as it implements 'Drawable'
    drawable.Draw
End

Function Main()
    Local actor:=New Actor

    Move actor
    Draw actor
End
</pre>


>> <a name="exceptions"></a> Exceptions

Exceptions are objects that can be 'thrown' to inform your program of unusual or abnormal behaviour.

By placing code inside a `Try` block, you can catch thrown exceptions with a corresponding `Catch` block. For example...

<pre>
Function Main()
    Try
        Print "Hello World!"
        Throw New Throwable
        Print "Where am I?"
    Catch ex:Throwable
        Print "Caught a Throwable!"
    End
End
</pre>

Try this with and without the throw statement.

`Throw` statements may appear anywhere in your application, not just inside a `Try` block. When an object is thrown, it is thrown to the most recently executed `Try` block capable of catching the object.

The class of objects used with throw and catch must extend the built-in class `Throwable`. The `Throwable` class itself simply extends Object and provides no new methods or fields, so you may wish to extend `Throwable` to create your own exception classes with more functionality.

You can also catch multiple classes of exception object per `Try` block, for example:

<pre>
Class Ex1 Extends Throwable
End

Class Ex2 Extends Throwable
End

Function Main()
	For Local i:=1 To 10
		Try
            If (i & 1) Throw New Ex1 Else Throw New Ex2
		Catch ex:Ex1
			Print "Caught an ex1!"
		Catch ex:Ex2
			Print "Caught an ex2!"
		End
	Next
End
</pre>

When a `Try` block has multiple `Catch` blocks and an exception is thrown, the first `Catch` block capable of handling the exception is executed. If no suitable `Catch` block can be found, the exception is passed to the next most recently executed `Try` block, and so on.

If no `Catch` block can be found to catch an exception, a runtime error occurs and the application is terminated.


>> <a name="modules"></a> Modules

A Cerberus&nbsp;X module corresponds to a single Cerberus&nbsp;X source file, and provides a named scope for the constants, globals, functions and classes declared in that file. Every Cerberus&nbsp;X source file declares a module, and every module has an associated source file.

The name of the module scope is the same as the name of the file (minus the directory path and file extension), so the names of Cerberus&nbsp;X source files must also be [valid Cerberus&nbsp;X identifiers](#identifiers).

It is also strongly recommend that file/module names be completely lower-case - both to prevent any issues with cased/uncased file systems and to provide consistency with the standard module set.

One module may import another using the import statement. All import statements must appear at the top of a module before any declarations. The syntax for an import statement is:

`*Import* %ModulePath%`

Where %ModulePath% describes the file location of the Cerberus&nbsp;X module to import. This must be a sequence of 'dot' separated identifiers, and is treated as a relative file system path with dots representing directory separators. The last component in the path represents either an actual .cxs source file, or a directory containing a .cxs source file of the same name.

Given a module's relative path, Cerberus&nbsp;X will look for an actual module to import in the following locations (and in this order):

* The current directory - ie: the directory the importing file is in.
* The project directory - ie: the directory the main source file is in. This is the source file that was passed to the 'trans' compiler, and that contains the declaration for Main().
* The modules directory - ie: the directory named 'modules' in the Cerberus&nbsp;X distribution.

For example, given the following import directive:

<pre>
Import myutil.mycolor
</pre>

Cerberus&nbsp;X will first look for the files myutil/mycolor.cxs and myutil/mycolor/mycolor.cxs in the current directory.

(Note: the reason modules are allowed to be represented as either a single .cxs file, or as a .cxs file within a directory of the same name is for pure convenience. Sometimes it's more convenient for a module to consist of a single file, while sometimes it's more convenient for a module to have its own directory.)

If either is found, it is imported into the current module and the search ends.

If both are found, an error is generated.

If neither is found the search continues with the project directory and, failing that, the modules directory.

If the module is not found anywhere, an error is generated.

Once successfully imported, the importing module can access the declarations made in the imported module, by using the imported module's name as a scope.

Here is a simple import example:

<pre>
'----- file1.cxs -----
Import file2                'after this, file2 can be used as a scope

Function Main()
    Print file2.X           'access global X in file2 module

    file2.Test              'access function Test in file2 module
End

'---- file2.cxs ----
Global X:=1

Function Test()
    Print "file2.Test"
End
</pre>

When accessing identifiers in imported modules, Cerberus&nbsp;X allows you to omit the module scope as long as there are no 'clashes' between identifiers in multiple modules. For example:

<pre>
'----- file1.cxs ----
Import file2
Import file3

Function Main()

    Print X     'OK, accesses file2.X
    Print Y     'OK, accesses file3.Y
    Test        'ERROR! Which Test? file2.Test or file3.Test?
    file2.Test  'OK, I now know which module to get Test from

End

'----- file2.cxs  -----
Global X:=1

Function Test()
    Print "file2.Test"
End

'----- file3.cxs -----
Global Y:=2

Function Test()
    Print "file3.Test"
End
</pre>

By default, any imports made by a module are automatically made available to importers of that module. That is, if module X imports module Y, and module Y imports module Z, the result is that module X effectively imports module Z.

However, if an import is declared to be private, that import is NOT made available. For example:

<pre>
'----- file1.cxs -----
Import file2
Function Main()

    Print X  'OK, accesses file2.X
    Print Y  'OK, accesses file3.Y
    Print Z  'ERROR! can't see file.Z

End

'----- file2.cxs -----
Import file3                'Public import: When you import file2, you also import file3

Private
Import file4                'Private - ie: internal use only. Only file2 can access file4.  file1 cannot access file4.

Public
Global X:=1

'----- file3.cxs -----
Global Y:=2

'----- file4.cxs -----
Global Z:=3
</pre>

Modules can be stored in a directory hierarchy and imported using a 'dotted' module path, for example:

<pre>
'----- file1.cxs  -----
Import file2
Import util.file3

Function Main()
    Print file2.X
    Print file3.Y
End


'----- util/file2.cxs  ----
Global X:=1

'----- util/file3.cxs -----
Global Y:=2
</pre>

Note that the directory path (in this case, 'util') is not used in any way except to locate the module. The module name is still just 'file3' - not 'util.file3'.


>>> <a name="alias"></a> The Alias directive

The `Alias` directive allows you to assign a local name to a constant, global, function or class declared in another module. This can be used to create 'shortcuts' for clashing identifiers.

The syntax for `Alias` is:

`*Alias* %Identifier% *=* %ModulePath% *.* %Identifier%`

`Alias` directives must appear in the 'import' section of a module, before any code.

For example:

<pre>
'----- file1.cxs  -----
Import file2
Import file3

Alias T=file2.T               'which 'T' to use

Function Main()
    Print T                   'Prints '1'
End

'----- file2.cxs  -----
Global T:=1

'----- file3.cxs -----
Global T:=2
</pre>


>> <a name="visibility"></a> Public and Private

The `Public` and `Private` directives are used to control the visibility of subsequent declarations in a module or class.

If the `Public` directive is used in the main body of a module, all subsequent declarations will be public, and will be visible outside of the current module.

If the `Private` directive is used in the main body of a module, all subsequent declarations will be private and will not be visible outside of the current module.

For example:

<pre>
Private
Global x,y,z        'These are private to the current module

Public
Global P,Q,R        'These can be used by any module
</pre>

When used inside a class declaration, `Public` and `Private` work in a similar way to control the visibility of subsequent member declarations. For example:

<pre>
Class MyClass
    Private
    Field x,y,z        'these are NOT visible outside of this module.
    
    Public
    Field P,Q,R        'these ARE visible outside of this module.
End
</pre>

Note that private class members are not private to the class, but to the entire module. This means that code outside of the class but within the same module can still access class private members.


>> <a name="extern"></a> External declarations

The `Extern` directive is used to connect Cerberus&nbsp;X code to non-Cerberus&nbsp;X code. It lets you mix Cerberus&nbsp;X code (to be translated into the target platform language) with native target platform code.

When the `Extern` directive is used in the main body of a module, all subsequent global, function and class declarations will be treated as external declarations.

External declarations are assumed to be implemented elsewhere in native code, and as such may not contain a 'body'.

In the case of external global variables, this means the global may not be initialized - it is assumed to be initialized by native code.

In the case of external functions, this means the function may not contain any code, and must not be terminated with an End directive.

In the case of external classes, this means any globals or methods declared in the class may not contain a 'body' either.

External declarations may however be assigned a 'symbol' in the form of a string literal. This is the native symbol to be used by the Cerberus&nbsp;X translator when the declaration is referenced by Cerberus&nbsp;X code.

By default, external declarations are public. You can use `Extern Private` to prevent external declarations from being visible outside the current module.

Here are some examples of using extern:

<pre>
Extern

Global ActiveDriver:Driver="xyzActiveDriver"  'Native name of this global is xyzActiveDriver

Class Driver="xyzDriver"   'The native name of this class is 'xyzDriver'.
    Method Method1()       'By default, native name is same as declaration name - Method1 here.
    Method Method2()       'native name is Method2
End

Public        'return to public declarations
</pre>


>> <a name="preprocessor"></a> The preprocessor

Cerberus&nbsp;X contains a very simple built-in preprocessor based on the syntax of the Cerberus&nbsp;X If statement that allows you to enable or disable blocks of code from being generated or translated, based on certain conditions.

The following preprocessor directives are supported:

| Directive   | Description
| `#If`       | Start of conditional directive block
| `#ElseIf`   | Alternative conditional directive block
| `#Else`     | Alternative conditional directive block
| `#End`      | End of directive block
| `#Rem`      | Start of block comment
| `#Print`    | Writes to the 'build log'
| `#Error`    | Writes to the 'build log' and aborts the building process

Preprocessor directives must appear at the start of a line, and may be preceded by optional whitespace.

The `#If` and `#ElseIf` directives must be followed by a constant Cerberus&nbsp;X expression. If this expression evaluates to true, then code generation is enabled, otherwise it is disabled.

The following built in constants may be used in preprocessor expressions:

| Constant	| Description
| HOST		| Host operating system, one of: *winnt* , *macos* , *linux*
| LANG		| Target language, one of: *js* , *as* , *cs* , *cpp* , *java*
| TARGET	| Target system, one of: *ios* , *android* , *winrt* , *glfw* , *html5* , *flash*
| CONFIG	| Target build config, one of: *debug* , *release*
| CD		| Directory of source file being built
| MODPATH	| Module being built

The `#Rem` directive is exactly the same as `#If False` - it unconditionally disables code generation. Note that this allows 'block rems' to be 'nested'.


>>> <a name="preprocessor_customs"></a> Custom preprocessor directives

It is possible to add your own preprocessor directives in your code to make it customisable:

<pre>
#BLOCK_TO_RUN = 1

#If BLOCK_TO_RUN = 0
	Print "Do this."
#Else
	Print "Do that."
#End
</pre>


>> <a name="iveseen"></a> I've seen...

Have you seen a strange notation in a Cerberus&nbsp;X source file and don’t know what it means? This condensed overview will help you:

| Notation | Description
| `%Identifier% ?` | Short notation for [the Bool type](#type_bool)
| `%Identifier% \%` | Short notation for [the Int type](#type_int)
| `%Identifier% #` | Short notation for [the Float type](#type_float)
| `%Identifier% $` | Short notation for [the String type](#type_string)
| `:=` | Implicit typing when declaring [variables](#variables)
| `$ %Literal%` | [Hexadecimal literal](#literal_hex)
| `&#96; %Character% &#96;` | [Character literal](#literal_char)
| `&#91; .. &#93;` | [Array slicing](#array_indexing) used to copy an array
| `&#91; %Index0% .. %Index1% &#93;` | [String slicing](#string_indexing) or [array slicing](#array_indexing)
| `\< %Identifier% \>` | [Generic class](#generics)
| `.%Identifier%` | Global access (when `%Identifier%` exists both as local and global, this accesses the global one)
| `Extern`<br/>`%Identifier% = "%AltIdentifier%"` | Native name of object in [external code](#extern)
| `\*=` | Multiplication [update assignment](#assignments)
| `/=` | Division [update assignment](#assignments)
| `Mod=` | Modulus [update assignment](#assignments)
| `Shl=` | Bitwise shift left [update assignment](#assignments)
| `Shr=` | Bitwise shift right (signed) [update assignment](#assignments)
| `+=` | Addition [update assignment](#assignments)
| `-=` | Subtraction [update assignment](#assignments)
| `&=` | Bitwise 'and' [update assignment](#assignments)
| `~=` | Bitwise 'xor' [update assignment](#assignments)
| `&#124;=` | Bitwise 'or' [update assignment](#assignments)
| `%Statement% ; %Statement%` | The `;` character is used to put multiple statements on one line
| `#If` | [Preprocessor directive](#preprocessor)


>> <a name="glossary"></a> Glossary

If you didn't read the language documentation attentive enough to find what you were looking for, you can try to find a cue in this alphabetically index.

<div class="multicolumn">
[Alias](#alias)~n
[Arithmetic operations](#operators)~n
[Array](#type_array)~n
[Assets](Asset import)~n
[Assignments](#assignments)~n
[Balancing](#balancing)~n
[Bitwise operators](#bitwise_ops)~n
[Bool](#type_bool)~n
[Boxing](#boxing)~n
[Casting](#explicit_conversions)~n
[Catch](#exceptions)~n
[Char literals](#literal_char)~n
[Classes](#classes)~n
[Collections](#loop_eachin)~n
[Comments](#comments)~n
[Comparison operators](#operators)~n
[Conditional operators](#operators)~n
[Constants](#constants)~n
[Constructors](#constructors)~n
[Continue](#exit_continue)~n
[Conversions](#implicit_conversions)~n
[Datatypes](#types)~n
[Declarations](#declarations)~n
[EachIn](#loop_eachin)~n
[Enumerations](#enumerates)~n
[Escape sequences](#string_escaping)~n
[Exceptions](#exceptions)~n
[Exit](#exit_continue)~n
[Extends](#classes)~n
[Extern](#extern)~n
[External declaration](#extern)~n
[Field](#fields)~n
[Float](#type_float)~n
[For](#loop_for)~n
[Garbage collector](Memory management)~n
[Generics](#generics)~n
[Global](#globals)~n
[HasNext](#loop_eachin)~n
[Hexadecimal literals](#literal_hex)~n
[Identifiers](#identifiers)~n
[If](#statement_if)~n
[Import assets](Asset import)~n
[Import modules](#modules)~n
[Inheritance](#classes)~n
[Int](#type_int)~n
[Interfaces](#interfaces)~n
[Literals](#literals)~n
[Local](#locals)~n
[Logical operators](#operators)~n
[Main](#programs)~n
[Media](#assetimport)~n
[Memory management](Memory management)~n
[Module Paths](#modules)~n
[Modules](#modules)~n
[Naming Conventions](#naming)~n
[NextObject](#loop_eachin)~n
[Object](#type_object)~n
[ObjectEnumerator](#loop_eachin)~n
[Operators](#operators)~n
[Optimisation](Optimisation)~n
[Optional parameters](#functions)~n
[Order of operations](#operators)~n
[Overloading](#overloading)~n
[Precedence](#operators)~n
[Preprocessor](#preprocessor)~n
[Private](#visibility)~n
[Properties](#properties)~n
[Public](#visibility)~n
[Repeat](#loop_repeat)~n
[Resources](#assetimport)~n
[Select](#statement_select)~n
[Self](#methods)~n
[Short notation for assignments](#assignments)~n
[Short notation for types](#types)~n
[Slicing (Arrays)](#array_indexing)~n
[Slicing (Strings)](#string_indexing)~n
[Strict](#strict)~n
[String](#type_string)~n
[Super](#methods)~n
[Throw](#exceptions)~n
[Try](#exceptions)~n
[Types](#types)~n
[Update assignments](#assignments)~n
[Visibility](#visibility)~n
[Void functions](#functions)~n
[While](#loop_while)~n
</div>